/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./docs/test.js":
/*!**********************!*\
  !*** ./docs/test.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = \"./src/operator/Test.ts\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"./node_modules/assertion-error/index.js\":\n/*!***********************************************!*\\\n  !*** ./node_modules/assertion-error/index.js ***!\n  \\***********************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\neval(\"/*!\\r\\n * assertion-error\\r\\n * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>\\r\\n * MIT Licensed\\r\\n */\\r\\n\\r\\n/*!\\r\\n * Return a function that will copy properties from\\r\\n * one object to another excluding any originally\\r\\n * listed. Returned function will create a new `{}`.\\r\\n *\\r\\n * @param {String} excluded properties ...\\r\\n * @return {Function}\\r\\n */\\r\\n\\r\\nfunction exclude () {\\r\\n  var excludes = [].slice.call(arguments);\\r\\n\\r\\n  function excludeProps (res, obj) {\\r\\n    Object.keys(obj).forEach(function (key) {\\r\\n      if (!~excludes.indexOf(key)) res[key] = obj[key];\\r\\n    });\\r\\n  }\\r\\n\\r\\n  return function extendExclude () {\\r\\n    var args = [].slice.call(arguments)\\r\\n      , i = 0\\r\\n      , res = {};\\r\\n\\r\\n    for (; i < args.length; i++) {\\r\\n      excludeProps(res, args[i]);\\r\\n    }\\r\\n\\r\\n    return res;\\r\\n  };\\r\\n};\\r\\n\\r\\n/*!\\r\\n * Primary Exports\\r\\n */\\r\\n\\r\\nmodule.exports = AssertionError;\\r\\n\\r\\n/**\\r\\n * ### AssertionError\\r\\n *\\r\\n * An extension of the JavaScript `Error` constructor for\\r\\n * assertion and validation scenarios.\\r\\n *\\r\\n * @param {String} message\\r\\n * @param {Object} properties to include (optional)\\r\\n * @param {callee} start stack function (optional)\\r\\n */\\r\\n\\r\\nfunction AssertionError (message, _props, ssf) {\\r\\n  var extend = exclude('name', 'message', 'stack', 'constructor', 'toJSON')\\r\\n    , props = extend(_props || {});\\r\\n\\r\\n  // default values\\r\\n  this.message = message || 'Unspecified AssertionError';\\r\\n  this.showDiff = false;\\r\\n\\r\\n  // copy from properties\\r\\n  for (var key in props) {\\r\\n    this[key] = props[key];\\r\\n  }\\r\\n\\r\\n  // capture stack trace\\r\\n  ssf = ssf || AssertionError;\\r\\n  if (Error.captureStackTrace) {\\r\\n    Error.captureStackTrace(this, ssf);\\r\\n  } else {\\r\\n    try {\\r\\n      throw new Error();\\r\\n    } catch(e) {\\r\\n      this.stack = e.stack;\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\n/*!\\r\\n * Inherit from Error.prototype\\r\\n */\\r\\n\\r\\nAssertionError.prototype = Object.create(Error.prototype);\\r\\n\\r\\n/*!\\r\\n * Statically set name\\r\\n */\\r\\n\\r\\nAssertionError.prototype.name = 'AssertionError';\\r\\n\\r\\n/*!\\r\\n * Ensure correct constructor\\r\\n */\\r\\n\\r\\nAssertionError.prototype.constructor = AssertionError;\\r\\n\\r\\n/**\\r\\n * Allow errors to be converted to JSON for static transfer.\\r\\n *\\r\\n * @param {Boolean} include stack (default: `true`)\\r\\n * @return {Object} object that can be `JSON.stringify`\\r\\n */\\r\\n\\r\\nAssertionError.prototype.toJSON = function (stack) {\\r\\n  var extend = exclude('constructor', 'toJSON', 'stack')\\r\\n    , props = extend({ name: this.name }, this);\\r\\n\\r\\n  // include stack if exists and not turned off\\r\\n  if (false !== stack && this.stack) {\\r\\n    props.stack = this.stack;\\r\\n  }\\r\\n\\r\\n  return props;\\r\\n};\\r\\n\\n\\n//# sourceURL=webpack:///./node_modules/assertion-error/index.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/chai/index.js\":\n/*!************************************!*\\\n  !*** ./node_modules/chai/index.js ***!\n  \\************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\neval(\"module.exports = __webpack_require__(/*! ./lib/chai */ \\\"./node_modules/chai/lib/chai.js\\\");\\r\\n\\n\\n//# sourceURL=webpack:///./node_modules/chai/index.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/chai/lib/chai.js\":\n/*!***************************************!*\\\n  !*** ./node_modules/chai/lib/chai.js ***!\n  \\***************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\neval(\"/*!\\r\\n * chai\\r\\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\\r\\n * MIT Licensed\\r\\n */\\r\\n\\r\\nvar used = [];\\r\\n\\r\\n/*!\\r\\n * Chai version\\r\\n */\\r\\n\\r\\nexports.version = '4.2.0';\\r\\n\\r\\n/*!\\r\\n * Assertion Error\\r\\n */\\r\\n\\r\\nexports.AssertionError = __webpack_require__(/*! assertion-error */ \\\"./node_modules/assertion-error/index.js\\\");\\r\\n\\r\\n/*!\\r\\n * Utils for plugins (not exported)\\r\\n */\\r\\n\\r\\nvar util = __webpack_require__(/*! ./chai/utils */ \\\"./node_modules/chai/lib/chai/utils/index.js\\\");\\r\\n\\r\\n/**\\r\\n * # .use(function)\\r\\n *\\r\\n * Provides a way to extend the internals of Chai.\\r\\n *\\r\\n * @param {Function}\\r\\n * @returns {this} for chaining\\r\\n * @api public\\r\\n */\\r\\n\\r\\nexports.use = function (fn) {\\r\\n  if (!~used.indexOf(fn)) {\\r\\n    fn(exports, util);\\r\\n    used.push(fn);\\r\\n  }\\r\\n\\r\\n  return exports;\\r\\n};\\r\\n\\r\\n/*!\\r\\n * Utility Functions\\r\\n */\\r\\n\\r\\nexports.util = util;\\r\\n\\r\\n/*!\\r\\n * Configuration\\r\\n */\\r\\n\\r\\nvar config = __webpack_require__(/*! ./chai/config */ \\\"./node_modules/chai/lib/chai/config.js\\\");\\r\\nexports.config = config;\\r\\n\\r\\n/*!\\r\\n * Primary `Assertion` prototype\\r\\n */\\r\\n\\r\\nvar assertion = __webpack_require__(/*! ./chai/assertion */ \\\"./node_modules/chai/lib/chai/assertion.js\\\");\\r\\nexports.use(assertion);\\r\\n\\r\\n/*!\\r\\n * Core Assertions\\r\\n */\\r\\n\\r\\nvar core = __webpack_require__(/*! ./chai/core/assertions */ \\\"./node_modules/chai/lib/chai/core/assertions.js\\\");\\r\\nexports.use(core);\\r\\n\\r\\n/*!\\r\\n * Expect interface\\r\\n */\\r\\n\\r\\nvar expect = __webpack_require__(/*! ./chai/interface/expect */ \\\"./node_modules/chai/lib/chai/interface/expect.js\\\");\\r\\nexports.use(expect);\\r\\n\\r\\n/*!\\r\\n * Should interface\\r\\n */\\r\\n\\r\\nvar should = __webpack_require__(/*! ./chai/interface/should */ \\\"./node_modules/chai/lib/chai/interface/should.js\\\");\\r\\nexports.use(should);\\r\\n\\r\\n/*!\\r\\n * Assert interface\\r\\n */\\r\\n\\r\\nvar assert = __webpack_require__(/*! ./chai/interface/assert */ \\\"./node_modules/chai/lib/chai/interface/assert.js\\\");\\r\\nexports.use(assert);\\r\\n\\n\\n//# sourceURL=webpack:///./node_modules/chai/lib/chai.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/chai/lib/chai/assertion.js\":\n/*!*************************************************!*\\\n  !*** ./node_modules/chai/lib/chai/assertion.js ***!\n  \\*************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\neval(\"/*!\\r\\n * chai\\r\\n * http://chaijs.com\\r\\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\\r\\n * MIT Licensed\\r\\n */\\r\\n\\r\\nvar config = __webpack_require__(/*! ./config */ \\\"./node_modules/chai/lib/chai/config.js\\\");\\r\\n\\r\\nmodule.exports = function (_chai, util) {\\r\\n  /*!\\r\\n   * Module dependencies.\\r\\n   */\\r\\n\\r\\n  var AssertionError = _chai.AssertionError\\r\\n    , flag = util.flag;\\r\\n\\r\\n  /*!\\r\\n   * Module export.\\r\\n   */\\r\\n\\r\\n  _chai.Assertion = Assertion;\\r\\n\\r\\n  /*!\\r\\n   * Assertion Constructor\\r\\n   *\\r\\n   * Creates object for chaining.\\r\\n   *\\r\\n   * `Assertion` objects contain metadata in the form of flags. Three flags can\\r\\n   * be assigned during instantiation by passing arguments to this constructor:\\r\\n   *\\r\\n   * - `object`: This flag contains the target of the assertion. For example, in\\r\\n   *   the assertion `expect(numKittens).to.equal(7);`, the `object` flag will\\r\\n   *   contain `numKittens` so that the `equal` assertion can reference it when\\r\\n   *   needed.\\r\\n   *\\r\\n   * - `message`: This flag contains an optional custom error message to be\\r\\n   *   prepended to the error message that's generated by the assertion when it\\r\\n   *   fails.\\r\\n   *\\r\\n   * - `ssfi`: This flag stands for \\\"start stack function indicator\\\". It\\r\\n   *   contains a function reference that serves as the starting point for\\r\\n   *   removing frames from the stack trace of the error that's created by the\\r\\n   *   assertion when it fails. The goal is to provide a cleaner stack trace to\\r\\n   *   end users by removing Chai's internal functions. Note that it only works\\r\\n   *   in environments that support `Error.captureStackTrace`, and only when\\r\\n   *   `Chai.config.includeStack` hasn't been set to `false`.\\r\\n   *\\r\\n   * - `lockSsfi`: This flag controls whether or not the given `ssfi` flag\\r\\n   *   should retain its current value, even as assertions are chained off of\\r\\n   *   this object. This is usually set to `true` when creating a new assertion\\r\\n   *   from within another assertion. It's also temporarily set to `true` before\\r\\n   *   an overwritten assertion gets called by the overwriting assertion.\\r\\n   *\\r\\n   * @param {Mixed} obj target of the assertion\\r\\n   * @param {String} msg (optional) custom error message\\r\\n   * @param {Function} ssfi (optional) starting point for removing stack frames\\r\\n   * @param {Boolean} lockSsfi (optional) whether or not the ssfi flag is locked\\r\\n   * @api private\\r\\n   */\\r\\n\\r\\n  function Assertion (obj, msg, ssfi, lockSsfi) {\\r\\n    flag(this, 'ssfi', ssfi || Assertion);\\r\\n    flag(this, 'lockSsfi', lockSsfi);\\r\\n    flag(this, 'object', obj);\\r\\n    flag(this, 'message', msg);\\r\\n\\r\\n    return util.proxify(this);\\r\\n  }\\r\\n\\r\\n  Object.defineProperty(Assertion, 'includeStack', {\\r\\n    get: function() {\\r\\n      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');\\r\\n      return config.includeStack;\\r\\n    },\\r\\n    set: function(value) {\\r\\n      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');\\r\\n      config.includeStack = value;\\r\\n    }\\r\\n  });\\r\\n\\r\\n  Object.defineProperty(Assertion, 'showDiff', {\\r\\n    get: function() {\\r\\n      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');\\r\\n      return config.showDiff;\\r\\n    },\\r\\n    set: function(value) {\\r\\n      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');\\r\\n      config.showDiff = value;\\r\\n    }\\r\\n  });\\r\\n\\r\\n  Assertion.addProperty = function (name, fn) {\\r\\n    util.addProperty(this.prototype, name, fn);\\r\\n  };\\r\\n\\r\\n  Assertion.addMethod = function (name, fn) {\\r\\n    util.addMethod(this.prototype, name, fn);\\r\\n  };\\r\\n\\r\\n  Assertion.addChainableMethod = function (name, fn, chainingBehavior) {\\r\\n    util.addChainableMethod(this.prototype, name, fn, chainingBehavior);\\r\\n  };\\r\\n\\r\\n  Assertion.overwriteProperty = function (name, fn) {\\r\\n    util.overwriteProperty(this.prototype, name, fn);\\r\\n  };\\r\\n\\r\\n  Assertion.overwriteMethod = function (name, fn) {\\r\\n    util.overwriteMethod(this.prototype, name, fn);\\r\\n  };\\r\\n\\r\\n  Assertion.overwriteChainableMethod = function (name, fn, chainingBehavior) {\\r\\n    util.overwriteChainableMethod(this.prototype, name, fn, chainingBehavior);\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .assert(expression, message, negateMessage, expected, actual, showDiff)\\r\\n   *\\r\\n   * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.\\r\\n   *\\r\\n   * @name assert\\r\\n   * @param {Philosophical} expression to be tested\\r\\n   * @param {String|Function} message or function that returns message to display if expression fails\\r\\n   * @param {String|Function} negatedMessage or function that returns negatedMessage to display if negated expression fails\\r\\n   * @param {Mixed} expected value (remember to check for negation)\\r\\n   * @param {Mixed} actual (optional) will default to `this.obj`\\r\\n   * @param {Boolean} showDiff (optional) when set to `true`, assert will display a diff in addition to the message if expression fails\\r\\n   * @api private\\r\\n   */\\r\\n\\r\\n  Assertion.prototype.assert = function (expr, msg, negateMsg, expected, _actual, showDiff) {\\r\\n    var ok = util.test(this, arguments);\\r\\n    if (false !== showDiff) showDiff = true;\\r\\n    if (undefined === expected && undefined === _actual) showDiff = false;\\r\\n    if (true !== config.showDiff) showDiff = false;\\r\\n\\r\\n    if (!ok) {\\r\\n      msg = util.getMessage(this, arguments);\\r\\n      var actual = util.getActual(this, arguments);\\r\\n      throw new AssertionError(msg, {\\r\\n          actual: actual\\r\\n        , expected: expected\\r\\n        , showDiff: showDiff\\r\\n      }, (config.includeStack) ? this.assert : flag(this, 'ssfi'));\\r\\n    }\\r\\n  };\\r\\n\\r\\n  /*!\\r\\n   * ### ._obj\\r\\n   *\\r\\n   * Quick reference to stored `actual` value for plugin developers.\\r\\n   *\\r\\n   * @api private\\r\\n   */\\r\\n\\r\\n  Object.defineProperty(Assertion.prototype, '_obj',\\r\\n    { get: function () {\\r\\n        return flag(this, 'object');\\r\\n      }\\r\\n    , set: function (val) {\\r\\n        flag(this, 'object', val);\\r\\n      }\\r\\n  });\\r\\n};\\r\\n\\n\\n//# sourceURL=webpack:///./node_modules/chai/lib/chai/assertion.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/chai/lib/chai/config.js\":\n/*!**********************************************!*\\\n  !*** ./node_modules/chai/lib/chai/config.js ***!\n  \\**********************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\neval(\"module.exports = {\\r\\n\\r\\n  /**\\r\\n   * ### config.includeStack\\r\\n   *\\r\\n   * User configurable property, influences whether stack trace\\r\\n   * is included in Assertion error message. Default of false\\r\\n   * suppresses stack trace in the error message.\\r\\n   *\\r\\n   *     chai.config.includeStack = true;  // enable stack on error\\r\\n   *\\r\\n   * @param {Boolean}\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  includeStack: false,\\r\\n\\r\\n  /**\\r\\n   * ### config.showDiff\\r\\n   *\\r\\n   * User configurable property, influences whether or not\\r\\n   * the `showDiff` flag should be included in the thrown\\r\\n   * AssertionErrors. `false` will always be `false`; `true`\\r\\n   * will be true when the assertion has requested a diff\\r\\n   * be shown.\\r\\n   *\\r\\n   * @param {Boolean}\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  showDiff: true,\\r\\n\\r\\n  /**\\r\\n   * ### config.truncateThreshold\\r\\n   *\\r\\n   * User configurable property, sets length threshold for actual and\\r\\n   * expected values in assertion errors. If this threshold is exceeded, for\\r\\n   * example for large data structures, the value is replaced with something\\r\\n   * like `[ Array(3) ]` or `{ Object (prop1, prop2) }`.\\r\\n   *\\r\\n   * Set it to zero if you want to disable truncating altogether.\\r\\n   *\\r\\n   * This is especially userful when doing assertions on arrays: having this\\r\\n   * set to a reasonable large value makes the failure messages readily\\r\\n   * inspectable.\\r\\n   *\\r\\n   *     chai.config.truncateThreshold = 0;  // disable truncating\\r\\n   *\\r\\n   * @param {Number}\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  truncateThreshold: 40,\\r\\n\\r\\n  /**\\r\\n   * ### config.useProxy\\r\\n   *\\r\\n   * User configurable property, defines if chai will use a Proxy to throw\\r\\n   * an error when a non-existent property is read, which protects users\\r\\n   * from typos when using property-based assertions.\\r\\n   *\\r\\n   * Set it to false if you want to disable this feature.\\r\\n   *\\r\\n   *     chai.config.useProxy = false;  // disable use of Proxy\\r\\n   *\\r\\n   * This feature is automatically disabled regardless of this config value\\r\\n   * in environments that don't support proxies.\\r\\n   *\\r\\n   * @param {Boolean}\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  useProxy: true,\\r\\n\\r\\n  /**\\r\\n   * ### config.proxyExcludedKeys\\r\\n   *\\r\\n   * User configurable property, defines which properties should be ignored\\r\\n   * instead of throwing an error if they do not exist on the assertion.\\r\\n   * This is only applied if the environment Chai is running in supports proxies and\\r\\n   * if the `useProxy` configuration setting is enabled.\\r\\n   * By default, `then` and `inspect` will not throw an error if they do not exist on the\\r\\n   * assertion object because the `.inspect` property is read by `util.inspect` (for example, when\\r\\n   * using `console.log` on the assertion object) and `.then` is necessary for promise type-checking.\\r\\n   *\\r\\n   *     // By default these keys will not throw an error if they do not exist on the assertion object\\r\\n   *     chai.config.proxyExcludedKeys = ['then', 'inspect'];\\r\\n   *\\r\\n   * @param {Array}\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  proxyExcludedKeys: ['then', 'catch', 'inspect', 'toJSON']\\r\\n};\\r\\n\\n\\n//# sourceURL=webpack:///./node_modules/chai/lib/chai/config.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/chai/lib/chai/core/assertions.js\":\n/*!*******************************************************!*\\\n  !*** ./node_modules/chai/lib/chai/core/assertions.js ***!\n  \\*******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\neval(\"/*!\\r\\n * chai\\r\\n * http://chaijs.com\\r\\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\\r\\n * MIT Licensed\\r\\n */\\r\\n\\r\\nmodule.exports = function (chai, _) {\\r\\n  var Assertion = chai.Assertion\\r\\n    , AssertionError = chai.AssertionError\\r\\n    , flag = _.flag;\\r\\n\\r\\n  /**\\r\\n   * ### Language Chains\\r\\n   *\\r\\n   * The following are provided as chainable getters to improve the readability\\r\\n   * of your assertions.\\r\\n   *\\r\\n   * **Chains**\\r\\n   *\\r\\n   * - to\\r\\n   * - be\\r\\n   * - been\\r\\n   * - is\\r\\n   * - that\\r\\n   * - which\\r\\n   * - and\\r\\n   * - has\\r\\n   * - have\\r\\n   * - with\\r\\n   * - at\\r\\n   * - of\\r\\n   * - same\\r\\n   * - but\\r\\n   * - does\\r\\n   * - still\\r\\n   *\\r\\n   * @name language chains\\r\\n   * @namespace BDD\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  [ 'to', 'be', 'been', 'is'\\r\\n  , 'and', 'has', 'have', 'with'\\r\\n  , 'that', 'which', 'at', 'of'\\r\\n  , 'same', 'but', 'does', 'still' ].forEach(function (chain) {\\r\\n    Assertion.addProperty(chain);\\r\\n  });\\r\\n\\r\\n  /**\\r\\n   * ### .not\\r\\n   *\\r\\n   * Negates all assertions that follow in the chain.\\r\\n   *\\r\\n   *     expect(function () {}).to.not.throw();\\r\\n   *     expect({a: 1}).to.not.have.property('b');\\r\\n   *     expect([1, 2]).to.be.an('array').that.does.not.include(3);\\r\\n   *\\r\\n   * Just because you can negate any assertion with `.not` doesn't mean you\\r\\n   * should. With great power comes great responsibility. It's often best to\\r\\n   * assert that the one expected output was produced, rather than asserting\\r\\n   * that one of countless unexpected outputs wasn't produced. See individual\\r\\n   * assertions for specific guidance.\\r\\n   *\\r\\n   *     expect(2).to.equal(2); // Recommended\\r\\n   *     expect(2).to.not.equal(1); // Not recommended\\r\\n   *\\r\\n   * @name not\\r\\n   * @namespace BDD\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  Assertion.addProperty('not', function () {\\r\\n    flag(this, 'negate', true);\\r\\n  });\\r\\n\\r\\n  /**\\r\\n   * ### .deep\\r\\n   *\\r\\n   * Causes all `.equal`, `.include`, `.members`, `.keys`, and `.property`\\r\\n   * assertions that follow in the chain to use deep equality instead of strict\\r\\n   * (`===`) equality. See the `deep-eql` project page for info on the deep\\r\\n   * equality algorithm: https://github.com/chaijs/deep-eql.\\r\\n   *\\r\\n   *     // Target object deeply (but not strictly) equals `{a: 1}`\\r\\n   *     expect({a: 1}).to.deep.equal({a: 1});\\r\\n   *     expect({a: 1}).to.not.equal({a: 1});\\r\\n   *\\r\\n   *     // Target array deeply (but not strictly) includes `{a: 1}`\\r\\n   *     expect([{a: 1}]).to.deep.include({a: 1});\\r\\n   *     expect([{a: 1}]).to.not.include({a: 1});\\r\\n   *\\r\\n   *     // Target object deeply (but not strictly) includes `x: {a: 1}`\\r\\n   *     expect({x: {a: 1}}).to.deep.include({x: {a: 1}});\\r\\n   *     expect({x: {a: 1}}).to.not.include({x: {a: 1}});\\r\\n   *\\r\\n   *     // Target array deeply (but not strictly) has member `{a: 1}`\\r\\n   *     expect([{a: 1}]).to.have.deep.members([{a: 1}]);\\r\\n   *     expect([{a: 1}]).to.not.have.members([{a: 1}]);\\r\\n   *\\r\\n   *     // Target set deeply (but not strictly) has key `{a: 1}`\\r\\n   *     expect(new Set([{a: 1}])).to.have.deep.keys([{a: 1}]);\\r\\n   *     expect(new Set([{a: 1}])).to.not.have.keys([{a: 1}]);\\r\\n   *\\r\\n   *     // Target object deeply (but not strictly) has property `x: {a: 1}`\\r\\n   *     expect({x: {a: 1}}).to.have.deep.property('x', {a: 1});\\r\\n   *     expect({x: {a: 1}}).to.not.have.property('x', {a: 1});\\r\\n   *\\r\\n   * @name deep\\r\\n   * @namespace BDD\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  Assertion.addProperty('deep', function () {\\r\\n    flag(this, 'deep', true);\\r\\n  });\\r\\n\\r\\n  /**\\r\\n   * ### .nested\\r\\n   *\\r\\n   * Enables dot- and bracket-notation in all `.property` and `.include`\\r\\n   * assertions that follow in the chain.\\r\\n   *\\r\\n   *     expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]');\\r\\n   *     expect({a: {b: ['x', 'y']}}).to.nested.include({'a.b[1]': 'y'});\\r\\n   *\\r\\n   * If `.` or `[]` are part of an actual property name, they can be escaped by\\r\\n   * adding two backslashes before them.\\r\\n   *\\r\\n   *     expect({'.a': {'[b]': 'x'}}).to.have.nested.property('\\\\\\\\.a.\\\\\\\\[b\\\\\\\\]');\\r\\n   *     expect({'.a': {'[b]': 'x'}}).to.nested.include({'\\\\\\\\.a.\\\\\\\\[b\\\\\\\\]': 'x'});\\r\\n   *\\r\\n   * `.nested` cannot be combined with `.own`.\\r\\n   *\\r\\n   * @name nested\\r\\n   * @namespace BDD\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  Assertion.addProperty('nested', function () {\\r\\n    flag(this, 'nested', true);\\r\\n  });\\r\\n\\r\\n  /**\\r\\n   * ### .own\\r\\n   *\\r\\n   * Causes all `.property` and `.include` assertions that follow in the chain\\r\\n   * to ignore inherited properties.\\r\\n   *\\r\\n   *     Object.prototype.b = 2;\\r\\n   *\\r\\n   *     expect({a: 1}).to.have.own.property('a');\\r\\n   *     expect({a: 1}).to.have.property('b');\\r\\n   *     expect({a: 1}).to.not.have.own.property('b');\\r\\n   *\\r\\n   *     expect({a: 1}).to.own.include({a: 1});\\r\\n   *     expect({a: 1}).to.include({b: 2}).but.not.own.include({b: 2});\\r\\n   *\\r\\n   * `.own` cannot be combined with `.nested`.\\r\\n   *\\r\\n   * @name own\\r\\n   * @namespace BDD\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  Assertion.addProperty('own', function () {\\r\\n    flag(this, 'own', true);\\r\\n  });\\r\\n\\r\\n  /**\\r\\n   * ### .ordered\\r\\n   *\\r\\n   * Causes all `.members` assertions that follow in the chain to require that\\r\\n   * members be in the same order.\\r\\n   *\\r\\n   *     expect([1, 2]).to.have.ordered.members([1, 2])\\r\\n   *       .but.not.have.ordered.members([2, 1]);\\r\\n   *\\r\\n   * When `.include` and `.ordered` are combined, the ordering begins at the\\r\\n   * start of both arrays.\\r\\n   *\\r\\n   *     expect([1, 2, 3]).to.include.ordered.members([1, 2])\\r\\n   *       .but.not.include.ordered.members([2, 3]);\\r\\n   *\\r\\n   * @name ordered\\r\\n   * @namespace BDD\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  Assertion.addProperty('ordered', function () {\\r\\n    flag(this, 'ordered', true);\\r\\n  });\\r\\n\\r\\n  /**\\r\\n   * ### .any\\r\\n   *\\r\\n   * Causes all `.keys` assertions that follow in the chain to only require that\\r\\n   * the target have at least one of the given keys. This is the opposite of\\r\\n   * `.all`, which requires that the target have all of the given keys.\\r\\n   *\\r\\n   *     expect({a: 1, b: 2}).to.not.have.any.keys('c', 'd');\\r\\n   *\\r\\n   * See the `.keys` doc for guidance on when to use `.any` or `.all`.\\r\\n   *\\r\\n   * @name any\\r\\n   * @namespace BDD\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  Assertion.addProperty('any', function () {\\r\\n    flag(this, 'any', true);\\r\\n    flag(this, 'all', false);\\r\\n  });\\r\\n\\r\\n  /**\\r\\n   * ### .all\\r\\n   *\\r\\n   * Causes all `.keys` assertions that follow in the chain to require that the\\r\\n   * target have all of the given keys. This is the opposite of `.any`, which\\r\\n   * only requires that the target have at least one of the given keys.\\r\\n   *\\r\\n   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b');\\r\\n   *\\r\\n   * Note that `.all` is used by default when neither `.all` nor `.any` are\\r\\n   * added earlier in the chain. However, it's often best to add `.all` anyway\\r\\n   * because it improves readability.\\r\\n   *\\r\\n   * See the `.keys` doc for guidance on when to use `.any` or `.all`.\\r\\n   *\\r\\n   * @name all\\r\\n   * @namespace BDD\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  Assertion.addProperty('all', function () {\\r\\n    flag(this, 'all', true);\\r\\n    flag(this, 'any', false);\\r\\n  });\\r\\n\\r\\n  /**\\r\\n   * ### .a(type[, msg])\\r\\n   *\\r\\n   * Asserts that the target's type is equal to the given string `type`. Types\\r\\n   * are case insensitive. See the `type-detect` project page for info on the\\r\\n   * type detection algorithm: https://github.com/chaijs/type-detect.\\r\\n   *\\r\\n   *     expect('foo').to.be.a('string');\\r\\n   *     expect({a: 1}).to.be.an('object');\\r\\n   *     expect(null).to.be.a('null');\\r\\n   *     expect(undefined).to.be.an('undefined');\\r\\n   *     expect(new Error).to.be.an('error');\\r\\n   *     expect(Promise.resolve()).to.be.a('promise');\\r\\n   *     expect(new Float32Array).to.be.a('float32array');\\r\\n   *     expect(Symbol()).to.be.a('symbol');\\r\\n   *\\r\\n   * `.a` supports objects that have a custom type set via `Symbol.toStringTag`.\\r\\n   *\\r\\n   *     var myObj = {\\r\\n   *       [Symbol.toStringTag]: 'myCustomType'\\r\\n   *     };\\r\\n   *\\r\\n   *     expect(myObj).to.be.a('myCustomType').but.not.an('object');\\r\\n   *\\r\\n   * It's often best to use `.a` to check a target's type before making more\\r\\n   * assertions on the same target. That way, you avoid unexpected behavior from\\r\\n   * any assertion that does different things based on the target's type.\\r\\n   *\\r\\n   *     expect([1, 2, 3]).to.be.an('array').that.includes(2);\\r\\n   *     expect([]).to.be.an('array').that.is.empty;\\r\\n   *\\r\\n   * Add `.not` earlier in the chain to negate `.a`. However, it's often best to\\r\\n   * assert that the target is the expected type, rather than asserting that it\\r\\n   * isn't one of many unexpected types.\\r\\n   *\\r\\n   *     expect('foo').to.be.a('string'); // Recommended\\r\\n   *     expect('foo').to.not.be.an('array'); // Not recommended\\r\\n   *\\r\\n   * `.a` accepts an optional `msg` argument which is a custom error message to\\r\\n   * show when the assertion fails. The message can also be given as the second\\r\\n   * argument to `expect`.\\r\\n   *\\r\\n   *     expect(1).to.be.a('string', 'nooo why fail??');\\r\\n   *     expect(1, 'nooo why fail??').to.be.a('string');\\r\\n   *\\r\\n   * `.a` can also be used as a language chain to improve the readability of\\r\\n   * your assertions.\\r\\n   *\\r\\n   *     expect({b: 2}).to.have.a.property('b');\\r\\n   *\\r\\n   * The alias `.an` can be used interchangeably with `.a`.\\r\\n   *\\r\\n   * @name a\\r\\n   * @alias an\\r\\n   * @param {String} type\\r\\n   * @param {String} msg _optional_\\r\\n   * @namespace BDD\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  function an (type, msg) {\\r\\n    if (msg) flag(this, 'message', msg);\\r\\n    type = type.toLowerCase();\\r\\n    var obj = flag(this, 'object')\\r\\n      , article = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(type.charAt(0)) ? 'an ' : 'a ';\\r\\n\\r\\n    this.assert(\\r\\n        type === _.type(obj).toLowerCase()\\r\\n      , 'expected #{this} to be ' + article + type\\r\\n      , 'expected #{this} not to be ' + article + type\\r\\n    );\\r\\n  }\\r\\n\\r\\n  Assertion.addChainableMethod('an', an);\\r\\n  Assertion.addChainableMethod('a', an);\\r\\n\\r\\n  /**\\r\\n   * ### .include(val[, msg])\\r\\n   *\\r\\n   * When the target is a string, `.include` asserts that the given string `val`\\r\\n   * is a substring of the target.\\r\\n   *\\r\\n   *     expect('foobar').to.include('foo');\\r\\n   *\\r\\n   * When the target is an array, `.include` asserts that the given `val` is a\\r\\n   * member of the target.\\r\\n   *\\r\\n   *     expect([1, 2, 3]).to.include(2);\\r\\n   *\\r\\n   * When the target is an object, `.include` asserts that the given object\\r\\n   * `val`'s properties are a subset of the target's properties.\\r\\n   *\\r\\n   *     expect({a: 1, b: 2, c: 3}).to.include({a: 1, b: 2});\\r\\n   *\\r\\n   * When the target is a Set or WeakSet, `.include` asserts that the given `val` is a\\r\\n   * member of the target. SameValueZero equality algorithm is used.\\r\\n   *\\r\\n   *     expect(new Set([1, 2])).to.include(2);\\r\\n   *\\r\\n   * When the target is a Map, `.include` asserts that the given `val` is one of\\r\\n   * the values of the target. SameValueZero equality algorithm is used.\\r\\n   *\\r\\n   *     expect(new Map([['a', 1], ['b', 2]])).to.include(2);\\r\\n   *\\r\\n   * Because `.include` does different things based on the target's type, it's\\r\\n   * important to check the target's type before using `.include`. See the `.a`\\r\\n   * doc for info on testing a target's type.\\r\\n   *\\r\\n   *     expect([1, 2, 3]).to.be.an('array').that.includes(2);\\r\\n   *\\r\\n   * By default, strict (`===`) equality is used to compare array members and\\r\\n   * object properties. Add `.deep` earlier in the chain to use deep equality\\r\\n   * instead (WeakSet targets are not supported). See the `deep-eql` project\\r\\n   * page for info on the deep equality algorithm: https://github.com/chaijs/deep-eql.\\r\\n   *\\r\\n   *     // Target array deeply (but not strictly) includes `{a: 1}`\\r\\n   *     expect([{a: 1}]).to.deep.include({a: 1});\\r\\n   *     expect([{a: 1}]).to.not.include({a: 1});\\r\\n   *\\r\\n   *     // Target object deeply (but not strictly) includes `x: {a: 1}`\\r\\n   *     expect({x: {a: 1}}).to.deep.include({x: {a: 1}});\\r\\n   *     expect({x: {a: 1}}).to.not.include({x: {a: 1}});\\r\\n   *\\r\\n   * By default, all of the target's properties are searched when working with\\r\\n   * objects. This includes properties that are inherited and/or non-enumerable.\\r\\n   * Add `.own` earlier in the chain to exclude the target's inherited\\r\\n   * properties from the search.\\r\\n   *\\r\\n   *     Object.prototype.b = 2;\\r\\n   *\\r\\n   *     expect({a: 1}).to.own.include({a: 1});\\r\\n   *     expect({a: 1}).to.include({b: 2}).but.not.own.include({b: 2});\\r\\n   *\\r\\n   * Note that a target object is always only searched for `val`'s own\\r\\n   * enumerable properties.\\r\\n   *\\r\\n   * `.deep` and `.own` can be combined.\\r\\n   *\\r\\n   *     expect({a: {b: 2}}).to.deep.own.include({a: {b: 2}});\\r\\n   *\\r\\n   * Add `.nested` earlier in the chain to enable dot- and bracket-notation when\\r\\n   * referencing nested properties.\\r\\n   *\\r\\n   *     expect({a: {b: ['x', 'y']}}).to.nested.include({'a.b[1]': 'y'});\\r\\n   *\\r\\n   * If `.` or `[]` are part of an actual property name, they can be escaped by\\r\\n   * adding two backslashes before them.\\r\\n   *\\r\\n   *     expect({'.a': {'[b]': 2}}).to.nested.include({'\\\\\\\\.a.\\\\\\\\[b\\\\\\\\]': 2});\\r\\n   *\\r\\n   * `.deep` and `.nested` can be combined.\\r\\n   *\\r\\n   *     expect({a: {b: [{c: 3}]}}).to.deep.nested.include({'a.b[0]': {c: 3}});\\r\\n   *\\r\\n   * `.own` and `.nested` cannot be combined.\\r\\n   *\\r\\n   * Add `.not` earlier in the chain to negate `.include`.\\r\\n   *\\r\\n   *     expect('foobar').to.not.include('taco');\\r\\n   *     expect([1, 2, 3]).to.not.include(4);\\r\\n   *\\r\\n   * However, it's dangerous to negate `.include` when the target is an object.\\r\\n   * The problem is that it creates uncertain expectations by asserting that the\\r\\n   * target object doesn't have all of `val`'s key/value pairs but may or may\\r\\n   * not have some of them. It's often best to identify the exact output that's\\r\\n   * expected, and then write an assertion that only accepts that exact output.\\r\\n   *\\r\\n   * When the target object isn't even expected to have `val`'s keys, it's\\r\\n   * often best to assert exactly that.\\r\\n   *\\r\\n   *     expect({c: 3}).to.not.have.any.keys('a', 'b'); // Recommended\\r\\n   *     expect({c: 3}).to.not.include({a: 1, b: 2}); // Not recommended\\r\\n   *\\r\\n   * When the target object is expected to have `val`'s keys, it's often best to\\r\\n   * assert that each of the properties has its expected value, rather than\\r\\n   * asserting that each property doesn't have one of many unexpected values.\\r\\n   *\\r\\n   *     expect({a: 3, b: 4}).to.include({a: 3, b: 4}); // Recommended\\r\\n   *     expect({a: 3, b: 4}).to.not.include({a: 1, b: 2}); // Not recommended\\r\\n   *\\r\\n   * `.include` accepts an optional `msg` argument which is a custom error\\r\\n   * message to show when the assertion fails. The message can also be given as\\r\\n   * the second argument to `expect`.\\r\\n   *\\r\\n   *     expect([1, 2, 3]).to.include(4, 'nooo why fail??');\\r\\n   *     expect([1, 2, 3], 'nooo why fail??').to.include(4);\\r\\n   *\\r\\n   * `.include` can also be used as a language chain, causing all `.members` and\\r\\n   * `.keys` assertions that follow in the chain to require the target to be a\\r\\n   * superset of the expected set, rather than an identical set. Note that\\r\\n   * `.members` ignores duplicates in the subset when `.include` is added.\\r\\n   *\\r\\n   *     // Target object's keys are a superset of ['a', 'b'] but not identical\\r\\n   *     expect({a: 1, b: 2, c: 3}).to.include.all.keys('a', 'b');\\r\\n   *     expect({a: 1, b: 2, c: 3}).to.not.have.all.keys('a', 'b');\\r\\n   *\\r\\n   *     // Target array is a superset of [1, 2] but not identical\\r\\n   *     expect([1, 2, 3]).to.include.members([1, 2]);\\r\\n   *     expect([1, 2, 3]).to.not.have.members([1, 2]);\\r\\n   *\\r\\n   *     // Duplicates in the subset are ignored\\r\\n   *     expect([1, 2, 3]).to.include.members([1, 2, 2, 2]);\\r\\n   *\\r\\n   * Note that adding `.any` earlier in the chain causes the `.keys` assertion\\r\\n   * to ignore `.include`.\\r\\n   *\\r\\n   *     // Both assertions are identical\\r\\n   *     expect({a: 1}).to.include.any.keys('a', 'b');\\r\\n   *     expect({a: 1}).to.have.any.keys('a', 'b');\\r\\n   *\\r\\n   * The aliases `.includes`, `.contain`, and `.contains` can be used\\r\\n   * interchangeably with `.include`.\\r\\n   *\\r\\n   * @name include\\r\\n   * @alias contain\\r\\n   * @alias includes\\r\\n   * @alias contains\\r\\n   * @param {Mixed} val\\r\\n   * @param {String} msg _optional_\\r\\n   * @namespace BDD\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  function SameValueZero(a, b) {\\r\\n    return (_.isNaN(a) && _.isNaN(b)) || a === b;\\r\\n  }\\r\\n\\r\\n  function includeChainingBehavior () {\\r\\n    flag(this, 'contains', true);\\r\\n  }\\r\\n\\r\\n  function include (val, msg) {\\r\\n    if (msg) flag(this, 'message', msg);\\r\\n\\r\\n    var obj = flag(this, 'object')\\r\\n      , objType = _.type(obj).toLowerCase()\\r\\n      , flagMsg = flag(this, 'message')\\r\\n      , negate = flag(this, 'negate')\\r\\n      , ssfi = flag(this, 'ssfi')\\r\\n      , isDeep = flag(this, 'deep')\\r\\n      , descriptor = isDeep ? 'deep ' : '';\\r\\n\\r\\n    flagMsg = flagMsg ? flagMsg + ': ' : '';\\r\\n\\r\\n    var included = false;\\r\\n\\r\\n    switch (objType) {\\r\\n      case 'string':\\r\\n        included = obj.indexOf(val) !== -1;\\r\\n        break;\\r\\n\\r\\n      case 'weakset':\\r\\n        if (isDeep) {\\r\\n          throw new AssertionError(\\r\\n            flagMsg + 'unable to use .deep.include with WeakSet',\\r\\n            undefined,\\r\\n            ssfi\\r\\n          );\\r\\n        }\\r\\n\\r\\n        included = obj.has(val);\\r\\n        break;\\r\\n\\r\\n      case 'map':\\r\\n        var isEql = isDeep ? _.eql : SameValueZero;\\r\\n        obj.forEach(function (item) {\\r\\n          included = included || isEql(item, val);\\r\\n        });\\r\\n        break;\\r\\n\\r\\n      case 'set':\\r\\n        if (isDeep) {\\r\\n          obj.forEach(function (item) {\\r\\n            included = included || _.eql(item, val);\\r\\n          });\\r\\n        } else {\\r\\n          included = obj.has(val);\\r\\n        }\\r\\n        break;\\r\\n\\r\\n      case 'array':\\r\\n        if (isDeep) {\\r\\n          included = obj.some(function (item) {\\r\\n            return _.eql(item, val);\\r\\n          })\\r\\n        } else {\\r\\n          included = obj.indexOf(val) !== -1;\\r\\n        }\\r\\n        break;\\r\\n\\r\\n      default:\\r\\n        // This block is for asserting a subset of properties in an object.\\r\\n        // `_.expectTypes` isn't used here because `.include` should work with\\r\\n        // objects with a custom `@@toStringTag`.\\r\\n        if (val !== Object(val)) {\\r\\n          throw new AssertionError(\\r\\n            flagMsg + 'object tested must be an array, a map, an object,'\\r\\n              + ' a set, a string, or a weakset, but ' + objType + ' given',\\r\\n            undefined,\\r\\n            ssfi\\r\\n          );\\r\\n        }\\r\\n\\r\\n        var props = Object.keys(val)\\r\\n          , firstErr = null\\r\\n          , numErrs = 0;\\r\\n\\r\\n        props.forEach(function (prop) {\\r\\n          var propAssertion = new Assertion(obj);\\r\\n          _.transferFlags(this, propAssertion, true);\\r\\n          flag(propAssertion, 'lockSsfi', true);\\r\\n\\r\\n          if (!negate || props.length === 1) {\\r\\n            propAssertion.property(prop, val[prop]);\\r\\n            return;\\r\\n          }\\r\\n\\r\\n          try {\\r\\n            propAssertion.property(prop, val[prop]);\\r\\n          } catch (err) {\\r\\n            if (!_.checkError.compatibleConstructor(err, AssertionError)) {\\r\\n              throw err;\\r\\n            }\\r\\n            if (firstErr === null) firstErr = err;\\r\\n            numErrs++;\\r\\n          }\\r\\n        }, this);\\r\\n\\r\\n        // When validating .not.include with multiple properties, we only want\\r\\n        // to throw an assertion error if all of the properties are included,\\r\\n        // in which case we throw the first property assertion error that we\\r\\n        // encountered.\\r\\n        if (negate && props.length > 1 && numErrs === props.length) {\\r\\n          throw firstErr;\\r\\n        }\\r\\n        return;\\r\\n    }\\r\\n\\r\\n    // Assert inclusion in collection or substring in a string.\\r\\n    this.assert(\\r\\n      included\\r\\n      , 'expected #{this} to ' + descriptor + 'include ' + _.inspect(val)\\r\\n      , 'expected #{this} to not ' + descriptor + 'include ' + _.inspect(val));\\r\\n  }\\r\\n\\r\\n  Assertion.addChainableMethod('include', include, includeChainingBehavior);\\r\\n  Assertion.addChainableMethod('contain', include, includeChainingBehavior);\\r\\n  Assertion.addChainableMethod('contains', include, includeChainingBehavior);\\r\\n  Assertion.addChainableMethod('includes', include, includeChainingBehavior);\\r\\n\\r\\n  /**\\r\\n   * ### .ok\\r\\n   *\\r\\n   * Asserts that the target is a truthy value (considered `true` in boolean context).\\r\\n   * However, it's often best to assert that the target is strictly (`===`) or\\r\\n   * deeply equal to its expected value.\\r\\n   *\\r\\n   *     expect(1).to.equal(1); // Recommended\\r\\n   *     expect(1).to.be.ok; // Not recommended\\r\\n   *\\r\\n   *     expect(true).to.be.true; // Recommended\\r\\n   *     expect(true).to.be.ok; // Not recommended\\r\\n   *\\r\\n   * Add `.not` earlier in the chain to negate `.ok`.\\r\\n   *\\r\\n   *     expect(0).to.equal(0); // Recommended\\r\\n   *     expect(0).to.not.be.ok; // Not recommended\\r\\n   *\\r\\n   *     expect(false).to.be.false; // Recommended\\r\\n   *     expect(false).to.not.be.ok; // Not recommended\\r\\n   *\\r\\n   *     expect(null).to.be.null; // Recommended\\r\\n   *     expect(null).to.not.be.ok; // Not recommended\\r\\n   *\\r\\n   *     expect(undefined).to.be.undefined; // Recommended\\r\\n   *     expect(undefined).to.not.be.ok; // Not recommended\\r\\n   *\\r\\n   * A custom error message can be given as the second argument to `expect`.\\r\\n   *\\r\\n   *     expect(false, 'nooo why fail??').to.be.ok;\\r\\n   *\\r\\n   * @name ok\\r\\n   * @namespace BDD\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  Assertion.addProperty('ok', function () {\\r\\n    this.assert(\\r\\n        flag(this, 'object')\\r\\n      , 'expected #{this} to be truthy'\\r\\n      , 'expected #{this} to be falsy');\\r\\n  });\\r\\n\\r\\n  /**\\r\\n   * ### .true\\r\\n   *\\r\\n   * Asserts that the target is strictly (`===`) equal to `true`.\\r\\n   *\\r\\n   *     expect(true).to.be.true;\\r\\n   *\\r\\n   * Add `.not` earlier in the chain to negate `.true`. However, it's often best\\r\\n   * to assert that the target is equal to its expected value, rather than not\\r\\n   * equal to `true`.\\r\\n   *\\r\\n   *     expect(false).to.be.false; // Recommended\\r\\n   *     expect(false).to.not.be.true; // Not recommended\\r\\n   *\\r\\n   *     expect(1).to.equal(1); // Recommended\\r\\n   *     expect(1).to.not.be.true; // Not recommended\\r\\n   *\\r\\n   * A custom error message can be given as the second argument to `expect`.\\r\\n   *\\r\\n   *     expect(false, 'nooo why fail??').to.be.true;\\r\\n   *\\r\\n   * @name true\\r\\n   * @namespace BDD\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  Assertion.addProperty('true', function () {\\r\\n    this.assert(\\r\\n        true === flag(this, 'object')\\r\\n      , 'expected #{this} to be true'\\r\\n      , 'expected #{this} to be false'\\r\\n      , flag(this, 'negate') ? false : true\\r\\n    );\\r\\n  });\\r\\n\\r\\n  /**\\r\\n   * ### .false\\r\\n   *\\r\\n   * Asserts that the target is strictly (`===`) equal to `false`.\\r\\n   *\\r\\n   *     expect(false).to.be.false;\\r\\n   *\\r\\n   * Add `.not` earlier in the chain to negate `.false`. However, it's often\\r\\n   * best to assert that the target is equal to its expected value, rather than\\r\\n   * not equal to `false`.\\r\\n   *\\r\\n   *     expect(true).to.be.true; // Recommended\\r\\n   *     expect(true).to.not.be.false; // Not recommended\\r\\n   *\\r\\n   *     expect(1).to.equal(1); // Recommended\\r\\n   *     expect(1).to.not.be.false; // Not recommended\\r\\n   *\\r\\n   * A custom error message can be given as the second argument to `expect`.\\r\\n   *\\r\\n   *     expect(true, 'nooo why fail??').to.be.false;\\r\\n   *\\r\\n   * @name false\\r\\n   * @namespace BDD\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  Assertion.addProperty('false', function () {\\r\\n    this.assert(\\r\\n        false === flag(this, 'object')\\r\\n      , 'expected #{this} to be false'\\r\\n      , 'expected #{this} to be true'\\r\\n      , flag(this, 'negate') ? true : false\\r\\n    );\\r\\n  });\\r\\n\\r\\n  /**\\r\\n   * ### .null\\r\\n   *\\r\\n   * Asserts that the target is strictly (`===`) equal to `null`.\\r\\n   *\\r\\n   *     expect(null).to.be.null;\\r\\n   *\\r\\n   * Add `.not` earlier in the chain to negate `.null`. However, it's often best\\r\\n   * to assert that the target is equal to its expected value, rather than not\\r\\n   * equal to `null`.\\r\\n   *\\r\\n   *     expect(1).to.equal(1); // Recommended\\r\\n   *     expect(1).to.not.be.null; // Not recommended\\r\\n   *\\r\\n   * A custom error message can be given as the second argument to `expect`.\\r\\n   *\\r\\n   *     expect(42, 'nooo why fail??').to.be.null;\\r\\n   *\\r\\n   * @name null\\r\\n   * @namespace BDD\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  Assertion.addProperty('null', function () {\\r\\n    this.assert(\\r\\n        null === flag(this, 'object')\\r\\n      , 'expected #{this} to be null'\\r\\n      , 'expected #{this} not to be null'\\r\\n    );\\r\\n  });\\r\\n\\r\\n  /**\\r\\n   * ### .undefined\\r\\n   *\\r\\n   * Asserts that the target is strictly (`===`) equal to `undefined`.\\r\\n   *\\r\\n   *     expect(undefined).to.be.undefined;\\r\\n   *\\r\\n   * Add `.not` earlier in the chain to negate `.undefined`. However, it's often\\r\\n   * best to assert that the target is equal to its expected value, rather than\\r\\n   * not equal to `undefined`.\\r\\n   *\\r\\n   *     expect(1).to.equal(1); // Recommended\\r\\n   *     expect(1).to.not.be.undefined; // Not recommended\\r\\n   *\\r\\n   * A custom error message can be given as the second argument to `expect`.\\r\\n   *\\r\\n   *     expect(42, 'nooo why fail??').to.be.undefined;\\r\\n   *\\r\\n   * @name undefined\\r\\n   * @namespace BDD\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  Assertion.addProperty('undefined', function () {\\r\\n    this.assert(\\r\\n        undefined === flag(this, 'object')\\r\\n      , 'expected #{this} to be undefined'\\r\\n      , 'expected #{this} not to be undefined'\\r\\n    );\\r\\n  });\\r\\n\\r\\n  /**\\r\\n   * ### .NaN\\r\\n   *\\r\\n   * Asserts that the target is exactly `NaN`.\\r\\n   *\\r\\n   *     expect(NaN).to.be.NaN;\\r\\n   *\\r\\n   * Add `.not` earlier in the chain to negate `.NaN`. However, it's often best\\r\\n   * to assert that the target is equal to its expected value, rather than not\\r\\n   * equal to `NaN`.\\r\\n   *\\r\\n   *     expect('foo').to.equal('foo'); // Recommended\\r\\n   *     expect('foo').to.not.be.NaN; // Not recommended\\r\\n   *\\r\\n   * A custom error message can be given as the second argument to `expect`.\\r\\n   *\\r\\n   *     expect(42, 'nooo why fail??').to.be.NaN;\\r\\n   *\\r\\n   * @name NaN\\r\\n   * @namespace BDD\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  Assertion.addProperty('NaN', function () {\\r\\n    this.assert(\\r\\n        _.isNaN(flag(this, 'object'))\\r\\n        , 'expected #{this} to be NaN'\\r\\n        , 'expected #{this} not to be NaN'\\r\\n    );\\r\\n  });\\r\\n\\r\\n  /**\\r\\n   * ### .exist\\r\\n   *\\r\\n   * Asserts that the target is not strictly (`===`) equal to either `null` or\\r\\n   * `undefined`. However, it's often best to assert that the target is equal to\\r\\n   * its expected value.\\r\\n   *\\r\\n   *     expect(1).to.equal(1); // Recommended\\r\\n   *     expect(1).to.exist; // Not recommended\\r\\n   *\\r\\n   *     expect(0).to.equal(0); // Recommended\\r\\n   *     expect(0).to.exist; // Not recommended\\r\\n   *\\r\\n   * Add `.not` earlier in the chain to negate `.exist`.\\r\\n   *\\r\\n   *     expect(null).to.be.null; // Recommended\\r\\n   *     expect(null).to.not.exist; // Not recommended\\r\\n   *\\r\\n   *     expect(undefined).to.be.undefined; // Recommended\\r\\n   *     expect(undefined).to.not.exist; // Not recommended\\r\\n   *\\r\\n   * A custom error message can be given as the second argument to `expect`.\\r\\n   *\\r\\n   *     expect(null, 'nooo why fail??').to.exist;\\r\\n   *\\r\\n   * @name exist\\r\\n   * @namespace BDD\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  Assertion.addProperty('exist', function () {\\r\\n    var val = flag(this, 'object');\\r\\n    this.assert(\\r\\n        val !== null && val !== undefined\\r\\n      , 'expected #{this} to exist'\\r\\n      , 'expected #{this} to not exist'\\r\\n    );\\r\\n  });\\r\\n\\r\\n  /**\\r\\n   * ### .empty\\r\\n   *\\r\\n   * When the target is a string or array, `.empty` asserts that the target's\\r\\n   * `length` property is strictly (`===`) equal to `0`.\\r\\n   *\\r\\n   *     expect([]).to.be.empty;\\r\\n   *     expect('').to.be.empty;\\r\\n   *\\r\\n   * When the target is a map or set, `.empty` asserts that the target's `size`\\r\\n   * property is strictly equal to `0`.\\r\\n   *\\r\\n   *     expect(new Set()).to.be.empty;\\r\\n   *     expect(new Map()).to.be.empty;\\r\\n   *\\r\\n   * When the target is a non-function object, `.empty` asserts that the target\\r\\n   * doesn't have any own enumerable properties. Properties with Symbol-based\\r\\n   * keys are excluded from the count.\\r\\n   *\\r\\n   *     expect({}).to.be.empty;\\r\\n   *\\r\\n   * Because `.empty` does different things based on the target's type, it's\\r\\n   * important to check the target's type before using `.empty`. See the `.a`\\r\\n   * doc for info on testing a target's type.\\r\\n   *\\r\\n   *     expect([]).to.be.an('array').that.is.empty;\\r\\n   *\\r\\n   * Add `.not` earlier in the chain to negate `.empty`. However, it's often\\r\\n   * best to assert that the target contains its expected number of values,\\r\\n   * rather than asserting that it's not empty.\\r\\n   *\\r\\n   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended\\r\\n   *     expect([1, 2, 3]).to.not.be.empty; // Not recommended\\r\\n   *\\r\\n   *     expect(new Set([1, 2, 3])).to.have.property('size', 3); // Recommended\\r\\n   *     expect(new Set([1, 2, 3])).to.not.be.empty; // Not recommended\\r\\n   *\\r\\n   *     expect(Object.keys({a: 1})).to.have.lengthOf(1); // Recommended\\r\\n   *     expect({a: 1}).to.not.be.empty; // Not recommended\\r\\n   *\\r\\n   * A custom error message can be given as the second argument to `expect`.\\r\\n   *\\r\\n   *     expect([1, 2, 3], 'nooo why fail??').to.be.empty;\\r\\n   *\\r\\n   * @name empty\\r\\n   * @namespace BDD\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  Assertion.addProperty('empty', function () {\\r\\n    var val = flag(this, 'object')\\r\\n      , ssfi = flag(this, 'ssfi')\\r\\n      , flagMsg = flag(this, 'message')\\r\\n      , itemsCount;\\r\\n\\r\\n    flagMsg = flagMsg ? flagMsg + ': ' : '';\\r\\n\\r\\n    switch (_.type(val).toLowerCase()) {\\r\\n      case 'array':\\r\\n      case 'string':\\r\\n        itemsCount = val.length;\\r\\n        break;\\r\\n      case 'map':\\r\\n      case 'set':\\r\\n        itemsCount = val.size;\\r\\n        break;\\r\\n      case 'weakmap':\\r\\n      case 'weakset':\\r\\n        throw new AssertionError(\\r\\n          flagMsg + '.empty was passed a weak collection',\\r\\n          undefined,\\r\\n          ssfi\\r\\n        );\\r\\n      case 'function':\\r\\n        var msg = flagMsg + '.empty was passed a function ' + _.getName(val);\\r\\n        throw new AssertionError(msg.trim(), undefined, ssfi);\\r\\n      default:\\r\\n        if (val !== Object(val)) {\\r\\n          throw new AssertionError(\\r\\n            flagMsg + '.empty was passed non-string primitive ' + _.inspect(val),\\r\\n            undefined,\\r\\n            ssfi\\r\\n          );\\r\\n        }\\r\\n        itemsCount = Object.keys(val).length;\\r\\n    }\\r\\n\\r\\n    this.assert(\\r\\n        0 === itemsCount\\r\\n      , 'expected #{this} to be empty'\\r\\n      , 'expected #{this} not to be empty'\\r\\n    );\\r\\n  });\\r\\n\\r\\n  /**\\r\\n   * ### .arguments\\r\\n   *\\r\\n   * Asserts that the target is an `arguments` object.\\r\\n   *\\r\\n   *     function test () {\\r\\n   *       expect(arguments).to.be.arguments;\\r\\n   *     }\\r\\n   *\\r\\n   *     test();\\r\\n   *\\r\\n   * Add `.not` earlier in the chain to negate `.arguments`. However, it's often\\r\\n   * best to assert which type the target is expected to be, rather than\\r\\n   * asserting that its not an `arguments` object.\\r\\n   *\\r\\n   *     expect('foo').to.be.a('string'); // Recommended\\r\\n   *     expect('foo').to.not.be.arguments; // Not recommended\\r\\n   *\\r\\n   * A custom error message can be given as the second argument to `expect`.\\r\\n   *\\r\\n   *     expect({}, 'nooo why fail??').to.be.arguments;\\r\\n   *\\r\\n   * The alias `.Arguments` can be used interchangeably with `.arguments`.\\r\\n   *\\r\\n   * @name arguments\\r\\n   * @alias Arguments\\r\\n   * @namespace BDD\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  function checkArguments () {\\r\\n    var obj = flag(this, 'object')\\r\\n      , type = _.type(obj);\\r\\n    this.assert(\\r\\n        'Arguments' === type\\r\\n      , 'expected #{this} to be arguments but got ' + type\\r\\n      , 'expected #{this} to not be arguments'\\r\\n    );\\r\\n  }\\r\\n\\r\\n  Assertion.addProperty('arguments', checkArguments);\\r\\n  Assertion.addProperty('Arguments', checkArguments);\\r\\n\\r\\n  /**\\r\\n   * ### .equal(val[, msg])\\r\\n   *\\r\\n   * Asserts that the target is strictly (`===`) equal to the given `val`.\\r\\n   *\\r\\n   *     expect(1).to.equal(1);\\r\\n   *     expect('foo').to.equal('foo');\\r\\n   *\\r\\n   * Add `.deep` earlier in the chain to use deep equality instead. See the\\r\\n   * `deep-eql` project page for info on the deep equality algorithm:\\r\\n   * https://github.com/chaijs/deep-eql.\\r\\n   *\\r\\n   *     // Target object deeply (but not strictly) equals `{a: 1}`\\r\\n   *     expect({a: 1}).to.deep.equal({a: 1});\\r\\n   *     expect({a: 1}).to.not.equal({a: 1});\\r\\n   *\\r\\n   *     // Target array deeply (but not strictly) equals `[1, 2]`\\r\\n   *     expect([1, 2]).to.deep.equal([1, 2]);\\r\\n   *     expect([1, 2]).to.not.equal([1, 2]);\\r\\n   *\\r\\n   * Add `.not` earlier in the chain to negate `.equal`. However, it's often\\r\\n   * best to assert that the target is equal to its expected value, rather than\\r\\n   * not equal to one of countless unexpected values.\\r\\n   *\\r\\n   *     expect(1).to.equal(1); // Recommended\\r\\n   *     expect(1).to.not.equal(2); // Not recommended\\r\\n   *\\r\\n   * `.equal` accepts an optional `msg` argument which is a custom error message\\r\\n   * to show when the assertion fails. The message can also be given as the\\r\\n   * second argument to `expect`.\\r\\n   *\\r\\n   *     expect(1).to.equal(2, 'nooo why fail??');\\r\\n   *     expect(1, 'nooo why fail??').to.equal(2);\\r\\n   *\\r\\n   * The aliases `.equals` and `eq` can be used interchangeably with `.equal`.\\r\\n   *\\r\\n   * @name equal\\r\\n   * @alias equals\\r\\n   * @alias eq\\r\\n   * @param {Mixed} val\\r\\n   * @param {String} msg _optional_\\r\\n   * @namespace BDD\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  function assertEqual (val, msg) {\\r\\n    if (msg) flag(this, 'message', msg);\\r\\n    var obj = flag(this, 'object');\\r\\n    if (flag(this, 'deep')) {\\r\\n      var prevLockSsfi = flag(this, 'lockSsfi');\\r\\n      flag(this, 'lockSsfi', true);\\r\\n      this.eql(val);\\r\\n      flag(this, 'lockSsfi', prevLockSsfi);\\r\\n    } else {\\r\\n      this.assert(\\r\\n          val === obj\\r\\n        , 'expected #{this} to equal #{exp}'\\r\\n        , 'expected #{this} to not equal #{exp}'\\r\\n        , val\\r\\n        , this._obj\\r\\n        , true\\r\\n      );\\r\\n    }\\r\\n  }\\r\\n\\r\\n  Assertion.addMethod('equal', assertEqual);\\r\\n  Assertion.addMethod('equals', assertEqual);\\r\\n  Assertion.addMethod('eq', assertEqual);\\r\\n\\r\\n  /**\\r\\n   * ### .eql(obj[, msg])\\r\\n   *\\r\\n   * Asserts that the target is deeply equal to the given `obj`. See the\\r\\n   * `deep-eql` project page for info on the deep equality algorithm:\\r\\n   * https://github.com/chaijs/deep-eql.\\r\\n   *\\r\\n   *     // Target object is deeply (but not strictly) equal to {a: 1}\\r\\n   *     expect({a: 1}).to.eql({a: 1}).but.not.equal({a: 1});\\r\\n   *\\r\\n   *     // Target array is deeply (but not strictly) equal to [1, 2]\\r\\n   *     expect([1, 2]).to.eql([1, 2]).but.not.equal([1, 2]);\\r\\n   *\\r\\n   * Add `.not` earlier in the chain to negate `.eql`. However, it's often best\\r\\n   * to assert that the target is deeply equal to its expected value, rather\\r\\n   * than not deeply equal to one of countless unexpected values.\\r\\n   *\\r\\n   *     expect({a: 1}).to.eql({a: 1}); // Recommended\\r\\n   *     expect({a: 1}).to.not.eql({b: 2}); // Not recommended\\r\\n   *\\r\\n   * `.eql` accepts an optional `msg` argument which is a custom error message\\r\\n   * to show when the assertion fails. The message can also be given as the\\r\\n   * second argument to `expect`.\\r\\n   *\\r\\n   *     expect({a: 1}).to.eql({b: 2}, 'nooo why fail??');\\r\\n   *     expect({a: 1}, 'nooo why fail??').to.eql({b: 2});\\r\\n   *\\r\\n   * The alias `.eqls` can be used interchangeably with `.eql`.\\r\\n   *\\r\\n   * The `.deep.equal` assertion is almost identical to `.eql` but with one\\r\\n   * difference: `.deep.equal` causes deep equality comparisons to also be used\\r\\n   * for any other assertions that follow in the chain.\\r\\n   *\\r\\n   * @name eql\\r\\n   * @alias eqls\\r\\n   * @param {Mixed} obj\\r\\n   * @param {String} msg _optional_\\r\\n   * @namespace BDD\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  function assertEql(obj, msg) {\\r\\n    if (msg) flag(this, 'message', msg);\\r\\n    this.assert(\\r\\n        _.eql(obj, flag(this, 'object'))\\r\\n      , 'expected #{this} to deeply equal #{exp}'\\r\\n      , 'expected #{this} to not deeply equal #{exp}'\\r\\n      , obj\\r\\n      , this._obj\\r\\n      , true\\r\\n    );\\r\\n  }\\r\\n\\r\\n  Assertion.addMethod('eql', assertEql);\\r\\n  Assertion.addMethod('eqls', assertEql);\\r\\n\\r\\n  /**\\r\\n   * ### .above(n[, msg])\\r\\n   *\\r\\n   * Asserts that the target is a number or a date greater than the given number or date `n` respectively.\\r\\n   * However, it's often best to assert that the target is equal to its expected\\r\\n   * value.\\r\\n   *\\r\\n   *     expect(2).to.equal(2); // Recommended\\r\\n   *     expect(2).to.be.above(1); // Not recommended\\r\\n   *\\r\\n   * Add `.lengthOf` earlier in the chain to assert that the target's `length`\\r\\n   * or `size` is greater than the given number `n`.\\r\\n   *\\r\\n   *     expect('foo').to.have.lengthOf(3); // Recommended\\r\\n   *     expect('foo').to.have.lengthOf.above(2); // Not recommended\\r\\n   *\\r\\n   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended\\r\\n   *     expect([1, 2, 3]).to.have.lengthOf.above(2); // Not recommended\\r\\n   *\\r\\n   * Add `.not` earlier in the chain to negate `.above`.\\r\\n   *\\r\\n   *     expect(2).to.equal(2); // Recommended\\r\\n   *     expect(1).to.not.be.above(2); // Not recommended\\r\\n   *\\r\\n   * `.above` accepts an optional `msg` argument which is a custom error message\\r\\n   * to show when the assertion fails. The message can also be given as the\\r\\n   * second argument to `expect`.\\r\\n   *\\r\\n   *     expect(1).to.be.above(2, 'nooo why fail??');\\r\\n   *     expect(1, 'nooo why fail??').to.be.above(2);\\r\\n   *\\r\\n   * The aliases `.gt` and `.greaterThan` can be used interchangeably with\\r\\n   * `.above`.\\r\\n   *\\r\\n   * @name above\\r\\n   * @alias gt\\r\\n   * @alias greaterThan\\r\\n   * @param {Number} n\\r\\n   * @param {String} msg _optional_\\r\\n   * @namespace BDD\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  function assertAbove (n, msg) {\\r\\n    if (msg) flag(this, 'message', msg);\\r\\n    var obj = flag(this, 'object')\\r\\n      , doLength = flag(this, 'doLength')\\r\\n      , flagMsg = flag(this, 'message')\\r\\n      , msgPrefix = ((flagMsg) ? flagMsg + ': ' : '')\\r\\n      , ssfi = flag(this, 'ssfi')\\r\\n      , objType = _.type(obj).toLowerCase()\\r\\n      , nType = _.type(n).toLowerCase()\\r\\n      , errorMessage\\r\\n      , shouldThrow = true;\\r\\n\\r\\n    if (doLength && objType !== 'map' && objType !== 'set') {\\r\\n      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');\\r\\n    }\\r\\n\\r\\n    if (!doLength && (objType === 'date' && nType !== 'date')) {\\r\\n      errorMessage = msgPrefix + 'the argument to above must be a date';\\r\\n    } else if (nType !== 'number' && (doLength || objType === 'number')) {\\r\\n      errorMessage = msgPrefix + 'the argument to above must be a number';\\r\\n    } else if (!doLength && (objType !== 'date' && objType !== 'number')) {\\r\\n      var printObj = (objType === 'string') ? \\\"'\\\" + obj + \\\"'\\\" : obj;\\r\\n      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';\\r\\n    } else {\\r\\n      shouldThrow = false;\\r\\n    }\\r\\n\\r\\n    if (shouldThrow) {\\r\\n      throw new AssertionError(errorMessage, undefined, ssfi);\\r\\n    }\\r\\n\\r\\n    if (doLength) {\\r\\n      var descriptor = 'length'\\r\\n        , itemsCount;\\r\\n      if (objType === 'map' || objType === 'set') {\\r\\n        descriptor = 'size';\\r\\n        itemsCount = obj.size;\\r\\n      } else {\\r\\n        itemsCount = obj.length;\\r\\n      }\\r\\n      this.assert(\\r\\n          itemsCount > n\\r\\n        , 'expected #{this} to have a ' + descriptor + ' above #{exp} but got #{act}'\\r\\n        , 'expected #{this} to not have a ' + descriptor + ' above #{exp}'\\r\\n        , n\\r\\n        , itemsCount\\r\\n      );\\r\\n    } else {\\r\\n      this.assert(\\r\\n          obj > n\\r\\n        , 'expected #{this} to be above #{exp}'\\r\\n        , 'expected #{this} to be at most #{exp}'\\r\\n        , n\\r\\n      );\\r\\n    }\\r\\n  }\\r\\n\\r\\n  Assertion.addMethod('above', assertAbove);\\r\\n  Assertion.addMethod('gt', assertAbove);\\r\\n  Assertion.addMethod('greaterThan', assertAbove);\\r\\n\\r\\n  /**\\r\\n   * ### .least(n[, msg])\\r\\n   *\\r\\n   * Asserts that the target is a number or a date greater than or equal to the given\\r\\n   * number or date `n` respectively. However, it's often best to assert that the target is equal to\\r\\n   * its expected value.\\r\\n   *\\r\\n   *     expect(2).to.equal(2); // Recommended\\r\\n   *     expect(2).to.be.at.least(1); // Not recommended\\r\\n   *     expect(2).to.be.at.least(2); // Not recommended\\r\\n   *\\r\\n   * Add `.lengthOf` earlier in the chain to assert that the target's `length`\\r\\n   * or `size` is greater than or equal to the given number `n`.\\r\\n   *\\r\\n   *     expect('foo').to.have.lengthOf(3); // Recommended\\r\\n   *     expect('foo').to.have.lengthOf.at.least(2); // Not recommended\\r\\n   *\\r\\n   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended\\r\\n   *     expect([1, 2, 3]).to.have.lengthOf.at.least(2); // Not recommended\\r\\n   *\\r\\n   * Add `.not` earlier in the chain to negate `.least`.\\r\\n   *\\r\\n   *     expect(1).to.equal(1); // Recommended\\r\\n   *     expect(1).to.not.be.at.least(2); // Not recommended\\r\\n   *\\r\\n   * `.least` accepts an optional `msg` argument which is a custom error message\\r\\n   * to show when the assertion fails. The message can also be given as the\\r\\n   * second argument to `expect`.\\r\\n   *\\r\\n   *     expect(1).to.be.at.least(2, 'nooo why fail??');\\r\\n   *     expect(1, 'nooo why fail??').to.be.at.least(2);\\r\\n   *\\r\\n   * The alias `.gte` can be used interchangeably with `.least`.\\r\\n   *\\r\\n   * @name least\\r\\n   * @alias gte\\r\\n   * @param {Number} n\\r\\n   * @param {String} msg _optional_\\r\\n   * @namespace BDD\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  function assertLeast (n, msg) {\\r\\n    if (msg) flag(this, 'message', msg);\\r\\n    var obj = flag(this, 'object')\\r\\n      , doLength = flag(this, 'doLength')\\r\\n      , flagMsg = flag(this, 'message')\\r\\n      , msgPrefix = ((flagMsg) ? flagMsg + ': ' : '')\\r\\n      , ssfi = flag(this, 'ssfi')\\r\\n      , objType = _.type(obj).toLowerCase()\\r\\n      , nType = _.type(n).toLowerCase()\\r\\n      , errorMessage\\r\\n      , shouldThrow = true;\\r\\n\\r\\n    if (doLength && objType !== 'map' && objType !== 'set') {\\r\\n      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');\\r\\n    }\\r\\n\\r\\n    if (!doLength && (objType === 'date' && nType !== 'date')) {\\r\\n      errorMessage = msgPrefix + 'the argument to least must be a date';\\r\\n    } else if (nType !== 'number' && (doLength || objType === 'number')) {\\r\\n      errorMessage = msgPrefix + 'the argument to least must be a number';\\r\\n    } else if (!doLength && (objType !== 'date' && objType !== 'number')) {\\r\\n      var printObj = (objType === 'string') ? \\\"'\\\" + obj + \\\"'\\\" : obj;\\r\\n      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';\\r\\n    } else {\\r\\n      shouldThrow = false;\\r\\n    }\\r\\n\\r\\n    if (shouldThrow) {\\r\\n      throw new AssertionError(errorMessage, undefined, ssfi);\\r\\n    }\\r\\n\\r\\n    if (doLength) {\\r\\n      var descriptor = 'length'\\r\\n        , itemsCount;\\r\\n      if (objType === 'map' || objType === 'set') {\\r\\n        descriptor = 'size';\\r\\n        itemsCount = obj.size;\\r\\n      } else {\\r\\n        itemsCount = obj.length;\\r\\n      }\\r\\n      this.assert(\\r\\n          itemsCount >= n\\r\\n        , 'expected #{this} to have a ' + descriptor + ' at least #{exp} but got #{act}'\\r\\n        , 'expected #{this} to have a ' + descriptor + ' below #{exp}'\\r\\n        , n\\r\\n        , itemsCount\\r\\n      );\\r\\n    } else {\\r\\n      this.assert(\\r\\n          obj >= n\\r\\n        , 'expected #{this} to be at least #{exp}'\\r\\n        , 'expected #{this} to be below #{exp}'\\r\\n        , n\\r\\n      );\\r\\n    }\\r\\n  }\\r\\n\\r\\n  Assertion.addMethod('least', assertLeast);\\r\\n  Assertion.addMethod('gte', assertLeast);\\r\\n\\r\\n  /**\\r\\n   * ### .below(n[, msg])\\r\\n   *\\r\\n   * Asserts that the target is a number or a date less than the given number or date `n` respectively.\\r\\n   * However, it's often best to assert that the target is equal to its expected\\r\\n   * value.\\r\\n   *\\r\\n   *     expect(1).to.equal(1); // Recommended\\r\\n   *     expect(1).to.be.below(2); // Not recommended\\r\\n   *\\r\\n   * Add `.lengthOf` earlier in the chain to assert that the target's `length`\\r\\n   * or `size` is less than the given number `n`.\\r\\n   *\\r\\n   *     expect('foo').to.have.lengthOf(3); // Recommended\\r\\n   *     expect('foo').to.have.lengthOf.below(4); // Not recommended\\r\\n   *\\r\\n   *     expect([1, 2, 3]).to.have.length(3); // Recommended\\r\\n   *     expect([1, 2, 3]).to.have.lengthOf.below(4); // Not recommended\\r\\n   *\\r\\n   * Add `.not` earlier in the chain to negate `.below`.\\r\\n   *\\r\\n   *     expect(2).to.equal(2); // Recommended\\r\\n   *     expect(2).to.not.be.below(1); // Not recommended\\r\\n   *\\r\\n   * `.below` accepts an optional `msg` argument which is a custom error message\\r\\n   * to show when the assertion fails. The message can also be given as the\\r\\n   * second argument to `expect`.\\r\\n   *\\r\\n   *     expect(2).to.be.below(1, 'nooo why fail??');\\r\\n   *     expect(2, 'nooo why fail??').to.be.below(1);\\r\\n   *\\r\\n   * The aliases `.lt` and `.lessThan` can be used interchangeably with\\r\\n   * `.below`.\\r\\n   *\\r\\n   * @name below\\r\\n   * @alias lt\\r\\n   * @alias lessThan\\r\\n   * @param {Number} n\\r\\n   * @param {String} msg _optional_\\r\\n   * @namespace BDD\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  function assertBelow (n, msg) {\\r\\n    if (msg) flag(this, 'message', msg);\\r\\n    var obj = flag(this, 'object')\\r\\n      , doLength = flag(this, 'doLength')\\r\\n      , flagMsg = flag(this, 'message')\\r\\n      , msgPrefix = ((flagMsg) ? flagMsg + ': ' : '')\\r\\n      , ssfi = flag(this, 'ssfi')\\r\\n      , objType = _.type(obj).toLowerCase()\\r\\n      , nType = _.type(n).toLowerCase()\\r\\n      , errorMessage\\r\\n      , shouldThrow = true;\\r\\n\\r\\n    if (doLength && objType !== 'map' && objType !== 'set') {\\r\\n      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');\\r\\n    }\\r\\n\\r\\n    if (!doLength && (objType === 'date' && nType !== 'date')) {\\r\\n      errorMessage = msgPrefix + 'the argument to below must be a date';\\r\\n    } else if (nType !== 'number' && (doLength || objType === 'number')) {\\r\\n      errorMessage = msgPrefix + 'the argument to below must be a number';\\r\\n    } else if (!doLength && (objType !== 'date' && objType !== 'number')) {\\r\\n      var printObj = (objType === 'string') ? \\\"'\\\" + obj + \\\"'\\\" : obj;\\r\\n      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';\\r\\n    } else {\\r\\n      shouldThrow = false;\\r\\n    }\\r\\n\\r\\n    if (shouldThrow) {\\r\\n      throw new AssertionError(errorMessage, undefined, ssfi);\\r\\n    }\\r\\n\\r\\n    if (doLength) {\\r\\n      var descriptor = 'length'\\r\\n        , itemsCount;\\r\\n      if (objType === 'map' || objType === 'set') {\\r\\n        descriptor = 'size';\\r\\n        itemsCount = obj.size;\\r\\n      } else {\\r\\n        itemsCount = obj.length;\\r\\n      }\\r\\n      this.assert(\\r\\n          itemsCount < n\\r\\n        , 'expected #{this} to have a ' + descriptor + ' below #{exp} but got #{act}'\\r\\n        , 'expected #{this} to not have a ' + descriptor + ' below #{exp}'\\r\\n        , n\\r\\n        , itemsCount\\r\\n      );\\r\\n    } else {\\r\\n      this.assert(\\r\\n          obj < n\\r\\n        , 'expected #{this} to be below #{exp}'\\r\\n        , 'expected #{this} to be at least #{exp}'\\r\\n        , n\\r\\n      );\\r\\n    }\\r\\n  }\\r\\n\\r\\n  Assertion.addMethod('below', assertBelow);\\r\\n  Assertion.addMethod('lt', assertBelow);\\r\\n  Assertion.addMethod('lessThan', assertBelow);\\r\\n\\r\\n  /**\\r\\n   * ### .most(n[, msg])\\r\\n   *\\r\\n   * Asserts that the target is a number or a date less than or equal to the given number\\r\\n   * or date `n` respectively. However, it's often best to assert that the target is equal to its\\r\\n   * expected value.\\r\\n   *\\r\\n   *     expect(1).to.equal(1); // Recommended\\r\\n   *     expect(1).to.be.at.most(2); // Not recommended\\r\\n   *     expect(1).to.be.at.most(1); // Not recommended\\r\\n   *\\r\\n   * Add `.lengthOf` earlier in the chain to assert that the target's `length`\\r\\n   * or `size` is less than or equal to the given number `n`.\\r\\n   *\\r\\n   *     expect('foo').to.have.lengthOf(3); // Recommended\\r\\n   *     expect('foo').to.have.lengthOf.at.most(4); // Not recommended\\r\\n   *\\r\\n   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended\\r\\n   *     expect([1, 2, 3]).to.have.lengthOf.at.most(4); // Not recommended\\r\\n   *\\r\\n   * Add `.not` earlier in the chain to negate `.most`.\\r\\n   *\\r\\n   *     expect(2).to.equal(2); // Recommended\\r\\n   *     expect(2).to.not.be.at.most(1); // Not recommended\\r\\n   *\\r\\n   * `.most` accepts an optional `msg` argument which is a custom error message\\r\\n   * to show when the assertion fails. The message can also be given as the\\r\\n   * second argument to `expect`.\\r\\n   *\\r\\n   *     expect(2).to.be.at.most(1, 'nooo why fail??');\\r\\n   *     expect(2, 'nooo why fail??').to.be.at.most(1);\\r\\n   *\\r\\n   * The alias `.lte` can be used interchangeably with `.most`.\\r\\n   *\\r\\n   * @name most\\r\\n   * @alias lte\\r\\n   * @param {Number} n\\r\\n   * @param {String} msg _optional_\\r\\n   * @namespace BDD\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  function assertMost (n, msg) {\\r\\n    if (msg) flag(this, 'message', msg);\\r\\n    var obj = flag(this, 'object')\\r\\n      , doLength = flag(this, 'doLength')\\r\\n      , flagMsg = flag(this, 'message')\\r\\n      , msgPrefix = ((flagMsg) ? flagMsg + ': ' : '')\\r\\n      , ssfi = flag(this, 'ssfi')\\r\\n      , objType = _.type(obj).toLowerCase()\\r\\n      , nType = _.type(n).toLowerCase()\\r\\n      , errorMessage\\r\\n      , shouldThrow = true;\\r\\n\\r\\n    if (doLength && objType !== 'map' && objType !== 'set') {\\r\\n      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');\\r\\n    }\\r\\n\\r\\n    if (!doLength && (objType === 'date' && nType !== 'date')) {\\r\\n      errorMessage = msgPrefix + 'the argument to most must be a date';\\r\\n    } else if (nType !== 'number' && (doLength || objType === 'number')) {\\r\\n      errorMessage = msgPrefix + 'the argument to most must be a number';\\r\\n    } else if (!doLength && (objType !== 'date' && objType !== 'number')) {\\r\\n      var printObj = (objType === 'string') ? \\\"'\\\" + obj + \\\"'\\\" : obj;\\r\\n      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';\\r\\n    } else {\\r\\n      shouldThrow = false;\\r\\n    }\\r\\n\\r\\n    if (shouldThrow) {\\r\\n      throw new AssertionError(errorMessage, undefined, ssfi);\\r\\n    }\\r\\n\\r\\n    if (doLength) {\\r\\n      var descriptor = 'length'\\r\\n        , itemsCount;\\r\\n      if (objType === 'map' || objType === 'set') {\\r\\n        descriptor = 'size';\\r\\n        itemsCount = obj.size;\\r\\n      } else {\\r\\n        itemsCount = obj.length;\\r\\n      }\\r\\n      this.assert(\\r\\n          itemsCount <= n\\r\\n        , 'expected #{this} to have a ' + descriptor + ' at most #{exp} but got #{act}'\\r\\n        , 'expected #{this} to have a ' + descriptor + ' above #{exp}'\\r\\n        , n\\r\\n        , itemsCount\\r\\n      );\\r\\n    } else {\\r\\n      this.assert(\\r\\n          obj <= n\\r\\n        , 'expected #{this} to be at most #{exp}'\\r\\n        , 'expected #{this} to be above #{exp}'\\r\\n        , n\\r\\n      );\\r\\n    }\\r\\n  }\\r\\n\\r\\n  Assertion.addMethod('most', assertMost);\\r\\n  Assertion.addMethod('lte', assertMost);\\r\\n\\r\\n  /**\\r\\n   * ### .within(start, finish[, msg])\\r\\n   *\\r\\n   * Asserts that the target is a number or a date greater than or equal to the given\\r\\n   * number or date `start`, and less than or equal to the given number or date `finish` respectively.\\r\\n   * However, it's often best to assert that the target is equal to its expected\\r\\n   * value.\\r\\n   *\\r\\n   *     expect(2).to.equal(2); // Recommended\\r\\n   *     expect(2).to.be.within(1, 3); // Not recommended\\r\\n   *     expect(2).to.be.within(2, 3); // Not recommended\\r\\n   *     expect(2).to.be.within(1, 2); // Not recommended\\r\\n   *\\r\\n   * Add `.lengthOf` earlier in the chain to assert that the target's `length`\\r\\n   * or `size` is greater than or equal to the given number `start`, and less\\r\\n   * than or equal to the given number `finish`.\\r\\n   *\\r\\n   *     expect('foo').to.have.lengthOf(3); // Recommended\\r\\n   *     expect('foo').to.have.lengthOf.within(2, 4); // Not recommended\\r\\n   *\\r\\n   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended\\r\\n   *     expect([1, 2, 3]).to.have.lengthOf.within(2, 4); // Not recommended\\r\\n   *\\r\\n   * Add `.not` earlier in the chain to negate `.within`.\\r\\n   *\\r\\n   *     expect(1).to.equal(1); // Recommended\\r\\n   *     expect(1).to.not.be.within(2, 4); // Not recommended\\r\\n   *\\r\\n   * `.within` accepts an optional `msg` argument which is a custom error\\r\\n   * message to show when the assertion fails. The message can also be given as\\r\\n   * the second argument to `expect`.\\r\\n   *\\r\\n   *     expect(4).to.be.within(1, 3, 'nooo why fail??');\\r\\n   *     expect(4, 'nooo why fail??').to.be.within(1, 3);\\r\\n   *\\r\\n   * @name within\\r\\n   * @param {Number} start lower bound inclusive\\r\\n   * @param {Number} finish upper bound inclusive\\r\\n   * @param {String} msg _optional_\\r\\n   * @namespace BDD\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  Assertion.addMethod('within', function (start, finish, msg) {\\r\\n    if (msg) flag(this, 'message', msg);\\r\\n    var obj = flag(this, 'object')\\r\\n      , doLength = flag(this, 'doLength')\\r\\n      , flagMsg = flag(this, 'message')\\r\\n      , msgPrefix = ((flagMsg) ? flagMsg + ': ' : '')\\r\\n      , ssfi = flag(this, 'ssfi')\\r\\n      , objType = _.type(obj).toLowerCase()\\r\\n      , startType = _.type(start).toLowerCase()\\r\\n      , finishType = _.type(finish).toLowerCase()\\r\\n      , errorMessage\\r\\n      , shouldThrow = true\\r\\n      , range = (startType === 'date' && finishType === 'date')\\r\\n          ? start.toUTCString() + '..' + finish.toUTCString()\\r\\n          : start + '..' + finish;\\r\\n\\r\\n    if (doLength && objType !== 'map' && objType !== 'set') {\\r\\n      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');\\r\\n    }\\r\\n\\r\\n    if (!doLength && (objType === 'date' && (startType !== 'date' || finishType !== 'date'))) {\\r\\n      errorMessage = msgPrefix + 'the arguments to within must be dates';\\r\\n    } else if ((startType !== 'number' || finishType !== 'number') && (doLength || objType === 'number')) {\\r\\n      errorMessage = msgPrefix + 'the arguments to within must be numbers';\\r\\n    } else if (!doLength && (objType !== 'date' && objType !== 'number')) {\\r\\n      var printObj = (objType === 'string') ? \\\"'\\\" + obj + \\\"'\\\" : obj;\\r\\n      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';\\r\\n    } else {\\r\\n      shouldThrow = false;\\r\\n    }\\r\\n\\r\\n    if (shouldThrow) {\\r\\n      throw new AssertionError(errorMessage, undefined, ssfi);\\r\\n    }\\r\\n\\r\\n    if (doLength) {\\r\\n      var descriptor = 'length'\\r\\n        , itemsCount;\\r\\n      if (objType === 'map' || objType === 'set') {\\r\\n        descriptor = 'size';\\r\\n        itemsCount = obj.size;\\r\\n      } else {\\r\\n        itemsCount = obj.length;\\r\\n      }\\r\\n      this.assert(\\r\\n          itemsCount >= start && itemsCount <= finish\\r\\n        , 'expected #{this} to have a ' + descriptor + ' within ' + range\\r\\n        , 'expected #{this} to not have a ' + descriptor + ' within ' + range\\r\\n      );\\r\\n    } else {\\r\\n      this.assert(\\r\\n          obj >= start && obj <= finish\\r\\n        , 'expected #{this} to be within ' + range\\r\\n        , 'expected #{this} to not be within ' + range\\r\\n      );\\r\\n    }\\r\\n  });\\r\\n\\r\\n  /**\\r\\n   * ### .instanceof(constructor[, msg])\\r\\n   *\\r\\n   * Asserts that the target is an instance of the given `constructor`.\\r\\n   *\\r\\n   *     function Cat () { }\\r\\n   *\\r\\n   *     expect(new Cat()).to.be.an.instanceof(Cat);\\r\\n   *     expect([1, 2]).to.be.an.instanceof(Array);\\r\\n   *\\r\\n   * Add `.not` earlier in the chain to negate `.instanceof`.\\r\\n   *\\r\\n   *     expect({a: 1}).to.not.be.an.instanceof(Array);\\r\\n   *\\r\\n   * `.instanceof` accepts an optional `msg` argument which is a custom error\\r\\n   * message to show when the assertion fails. The message can also be given as\\r\\n   * the second argument to `expect`.\\r\\n   *\\r\\n   *     expect(1).to.be.an.instanceof(Array, 'nooo why fail??');\\r\\n   *     expect(1, 'nooo why fail??').to.be.an.instanceof(Array);\\r\\n   *\\r\\n   * Due to limitations in ES5, `.instanceof` may not always work as expected\\r\\n   * when using a transpiler such as Babel or TypeScript. In particular, it may\\r\\n   * produce unexpected results when subclassing built-in object such as\\r\\n   * `Array`, `Error`, and `Map`. See your transpiler's docs for details:\\r\\n   *\\r\\n   * - ([Babel](https://babeljs.io/docs/usage/caveats/#classes))\\r\\n   * - ([TypeScript](https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work))\\r\\n   *\\r\\n   * The alias `.instanceOf` can be used interchangeably with `.instanceof`.\\r\\n   *\\r\\n   * @name instanceof\\r\\n   * @param {Constructor} constructor\\r\\n   * @param {String} msg _optional_\\r\\n   * @alias instanceOf\\r\\n   * @namespace BDD\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  function assertInstanceOf (constructor, msg) {\\r\\n    if (msg) flag(this, 'message', msg);\\r\\n\\r\\n    var target = flag(this, 'object')\\r\\n    var ssfi = flag(this, 'ssfi');\\r\\n    var flagMsg = flag(this, 'message');\\r\\n\\r\\n    try {\\r\\n      var isInstanceOf = target instanceof constructor;\\r\\n    } catch (err) {\\r\\n      if (err instanceof TypeError) {\\r\\n        flagMsg = flagMsg ? flagMsg + ': ' : '';\\r\\n        throw new AssertionError(\\r\\n          flagMsg + 'The instanceof assertion needs a constructor but '\\r\\n            + _.type(constructor) + ' was given.',\\r\\n          undefined,\\r\\n          ssfi\\r\\n        );\\r\\n      }\\r\\n      throw err;\\r\\n    }\\r\\n\\r\\n    var name = _.getName(constructor);\\r\\n    if (name === null) {\\r\\n      name = 'an unnamed constructor';\\r\\n    }\\r\\n\\r\\n    this.assert(\\r\\n        isInstanceOf\\r\\n      , 'expected #{this} to be an instance of ' + name\\r\\n      , 'expected #{this} to not be an instance of ' + name\\r\\n    );\\r\\n  };\\r\\n\\r\\n  Assertion.addMethod('instanceof', assertInstanceOf);\\r\\n  Assertion.addMethod('instanceOf', assertInstanceOf);\\r\\n\\r\\n  /**\\r\\n   * ### .property(name[, val[, msg]])\\r\\n   *\\r\\n   * Asserts that the target has a property with the given key `name`.\\r\\n   *\\r\\n   *     expect({a: 1}).to.have.property('a');\\r\\n   *\\r\\n   * When `val` is provided, `.property` also asserts that the property's value\\r\\n   * is equal to the given `val`.\\r\\n   *\\r\\n   *     expect({a: 1}).to.have.property('a', 1);\\r\\n   *\\r\\n   * By default, strict (`===`) equality is used. Add `.deep` earlier in the\\r\\n   * chain to use deep equality instead. See the `deep-eql` project page for\\r\\n   * info on the deep equality algorithm: https://github.com/chaijs/deep-eql.\\r\\n   *\\r\\n   *     // Target object deeply (but not strictly) has property `x: {a: 1}`\\r\\n   *     expect({x: {a: 1}}).to.have.deep.property('x', {a: 1});\\r\\n   *     expect({x: {a: 1}}).to.not.have.property('x', {a: 1});\\r\\n   *\\r\\n   * The target's enumerable and non-enumerable properties are always included\\r\\n   * in the search. By default, both own and inherited properties are included.\\r\\n   * Add `.own` earlier in the chain to exclude inherited properties from the\\r\\n   * search.\\r\\n   *\\r\\n   *     Object.prototype.b = 2;\\r\\n   *\\r\\n   *     expect({a: 1}).to.have.own.property('a');\\r\\n   *     expect({a: 1}).to.have.own.property('a', 1);\\r\\n   *     expect({a: 1}).to.have.property('b');\\r\\n   *     expect({a: 1}).to.not.have.own.property('b');\\r\\n   *\\r\\n   * `.deep` and `.own` can be combined.\\r\\n   *\\r\\n   *     expect({x: {a: 1}}).to.have.deep.own.property('x', {a: 1});\\r\\n   *\\r\\n   * Add `.nested` earlier in the chain to enable dot- and bracket-notation when\\r\\n   * referencing nested properties.\\r\\n   *\\r\\n   *     expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]');\\r\\n   *     expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]', 'y');\\r\\n   *\\r\\n   * If `.` or `[]` are part of an actual property name, they can be escaped by\\r\\n   * adding two backslashes before them.\\r\\n   *\\r\\n   *     expect({'.a': {'[b]': 'x'}}).to.have.nested.property('\\\\\\\\.a.\\\\\\\\[b\\\\\\\\]');\\r\\n   *\\r\\n   * `.deep` and `.nested` can be combined.\\r\\n   *\\r\\n   *     expect({a: {b: [{c: 3}]}})\\r\\n   *       .to.have.deep.nested.property('a.b[0]', {c: 3});\\r\\n   *\\r\\n   * `.own` and `.nested` cannot be combined.\\r\\n   *\\r\\n   * Add `.not` earlier in the chain to negate `.property`.\\r\\n   *\\r\\n   *     expect({a: 1}).to.not.have.property('b');\\r\\n   *\\r\\n   * However, it's dangerous to negate `.property` when providing `val`. The\\r\\n   * problem is that it creates uncertain expectations by asserting that the\\r\\n   * target either doesn't have a property with the given key `name`, or that it\\r\\n   * does have a property with the given key `name` but its value isn't equal to\\r\\n   * the given `val`. It's often best to identify the exact output that's\\r\\n   * expected, and then write an assertion that only accepts that exact output.\\r\\n   *\\r\\n   * When the target isn't expected to have a property with the given key\\r\\n   * `name`, it's often best to assert exactly that.\\r\\n   *\\r\\n   *     expect({b: 2}).to.not.have.property('a'); // Recommended\\r\\n   *     expect({b: 2}).to.not.have.property('a', 1); // Not recommended\\r\\n   *\\r\\n   * When the target is expected to have a property with the given key `name`,\\r\\n   * it's often best to assert that the property has its expected value, rather\\r\\n   * than asserting that it doesn't have one of many unexpected values.\\r\\n   *\\r\\n   *     expect({a: 3}).to.have.property('a', 3); // Recommended\\r\\n   *     expect({a: 3}).to.not.have.property('a', 1); // Not recommended\\r\\n   *\\r\\n   * `.property` changes the target of any assertions that follow in the chain\\r\\n   * to be the value of the property from the original target object.\\r\\n   *\\r\\n   *     expect({a: 1}).to.have.property('a').that.is.a('number');\\r\\n   *\\r\\n   * `.property` accepts an optional `msg` argument which is a custom error\\r\\n   * message to show when the assertion fails. The message can also be given as\\r\\n   * the second argument to `expect`. When not providing `val`, only use the\\r\\n   * second form.\\r\\n   *\\r\\n   *     // Recommended\\r\\n   *     expect({a: 1}).to.have.property('a', 2, 'nooo why fail??');\\r\\n   *     expect({a: 1}, 'nooo why fail??').to.have.property('a', 2);\\r\\n   *     expect({a: 1}, 'nooo why fail??').to.have.property('b');\\r\\n   *\\r\\n   *     // Not recommended\\r\\n   *     expect({a: 1}).to.have.property('b', undefined, 'nooo why fail??');\\r\\n   *\\r\\n   * The above assertion isn't the same thing as not providing `val`. Instead,\\r\\n   * it's asserting that the target object has a `b` property that's equal to\\r\\n   * `undefined`.\\r\\n   *\\r\\n   * The assertions `.ownProperty` and `.haveOwnProperty` can be used\\r\\n   * interchangeably with `.own.property`.\\r\\n   *\\r\\n   * @name property\\r\\n   * @param {String} name\\r\\n   * @param {Mixed} val (optional)\\r\\n   * @param {String} msg _optional_\\r\\n   * @returns value of property for chaining\\r\\n   * @namespace BDD\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  function assertProperty (name, val, msg) {\\r\\n    if (msg) flag(this, 'message', msg);\\r\\n\\r\\n    var isNested = flag(this, 'nested')\\r\\n      , isOwn = flag(this, 'own')\\r\\n      , flagMsg = flag(this, 'message')\\r\\n      , obj = flag(this, 'object')\\r\\n      , ssfi = flag(this, 'ssfi')\\r\\n      , nameType = typeof name;\\r\\n\\r\\n    flagMsg = flagMsg ? flagMsg + ': ' : '';\\r\\n\\r\\n    if (isNested) {\\r\\n      if (nameType !== 'string') {\\r\\n        throw new AssertionError(\\r\\n          flagMsg + 'the argument to property must be a string when using nested syntax',\\r\\n          undefined,\\r\\n          ssfi\\r\\n        );\\r\\n      }\\r\\n    } else {\\r\\n      if (nameType !== 'string' && nameType !== 'number' && nameType !== 'symbol') {\\r\\n        throw new AssertionError(\\r\\n          flagMsg + 'the argument to property must be a string, number, or symbol',\\r\\n          undefined,\\r\\n          ssfi\\r\\n        );\\r\\n      }\\r\\n    }\\r\\n\\r\\n    if (isNested && isOwn) {\\r\\n      throw new AssertionError(\\r\\n        flagMsg + 'The \\\"nested\\\" and \\\"own\\\" flags cannot be combined.',\\r\\n        undefined,\\r\\n        ssfi\\r\\n      );\\r\\n    }\\r\\n\\r\\n    if (obj === null || obj === undefined) {\\r\\n      throw new AssertionError(\\r\\n        flagMsg + 'Target cannot be null or undefined.',\\r\\n        undefined,\\r\\n        ssfi\\r\\n      );\\r\\n    }\\r\\n\\r\\n    var isDeep = flag(this, 'deep')\\r\\n      , negate = flag(this, 'negate')\\r\\n      , pathInfo = isNested ? _.getPathInfo(obj, name) : null\\r\\n      , value = isNested ? pathInfo.value : obj[name];\\r\\n\\r\\n    var descriptor = '';\\r\\n    if (isDeep) descriptor += 'deep ';\\r\\n    if (isOwn) descriptor += 'own ';\\r\\n    if (isNested) descriptor += 'nested ';\\r\\n    descriptor += 'property ';\\r\\n\\r\\n    var hasProperty;\\r\\n    if (isOwn) hasProperty = Object.prototype.hasOwnProperty.call(obj, name);\\r\\n    else if (isNested) hasProperty = pathInfo.exists;\\r\\n    else hasProperty = _.hasProperty(obj, name);\\r\\n\\r\\n    // When performing a negated assertion for both name and val, merely having\\r\\n    // a property with the given name isn't enough to cause the assertion to\\r\\n    // fail. It must both have a property with the given name, and the value of\\r\\n    // that property must equal the given val. Therefore, skip this assertion in\\r\\n    // favor of the next.\\r\\n    if (!negate || arguments.length === 1) {\\r\\n      this.assert(\\r\\n          hasProperty\\r\\n        , 'expected #{this} to have ' + descriptor + _.inspect(name)\\r\\n        , 'expected #{this} to not have ' + descriptor + _.inspect(name));\\r\\n    }\\r\\n\\r\\n    if (arguments.length > 1) {\\r\\n      this.assert(\\r\\n          hasProperty && (isDeep ? _.eql(val, value) : val === value)\\r\\n        , 'expected #{this} to have ' + descriptor + _.inspect(name) + ' of #{exp}, but got #{act}'\\r\\n        , 'expected #{this} to not have ' + descriptor + _.inspect(name) + ' of #{act}'\\r\\n        , val\\r\\n        , value\\r\\n      );\\r\\n    }\\r\\n\\r\\n    flag(this, 'object', value);\\r\\n  }\\r\\n\\r\\n  Assertion.addMethod('property', assertProperty);\\r\\n\\r\\n  function assertOwnProperty (name, value, msg) {\\r\\n    flag(this, 'own', true);\\r\\n    assertProperty.apply(this, arguments);\\r\\n  }\\r\\n\\r\\n  Assertion.addMethod('ownProperty', assertOwnProperty);\\r\\n  Assertion.addMethod('haveOwnProperty', assertOwnProperty);\\r\\n\\r\\n  /**\\r\\n   * ### .ownPropertyDescriptor(name[, descriptor[, msg]])\\r\\n   *\\r\\n   * Asserts that the target has its own property descriptor with the given key\\r\\n   * `name`. Enumerable and non-enumerable properties are included in the\\r\\n   * search.\\r\\n   *\\r\\n   *     expect({a: 1}).to.have.ownPropertyDescriptor('a');\\r\\n   *\\r\\n   * When `descriptor` is provided, `.ownPropertyDescriptor` also asserts that\\r\\n   * the property's descriptor is deeply equal to the given `descriptor`. See\\r\\n   * the `deep-eql` project page for info on the deep equality algorithm:\\r\\n   * https://github.com/chaijs/deep-eql.\\r\\n   *\\r\\n   *     expect({a: 1}).to.have.ownPropertyDescriptor('a', {\\r\\n   *       configurable: true,\\r\\n   *       enumerable: true,\\r\\n   *       writable: true,\\r\\n   *       value: 1,\\r\\n   *     });\\r\\n   *\\r\\n   * Add `.not` earlier in the chain to negate `.ownPropertyDescriptor`.\\r\\n   *\\r\\n   *     expect({a: 1}).to.not.have.ownPropertyDescriptor('b');\\r\\n   *\\r\\n   * However, it's dangerous to negate `.ownPropertyDescriptor` when providing\\r\\n   * a `descriptor`. The problem is that it creates uncertain expectations by\\r\\n   * asserting that the target either doesn't have a property descriptor with\\r\\n   * the given key `name`, or that it does have a property descriptor with the\\r\\n   * given key `name` but its not deeply equal to the given `descriptor`. It's\\r\\n   * often best to identify the exact output that's expected, and then write an\\r\\n   * assertion that only accepts that exact output.\\r\\n   *\\r\\n   * When the target isn't expected to have a property descriptor with the given\\r\\n   * key `name`, it's often best to assert exactly that.\\r\\n   *\\r\\n   *     // Recommended\\r\\n   *     expect({b: 2}).to.not.have.ownPropertyDescriptor('a');\\r\\n   *\\r\\n   *     // Not recommended\\r\\n   *     expect({b: 2}).to.not.have.ownPropertyDescriptor('a', {\\r\\n   *       configurable: true,\\r\\n   *       enumerable: true,\\r\\n   *       writable: true,\\r\\n   *       value: 1,\\r\\n   *     });\\r\\n   *\\r\\n   * When the target is expected to have a property descriptor with the given\\r\\n   * key `name`, it's often best to assert that the property has its expected\\r\\n   * descriptor, rather than asserting that it doesn't have one of many\\r\\n   * unexpected descriptors.\\r\\n   *\\r\\n   *     // Recommended\\r\\n   *     expect({a: 3}).to.have.ownPropertyDescriptor('a', {\\r\\n   *       configurable: true,\\r\\n   *       enumerable: true,\\r\\n   *       writable: true,\\r\\n   *       value: 3,\\r\\n   *     });\\r\\n   *\\r\\n   *     // Not recommended\\r\\n   *     expect({a: 3}).to.not.have.ownPropertyDescriptor('a', {\\r\\n   *       configurable: true,\\r\\n   *       enumerable: true,\\r\\n   *       writable: true,\\r\\n   *       value: 1,\\r\\n   *     });\\r\\n   *\\r\\n   * `.ownPropertyDescriptor` changes the target of any assertions that follow\\r\\n   * in the chain to be the value of the property descriptor from the original\\r\\n   * target object.\\r\\n   *\\r\\n   *     expect({a: 1}).to.have.ownPropertyDescriptor('a')\\r\\n   *       .that.has.property('enumerable', true);\\r\\n   *\\r\\n   * `.ownPropertyDescriptor` accepts an optional `msg` argument which is a\\r\\n   * custom error message to show when the assertion fails. The message can also\\r\\n   * be given as the second argument to `expect`. When not providing\\r\\n   * `descriptor`, only use the second form.\\r\\n   *\\r\\n   *     // Recommended\\r\\n   *     expect({a: 1}).to.have.ownPropertyDescriptor('a', {\\r\\n   *       configurable: true,\\r\\n   *       enumerable: true,\\r\\n   *       writable: true,\\r\\n   *       value: 2,\\r\\n   *     }, 'nooo why fail??');\\r\\n   *\\r\\n   *     // Recommended\\r\\n   *     expect({a: 1}, 'nooo why fail??').to.have.ownPropertyDescriptor('a', {\\r\\n   *       configurable: true,\\r\\n   *       enumerable: true,\\r\\n   *       writable: true,\\r\\n   *       value: 2,\\r\\n   *     });\\r\\n   *\\r\\n   *     // Recommended\\r\\n   *     expect({a: 1}, 'nooo why fail??').to.have.ownPropertyDescriptor('b');\\r\\n   *\\r\\n   *     // Not recommended\\r\\n   *     expect({a: 1})\\r\\n   *       .to.have.ownPropertyDescriptor('b', undefined, 'nooo why fail??');\\r\\n   *\\r\\n   * The above assertion isn't the same thing as not providing `descriptor`.\\r\\n   * Instead, it's asserting that the target object has a `b` property\\r\\n   * descriptor that's deeply equal to `undefined`.\\r\\n   *\\r\\n   * The alias `.haveOwnPropertyDescriptor` can be used interchangeably with\\r\\n   * `.ownPropertyDescriptor`.\\r\\n   *\\r\\n   * @name ownPropertyDescriptor\\r\\n   * @alias haveOwnPropertyDescriptor\\r\\n   * @param {String} name\\r\\n   * @param {Object} descriptor _optional_\\r\\n   * @param {String} msg _optional_\\r\\n   * @namespace BDD\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  function assertOwnPropertyDescriptor (name, descriptor, msg) {\\r\\n    if (typeof descriptor === 'string') {\\r\\n      msg = descriptor;\\r\\n      descriptor = null;\\r\\n    }\\r\\n    if (msg) flag(this, 'message', msg);\\r\\n    var obj = flag(this, 'object');\\r\\n    var actualDescriptor = Object.getOwnPropertyDescriptor(Object(obj), name);\\r\\n    if (actualDescriptor && descriptor) {\\r\\n      this.assert(\\r\\n          _.eql(descriptor, actualDescriptor)\\r\\n        , 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to match ' + _.inspect(descriptor) + ', got ' + _.inspect(actualDescriptor)\\r\\n        , 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to not match ' + _.inspect(descriptor)\\r\\n        , descriptor\\r\\n        , actualDescriptor\\r\\n        , true\\r\\n      );\\r\\n    } else {\\r\\n      this.assert(\\r\\n          actualDescriptor\\r\\n        , 'expected #{this} to have an own property descriptor for ' + _.inspect(name)\\r\\n        , 'expected #{this} to not have an own property descriptor for ' + _.inspect(name)\\r\\n      );\\r\\n    }\\r\\n    flag(this, 'object', actualDescriptor);\\r\\n  }\\r\\n\\r\\n  Assertion.addMethod('ownPropertyDescriptor', assertOwnPropertyDescriptor);\\r\\n  Assertion.addMethod('haveOwnPropertyDescriptor', assertOwnPropertyDescriptor);\\r\\n\\r\\n  /**\\r\\n   * ### .lengthOf(n[, msg])\\r\\n   *\\r\\n   * Asserts that the target's `length` or `size` is equal to the given number\\r\\n   * `n`.\\r\\n   *\\r\\n   *     expect([1, 2, 3]).to.have.lengthOf(3);\\r\\n   *     expect('foo').to.have.lengthOf(3);\\r\\n   *     expect(new Set([1, 2, 3])).to.have.lengthOf(3);\\r\\n   *     expect(new Map([['a', 1], ['b', 2], ['c', 3]])).to.have.lengthOf(3);\\r\\n   *\\r\\n   * Add `.not` earlier in the chain to negate `.lengthOf`. However, it's often\\r\\n   * best to assert that the target's `length` property is equal to its expected\\r\\n   * value, rather than not equal to one of many unexpected values.\\r\\n   *\\r\\n   *     expect('foo').to.have.lengthOf(3); // Recommended\\r\\n   *     expect('foo').to.not.have.lengthOf(4); // Not recommended\\r\\n   *\\r\\n   * `.lengthOf` accepts an optional `msg` argument which is a custom error\\r\\n   * message to show when the assertion fails. The message can also be given as\\r\\n   * the second argument to `expect`.\\r\\n   *\\r\\n   *     expect([1, 2, 3]).to.have.lengthOf(2, 'nooo why fail??');\\r\\n   *     expect([1, 2, 3], 'nooo why fail??').to.have.lengthOf(2);\\r\\n   *\\r\\n   * `.lengthOf` can also be used as a language chain, causing all `.above`,\\r\\n   * `.below`, `.least`, `.most`, and `.within` assertions that follow in the\\r\\n   * chain to use the target's `length` property as the target. However, it's\\r\\n   * often best to assert that the target's `length` property is equal to its\\r\\n   * expected length, rather than asserting that its `length` property falls\\r\\n   * within some range of values.\\r\\n   *\\r\\n   *     // Recommended\\r\\n   *     expect([1, 2, 3]).to.have.lengthOf(3);\\r\\n   *\\r\\n   *     // Not recommended\\r\\n   *     expect([1, 2, 3]).to.have.lengthOf.above(2);\\r\\n   *     expect([1, 2, 3]).to.have.lengthOf.below(4);\\r\\n   *     expect([1, 2, 3]).to.have.lengthOf.at.least(3);\\r\\n   *     expect([1, 2, 3]).to.have.lengthOf.at.most(3);\\r\\n   *     expect([1, 2, 3]).to.have.lengthOf.within(2,4);\\r\\n   *\\r\\n   * Due to a compatibility issue, the alias `.length` can't be chained directly\\r\\n   * off of an uninvoked method such as `.a`. Therefore, `.length` can't be used\\r\\n   * interchangeably with `.lengthOf` in every situation. It's recommended to\\r\\n   * always use `.lengthOf` instead of `.length`.\\r\\n   *\\r\\n   *     expect([1, 2, 3]).to.have.a.length(3); // incompatible; throws error\\r\\n   *     expect([1, 2, 3]).to.have.a.lengthOf(3);  // passes as expected\\r\\n   *\\r\\n   * @name lengthOf\\r\\n   * @alias length\\r\\n   * @param {Number} n\\r\\n   * @param {String} msg _optional_\\r\\n   * @namespace BDD\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  function assertLengthChain () {\\r\\n    flag(this, 'doLength', true);\\r\\n  }\\r\\n\\r\\n  function assertLength (n, msg) {\\r\\n    if (msg) flag(this, 'message', msg);\\r\\n    var obj = flag(this, 'object')\\r\\n      , objType = _.type(obj).toLowerCase()\\r\\n      , flagMsg = flag(this, 'message')\\r\\n      , ssfi = flag(this, 'ssfi')\\r\\n      , descriptor = 'length'\\r\\n      , itemsCount;\\r\\n\\r\\n    switch (objType) {\\r\\n      case 'map':\\r\\n      case 'set':\\r\\n        descriptor = 'size';\\r\\n        itemsCount = obj.size;\\r\\n        break;\\r\\n      default:\\r\\n        new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');\\r\\n        itemsCount = obj.length;\\r\\n    }\\r\\n\\r\\n    this.assert(\\r\\n        itemsCount == n\\r\\n      , 'expected #{this} to have a ' + descriptor + ' of #{exp} but got #{act}'\\r\\n      , 'expected #{this} to not have a ' + descriptor + ' of #{act}'\\r\\n      , n\\r\\n      , itemsCount\\r\\n    );\\r\\n  }\\r\\n\\r\\n  Assertion.addChainableMethod('length', assertLength, assertLengthChain);\\r\\n  Assertion.addChainableMethod('lengthOf', assertLength, assertLengthChain);\\r\\n\\r\\n  /**\\r\\n   * ### .match(re[, msg])\\r\\n   *\\r\\n   * Asserts that the target matches the given regular expression `re`.\\r\\n   *\\r\\n   *     expect('foobar').to.match(/^foo/);\\r\\n   *\\r\\n   * Add `.not` earlier in the chain to negate `.match`.\\r\\n   *\\r\\n   *     expect('foobar').to.not.match(/taco/);\\r\\n   *\\r\\n   * `.match` accepts an optional `msg` argument which is a custom error message\\r\\n   * to show when the assertion fails. The message can also be given as the\\r\\n   * second argument to `expect`.\\r\\n   *\\r\\n   *     expect('foobar').to.match(/taco/, 'nooo why fail??');\\r\\n   *     expect('foobar', 'nooo why fail??').to.match(/taco/);\\r\\n   *\\r\\n   * The alias `.matches` can be used interchangeably with `.match`.\\r\\n   *\\r\\n   * @name match\\r\\n   * @alias matches\\r\\n   * @param {RegExp} re\\r\\n   * @param {String} msg _optional_\\r\\n   * @namespace BDD\\r\\n   * @api public\\r\\n   */\\r\\n  function assertMatch(re, msg) {\\r\\n    if (msg) flag(this, 'message', msg);\\r\\n    var obj = flag(this, 'object');\\r\\n    this.assert(\\r\\n        re.exec(obj)\\r\\n      , 'expected #{this} to match ' + re\\r\\n      , 'expected #{this} not to match ' + re\\r\\n    );\\r\\n  }\\r\\n\\r\\n  Assertion.addMethod('match', assertMatch);\\r\\n  Assertion.addMethod('matches', assertMatch);\\r\\n\\r\\n  /**\\r\\n   * ### .string(str[, msg])\\r\\n   *\\r\\n   * Asserts that the target string contains the given substring `str`.\\r\\n   *\\r\\n   *     expect('foobar').to.have.string('bar');\\r\\n   *\\r\\n   * Add `.not` earlier in the chain to negate `.string`.\\r\\n   *\\r\\n   *     expect('foobar').to.not.have.string('taco');\\r\\n   *\\r\\n   * `.string` accepts an optional `msg` argument which is a custom error\\r\\n   * message to show when the assertion fails. The message can also be given as\\r\\n   * the second argument to `expect`.\\r\\n   *\\r\\n   *     expect('foobar').to.have.string('taco', 'nooo why fail??');\\r\\n   *     expect('foobar', 'nooo why fail??').to.have.string('taco');\\r\\n   *\\r\\n   * @name string\\r\\n   * @param {String} str\\r\\n   * @param {String} msg _optional_\\r\\n   * @namespace BDD\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  Assertion.addMethod('string', function (str, msg) {\\r\\n    if (msg) flag(this, 'message', msg);\\r\\n    var obj = flag(this, 'object')\\r\\n      , flagMsg = flag(this, 'message')\\r\\n      , ssfi = flag(this, 'ssfi');\\r\\n    new Assertion(obj, flagMsg, ssfi, true).is.a('string');\\r\\n\\r\\n    this.assert(\\r\\n        ~obj.indexOf(str)\\r\\n      , 'expected #{this} to contain ' + _.inspect(str)\\r\\n      , 'expected #{this} to not contain ' + _.inspect(str)\\r\\n    );\\r\\n  });\\r\\n\\r\\n  /**\\r\\n   * ### .keys(key1[, key2[, ...]])\\r\\n   *\\r\\n   * Asserts that the target object, array, map, or set has the given keys. Only\\r\\n   * the target's own inherited properties are included in the search.\\r\\n   *\\r\\n   * When the target is an object or array, keys can be provided as one or more\\r\\n   * string arguments, a single array argument, or a single object argument. In\\r\\n   * the latter case, only the keys in the given object matter; the values are\\r\\n   * ignored.\\r\\n   *\\r\\n   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b');\\r\\n   *     expect(['x', 'y']).to.have.all.keys(0, 1);\\r\\n   *\\r\\n   *     expect({a: 1, b: 2}).to.have.all.keys(['a', 'b']);\\r\\n   *     expect(['x', 'y']).to.have.all.keys([0, 1]);\\r\\n   *\\r\\n   *     expect({a: 1, b: 2}).to.have.all.keys({a: 4, b: 5}); // ignore 4 and 5\\r\\n   *     expect(['x', 'y']).to.have.all.keys({0: 4, 1: 5}); // ignore 4 and 5\\r\\n   *\\r\\n   * When the target is a map or set, each key must be provided as a separate\\r\\n   * argument.\\r\\n   *\\r\\n   *     expect(new Map([['a', 1], ['b', 2]])).to.have.all.keys('a', 'b');\\r\\n   *     expect(new Set(['a', 'b'])).to.have.all.keys('a', 'b');\\r\\n   *\\r\\n   * Because `.keys` does different things based on the target's type, it's\\r\\n   * important to check the target's type before using `.keys`. See the `.a` doc\\r\\n   * for info on testing a target's type.\\r\\n   *\\r\\n   *     expect({a: 1, b: 2}).to.be.an('object').that.has.all.keys('a', 'b');\\r\\n   *\\r\\n   * By default, strict (`===`) equality is used to compare keys of maps and\\r\\n   * sets. Add `.deep` earlier in the chain to use deep equality instead. See\\r\\n   * the `deep-eql` project page for info on the deep equality algorithm:\\r\\n   * https://github.com/chaijs/deep-eql.\\r\\n   *\\r\\n   *     // Target set deeply (but not strictly) has key `{a: 1}`\\r\\n   *     expect(new Set([{a: 1}])).to.have.all.deep.keys([{a: 1}]);\\r\\n   *     expect(new Set([{a: 1}])).to.not.have.all.keys([{a: 1}]);\\r\\n   *\\r\\n   * By default, the target must have all of the given keys and no more. Add\\r\\n   * `.any` earlier in the chain to only require that the target have at least\\r\\n   * one of the given keys. Also, add `.not` earlier in the chain to negate\\r\\n   * `.keys`. It's often best to add `.any` when negating `.keys`, and to use\\r\\n   * `.all` when asserting `.keys` without negation.\\r\\n   *\\r\\n   * When negating `.keys`, `.any` is preferred because `.not.any.keys` asserts\\r\\n   * exactly what's expected of the output, whereas `.not.all.keys` creates\\r\\n   * uncertain expectations.\\r\\n   *\\r\\n   *     // Recommended; asserts that target doesn't have any of the given keys\\r\\n   *     expect({a: 1, b: 2}).to.not.have.any.keys('c', 'd');\\r\\n   *\\r\\n   *     // Not recommended; asserts that target doesn't have all of the given\\r\\n   *     // keys but may or may not have some of them\\r\\n   *     expect({a: 1, b: 2}).to.not.have.all.keys('c', 'd');\\r\\n   *\\r\\n   * When asserting `.keys` without negation, `.all` is preferred because\\r\\n   * `.all.keys` asserts exactly what's expected of the output, whereas\\r\\n   * `.any.keys` creates uncertain expectations.\\r\\n   *\\r\\n   *     // Recommended; asserts that target has all the given keys\\r\\n   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b');\\r\\n   *\\r\\n   *     // Not recommended; asserts that target has at least one of the given\\r\\n   *     // keys but may or may not have more of them\\r\\n   *     expect({a: 1, b: 2}).to.have.any.keys('a', 'b');\\r\\n   *\\r\\n   * Note that `.all` is used by default when neither `.all` nor `.any` appear\\r\\n   * earlier in the chain. However, it's often best to add `.all` anyway because\\r\\n   * it improves readability.\\r\\n   *\\r\\n   *     // Both assertions are identical\\r\\n   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b'); // Recommended\\r\\n   *     expect({a: 1, b: 2}).to.have.keys('a', 'b'); // Not recommended\\r\\n   *\\r\\n   * Add `.include` earlier in the chain to require that the target's keys be a\\r\\n   * superset of the expected keys, rather than identical sets.\\r\\n   *\\r\\n   *     // Target object's keys are a superset of ['a', 'b'] but not identical\\r\\n   *     expect({a: 1, b: 2, c: 3}).to.include.all.keys('a', 'b');\\r\\n   *     expect({a: 1, b: 2, c: 3}).to.not.have.all.keys('a', 'b');\\r\\n   *\\r\\n   * However, if `.any` and `.include` are combined, only the `.any` takes\\r\\n   * effect. The `.include` is ignored in this case.\\r\\n   *\\r\\n   *     // Both assertions are identical\\r\\n   *     expect({a: 1}).to.have.any.keys('a', 'b');\\r\\n   *     expect({a: 1}).to.include.any.keys('a', 'b');\\r\\n   *\\r\\n   * A custom error message can be given as the second argument to `expect`.\\r\\n   *\\r\\n   *     expect({a: 1}, 'nooo why fail??').to.have.key('b');\\r\\n   *\\r\\n   * The alias `.key` can be used interchangeably with `.keys`.\\r\\n   *\\r\\n   * @name keys\\r\\n   * @alias key\\r\\n   * @param {...String|Array|Object} keys\\r\\n   * @namespace BDD\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  function assertKeys (keys) {\\r\\n    var obj = flag(this, 'object')\\r\\n      , objType = _.type(obj)\\r\\n      , keysType = _.type(keys)\\r\\n      , ssfi = flag(this, 'ssfi')\\r\\n      , isDeep = flag(this, 'deep')\\r\\n      , str\\r\\n      , deepStr = ''\\r\\n      , actual\\r\\n      , ok = true\\r\\n      , flagMsg = flag(this, 'message');\\r\\n\\r\\n    flagMsg = flagMsg ? flagMsg + ': ' : '';\\r\\n    var mixedArgsMsg = flagMsg + 'when testing keys against an object or an array you must give a single Array|Object|String argument or multiple String arguments';\\r\\n\\r\\n    if (objType === 'Map' || objType === 'Set') {\\r\\n      deepStr = isDeep ? 'deeply ' : '';\\r\\n      actual = [];\\r\\n\\r\\n      // Map and Set '.keys' aren't supported in IE 11. Therefore, use .forEach.\\r\\n      obj.forEach(function (val, key) { actual.push(key) });\\r\\n\\r\\n      if (keysType !== 'Array') {\\r\\n        keys = Array.prototype.slice.call(arguments);\\r\\n      }\\r\\n    } else {\\r\\n      actual = _.getOwnEnumerableProperties(obj);\\r\\n\\r\\n      switch (keysType) {\\r\\n        case 'Array':\\r\\n          if (arguments.length > 1) {\\r\\n            throw new AssertionError(mixedArgsMsg, undefined, ssfi);\\r\\n          }\\r\\n          break;\\r\\n        case 'Object':\\r\\n          if (arguments.length > 1) {\\r\\n            throw new AssertionError(mixedArgsMsg, undefined, ssfi);\\r\\n          }\\r\\n          keys = Object.keys(keys);\\r\\n          break;\\r\\n        default:\\r\\n          keys = Array.prototype.slice.call(arguments);\\r\\n      }\\r\\n\\r\\n      // Only stringify non-Symbols because Symbols would become \\\"Symbol()\\\"\\r\\n      keys = keys.map(function (val) {\\r\\n        return typeof val === 'symbol' ? val : String(val);\\r\\n      });\\r\\n    }\\r\\n\\r\\n    if (!keys.length) {\\r\\n      throw new AssertionError(flagMsg + 'keys required', undefined, ssfi);\\r\\n    }\\r\\n\\r\\n    var len = keys.length\\r\\n      , any = flag(this, 'any')\\r\\n      , all = flag(this, 'all')\\r\\n      , expected = keys;\\r\\n\\r\\n    if (!any && !all) {\\r\\n      all = true;\\r\\n    }\\r\\n\\r\\n    // Has any\\r\\n    if (any) {\\r\\n      ok = expected.some(function(expectedKey) {\\r\\n        return actual.some(function(actualKey) {\\r\\n          if (isDeep) {\\r\\n            return _.eql(expectedKey, actualKey);\\r\\n          } else {\\r\\n            return expectedKey === actualKey;\\r\\n          }\\r\\n        });\\r\\n      });\\r\\n    }\\r\\n\\r\\n    // Has all\\r\\n    if (all) {\\r\\n      ok = expected.every(function(expectedKey) {\\r\\n        return actual.some(function(actualKey) {\\r\\n          if (isDeep) {\\r\\n            return _.eql(expectedKey, actualKey);\\r\\n          } else {\\r\\n            return expectedKey === actualKey;\\r\\n          }\\r\\n        });\\r\\n      });\\r\\n\\r\\n      if (!flag(this, 'contains')) {\\r\\n        ok = ok && keys.length == actual.length;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    // Key string\\r\\n    if (len > 1) {\\r\\n      keys = keys.map(function(key) {\\r\\n        return _.inspect(key);\\r\\n      });\\r\\n      var last = keys.pop();\\r\\n      if (all) {\\r\\n        str = keys.join(', ') + ', and ' + last;\\r\\n      }\\r\\n      if (any) {\\r\\n        str = keys.join(', ') + ', or ' + last;\\r\\n      }\\r\\n    } else {\\r\\n      str = _.inspect(keys[0]);\\r\\n    }\\r\\n\\r\\n    // Form\\r\\n    str = (len > 1 ? 'keys ' : 'key ') + str;\\r\\n\\r\\n    // Have / include\\r\\n    str = (flag(this, 'contains') ? 'contain ' : 'have ') + str;\\r\\n\\r\\n    // Assertion\\r\\n    this.assert(\\r\\n        ok\\r\\n      , 'expected #{this} to ' + deepStr + str\\r\\n      , 'expected #{this} to not ' + deepStr + str\\r\\n      , expected.slice(0).sort(_.compareByInspect)\\r\\n      , actual.sort(_.compareByInspect)\\r\\n      , true\\r\\n    );\\r\\n  }\\r\\n\\r\\n  Assertion.addMethod('keys', assertKeys);\\r\\n  Assertion.addMethod('key', assertKeys);\\r\\n\\r\\n  /**\\r\\n   * ### .throw([errorLike], [errMsgMatcher], [msg])\\r\\n   *\\r\\n   * When no arguments are provided, `.throw` invokes the target function and\\r\\n   * asserts that an error is thrown.\\r\\n   *\\r\\n   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };\\r\\n   *\\r\\n   *     expect(badFn).to.throw();\\r\\n   *\\r\\n   * When one argument is provided, and it's an error constructor, `.throw`\\r\\n   * invokes the target function and asserts that an error is thrown that's an\\r\\n   * instance of that error constructor.\\r\\n   *\\r\\n   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };\\r\\n   *\\r\\n   *     expect(badFn).to.throw(TypeError);\\r\\n   *\\r\\n   * When one argument is provided, and it's an error instance, `.throw` invokes\\r\\n   * the target function and asserts that an error is thrown that's strictly\\r\\n   * (`===`) equal to that error instance.\\r\\n   *\\r\\n   *     var err = new TypeError('Illegal salmon!');\\r\\n   *     var badFn = function () { throw err; };\\r\\n   *\\r\\n   *     expect(badFn).to.throw(err);\\r\\n   *\\r\\n   * When one argument is provided, and it's a string, `.throw` invokes the\\r\\n   * target function and asserts that an error is thrown with a message that\\r\\n   * contains that string.\\r\\n   *\\r\\n   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };\\r\\n   *\\r\\n   *     expect(badFn).to.throw('salmon');\\r\\n   *\\r\\n   * When one argument is provided, and it's a regular expression, `.throw`\\r\\n   * invokes the target function and asserts that an error is thrown with a\\r\\n   * message that matches that regular expression.\\r\\n   *\\r\\n   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };\\r\\n   *\\r\\n   *     expect(badFn).to.throw(/salmon/);\\r\\n   *\\r\\n   * When two arguments are provided, and the first is an error instance or\\r\\n   * constructor, and the second is a string or regular expression, `.throw`\\r\\n   * invokes the function and asserts that an error is thrown that fulfills both\\r\\n   * conditions as described above.\\r\\n   *\\r\\n   *     var err = new TypeError('Illegal salmon!');\\r\\n   *     var badFn = function () { throw err; };\\r\\n   *\\r\\n   *     expect(badFn).to.throw(TypeError, 'salmon');\\r\\n   *     expect(badFn).to.throw(TypeError, /salmon/);\\r\\n   *     expect(badFn).to.throw(err, 'salmon');\\r\\n   *     expect(badFn).to.throw(err, /salmon/);\\r\\n   *\\r\\n   * Add `.not` earlier in the chain to negate `.throw`.\\r\\n   *\\r\\n   *     var goodFn = function () {};\\r\\n   *\\r\\n   *     expect(goodFn).to.not.throw();\\r\\n   *\\r\\n   * However, it's dangerous to negate `.throw` when providing any arguments.\\r\\n   * The problem is that it creates uncertain expectations by asserting that the\\r\\n   * target either doesn't throw an error, or that it throws an error but of a\\r\\n   * different type than the given type, or that it throws an error of the given\\r\\n   * type but with a message that doesn't include the given string. It's often\\r\\n   * best to identify the exact output that's expected, and then write an\\r\\n   * assertion that only accepts that exact output.\\r\\n   *\\r\\n   * When the target isn't expected to throw an error, it's often best to assert\\r\\n   * exactly that.\\r\\n   *\\r\\n   *     var goodFn = function () {};\\r\\n   *\\r\\n   *     expect(goodFn).to.not.throw(); // Recommended\\r\\n   *     expect(goodFn).to.not.throw(ReferenceError, 'x'); // Not recommended\\r\\n   *\\r\\n   * When the target is expected to throw an error, it's often best to assert\\r\\n   * that the error is of its expected type, and has a message that includes an\\r\\n   * expected string, rather than asserting that it doesn't have one of many\\r\\n   * unexpected types, and doesn't have a message that includes some string.\\r\\n   *\\r\\n   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };\\r\\n   *\\r\\n   *     expect(badFn).to.throw(TypeError, 'salmon'); // Recommended\\r\\n   *     expect(badFn).to.not.throw(ReferenceError, 'x'); // Not recommended\\r\\n   *\\r\\n   * `.throw` changes the target of any assertions that follow in the chain to\\r\\n   * be the error object that's thrown.\\r\\n   *\\r\\n   *     var err = new TypeError('Illegal salmon!');\\r\\n   *     err.code = 42;\\r\\n   *     var badFn = function () { throw err; };\\r\\n   *\\r\\n   *     expect(badFn).to.throw(TypeError).with.property('code', 42);\\r\\n   *\\r\\n   * `.throw` accepts an optional `msg` argument which is a custom error message\\r\\n   * to show when the assertion fails. The message can also be given as the\\r\\n   * second argument to `expect`. When not providing two arguments, always use\\r\\n   * the second form.\\r\\n   *\\r\\n   *     var goodFn = function () {};\\r\\n   *\\r\\n   *     expect(goodFn).to.throw(TypeError, 'x', 'nooo why fail??');\\r\\n   *     expect(goodFn, 'nooo why fail??').to.throw();\\r\\n   *\\r\\n   * Due to limitations in ES5, `.throw` may not always work as expected when\\r\\n   * using a transpiler such as Babel or TypeScript. In particular, it may\\r\\n   * produce unexpected results when subclassing the built-in `Error` object and\\r\\n   * then passing the subclassed constructor to `.throw`. See your transpiler's\\r\\n   * docs for details:\\r\\n   *\\r\\n   * - ([Babel](https://babeljs.io/docs/usage/caveats/#classes))\\r\\n   * - ([TypeScript](https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work))\\r\\n   *\\r\\n   * Beware of some common mistakes when using the `throw` assertion. One common\\r\\n   * mistake is to accidentally invoke the function yourself instead of letting\\r\\n   * the `throw` assertion invoke the function for you. For example, when\\r\\n   * testing if a function named `fn` throws, provide `fn` instead of `fn()` as\\r\\n   * the target for the assertion.\\r\\n   *\\r\\n   *     expect(fn).to.throw();     // Good! Tests `fn` as desired\\r\\n   *     expect(fn()).to.throw();   // Bad! Tests result of `fn()`, not `fn`\\r\\n   *\\r\\n   * If you need to assert that your function `fn` throws when passed certain\\r\\n   * arguments, then wrap a call to `fn` inside of another function.\\r\\n   *\\r\\n   *     expect(function () { fn(42); }).to.throw();  // Function expression\\r\\n   *     expect(() => fn(42)).to.throw();             // ES6 arrow function\\r\\n   *\\r\\n   * Another common mistake is to provide an object method (or any stand-alone\\r\\n   * function that relies on `this`) as the target of the assertion. Doing so is\\r\\n   * problematic because the `this` context will be lost when the function is\\r\\n   * invoked by `.throw`; there's no way for it to know what `this` is supposed\\r\\n   * to be. There are two ways around this problem. One solution is to wrap the\\r\\n   * method or function call inside of another function. Another solution is to\\r\\n   * use `bind`.\\r\\n   *\\r\\n   *     expect(function () { cat.meow(); }).to.throw();  // Function expression\\r\\n   *     expect(() => cat.meow()).to.throw();             // ES6 arrow function\\r\\n   *     expect(cat.meow.bind(cat)).to.throw();           // Bind\\r\\n   *\\r\\n   * Finally, it's worth mentioning that it's a best practice in JavaScript to\\r\\n   * only throw `Error` and derivatives of `Error` such as `ReferenceError`,\\r\\n   * `TypeError`, and user-defined objects that extend `Error`. No other type of\\r\\n   * value will generate a stack trace when initialized. With that said, the\\r\\n   * `throw` assertion does technically support any type of value being thrown,\\r\\n   * not just `Error` and its derivatives.\\r\\n   *\\r\\n   * The aliases `.throws` and `.Throw` can be used interchangeably with\\r\\n   * `.throw`.\\r\\n   *\\r\\n   * @name throw\\r\\n   * @alias throws\\r\\n   * @alias Throw\\r\\n   * @param {Error|ErrorConstructor} errorLike\\r\\n   * @param {String|RegExp} errMsgMatcher error message\\r\\n   * @param {String} msg _optional_\\r\\n   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types\\r\\n   * @returns error for chaining (null if no error)\\r\\n   * @namespace BDD\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  function assertThrows (errorLike, errMsgMatcher, msg) {\\r\\n    if (msg) flag(this, 'message', msg);\\r\\n    var obj = flag(this, 'object')\\r\\n      , ssfi = flag(this, 'ssfi')\\r\\n      , flagMsg = flag(this, 'message')\\r\\n      , negate = flag(this, 'negate') || false;\\r\\n    new Assertion(obj, flagMsg, ssfi, true).is.a('function');\\r\\n\\r\\n    if (errorLike instanceof RegExp || typeof errorLike === 'string') {\\r\\n      errMsgMatcher = errorLike;\\r\\n      errorLike = null;\\r\\n    }\\r\\n\\r\\n    var caughtErr;\\r\\n    try {\\r\\n      obj();\\r\\n    } catch (err) {\\r\\n      caughtErr = err;\\r\\n    }\\r\\n\\r\\n    // If we have the negate flag enabled and at least one valid argument it means we do expect an error\\r\\n    // but we want it to match a given set of criteria\\r\\n    var everyArgIsUndefined = errorLike === undefined && errMsgMatcher === undefined;\\r\\n\\r\\n    // If we've got the negate flag enabled and both args, we should only fail if both aren't compatible\\r\\n    // See Issue #551 and PR #683@GitHub\\r\\n    var everyArgIsDefined = Boolean(errorLike && errMsgMatcher);\\r\\n    var errorLikeFail = false;\\r\\n    var errMsgMatcherFail = false;\\r\\n\\r\\n    // Checking if error was thrown\\r\\n    if (everyArgIsUndefined || !everyArgIsUndefined && !negate) {\\r\\n      // We need this to display results correctly according to their types\\r\\n      var errorLikeString = 'an error';\\r\\n      if (errorLike instanceof Error) {\\r\\n        errorLikeString = '#{exp}';\\r\\n      } else if (errorLike) {\\r\\n        errorLikeString = _.checkError.getConstructorName(errorLike);\\r\\n      }\\r\\n\\r\\n      this.assert(\\r\\n          caughtErr\\r\\n        , 'expected #{this} to throw ' + errorLikeString\\r\\n        , 'expected #{this} to not throw an error but #{act} was thrown'\\r\\n        , errorLike && errorLike.toString()\\r\\n        , (caughtErr instanceof Error ?\\r\\n            caughtErr.toString() : (typeof caughtErr === 'string' ? caughtErr : caughtErr &&\\r\\n                                    _.checkError.getConstructorName(caughtErr)))\\r\\n      );\\r\\n    }\\r\\n\\r\\n    if (errorLike && caughtErr) {\\r\\n      // We should compare instances only if `errorLike` is an instance of `Error`\\r\\n      if (errorLike instanceof Error) {\\r\\n        var isCompatibleInstance = _.checkError.compatibleInstance(caughtErr, errorLike);\\r\\n\\r\\n        if (isCompatibleInstance === negate) {\\r\\n          // These checks were created to ensure we won't fail too soon when we've got both args and a negate\\r\\n          // See Issue #551 and PR #683@GitHub\\r\\n          if (everyArgIsDefined && negate) {\\r\\n            errorLikeFail = true;\\r\\n          } else {\\r\\n            this.assert(\\r\\n                negate\\r\\n              , 'expected #{this} to throw #{exp} but #{act} was thrown'\\r\\n              , 'expected #{this} to not throw #{exp}' + (caughtErr && !negate ? ' but #{act} was thrown' : '')\\r\\n              , errorLike.toString()\\r\\n              , caughtErr.toString()\\r\\n            );\\r\\n          }\\r\\n        }\\r\\n      }\\r\\n\\r\\n      var isCompatibleConstructor = _.checkError.compatibleConstructor(caughtErr, errorLike);\\r\\n      if (isCompatibleConstructor === negate) {\\r\\n        if (everyArgIsDefined && negate) {\\r\\n            errorLikeFail = true;\\r\\n        } else {\\r\\n          this.assert(\\r\\n              negate\\r\\n            , 'expected #{this} to throw #{exp} but #{act} was thrown'\\r\\n            , 'expected #{this} to not throw #{exp}' + (caughtErr ? ' but #{act} was thrown' : '')\\r\\n            , (errorLike instanceof Error ? errorLike.toString() : errorLike && _.checkError.getConstructorName(errorLike))\\r\\n            , (caughtErr instanceof Error ? caughtErr.toString() : caughtErr && _.checkError.getConstructorName(caughtErr))\\r\\n          );\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n\\r\\n    if (caughtErr && errMsgMatcher !== undefined && errMsgMatcher !== null) {\\r\\n      // Here we check compatible messages\\r\\n      var placeholder = 'including';\\r\\n      if (errMsgMatcher instanceof RegExp) {\\r\\n        placeholder = 'matching'\\r\\n      }\\r\\n\\r\\n      var isCompatibleMessage = _.checkError.compatibleMessage(caughtErr, errMsgMatcher);\\r\\n      if (isCompatibleMessage === negate) {\\r\\n        if (everyArgIsDefined && negate) {\\r\\n            errMsgMatcherFail = true;\\r\\n        } else {\\r\\n          this.assert(\\r\\n            negate\\r\\n            , 'expected #{this} to throw error ' + placeholder + ' #{exp} but got #{act}'\\r\\n            , 'expected #{this} to throw error not ' + placeholder + ' #{exp}'\\r\\n            ,  errMsgMatcher\\r\\n            ,  _.checkError.getMessage(caughtErr)\\r\\n          );\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n\\r\\n    // If both assertions failed and both should've matched we throw an error\\r\\n    if (errorLikeFail && errMsgMatcherFail) {\\r\\n      this.assert(\\r\\n        negate\\r\\n        , 'expected #{this} to throw #{exp} but #{act} was thrown'\\r\\n        , 'expected #{this} to not throw #{exp}' + (caughtErr ? ' but #{act} was thrown' : '')\\r\\n        , (errorLike instanceof Error ? errorLike.toString() : errorLike && _.checkError.getConstructorName(errorLike))\\r\\n        , (caughtErr instanceof Error ? caughtErr.toString() : caughtErr && _.checkError.getConstructorName(caughtErr))\\r\\n      );\\r\\n    }\\r\\n\\r\\n    flag(this, 'object', caughtErr);\\r\\n  };\\r\\n\\r\\n  Assertion.addMethod('throw', assertThrows);\\r\\n  Assertion.addMethod('throws', assertThrows);\\r\\n  Assertion.addMethod('Throw', assertThrows);\\r\\n\\r\\n  /**\\r\\n   * ### .respondTo(method[, msg])\\r\\n   *\\r\\n   * When the target is a non-function object, `.respondTo` asserts that the\\r\\n   * target has a method with the given name `method`. The method can be own or\\r\\n   * inherited, and it can be enumerable or non-enumerable.\\r\\n   *\\r\\n   *     function Cat () {}\\r\\n   *     Cat.prototype.meow = function () {};\\r\\n   *\\r\\n   *     expect(new Cat()).to.respondTo('meow');\\r\\n   *\\r\\n   * When the target is a function, `.respondTo` asserts that the target's\\r\\n   * `prototype` property has a method with the given name `method`. Again, the\\r\\n   * method can be own or inherited, and it can be enumerable or non-enumerable.\\r\\n   *\\r\\n   *     function Cat () {}\\r\\n   *     Cat.prototype.meow = function () {};\\r\\n   *\\r\\n   *     expect(Cat).to.respondTo('meow');\\r\\n   *\\r\\n   * Add `.itself` earlier in the chain to force `.respondTo` to treat the\\r\\n   * target as a non-function object, even if it's a function. Thus, it asserts\\r\\n   * that the target has a method with the given name `method`, rather than\\r\\n   * asserting that the target's `prototype` property has a method with the\\r\\n   * given name `method`.\\r\\n   *\\r\\n   *     function Cat () {}\\r\\n   *     Cat.prototype.meow = function () {};\\r\\n   *     Cat.hiss = function () {};\\r\\n   *\\r\\n   *     expect(Cat).itself.to.respondTo('hiss').but.not.respondTo('meow');\\r\\n   *\\r\\n   * When not adding `.itself`, it's important to check the target's type before\\r\\n   * using `.respondTo`. See the `.a` doc for info on checking a target's type.\\r\\n   *\\r\\n   *     function Cat () {}\\r\\n   *     Cat.prototype.meow = function () {};\\r\\n   *\\r\\n   *     expect(new Cat()).to.be.an('object').that.respondsTo('meow');\\r\\n   *\\r\\n   * Add `.not` earlier in the chain to negate `.respondTo`.\\r\\n   *\\r\\n   *     function Dog () {}\\r\\n   *     Dog.prototype.bark = function () {};\\r\\n   *\\r\\n   *     expect(new Dog()).to.not.respondTo('meow');\\r\\n   *\\r\\n   * `.respondTo` accepts an optional `msg` argument which is a custom error\\r\\n   * message to show when the assertion fails. The message can also be given as\\r\\n   * the second argument to `expect`.\\r\\n   *\\r\\n   *     expect({}).to.respondTo('meow', 'nooo why fail??');\\r\\n   *     expect({}, 'nooo why fail??').to.respondTo('meow');\\r\\n   *\\r\\n   * The alias `.respondsTo` can be used interchangeably with `.respondTo`.\\r\\n   *\\r\\n   * @name respondTo\\r\\n   * @alias respondsTo\\r\\n   * @param {String} method\\r\\n   * @param {String} msg _optional_\\r\\n   * @namespace BDD\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  function respondTo (method, msg) {\\r\\n    if (msg) flag(this, 'message', msg);\\r\\n    var obj = flag(this, 'object')\\r\\n      , itself = flag(this, 'itself')\\r\\n      , context = ('function' === typeof obj && !itself)\\r\\n        ? obj.prototype[method]\\r\\n        : obj[method];\\r\\n\\r\\n    this.assert(\\r\\n        'function' === typeof context\\r\\n      , 'expected #{this} to respond to ' + _.inspect(method)\\r\\n      , 'expected #{this} to not respond to ' + _.inspect(method)\\r\\n    );\\r\\n  }\\r\\n\\r\\n  Assertion.addMethod('respondTo', respondTo);\\r\\n  Assertion.addMethod('respondsTo', respondTo);\\r\\n\\r\\n  /**\\r\\n   * ### .itself\\r\\n   *\\r\\n   * Forces all `.respondTo` assertions that follow in the chain to behave as if\\r\\n   * the target is a non-function object, even if it's a function. Thus, it\\r\\n   * causes `.respondTo` to assert that the target has a method with the given\\r\\n   * name, rather than asserting that the target's `prototype` property has a\\r\\n   * method with the given name.\\r\\n   *\\r\\n   *     function Cat () {}\\r\\n   *     Cat.prototype.meow = function () {};\\r\\n   *     Cat.hiss = function () {};\\r\\n   *\\r\\n   *     expect(Cat).itself.to.respondTo('hiss').but.not.respondTo('meow');\\r\\n   *\\r\\n   * @name itself\\r\\n   * @namespace BDD\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  Assertion.addProperty('itself', function () {\\r\\n    flag(this, 'itself', true);\\r\\n  });\\r\\n\\r\\n  /**\\r\\n   * ### .satisfy(matcher[, msg])\\r\\n   *\\r\\n   * Invokes the given `matcher` function with the target being passed as the\\r\\n   * first argument, and asserts that the value returned is truthy.\\r\\n   *\\r\\n   *     expect(1).to.satisfy(function(num) {\\r\\n   *       return num > 0;\\r\\n   *     });\\r\\n   *\\r\\n   * Add `.not` earlier in the chain to negate `.satisfy`.\\r\\n   *\\r\\n   *     expect(1).to.not.satisfy(function(num) {\\r\\n   *       return num > 2;\\r\\n   *     });\\r\\n   *\\r\\n   * `.satisfy` accepts an optional `msg` argument which is a custom error\\r\\n   * message to show when the assertion fails. The message can also be given as\\r\\n   * the second argument to `expect`.\\r\\n   *\\r\\n   *     expect(1).to.satisfy(function(num) {\\r\\n   *       return num > 2;\\r\\n   *     }, 'nooo why fail??');\\r\\n   *\\r\\n   *     expect(1, 'nooo why fail??').to.satisfy(function(num) {\\r\\n   *       return num > 2;\\r\\n   *     });\\r\\n   *\\r\\n   * The alias `.satisfies` can be used interchangeably with `.satisfy`.\\r\\n   *\\r\\n   * @name satisfy\\r\\n   * @alias satisfies\\r\\n   * @param {Function} matcher\\r\\n   * @param {String} msg _optional_\\r\\n   * @namespace BDD\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  function satisfy (matcher, msg) {\\r\\n    if (msg) flag(this, 'message', msg);\\r\\n    var obj = flag(this, 'object');\\r\\n    var result = matcher(obj);\\r\\n    this.assert(\\r\\n        result\\r\\n      , 'expected #{this} to satisfy ' + _.objDisplay(matcher)\\r\\n      , 'expected #{this} to not satisfy' + _.objDisplay(matcher)\\r\\n      , flag(this, 'negate') ? false : true\\r\\n      , result\\r\\n    );\\r\\n  }\\r\\n\\r\\n  Assertion.addMethod('satisfy', satisfy);\\r\\n  Assertion.addMethod('satisfies', satisfy);\\r\\n\\r\\n  /**\\r\\n   * ### .closeTo(expected, delta[, msg])\\r\\n   *\\r\\n   * Asserts that the target is a number that's within a given +/- `delta` range\\r\\n   * of the given number `expected`. However, it's often best to assert that the\\r\\n   * target is equal to its expected value.\\r\\n   *\\r\\n   *     // Recommended\\r\\n   *     expect(1.5).to.equal(1.5);\\r\\n   *\\r\\n   *     // Not recommended\\r\\n   *     expect(1.5).to.be.closeTo(1, 0.5);\\r\\n   *     expect(1.5).to.be.closeTo(2, 0.5);\\r\\n   *     expect(1.5).to.be.closeTo(1, 1);\\r\\n   *\\r\\n   * Add `.not` earlier in the chain to negate `.closeTo`.\\r\\n   *\\r\\n   *     expect(1.5).to.equal(1.5); // Recommended\\r\\n   *     expect(1.5).to.not.be.closeTo(3, 1); // Not recommended\\r\\n   *\\r\\n   * `.closeTo` accepts an optional `msg` argument which is a custom error\\r\\n   * message to show when the assertion fails. The message can also be given as\\r\\n   * the second argument to `expect`.\\r\\n   *\\r\\n   *     expect(1.5).to.be.closeTo(3, 1, 'nooo why fail??');\\r\\n   *     expect(1.5, 'nooo why fail??').to.be.closeTo(3, 1);\\r\\n   *\\r\\n   * The alias `.approximately` can be used interchangeably with `.closeTo`.\\r\\n   *\\r\\n   * @name closeTo\\r\\n   * @alias approximately\\r\\n   * @param {Number} expected\\r\\n   * @param {Number} delta\\r\\n   * @param {String} msg _optional_\\r\\n   * @namespace BDD\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  function closeTo(expected, delta, msg) {\\r\\n    if (msg) flag(this, 'message', msg);\\r\\n    var obj = flag(this, 'object')\\r\\n      , flagMsg = flag(this, 'message')\\r\\n      , ssfi = flag(this, 'ssfi');\\r\\n\\r\\n    new Assertion(obj, flagMsg, ssfi, true).is.a('number');\\r\\n    if (typeof expected !== 'number' || typeof delta !== 'number') {\\r\\n      flagMsg = flagMsg ? flagMsg + ': ' : '';\\r\\n      throw new AssertionError(\\r\\n          flagMsg + 'the arguments to closeTo or approximately must be numbers',\\r\\n          undefined,\\r\\n          ssfi\\r\\n      );\\r\\n    }\\r\\n\\r\\n    this.assert(\\r\\n        Math.abs(obj - expected) <= delta\\r\\n      , 'expected #{this} to be close to ' + expected + ' +/- ' + delta\\r\\n      , 'expected #{this} not to be close to ' + expected + ' +/- ' + delta\\r\\n    );\\r\\n  }\\r\\n\\r\\n  Assertion.addMethod('closeTo', closeTo);\\r\\n  Assertion.addMethod('approximately', closeTo);\\r\\n\\r\\n  // Note: Duplicates are ignored if testing for inclusion instead of sameness.\\r\\n  function isSubsetOf(subset, superset, cmp, contains, ordered) {\\r\\n    if (!contains) {\\r\\n      if (subset.length !== superset.length) return false;\\r\\n      superset = superset.slice();\\r\\n    }\\r\\n\\r\\n    return subset.every(function(elem, idx) {\\r\\n      if (ordered) return cmp ? cmp(elem, superset[idx]) : elem === superset[idx];\\r\\n\\r\\n      if (!cmp) {\\r\\n        var matchIdx = superset.indexOf(elem);\\r\\n        if (matchIdx === -1) return false;\\r\\n\\r\\n        // Remove match from superset so not counted twice if duplicate in subset.\\r\\n        if (!contains) superset.splice(matchIdx, 1);\\r\\n        return true;\\r\\n      }\\r\\n\\r\\n      return superset.some(function(elem2, matchIdx) {\\r\\n        if (!cmp(elem, elem2)) return false;\\r\\n\\r\\n        // Remove match from superset so not counted twice if duplicate in subset.\\r\\n        if (!contains) superset.splice(matchIdx, 1);\\r\\n        return true;\\r\\n      });\\r\\n    });\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * ### .members(set[, msg])\\r\\n   *\\r\\n   * Asserts that the target array has the same members as the given array\\r\\n   * `set`.\\r\\n   *\\r\\n   *     expect([1, 2, 3]).to.have.members([2, 1, 3]);\\r\\n   *     expect([1, 2, 2]).to.have.members([2, 1, 2]);\\r\\n   *\\r\\n   * By default, members are compared using strict (`===`) equality. Add `.deep`\\r\\n   * earlier in the chain to use deep equality instead. See the `deep-eql`\\r\\n   * project page for info on the deep equality algorithm:\\r\\n   * https://github.com/chaijs/deep-eql.\\r\\n   *\\r\\n   *     // Target array deeply (but not strictly) has member `{a: 1}`\\r\\n   *     expect([{a: 1}]).to.have.deep.members([{a: 1}]);\\r\\n   *     expect([{a: 1}]).to.not.have.members([{a: 1}]);\\r\\n   *\\r\\n   * By default, order doesn't matter. Add `.ordered` earlier in the chain to\\r\\n   * require that members appear in the same order.\\r\\n   *\\r\\n   *     expect([1, 2, 3]).to.have.ordered.members([1, 2, 3]);\\r\\n   *     expect([1, 2, 3]).to.have.members([2, 1, 3])\\r\\n   *       .but.not.ordered.members([2, 1, 3]);\\r\\n   *\\r\\n   * By default, both arrays must be the same size. Add `.include` earlier in\\r\\n   * the chain to require that the target's members be a superset of the\\r\\n   * expected members. Note that duplicates are ignored in the subset when\\r\\n   * `.include` is added.\\r\\n   *\\r\\n   *     // Target array is a superset of [1, 2] but not identical\\r\\n   *     expect([1, 2, 3]).to.include.members([1, 2]);\\r\\n   *     expect([1, 2, 3]).to.not.have.members([1, 2]);\\r\\n   *\\r\\n   *     // Duplicates in the subset are ignored\\r\\n   *     expect([1, 2, 3]).to.include.members([1, 2, 2, 2]);\\r\\n   *\\r\\n   * `.deep`, `.ordered`, and `.include` can all be combined. However, if\\r\\n   * `.include` and `.ordered` are combined, the ordering begins at the start of\\r\\n   * both arrays.\\r\\n   *\\r\\n   *     expect([{a: 1}, {b: 2}, {c: 3}])\\r\\n   *       .to.include.deep.ordered.members([{a: 1}, {b: 2}])\\r\\n   *       .but.not.include.deep.ordered.members([{b: 2}, {c: 3}]);\\r\\n   *\\r\\n   * Add `.not` earlier in the chain to negate `.members`. However, it's\\r\\n   * dangerous to do so. The problem is that it creates uncertain expectations\\r\\n   * by asserting that the target array doesn't have all of the same members as\\r\\n   * the given array `set` but may or may not have some of them. It's often best\\r\\n   * to identify the exact output that's expected, and then write an assertion\\r\\n   * that only accepts that exact output.\\r\\n   *\\r\\n   *     expect([1, 2]).to.not.include(3).and.not.include(4); // Recommended\\r\\n   *     expect([1, 2]).to.not.have.members([3, 4]); // Not recommended\\r\\n   *\\r\\n   * `.members` accepts an optional `msg` argument which is a custom error\\r\\n   * message to show when the assertion fails. The message can also be given as\\r\\n   * the second argument to `expect`.\\r\\n   *\\r\\n   *     expect([1, 2]).to.have.members([1, 2, 3], 'nooo why fail??');\\r\\n   *     expect([1, 2], 'nooo why fail??').to.have.members([1, 2, 3]);\\r\\n   *\\r\\n   * @name members\\r\\n   * @param {Array} set\\r\\n   * @param {String} msg _optional_\\r\\n   * @namespace BDD\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  Assertion.addMethod('members', function (subset, msg) {\\r\\n    if (msg) flag(this, 'message', msg);\\r\\n    var obj = flag(this, 'object')\\r\\n      , flagMsg = flag(this, 'message')\\r\\n      , ssfi = flag(this, 'ssfi');\\r\\n\\r\\n    new Assertion(obj, flagMsg, ssfi, true).to.be.an('array');\\r\\n    new Assertion(subset, flagMsg, ssfi, true).to.be.an('array');\\r\\n\\r\\n    var contains = flag(this, 'contains');\\r\\n    var ordered = flag(this, 'ordered');\\r\\n\\r\\n    var subject, failMsg, failNegateMsg;\\r\\n\\r\\n    if (contains) {\\r\\n      subject = ordered ? 'an ordered superset' : 'a superset';\\r\\n      failMsg = 'expected #{this} to be ' + subject + ' of #{exp}';\\r\\n      failNegateMsg = 'expected #{this} to not be ' + subject + ' of #{exp}';\\r\\n    } else {\\r\\n      subject = ordered ? 'ordered members' : 'members';\\r\\n      failMsg = 'expected #{this} to have the same ' + subject + ' as #{exp}';\\r\\n      failNegateMsg = 'expected #{this} to not have the same ' + subject + ' as #{exp}';\\r\\n    }\\r\\n\\r\\n    var cmp = flag(this, 'deep') ? _.eql : undefined;\\r\\n\\r\\n    this.assert(\\r\\n        isSubsetOf(subset, obj, cmp, contains, ordered)\\r\\n      , failMsg\\r\\n      , failNegateMsg\\r\\n      , subset\\r\\n      , obj\\r\\n      , true\\r\\n    );\\r\\n  });\\r\\n\\r\\n  /**\\r\\n   * ### .oneOf(list[, msg])\\r\\n   *\\r\\n   * Asserts that the target is a member of the given array `list`. However,\\r\\n   * it's often best to assert that the target is equal to its expected value.\\r\\n   *\\r\\n   *     expect(1).to.equal(1); // Recommended\\r\\n   *     expect(1).to.be.oneOf([1, 2, 3]); // Not recommended\\r\\n   *\\r\\n   * Comparisons are performed using strict (`===`) equality.\\r\\n   *\\r\\n   * Add `.not` earlier in the chain to negate `.oneOf`.\\r\\n   *\\r\\n   *     expect(1).to.equal(1); // Recommended\\r\\n   *     expect(1).to.not.be.oneOf([2, 3, 4]); // Not recommended\\r\\n   *\\r\\n   * `.oneOf` accepts an optional `msg` argument which is a custom error message\\r\\n   * to show when the assertion fails. The message can also be given as the\\r\\n   * second argument to `expect`.\\r\\n   *\\r\\n   *     expect(1).to.be.oneOf([2, 3, 4], 'nooo why fail??');\\r\\n   *     expect(1, 'nooo why fail??').to.be.oneOf([2, 3, 4]);\\r\\n   *\\r\\n   * @name oneOf\\r\\n   * @param {Array<*>} list\\r\\n   * @param {String} msg _optional_\\r\\n   * @namespace BDD\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  function oneOf (list, msg) {\\r\\n    if (msg) flag(this, 'message', msg);\\r\\n    var expected = flag(this, 'object')\\r\\n      , flagMsg = flag(this, 'message')\\r\\n      , ssfi = flag(this, 'ssfi');\\r\\n    new Assertion(list, flagMsg, ssfi, true).to.be.an('array');\\r\\n\\r\\n    this.assert(\\r\\n        list.indexOf(expected) > -1\\r\\n      , 'expected #{this} to be one of #{exp}'\\r\\n      , 'expected #{this} to not be one of #{exp}'\\r\\n      , list\\r\\n      , expected\\r\\n    );\\r\\n  }\\r\\n\\r\\n  Assertion.addMethod('oneOf', oneOf);\\r\\n\\r\\n  /**\\r\\n   * ### .change(subject[, prop[, msg]])\\r\\n   *\\r\\n   * When one argument is provided, `.change` asserts that the given function\\r\\n   * `subject` returns a different value when it's invoked before the target\\r\\n   * function compared to when it's invoked afterward. However, it's often best\\r\\n   * to assert that `subject` is equal to its expected value.\\r\\n   *\\r\\n   *     var dots = ''\\r\\n   *       , addDot = function () { dots += '.'; }\\r\\n   *       , getDots = function () { return dots; };\\r\\n   *\\r\\n   *     // Recommended\\r\\n   *     expect(getDots()).to.equal('');\\r\\n   *     addDot();\\r\\n   *     expect(getDots()).to.equal('.');\\r\\n   *\\r\\n   *     // Not recommended\\r\\n   *     expect(addDot).to.change(getDots);\\r\\n   *\\r\\n   * When two arguments are provided, `.change` asserts that the value of the\\r\\n   * given object `subject`'s `prop` property is different before invoking the\\r\\n   * target function compared to afterward.\\r\\n   *\\r\\n   *     var myObj = {dots: ''}\\r\\n   *       , addDot = function () { myObj.dots += '.'; };\\r\\n   *\\r\\n   *     // Recommended\\r\\n   *     expect(myObj).to.have.property('dots', '');\\r\\n   *     addDot();\\r\\n   *     expect(myObj).to.have.property('dots', '.');\\r\\n   *\\r\\n   *     // Not recommended\\r\\n   *     expect(addDot).to.change(myObj, 'dots');\\r\\n   *\\r\\n   * Strict (`===`) equality is used to compare before and after values.\\r\\n   *\\r\\n   * Add `.not` earlier in the chain to negate `.change`.\\r\\n   *\\r\\n   *     var dots = ''\\r\\n   *       , noop = function () {}\\r\\n   *       , getDots = function () { return dots; };\\r\\n   *\\r\\n   *     expect(noop).to.not.change(getDots);\\r\\n   *\\r\\n   *     var myObj = {dots: ''}\\r\\n   *       , noop = function () {};\\r\\n   *\\r\\n   *     expect(noop).to.not.change(myObj, 'dots');\\r\\n   *\\r\\n   * `.change` accepts an optional `msg` argument which is a custom error\\r\\n   * message to show when the assertion fails. The message can also be given as\\r\\n   * the second argument to `expect`. When not providing two arguments, always\\r\\n   * use the second form.\\r\\n   *\\r\\n   *     var myObj = {dots: ''}\\r\\n   *       , addDot = function () { myObj.dots += '.'; };\\r\\n   *\\r\\n   *     expect(addDot).to.not.change(myObj, 'dots', 'nooo why fail??');\\r\\n   *\\r\\n   *     var dots = ''\\r\\n   *       , addDot = function () { dots += '.'; }\\r\\n   *       , getDots = function () { return dots; };\\r\\n   *\\r\\n   *     expect(addDot, 'nooo why fail??').to.not.change(getDots);\\r\\n   *\\r\\n   * `.change` also causes all `.by` assertions that follow in the chain to\\r\\n   * assert how much a numeric subject was increased or decreased by. However,\\r\\n   * it's dangerous to use `.change.by`. The problem is that it creates\\r\\n   * uncertain expectations by asserting that the subject either increases by\\r\\n   * the given delta, or that it decreases by the given delta. It's often best\\r\\n   * to identify the exact output that's expected, and then write an assertion\\r\\n   * that only accepts that exact output.\\r\\n   *\\r\\n   *     var myObj = {val: 1}\\r\\n   *       , addTwo = function () { myObj.val += 2; }\\r\\n   *       , subtractTwo = function () { myObj.val -= 2; };\\r\\n   *\\r\\n   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended\\r\\n   *     expect(addTwo).to.change(myObj, 'val').by(2); // Not recommended\\r\\n   *\\r\\n   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended\\r\\n   *     expect(subtractTwo).to.change(myObj, 'val').by(2); // Not recommended\\r\\n   *\\r\\n   * The alias `.changes` can be used interchangeably with `.change`.\\r\\n   *\\r\\n   * @name change\\r\\n   * @alias changes\\r\\n   * @param {String} subject\\r\\n   * @param {String} prop name _optional_\\r\\n   * @param {String} msg _optional_\\r\\n   * @namespace BDD\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  function assertChanges (subject, prop, msg) {\\r\\n    if (msg) flag(this, 'message', msg);\\r\\n    var fn = flag(this, 'object')\\r\\n      , flagMsg = flag(this, 'message')\\r\\n      , ssfi = flag(this, 'ssfi');\\r\\n    new Assertion(fn, flagMsg, ssfi, true).is.a('function');\\r\\n\\r\\n    var initial;\\r\\n    if (!prop) {\\r\\n      new Assertion(subject, flagMsg, ssfi, true).is.a('function');\\r\\n      initial = subject();\\r\\n    } else {\\r\\n      new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);\\r\\n      initial = subject[prop];\\r\\n    }\\r\\n\\r\\n    fn();\\r\\n\\r\\n    var final = prop === undefined || prop === null ? subject() : subject[prop];\\r\\n    var msgObj = prop === undefined || prop === null ? initial : '.' + prop;\\r\\n\\r\\n    // This gets flagged because of the .by(delta) assertion\\r\\n    flag(this, 'deltaMsgObj', msgObj);\\r\\n    flag(this, 'initialDeltaValue', initial);\\r\\n    flag(this, 'finalDeltaValue', final);\\r\\n    flag(this, 'deltaBehavior', 'change');\\r\\n    flag(this, 'realDelta', final !== initial);\\r\\n\\r\\n    this.assert(\\r\\n      initial !== final\\r\\n      , 'expected ' + msgObj + ' to change'\\r\\n      , 'expected ' + msgObj + ' to not change'\\r\\n    );\\r\\n  }\\r\\n\\r\\n  Assertion.addMethod('change', assertChanges);\\r\\n  Assertion.addMethod('changes', assertChanges);\\r\\n\\r\\n  /**\\r\\n   * ### .increase(subject[, prop[, msg]])\\r\\n   *\\r\\n   * When one argument is provided, `.increase` asserts that the given function\\r\\n   * `subject` returns a greater number when it's invoked after invoking the\\r\\n   * target function compared to when it's invoked beforehand. `.increase` also\\r\\n   * causes all `.by` assertions that follow in the chain to assert how much\\r\\n   * greater of a number is returned. It's often best to assert that the return\\r\\n   * value increased by the expected amount, rather than asserting it increased\\r\\n   * by any amount.\\r\\n   *\\r\\n   *     var val = 1\\r\\n   *       , addTwo = function () { val += 2; }\\r\\n   *       , getVal = function () { return val; };\\r\\n   *\\r\\n   *     expect(addTwo).to.increase(getVal).by(2); // Recommended\\r\\n   *     expect(addTwo).to.increase(getVal); // Not recommended\\r\\n   *\\r\\n   * When two arguments are provided, `.increase` asserts that the value of the\\r\\n   * given object `subject`'s `prop` property is greater after invoking the\\r\\n   * target function compared to beforehand.\\r\\n   *\\r\\n   *     var myObj = {val: 1}\\r\\n   *       , addTwo = function () { myObj.val += 2; };\\r\\n   *\\r\\n   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended\\r\\n   *     expect(addTwo).to.increase(myObj, 'val'); // Not recommended\\r\\n   *\\r\\n   * Add `.not` earlier in the chain to negate `.increase`. However, it's\\r\\n   * dangerous to do so. The problem is that it creates uncertain expectations\\r\\n   * by asserting that the subject either decreases, or that it stays the same.\\r\\n   * It's often best to identify the exact output that's expected, and then\\r\\n   * write an assertion that only accepts that exact output.\\r\\n   *\\r\\n   * When the subject is expected to decrease, it's often best to assert that it\\r\\n   * decreased by the expected amount.\\r\\n   *\\r\\n   *     var myObj = {val: 1}\\r\\n   *       , subtractTwo = function () { myObj.val -= 2; };\\r\\n   *\\r\\n   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended\\r\\n   *     expect(subtractTwo).to.not.increase(myObj, 'val'); // Not recommended\\r\\n   *\\r\\n   * When the subject is expected to stay the same, it's often best to assert\\r\\n   * exactly that.\\r\\n   *\\r\\n   *     var myObj = {val: 1}\\r\\n   *       , noop = function () {};\\r\\n   *\\r\\n   *     expect(noop).to.not.change(myObj, 'val'); // Recommended\\r\\n   *     expect(noop).to.not.increase(myObj, 'val'); // Not recommended\\r\\n   *\\r\\n   * `.increase` accepts an optional `msg` argument which is a custom error\\r\\n   * message to show when the assertion fails. The message can also be given as\\r\\n   * the second argument to `expect`. When not providing two arguments, always\\r\\n   * use the second form.\\r\\n   *\\r\\n   *     var myObj = {val: 1}\\r\\n   *       , noop = function () {};\\r\\n   *\\r\\n   *     expect(noop).to.increase(myObj, 'val', 'nooo why fail??');\\r\\n   *\\r\\n   *     var val = 1\\r\\n   *       , noop = function () {}\\r\\n   *       , getVal = function () { return val; };\\r\\n   *\\r\\n   *     expect(noop, 'nooo why fail??').to.increase(getVal);\\r\\n   *\\r\\n   * The alias `.increases` can be used interchangeably with `.increase`.\\r\\n   *\\r\\n   * @name increase\\r\\n   * @alias increases\\r\\n   * @param {String|Function} subject\\r\\n   * @param {String} prop name _optional_\\r\\n   * @param {String} msg _optional_\\r\\n   * @namespace BDD\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  function assertIncreases (subject, prop, msg) {\\r\\n    if (msg) flag(this, 'message', msg);\\r\\n    var fn = flag(this, 'object')\\r\\n      , flagMsg = flag(this, 'message')\\r\\n      , ssfi = flag(this, 'ssfi');\\r\\n    new Assertion(fn, flagMsg, ssfi, true).is.a('function');\\r\\n\\r\\n    var initial;\\r\\n    if (!prop) {\\r\\n      new Assertion(subject, flagMsg, ssfi, true).is.a('function');\\r\\n      initial = subject();\\r\\n    } else {\\r\\n      new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);\\r\\n      initial = subject[prop];\\r\\n    }\\r\\n\\r\\n    // Make sure that the target is a number\\r\\n    new Assertion(initial, flagMsg, ssfi, true).is.a('number');\\r\\n\\r\\n    fn();\\r\\n\\r\\n    var final = prop === undefined || prop === null ? subject() : subject[prop];\\r\\n    var msgObj = prop === undefined || prop === null ? initial : '.' + prop;\\r\\n\\r\\n    flag(this, 'deltaMsgObj', msgObj);\\r\\n    flag(this, 'initialDeltaValue', initial);\\r\\n    flag(this, 'finalDeltaValue', final);\\r\\n    flag(this, 'deltaBehavior', 'increase');\\r\\n    flag(this, 'realDelta', final - initial);\\r\\n\\r\\n    this.assert(\\r\\n      final - initial > 0\\r\\n      , 'expected ' + msgObj + ' to increase'\\r\\n      , 'expected ' + msgObj + ' to not increase'\\r\\n    );\\r\\n  }\\r\\n\\r\\n  Assertion.addMethod('increase', assertIncreases);\\r\\n  Assertion.addMethod('increases', assertIncreases);\\r\\n\\r\\n  /**\\r\\n   * ### .decrease(subject[, prop[, msg]])\\r\\n   *\\r\\n   * When one argument is provided, `.decrease` asserts that the given function\\r\\n   * `subject` returns a lesser number when it's invoked after invoking the\\r\\n   * target function compared to when it's invoked beforehand. `.decrease` also\\r\\n   * causes all `.by` assertions that follow in the chain to assert how much\\r\\n   * lesser of a number is returned. It's often best to assert that the return\\r\\n   * value decreased by the expected amount, rather than asserting it decreased\\r\\n   * by any amount.\\r\\n   *\\r\\n   *     var val = 1\\r\\n   *       , subtractTwo = function () { val -= 2; }\\r\\n   *       , getVal = function () { return val; };\\r\\n   *\\r\\n   *     expect(subtractTwo).to.decrease(getVal).by(2); // Recommended\\r\\n   *     expect(subtractTwo).to.decrease(getVal); // Not recommended\\r\\n   *\\r\\n   * When two arguments are provided, `.decrease` asserts that the value of the\\r\\n   * given object `subject`'s `prop` property is lesser after invoking the\\r\\n   * target function compared to beforehand.\\r\\n   *\\r\\n   *     var myObj = {val: 1}\\r\\n   *       , subtractTwo = function () { myObj.val -= 2; };\\r\\n   *\\r\\n   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended\\r\\n   *     expect(subtractTwo).to.decrease(myObj, 'val'); // Not recommended\\r\\n   *\\r\\n   * Add `.not` earlier in the chain to negate `.decrease`. However, it's\\r\\n   * dangerous to do so. The problem is that it creates uncertain expectations\\r\\n   * by asserting that the subject either increases, or that it stays the same.\\r\\n   * It's often best to identify the exact output that's expected, and then\\r\\n   * write an assertion that only accepts that exact output.\\r\\n   *\\r\\n   * When the subject is expected to increase, it's often best to assert that it\\r\\n   * increased by the expected amount.\\r\\n   *\\r\\n   *     var myObj = {val: 1}\\r\\n   *       , addTwo = function () { myObj.val += 2; };\\r\\n   *\\r\\n   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended\\r\\n   *     expect(addTwo).to.not.decrease(myObj, 'val'); // Not recommended\\r\\n   *\\r\\n   * When the subject is expected to stay the same, it's often best to assert\\r\\n   * exactly that.\\r\\n   *\\r\\n   *     var myObj = {val: 1}\\r\\n   *       , noop = function () {};\\r\\n   *\\r\\n   *     expect(noop).to.not.change(myObj, 'val'); // Recommended\\r\\n   *     expect(noop).to.not.decrease(myObj, 'val'); // Not recommended\\r\\n   *\\r\\n   * `.decrease` accepts an optional `msg` argument which is a custom error\\r\\n   * message to show when the assertion fails. The message can also be given as\\r\\n   * the second argument to `expect`. When not providing two arguments, always\\r\\n   * use the second form.\\r\\n   *\\r\\n   *     var myObj = {val: 1}\\r\\n   *       , noop = function () {};\\r\\n   *\\r\\n   *     expect(noop).to.decrease(myObj, 'val', 'nooo why fail??');\\r\\n   *\\r\\n   *     var val = 1\\r\\n   *       , noop = function () {}\\r\\n   *       , getVal = function () { return val; };\\r\\n   *\\r\\n   *     expect(noop, 'nooo why fail??').to.decrease(getVal);\\r\\n   *\\r\\n   * The alias `.decreases` can be used interchangeably with `.decrease`.\\r\\n   *\\r\\n   * @name decrease\\r\\n   * @alias decreases\\r\\n   * @param {String|Function} subject\\r\\n   * @param {String} prop name _optional_\\r\\n   * @param {String} msg _optional_\\r\\n   * @namespace BDD\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  function assertDecreases (subject, prop, msg) {\\r\\n    if (msg) flag(this, 'message', msg);\\r\\n    var fn = flag(this, 'object')\\r\\n      , flagMsg = flag(this, 'message')\\r\\n      , ssfi = flag(this, 'ssfi');\\r\\n    new Assertion(fn, flagMsg, ssfi, true).is.a('function');\\r\\n\\r\\n    var initial;\\r\\n    if (!prop) {\\r\\n      new Assertion(subject, flagMsg, ssfi, true).is.a('function');\\r\\n      initial = subject();\\r\\n    } else {\\r\\n      new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);\\r\\n      initial = subject[prop];\\r\\n    }\\r\\n\\r\\n    // Make sure that the target is a number\\r\\n    new Assertion(initial, flagMsg, ssfi, true).is.a('number');\\r\\n\\r\\n    fn();\\r\\n\\r\\n    var final = prop === undefined || prop === null ? subject() : subject[prop];\\r\\n    var msgObj = prop === undefined || prop === null ? initial : '.' + prop;\\r\\n\\r\\n    flag(this, 'deltaMsgObj', msgObj);\\r\\n    flag(this, 'initialDeltaValue', initial);\\r\\n    flag(this, 'finalDeltaValue', final);\\r\\n    flag(this, 'deltaBehavior', 'decrease');\\r\\n    flag(this, 'realDelta', initial - final);\\r\\n\\r\\n    this.assert(\\r\\n      final - initial < 0\\r\\n      , 'expected ' + msgObj + ' to decrease'\\r\\n      , 'expected ' + msgObj + ' to not decrease'\\r\\n    );\\r\\n  }\\r\\n\\r\\n  Assertion.addMethod('decrease', assertDecreases);\\r\\n  Assertion.addMethod('decreases', assertDecreases);\\r\\n\\r\\n  /**\\r\\n   * ### .by(delta[, msg])\\r\\n   *\\r\\n   * When following an `.increase` assertion in the chain, `.by` asserts that\\r\\n   * the subject of the `.increase` assertion increased by the given `delta`.\\r\\n   *\\r\\n   *     var myObj = {val: 1}\\r\\n   *       , addTwo = function () { myObj.val += 2; };\\r\\n   *\\r\\n   *     expect(addTwo).to.increase(myObj, 'val').by(2);\\r\\n   *\\r\\n   * When following a `.decrease` assertion in the chain, `.by` asserts that the\\r\\n   * subject of the `.decrease` assertion decreased by the given `delta`.\\r\\n   *\\r\\n   *     var myObj = {val: 1}\\r\\n   *       , subtractTwo = function () { myObj.val -= 2; };\\r\\n   *\\r\\n   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2);\\r\\n   *\\r\\n   * When following a `.change` assertion in the chain, `.by` asserts that the\\r\\n   * subject of the `.change` assertion either increased or decreased by the\\r\\n   * given `delta`. However, it's dangerous to use `.change.by`. The problem is\\r\\n   * that it creates uncertain expectations. It's often best to identify the\\r\\n   * exact output that's expected, and then write an assertion that only accepts\\r\\n   * that exact output.\\r\\n   *\\r\\n   *     var myObj = {val: 1}\\r\\n   *       , addTwo = function () { myObj.val += 2; }\\r\\n   *       , subtractTwo = function () { myObj.val -= 2; };\\r\\n   *\\r\\n   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended\\r\\n   *     expect(addTwo).to.change(myObj, 'val').by(2); // Not recommended\\r\\n   *\\r\\n   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended\\r\\n   *     expect(subtractTwo).to.change(myObj, 'val').by(2); // Not recommended\\r\\n   *\\r\\n   * Add `.not` earlier in the chain to negate `.by`. However, it's often best\\r\\n   * to assert that the subject changed by its expected delta, rather than\\r\\n   * asserting that it didn't change by one of countless unexpected deltas.\\r\\n   *\\r\\n   *     var myObj = {val: 1}\\r\\n   *       , addTwo = function () { myObj.val += 2; };\\r\\n   *\\r\\n   *     // Recommended\\r\\n   *     expect(addTwo).to.increase(myObj, 'val').by(2);\\r\\n   *\\r\\n   *     // Not recommended\\r\\n   *     expect(addTwo).to.increase(myObj, 'val').but.not.by(3);\\r\\n   *\\r\\n   * `.by` accepts an optional `msg` argument which is a custom error message to\\r\\n   * show when the assertion fails. The message can also be given as the second\\r\\n   * argument to `expect`.\\r\\n   *\\r\\n   *     var myObj = {val: 1}\\r\\n   *       , addTwo = function () { myObj.val += 2; };\\r\\n   *\\r\\n   *     expect(addTwo).to.increase(myObj, 'val').by(3, 'nooo why fail??');\\r\\n   *     expect(addTwo, 'nooo why fail??').to.increase(myObj, 'val').by(3);\\r\\n   *\\r\\n   * @name by\\r\\n   * @param {Number} delta\\r\\n   * @param {String} msg _optional_\\r\\n   * @namespace BDD\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  function assertDelta(delta, msg) {\\r\\n    if (msg) flag(this, 'message', msg);\\r\\n\\r\\n    var msgObj = flag(this, 'deltaMsgObj');\\r\\n    var initial = flag(this, 'initialDeltaValue');\\r\\n    var final = flag(this, 'finalDeltaValue');\\r\\n    var behavior = flag(this, 'deltaBehavior');\\r\\n    var realDelta = flag(this, 'realDelta');\\r\\n\\r\\n    var expression;\\r\\n    if (behavior === 'change') {\\r\\n      expression = Math.abs(final - initial) === Math.abs(delta);\\r\\n    } else {\\r\\n      expression = realDelta === Math.abs(delta);\\r\\n    }\\r\\n\\r\\n    this.assert(\\r\\n      expression\\r\\n      , 'expected ' + msgObj + ' to ' + behavior + ' by ' + delta\\r\\n      , 'expected ' + msgObj + ' to not ' + behavior + ' by ' + delta\\r\\n    );\\r\\n  }\\r\\n\\r\\n  Assertion.addMethod('by', assertDelta);\\r\\n\\r\\n  /**\\r\\n   * ### .extensible\\r\\n   *\\r\\n   * Asserts that the target is extensible, which means that new properties can\\r\\n   * be added to it. Primitives are never extensible.\\r\\n   *\\r\\n   *     expect({a: 1}).to.be.extensible;\\r\\n   *\\r\\n   * Add `.not` earlier in the chain to negate `.extensible`.\\r\\n   *\\r\\n   *     var nonExtensibleObject = Object.preventExtensions({})\\r\\n   *       , sealedObject = Object.seal({})\\r\\n   *       , frozenObject = Object.freeze({});\\r\\n   *\\r\\n   *     expect(nonExtensibleObject).to.not.be.extensible;\\r\\n   *     expect(sealedObject).to.not.be.extensible;\\r\\n   *     expect(frozenObject).to.not.be.extensible;\\r\\n   *     expect(1).to.not.be.extensible;\\r\\n   *\\r\\n   * A custom error message can be given as the second argument to `expect`.\\r\\n   *\\r\\n   *     expect(1, 'nooo why fail??').to.be.extensible;\\r\\n   *\\r\\n   * @name extensible\\r\\n   * @namespace BDD\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  Assertion.addProperty('extensible', function() {\\r\\n    var obj = flag(this, 'object');\\r\\n\\r\\n    // In ES5, if the argument to this method is a primitive, then it will cause a TypeError.\\r\\n    // In ES6, a non-object argument will be treated as if it was a non-extensible ordinary object, simply return false.\\r\\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible\\r\\n    // The following provides ES6 behavior for ES5 environments.\\r\\n\\r\\n    var isExtensible = obj === Object(obj) && Object.isExtensible(obj);\\r\\n\\r\\n    this.assert(\\r\\n      isExtensible\\r\\n      , 'expected #{this} to be extensible'\\r\\n      , 'expected #{this} to not be extensible'\\r\\n    );\\r\\n  });\\r\\n\\r\\n  /**\\r\\n   * ### .sealed\\r\\n   *\\r\\n   * Asserts that the target is sealed, which means that new properties can't be\\r\\n   * added to it, and its existing properties can't be reconfigured or deleted.\\r\\n   * However, it's possible that its existing properties can still be reassigned\\r\\n   * to different values. Primitives are always sealed.\\r\\n   *\\r\\n   *     var sealedObject = Object.seal({});\\r\\n   *     var frozenObject = Object.freeze({});\\r\\n   *\\r\\n   *     expect(sealedObject).to.be.sealed;\\r\\n   *     expect(frozenObject).to.be.sealed;\\r\\n   *     expect(1).to.be.sealed;\\r\\n   *\\r\\n   * Add `.not` earlier in the chain to negate `.sealed`.\\r\\n   *\\r\\n   *     expect({a: 1}).to.not.be.sealed;\\r\\n   *\\r\\n   * A custom error message can be given as the second argument to `expect`.\\r\\n   *\\r\\n   *     expect({a: 1}, 'nooo why fail??').to.be.sealed;\\r\\n   *\\r\\n   * @name sealed\\r\\n   * @namespace BDD\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  Assertion.addProperty('sealed', function() {\\r\\n    var obj = flag(this, 'object');\\r\\n\\r\\n    // In ES5, if the argument to this method is a primitive, then it will cause a TypeError.\\r\\n    // In ES6, a non-object argument will be treated as if it was a sealed ordinary object, simply return true.\\r\\n    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed\\r\\n    // The following provides ES6 behavior for ES5 environments.\\r\\n\\r\\n    var isSealed = obj === Object(obj) ? Object.isSealed(obj) : true;\\r\\n\\r\\n    this.assert(\\r\\n      isSealed\\r\\n      , 'expected #{this} to be sealed'\\r\\n      , 'expected #{this} to not be sealed'\\r\\n    );\\r\\n  });\\r\\n\\r\\n  /**\\r\\n   * ### .frozen\\r\\n   *\\r\\n   * Asserts that the target is frozen, which means that new properties can't be\\r\\n   * added to it, and its existing properties can't be reassigned to different\\r\\n   * values, reconfigured, or deleted. Primitives are always frozen.\\r\\n   *\\r\\n   *     var frozenObject = Object.freeze({});\\r\\n   *\\r\\n   *     expect(frozenObject).to.be.frozen;\\r\\n   *     expect(1).to.be.frozen;\\r\\n   *\\r\\n   * Add `.not` earlier in the chain to negate `.frozen`.\\r\\n   *\\r\\n   *     expect({a: 1}).to.not.be.frozen;\\r\\n   *\\r\\n   * A custom error message can be given as the second argument to `expect`.\\r\\n   *\\r\\n   *     expect({a: 1}, 'nooo why fail??').to.be.frozen;\\r\\n   *\\r\\n   * @name frozen\\r\\n   * @namespace BDD\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  Assertion.addProperty('frozen', function() {\\r\\n    var obj = flag(this, 'object');\\r\\n\\r\\n    // In ES5, if the argument to this method is a primitive, then it will cause a TypeError.\\r\\n    // In ES6, a non-object argument will be treated as if it was a frozen ordinary object, simply return true.\\r\\n    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen\\r\\n    // The following provides ES6 behavior for ES5 environments.\\r\\n\\r\\n    var isFrozen = obj === Object(obj) ? Object.isFrozen(obj) : true;\\r\\n\\r\\n    this.assert(\\r\\n      isFrozen\\r\\n      , 'expected #{this} to be frozen'\\r\\n      , 'expected #{this} to not be frozen'\\r\\n    );\\r\\n  });\\r\\n\\r\\n  /**\\r\\n   * ### .finite\\r\\n   *\\r\\n   * Asserts that the target is a number, and isn't `NaN` or positive/negative\\r\\n   * `Infinity`.\\r\\n   *\\r\\n   *     expect(1).to.be.finite;\\r\\n   *\\r\\n   * Add `.not` earlier in the chain to negate `.finite`. However, it's\\r\\n   * dangerous to do so. The problem is that it creates uncertain expectations\\r\\n   * by asserting that the subject either isn't a number, or that it's `NaN`, or\\r\\n   * that it's positive `Infinity`, or that it's negative `Infinity`. It's often\\r\\n   * best to identify the exact output that's expected, and then write an\\r\\n   * assertion that only accepts that exact output.\\r\\n   *\\r\\n   * When the target isn't expected to be a number, it's often best to assert\\r\\n   * that it's the expected type, rather than asserting that it isn't one of\\r\\n   * many unexpected types.\\r\\n   *\\r\\n   *     expect('foo').to.be.a('string'); // Recommended\\r\\n   *     expect('foo').to.not.be.finite; // Not recommended\\r\\n   *\\r\\n   * When the target is expected to be `NaN`, it's often best to assert exactly\\r\\n   * that.\\r\\n   *\\r\\n   *     expect(NaN).to.be.NaN; // Recommended\\r\\n   *     expect(NaN).to.not.be.finite; // Not recommended\\r\\n   *\\r\\n   * When the target is expected to be positive infinity, it's often best to\\r\\n   * assert exactly that.\\r\\n   *\\r\\n   *     expect(Infinity).to.equal(Infinity); // Recommended\\r\\n   *     expect(Infinity).to.not.be.finite; // Not recommended\\r\\n   *\\r\\n   * When the target is expected to be negative infinity, it's often best to\\r\\n   * assert exactly that.\\r\\n   *\\r\\n   *     expect(-Infinity).to.equal(-Infinity); // Recommended\\r\\n   *     expect(-Infinity).to.not.be.finite; // Not recommended\\r\\n   *\\r\\n   * A custom error message can be given as the second argument to `expect`.\\r\\n   *\\r\\n   *     expect('foo', 'nooo why fail??').to.be.finite;\\r\\n   *\\r\\n   * @name finite\\r\\n   * @namespace BDD\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  Assertion.addProperty('finite', function(msg) {\\r\\n    var obj = flag(this, 'object');\\r\\n\\r\\n    this.assert(\\r\\n        typeof obj === 'number' && isFinite(obj)\\r\\n      , 'expected #{this} to be a finite number'\\r\\n      , 'expected #{this} to not be a finite number'\\r\\n    );\\r\\n  });\\r\\n};\\r\\n\\n\\n//# sourceURL=webpack:///./node_modules/chai/lib/chai/core/assertions.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/chai/lib/chai/interface/assert.js\":\n/*!********************************************************!*\\\n  !*** ./node_modules/chai/lib/chai/interface/assert.js ***!\n  \\********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\neval(\"/*!\\r\\n * chai\\r\\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\\r\\n * MIT Licensed\\r\\n */\\r\\n\\r\\nmodule.exports = function (chai, util) {\\r\\n  /*!\\r\\n   * Chai dependencies.\\r\\n   */\\r\\n\\r\\n  var Assertion = chai.Assertion\\r\\n    , flag = util.flag;\\r\\n\\r\\n  /*!\\r\\n   * Module export.\\r\\n   */\\r\\n\\r\\n  /**\\r\\n   * ### assert(expression, message)\\r\\n   *\\r\\n   * Write your own test expressions.\\r\\n   *\\r\\n   *     assert('foo' !== 'bar', 'foo is not bar');\\r\\n   *     assert(Array.isArray([]), 'empty arrays are arrays');\\r\\n   *\\r\\n   * @param {Mixed} expression to test for truthiness\\r\\n   * @param {String} message to display on error\\r\\n   * @name assert\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  var assert = chai.assert = function (express, errmsg) {\\r\\n    var test = new Assertion(null, null, chai.assert, true);\\r\\n    test.assert(\\r\\n        express\\r\\n      , errmsg\\r\\n      , '[ negation message unavailable ]'\\r\\n    );\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .fail([message])\\r\\n   * ### .fail(actual, expected, [message], [operator])\\r\\n   *\\r\\n   * Throw a failure. Node.js `assert` module-compatible.\\r\\n   *\\r\\n   *     assert.fail();\\r\\n   *     assert.fail(\\\"custom error message\\\");\\r\\n   *     assert.fail(1, 2);\\r\\n   *     assert.fail(1, 2, \\\"custom error message\\\");\\r\\n   *     assert.fail(1, 2, \\\"custom error message\\\", \\\">\\\");\\r\\n   *     assert.fail(1, 2, undefined, \\\">\\\");\\r\\n   *\\r\\n   * @name fail\\r\\n   * @param {Mixed} actual\\r\\n   * @param {Mixed} expected\\r\\n   * @param {String} message\\r\\n   * @param {String} operator\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.fail = function (actual, expected, message, operator) {\\r\\n    if (arguments.length < 2) {\\r\\n        // Comply with Node's fail([message]) interface\\r\\n\\r\\n        message = actual;\\r\\n        actual = undefined;\\r\\n    }\\r\\n\\r\\n    message = message || 'assert.fail()';\\r\\n    throw new chai.AssertionError(message, {\\r\\n        actual: actual\\r\\n      , expected: expected\\r\\n      , operator: operator\\r\\n    }, assert.fail);\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .isOk(object, [message])\\r\\n   *\\r\\n   * Asserts that `object` is truthy.\\r\\n   *\\r\\n   *     assert.isOk('everything', 'everything is ok');\\r\\n   *     assert.isOk(false, 'this will fail');\\r\\n   *\\r\\n   * @name isOk\\r\\n   * @alias ok\\r\\n   * @param {Mixed} object to test\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.isOk = function (val, msg) {\\r\\n    new Assertion(val, msg, assert.isOk, true).is.ok;\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .isNotOk(object, [message])\\r\\n   *\\r\\n   * Asserts that `object` is falsy.\\r\\n   *\\r\\n   *     assert.isNotOk('everything', 'this will fail');\\r\\n   *     assert.isNotOk(false, 'this will pass');\\r\\n   *\\r\\n   * @name isNotOk\\r\\n   * @alias notOk\\r\\n   * @param {Mixed} object to test\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.isNotOk = function (val, msg) {\\r\\n    new Assertion(val, msg, assert.isNotOk, true).is.not.ok;\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .equal(actual, expected, [message])\\r\\n   *\\r\\n   * Asserts non-strict equality (`==`) of `actual` and `expected`.\\r\\n   *\\r\\n   *     assert.equal(3, '3', '== coerces values to strings');\\r\\n   *\\r\\n   * @name equal\\r\\n   * @param {Mixed} actual\\r\\n   * @param {Mixed} expected\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.equal = function (act, exp, msg) {\\r\\n    var test = new Assertion(act, msg, assert.equal, true);\\r\\n\\r\\n    test.assert(\\r\\n        exp == flag(test, 'object')\\r\\n      , 'expected #{this} to equal #{exp}'\\r\\n      , 'expected #{this} to not equal #{act}'\\r\\n      , exp\\r\\n      , act\\r\\n      , true\\r\\n    );\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .notEqual(actual, expected, [message])\\r\\n   *\\r\\n   * Asserts non-strict inequality (`!=`) of `actual` and `expected`.\\r\\n   *\\r\\n   *     assert.notEqual(3, 4, 'these numbers are not equal');\\r\\n   *\\r\\n   * @name notEqual\\r\\n   * @param {Mixed} actual\\r\\n   * @param {Mixed} expected\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.notEqual = function (act, exp, msg) {\\r\\n    var test = new Assertion(act, msg, assert.notEqual, true);\\r\\n\\r\\n    test.assert(\\r\\n        exp != flag(test, 'object')\\r\\n      , 'expected #{this} to not equal #{exp}'\\r\\n      , 'expected #{this} to equal #{act}'\\r\\n      , exp\\r\\n      , act\\r\\n      , true\\r\\n    );\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .strictEqual(actual, expected, [message])\\r\\n   *\\r\\n   * Asserts strict equality (`===`) of `actual` and `expected`.\\r\\n   *\\r\\n   *     assert.strictEqual(true, true, 'these booleans are strictly equal');\\r\\n   *\\r\\n   * @name strictEqual\\r\\n   * @param {Mixed} actual\\r\\n   * @param {Mixed} expected\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.strictEqual = function (act, exp, msg) {\\r\\n    new Assertion(act, msg, assert.strictEqual, true).to.equal(exp);\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .notStrictEqual(actual, expected, [message])\\r\\n   *\\r\\n   * Asserts strict inequality (`!==`) of `actual` and `expected`.\\r\\n   *\\r\\n   *     assert.notStrictEqual(3, '3', 'no coercion for strict equality');\\r\\n   *\\r\\n   * @name notStrictEqual\\r\\n   * @param {Mixed} actual\\r\\n   * @param {Mixed} expected\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.notStrictEqual = function (act, exp, msg) {\\r\\n    new Assertion(act, msg, assert.notStrictEqual, true).to.not.equal(exp);\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .deepEqual(actual, expected, [message])\\r\\n   *\\r\\n   * Asserts that `actual` is deeply equal to `expected`.\\r\\n   *\\r\\n   *     assert.deepEqual({ tea: 'green' }, { tea: 'green' });\\r\\n   *\\r\\n   * @name deepEqual\\r\\n   * @param {Mixed} actual\\r\\n   * @param {Mixed} expected\\r\\n   * @param {String} message\\r\\n   * @alias deepStrictEqual\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.deepEqual = assert.deepStrictEqual = function (act, exp, msg) {\\r\\n    new Assertion(act, msg, assert.deepEqual, true).to.eql(exp);\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .notDeepEqual(actual, expected, [message])\\r\\n   *\\r\\n   * Assert that `actual` is not deeply equal to `expected`.\\r\\n   *\\r\\n   *     assert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' });\\r\\n   *\\r\\n   * @name notDeepEqual\\r\\n   * @param {Mixed} actual\\r\\n   * @param {Mixed} expected\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.notDeepEqual = function (act, exp, msg) {\\r\\n    new Assertion(act, msg, assert.notDeepEqual, true).to.not.eql(exp);\\r\\n  };\\r\\n\\r\\n   /**\\r\\n   * ### .isAbove(valueToCheck, valueToBeAbove, [message])\\r\\n   *\\r\\n   * Asserts `valueToCheck` is strictly greater than (>) `valueToBeAbove`.\\r\\n   *\\r\\n   *     assert.isAbove(5, 2, '5 is strictly greater than 2');\\r\\n   *\\r\\n   * @name isAbove\\r\\n   * @param {Mixed} valueToCheck\\r\\n   * @param {Mixed} valueToBeAbove\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.isAbove = function (val, abv, msg) {\\r\\n    new Assertion(val, msg, assert.isAbove, true).to.be.above(abv);\\r\\n  };\\r\\n\\r\\n   /**\\r\\n   * ### .isAtLeast(valueToCheck, valueToBeAtLeast, [message])\\r\\n   *\\r\\n   * Asserts `valueToCheck` is greater than or equal to (>=) `valueToBeAtLeast`.\\r\\n   *\\r\\n   *     assert.isAtLeast(5, 2, '5 is greater or equal to 2');\\r\\n   *     assert.isAtLeast(3, 3, '3 is greater or equal to 3');\\r\\n   *\\r\\n   * @name isAtLeast\\r\\n   * @param {Mixed} valueToCheck\\r\\n   * @param {Mixed} valueToBeAtLeast\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.isAtLeast = function (val, atlst, msg) {\\r\\n    new Assertion(val, msg, assert.isAtLeast, true).to.be.least(atlst);\\r\\n  };\\r\\n\\r\\n   /**\\r\\n   * ### .isBelow(valueToCheck, valueToBeBelow, [message])\\r\\n   *\\r\\n   * Asserts `valueToCheck` is strictly less than (<) `valueToBeBelow`.\\r\\n   *\\r\\n   *     assert.isBelow(3, 6, '3 is strictly less than 6');\\r\\n   *\\r\\n   * @name isBelow\\r\\n   * @param {Mixed} valueToCheck\\r\\n   * @param {Mixed} valueToBeBelow\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.isBelow = function (val, blw, msg) {\\r\\n    new Assertion(val, msg, assert.isBelow, true).to.be.below(blw);\\r\\n  };\\r\\n\\r\\n   /**\\r\\n   * ### .isAtMost(valueToCheck, valueToBeAtMost, [message])\\r\\n   *\\r\\n   * Asserts `valueToCheck` is less than or equal to (<=) `valueToBeAtMost`.\\r\\n   *\\r\\n   *     assert.isAtMost(3, 6, '3 is less than or equal to 6');\\r\\n   *     assert.isAtMost(4, 4, '4 is less than or equal to 4');\\r\\n   *\\r\\n   * @name isAtMost\\r\\n   * @param {Mixed} valueToCheck\\r\\n   * @param {Mixed} valueToBeAtMost\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.isAtMost = function (val, atmst, msg) {\\r\\n    new Assertion(val, msg, assert.isAtMost, true).to.be.most(atmst);\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .isTrue(value, [message])\\r\\n   *\\r\\n   * Asserts that `value` is true.\\r\\n   *\\r\\n   *     var teaServed = true;\\r\\n   *     assert.isTrue(teaServed, 'the tea has been served');\\r\\n   *\\r\\n   * @name isTrue\\r\\n   * @param {Mixed} value\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.isTrue = function (val, msg) {\\r\\n    new Assertion(val, msg, assert.isTrue, true).is['true'];\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .isNotTrue(value, [message])\\r\\n   *\\r\\n   * Asserts that `value` is not true.\\r\\n   *\\r\\n   *     var tea = 'tasty chai';\\r\\n   *     assert.isNotTrue(tea, 'great, time for tea!');\\r\\n   *\\r\\n   * @name isNotTrue\\r\\n   * @param {Mixed} value\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.isNotTrue = function (val, msg) {\\r\\n    new Assertion(val, msg, assert.isNotTrue, true).to.not.equal(true);\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .isFalse(value, [message])\\r\\n   *\\r\\n   * Asserts that `value` is false.\\r\\n   *\\r\\n   *     var teaServed = false;\\r\\n   *     assert.isFalse(teaServed, 'no tea yet? hmm...');\\r\\n   *\\r\\n   * @name isFalse\\r\\n   * @param {Mixed} value\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.isFalse = function (val, msg) {\\r\\n    new Assertion(val, msg, assert.isFalse, true).is['false'];\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .isNotFalse(value, [message])\\r\\n   *\\r\\n   * Asserts that `value` is not false.\\r\\n   *\\r\\n   *     var tea = 'tasty chai';\\r\\n   *     assert.isNotFalse(tea, 'great, time for tea!');\\r\\n   *\\r\\n   * @name isNotFalse\\r\\n   * @param {Mixed} value\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.isNotFalse = function (val, msg) {\\r\\n    new Assertion(val, msg, assert.isNotFalse, true).to.not.equal(false);\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .isNull(value, [message])\\r\\n   *\\r\\n   * Asserts that `value` is null.\\r\\n   *\\r\\n   *     assert.isNull(err, 'there was no error');\\r\\n   *\\r\\n   * @name isNull\\r\\n   * @param {Mixed} value\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.isNull = function (val, msg) {\\r\\n    new Assertion(val, msg, assert.isNull, true).to.equal(null);\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .isNotNull(value, [message])\\r\\n   *\\r\\n   * Asserts that `value` is not null.\\r\\n   *\\r\\n   *     var tea = 'tasty chai';\\r\\n   *     assert.isNotNull(tea, 'great, time for tea!');\\r\\n   *\\r\\n   * @name isNotNull\\r\\n   * @param {Mixed} value\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.isNotNull = function (val, msg) {\\r\\n    new Assertion(val, msg, assert.isNotNull, true).to.not.equal(null);\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .isNaN\\r\\n   *\\r\\n   * Asserts that value is NaN.\\r\\n   *\\r\\n   *     assert.isNaN(NaN, 'NaN is NaN');\\r\\n   *\\r\\n   * @name isNaN\\r\\n   * @param {Mixed} value\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.isNaN = function (val, msg) {\\r\\n    new Assertion(val, msg, assert.isNaN, true).to.be.NaN;\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .isNotNaN\\r\\n   *\\r\\n   * Asserts that value is not NaN.\\r\\n   *\\r\\n   *     assert.isNotNaN(4, '4 is not NaN');\\r\\n   *\\r\\n   * @name isNotNaN\\r\\n   * @param {Mixed} value\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n  assert.isNotNaN = function (val, msg) {\\r\\n    new Assertion(val, msg, assert.isNotNaN, true).not.to.be.NaN;\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .exists\\r\\n   *\\r\\n   * Asserts that the target is neither `null` nor `undefined`.\\r\\n   *\\r\\n   *     var foo = 'hi';\\r\\n   *\\r\\n   *     assert.exists(foo, 'foo is neither `null` nor `undefined`');\\r\\n   *\\r\\n   * @name exists\\r\\n   * @param {Mixed} value\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.exists = function (val, msg) {\\r\\n    new Assertion(val, msg, assert.exists, true).to.exist;\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .notExists\\r\\n   *\\r\\n   * Asserts that the target is either `null` or `undefined`.\\r\\n   *\\r\\n   *     var bar = null\\r\\n   *       , baz;\\r\\n   *\\r\\n   *     assert.notExists(bar);\\r\\n   *     assert.notExists(baz, 'baz is either null or undefined');\\r\\n   *\\r\\n   * @name notExists\\r\\n   * @param {Mixed} value\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.notExists = function (val, msg) {\\r\\n    new Assertion(val, msg, assert.notExists, true).to.not.exist;\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .isUndefined(value, [message])\\r\\n   *\\r\\n   * Asserts that `value` is `undefined`.\\r\\n   *\\r\\n   *     var tea;\\r\\n   *     assert.isUndefined(tea, 'no tea defined');\\r\\n   *\\r\\n   * @name isUndefined\\r\\n   * @param {Mixed} value\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.isUndefined = function (val, msg) {\\r\\n    new Assertion(val, msg, assert.isUndefined, true).to.equal(undefined);\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .isDefined(value, [message])\\r\\n   *\\r\\n   * Asserts that `value` is not `undefined`.\\r\\n   *\\r\\n   *     var tea = 'cup of chai';\\r\\n   *     assert.isDefined(tea, 'tea has been defined');\\r\\n   *\\r\\n   * @name isDefined\\r\\n   * @param {Mixed} value\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.isDefined = function (val, msg) {\\r\\n    new Assertion(val, msg, assert.isDefined, true).to.not.equal(undefined);\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .isFunction(value, [message])\\r\\n   *\\r\\n   * Asserts that `value` is a function.\\r\\n   *\\r\\n   *     function serveTea() { return 'cup of tea'; };\\r\\n   *     assert.isFunction(serveTea, 'great, we can have tea now');\\r\\n   *\\r\\n   * @name isFunction\\r\\n   * @param {Mixed} value\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.isFunction = function (val, msg) {\\r\\n    new Assertion(val, msg, assert.isFunction, true).to.be.a('function');\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .isNotFunction(value, [message])\\r\\n   *\\r\\n   * Asserts that `value` is _not_ a function.\\r\\n   *\\r\\n   *     var serveTea = [ 'heat', 'pour', 'sip' ];\\r\\n   *     assert.isNotFunction(serveTea, 'great, we have listed the steps');\\r\\n   *\\r\\n   * @name isNotFunction\\r\\n   * @param {Mixed} value\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.isNotFunction = function (val, msg) {\\r\\n    new Assertion(val, msg, assert.isNotFunction, true).to.not.be.a('function');\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .isObject(value, [message])\\r\\n   *\\r\\n   * Asserts that `value` is an object of type 'Object' (as revealed by `Object.prototype.toString`).\\r\\n   * _The assertion does not match subclassed objects._\\r\\n   *\\r\\n   *     var selection = { name: 'Chai', serve: 'with spices' };\\r\\n   *     assert.isObject(selection, 'tea selection is an object');\\r\\n   *\\r\\n   * @name isObject\\r\\n   * @param {Mixed} value\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.isObject = function (val, msg) {\\r\\n    new Assertion(val, msg, assert.isObject, true).to.be.a('object');\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .isNotObject(value, [message])\\r\\n   *\\r\\n   * Asserts that `value` is _not_ an object of type 'Object' (as revealed by `Object.prototype.toString`).\\r\\n   *\\r\\n   *     var selection = 'chai'\\r\\n   *     assert.isNotObject(selection, 'tea selection is not an object');\\r\\n   *     assert.isNotObject(null, 'null is not an object');\\r\\n   *\\r\\n   * @name isNotObject\\r\\n   * @param {Mixed} value\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.isNotObject = function (val, msg) {\\r\\n    new Assertion(val, msg, assert.isNotObject, true).to.not.be.a('object');\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .isArray(value, [message])\\r\\n   *\\r\\n   * Asserts that `value` is an array.\\r\\n   *\\r\\n   *     var menu = [ 'green', 'chai', 'oolong' ];\\r\\n   *     assert.isArray(menu, 'what kind of tea do we want?');\\r\\n   *\\r\\n   * @name isArray\\r\\n   * @param {Mixed} value\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.isArray = function (val, msg) {\\r\\n    new Assertion(val, msg, assert.isArray, true).to.be.an('array');\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .isNotArray(value, [message])\\r\\n   *\\r\\n   * Asserts that `value` is _not_ an array.\\r\\n   *\\r\\n   *     var menu = 'green|chai|oolong';\\r\\n   *     assert.isNotArray(menu, 'what kind of tea do we want?');\\r\\n   *\\r\\n   * @name isNotArray\\r\\n   * @param {Mixed} value\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.isNotArray = function (val, msg) {\\r\\n    new Assertion(val, msg, assert.isNotArray, true).to.not.be.an('array');\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .isString(value, [message])\\r\\n   *\\r\\n   * Asserts that `value` is a string.\\r\\n   *\\r\\n   *     var teaOrder = 'chai';\\r\\n   *     assert.isString(teaOrder, 'order placed');\\r\\n   *\\r\\n   * @name isString\\r\\n   * @param {Mixed} value\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.isString = function (val, msg) {\\r\\n    new Assertion(val, msg, assert.isString, true).to.be.a('string');\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .isNotString(value, [message])\\r\\n   *\\r\\n   * Asserts that `value` is _not_ a string.\\r\\n   *\\r\\n   *     var teaOrder = 4;\\r\\n   *     assert.isNotString(teaOrder, 'order placed');\\r\\n   *\\r\\n   * @name isNotString\\r\\n   * @param {Mixed} value\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.isNotString = function (val, msg) {\\r\\n    new Assertion(val, msg, assert.isNotString, true).to.not.be.a('string');\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .isNumber(value, [message])\\r\\n   *\\r\\n   * Asserts that `value` is a number.\\r\\n   *\\r\\n   *     var cups = 2;\\r\\n   *     assert.isNumber(cups, 'how many cups');\\r\\n   *\\r\\n   * @name isNumber\\r\\n   * @param {Number} value\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.isNumber = function (val, msg) {\\r\\n    new Assertion(val, msg, assert.isNumber, true).to.be.a('number');\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .isNotNumber(value, [message])\\r\\n   *\\r\\n   * Asserts that `value` is _not_ a number.\\r\\n   *\\r\\n   *     var cups = '2 cups please';\\r\\n   *     assert.isNotNumber(cups, 'how many cups');\\r\\n   *\\r\\n   * @name isNotNumber\\r\\n   * @param {Mixed} value\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.isNotNumber = function (val, msg) {\\r\\n    new Assertion(val, msg, assert.isNotNumber, true).to.not.be.a('number');\\r\\n  };\\r\\n\\r\\n   /**\\r\\n   * ### .isFinite(value, [message])\\r\\n   *\\r\\n   * Asserts that `value` is a finite number. Unlike `.isNumber`, this will fail for `NaN` and `Infinity`.\\r\\n   *\\r\\n   *     var cups = 2;\\r\\n   *     assert.isFinite(cups, 'how many cups');\\r\\n   *\\r\\n   *     assert.isFinite(NaN); // throws\\r\\n   *\\r\\n   * @name isFinite\\r\\n   * @param {Number} value\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.isFinite = function (val, msg) {\\r\\n    new Assertion(val, msg, assert.isFinite, true).to.be.finite;\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .isBoolean(value, [message])\\r\\n   *\\r\\n   * Asserts that `value` is a boolean.\\r\\n   *\\r\\n   *     var teaReady = true\\r\\n   *       , teaServed = false;\\r\\n   *\\r\\n   *     assert.isBoolean(teaReady, 'is the tea ready');\\r\\n   *     assert.isBoolean(teaServed, 'has tea been served');\\r\\n   *\\r\\n   * @name isBoolean\\r\\n   * @param {Mixed} value\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.isBoolean = function (val, msg) {\\r\\n    new Assertion(val, msg, assert.isBoolean, true).to.be.a('boolean');\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .isNotBoolean(value, [message])\\r\\n   *\\r\\n   * Asserts that `value` is _not_ a boolean.\\r\\n   *\\r\\n   *     var teaReady = 'yep'\\r\\n   *       , teaServed = 'nope';\\r\\n   *\\r\\n   *     assert.isNotBoolean(teaReady, 'is the tea ready');\\r\\n   *     assert.isNotBoolean(teaServed, 'has tea been served');\\r\\n   *\\r\\n   * @name isNotBoolean\\r\\n   * @param {Mixed} value\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.isNotBoolean = function (val, msg) {\\r\\n    new Assertion(val, msg, assert.isNotBoolean, true).to.not.be.a('boolean');\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .typeOf(value, name, [message])\\r\\n   *\\r\\n   * Asserts that `value`'s type is `name`, as determined by\\r\\n   * `Object.prototype.toString`.\\r\\n   *\\r\\n   *     assert.typeOf({ tea: 'chai' }, 'object', 'we have an object');\\r\\n   *     assert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');\\r\\n   *     assert.typeOf('tea', 'string', 'we have a string');\\r\\n   *     assert.typeOf(/tea/, 'regexp', 'we have a regular expression');\\r\\n   *     assert.typeOf(null, 'null', 'we have a null');\\r\\n   *     assert.typeOf(undefined, 'undefined', 'we have an undefined');\\r\\n   *\\r\\n   * @name typeOf\\r\\n   * @param {Mixed} value\\r\\n   * @param {String} name\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.typeOf = function (val, type, msg) {\\r\\n    new Assertion(val, msg, assert.typeOf, true).to.be.a(type);\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .notTypeOf(value, name, [message])\\r\\n   *\\r\\n   * Asserts that `value`'s type is _not_ `name`, as determined by\\r\\n   * `Object.prototype.toString`.\\r\\n   *\\r\\n   *     assert.notTypeOf('tea', 'number', 'strings are not numbers');\\r\\n   *\\r\\n   * @name notTypeOf\\r\\n   * @param {Mixed} value\\r\\n   * @param {String} typeof name\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.notTypeOf = function (val, type, msg) {\\r\\n    new Assertion(val, msg, assert.notTypeOf, true).to.not.be.a(type);\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .instanceOf(object, constructor, [message])\\r\\n   *\\r\\n   * Asserts that `value` is an instance of `constructor`.\\r\\n   *\\r\\n   *     var Tea = function (name) { this.name = name; }\\r\\n   *       , chai = new Tea('chai');\\r\\n   *\\r\\n   *     assert.instanceOf(chai, Tea, 'chai is an instance of tea');\\r\\n   *\\r\\n   * @name instanceOf\\r\\n   * @param {Object} object\\r\\n   * @param {Constructor} constructor\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.instanceOf = function (val, type, msg) {\\r\\n    new Assertion(val, msg, assert.instanceOf, true).to.be.instanceOf(type);\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .notInstanceOf(object, constructor, [message])\\r\\n   *\\r\\n   * Asserts `value` is not an instance of `constructor`.\\r\\n   *\\r\\n   *     var Tea = function (name) { this.name = name; }\\r\\n   *       , chai = new String('chai');\\r\\n   *\\r\\n   *     assert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');\\r\\n   *\\r\\n   * @name notInstanceOf\\r\\n   * @param {Object} object\\r\\n   * @param {Constructor} constructor\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.notInstanceOf = function (val, type, msg) {\\r\\n    new Assertion(val, msg, assert.notInstanceOf, true)\\r\\n      .to.not.be.instanceOf(type);\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .include(haystack, needle, [message])\\r\\n   *\\r\\n   * Asserts that `haystack` includes `needle`. Can be used to assert the\\r\\n   * inclusion of a value in an array, a substring in a string, or a subset of\\r\\n   * properties in an object.\\r\\n   *\\r\\n   *     assert.include([1,2,3], 2, 'array contains value');\\r\\n   *     assert.include('foobar', 'foo', 'string contains substring');\\r\\n   *     assert.include({ foo: 'bar', hello: 'universe' }, { foo: 'bar' }, 'object contains property');\\r\\n   *\\r\\n   * Strict equality (===) is used. When asserting the inclusion of a value in\\r\\n   * an array, the array is searched for an element that's strictly equal to the\\r\\n   * given value. When asserting a subset of properties in an object, the object\\r\\n   * is searched for the given property keys, checking that each one is present\\r\\n   * and strictly equal to the given property value. For instance:\\r\\n   *\\r\\n   *     var obj1 = {a: 1}\\r\\n   *       , obj2 = {b: 2};\\r\\n   *     assert.include([obj1, obj2], obj1);\\r\\n   *     assert.include({foo: obj1, bar: obj2}, {foo: obj1});\\r\\n   *     assert.include({foo: obj1, bar: obj2}, {foo: obj1, bar: obj2});\\r\\n   *\\r\\n   * @name include\\r\\n   * @param {Array|String} haystack\\r\\n   * @param {Mixed} needle\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.include = function (exp, inc, msg) {\\r\\n    new Assertion(exp, msg, assert.include, true).include(inc);\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .notInclude(haystack, needle, [message])\\r\\n   *\\r\\n   * Asserts that `haystack` does not include `needle`. Can be used to assert\\r\\n   * the absence of a value in an array, a substring in a string, or a subset of\\r\\n   * properties in an object.\\r\\n   *\\r\\n   *     assert.notInclude([1,2,3], 4, \\\"array doesn't contain value\\\");\\r\\n   *     assert.notInclude('foobar', 'baz', \\\"string doesn't contain substring\\\");\\r\\n   *     assert.notInclude({ foo: 'bar', hello: 'universe' }, { foo: 'baz' }, 'object doesn't contain property');\\r\\n   *\\r\\n   * Strict equality (===) is used. When asserting the absence of a value in an\\r\\n   * array, the array is searched to confirm the absence of an element that's\\r\\n   * strictly equal to the given value. When asserting a subset of properties in\\r\\n   * an object, the object is searched to confirm that at least one of the given\\r\\n   * property keys is either not present or not strictly equal to the given\\r\\n   * property value. For instance:\\r\\n   *\\r\\n   *     var obj1 = {a: 1}\\r\\n   *       , obj2 = {b: 2};\\r\\n   *     assert.notInclude([obj1, obj2], {a: 1});\\r\\n   *     assert.notInclude({foo: obj1, bar: obj2}, {foo: {a: 1}});\\r\\n   *     assert.notInclude({foo: obj1, bar: obj2}, {foo: obj1, bar: {b: 2}});\\r\\n   *\\r\\n   * @name notInclude\\r\\n   * @param {Array|String} haystack\\r\\n   * @param {Mixed} needle\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.notInclude = function (exp, inc, msg) {\\r\\n    new Assertion(exp, msg, assert.notInclude, true).not.include(inc);\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .deepInclude(haystack, needle, [message])\\r\\n   *\\r\\n   * Asserts that `haystack` includes `needle`. Can be used to assert the\\r\\n   * inclusion of a value in an array or a subset of properties in an object.\\r\\n   * Deep equality is used.\\r\\n   *\\r\\n   *     var obj1 = {a: 1}\\r\\n   *       , obj2 = {b: 2};\\r\\n   *     assert.deepInclude([obj1, obj2], {a: 1});\\r\\n   *     assert.deepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}});\\r\\n   *     assert.deepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}, bar: {b: 2}});\\r\\n   *\\r\\n   * @name deepInclude\\r\\n   * @param {Array|String} haystack\\r\\n   * @param {Mixed} needle\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.deepInclude = function (exp, inc, msg) {\\r\\n    new Assertion(exp, msg, assert.deepInclude, true).deep.include(inc);\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .notDeepInclude(haystack, needle, [message])\\r\\n   *\\r\\n   * Asserts that `haystack` does not include `needle`. Can be used to assert\\r\\n   * the absence of a value in an array or a subset of properties in an object.\\r\\n   * Deep equality is used.\\r\\n   *\\r\\n   *     var obj1 = {a: 1}\\r\\n   *       , obj2 = {b: 2};\\r\\n   *     assert.notDeepInclude([obj1, obj2], {a: 9});\\r\\n   *     assert.notDeepInclude({foo: obj1, bar: obj2}, {foo: {a: 9}});\\r\\n   *     assert.notDeepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}, bar: {b: 9}});\\r\\n   *\\r\\n   * @name notDeepInclude\\r\\n   * @param {Array|String} haystack\\r\\n   * @param {Mixed} needle\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.notDeepInclude = function (exp, inc, msg) {\\r\\n    new Assertion(exp, msg, assert.notDeepInclude, true).not.deep.include(inc);\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .nestedInclude(haystack, needle, [message])\\r\\n   *\\r\\n   * Asserts that 'haystack' includes 'needle'.\\r\\n   * Can be used to assert the inclusion of a subset of properties in an\\r\\n   * object.\\r\\n   * Enables the use of dot- and bracket-notation for referencing nested\\r\\n   * properties.\\r\\n   * '[]' and '.' in property names can be escaped using double backslashes.\\r\\n   *\\r\\n   *     assert.nestedInclude({'.a': {'b': 'x'}}, {'\\\\\\\\.a.[b]': 'x'});\\r\\n   *     assert.nestedInclude({'a': {'[b]': 'x'}}, {'a.\\\\\\\\[b\\\\\\\\]': 'x'});\\r\\n   *\\r\\n   * @name nestedInclude\\r\\n   * @param {Object} haystack\\r\\n   * @param {Object} needle\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.nestedInclude = function (exp, inc, msg) {\\r\\n    new Assertion(exp, msg, assert.nestedInclude, true).nested.include(inc);\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .notNestedInclude(haystack, needle, [message])\\r\\n   *\\r\\n   * Asserts that 'haystack' does not include 'needle'.\\r\\n   * Can be used to assert the absence of a subset of properties in an\\r\\n   * object.\\r\\n   * Enables the use of dot- and bracket-notation for referencing nested\\r\\n   * properties.\\r\\n   * '[]' and '.' in property names can be escaped using double backslashes.\\r\\n   *\\r\\n   *     assert.notNestedInclude({'.a': {'b': 'x'}}, {'\\\\\\\\.a.b': 'y'});\\r\\n   *     assert.notNestedInclude({'a': {'[b]': 'x'}}, {'a.\\\\\\\\[b\\\\\\\\]': 'y'});\\r\\n   *\\r\\n   * @name notNestedInclude\\r\\n   * @param {Object} haystack\\r\\n   * @param {Object} needle\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.notNestedInclude = function (exp, inc, msg) {\\r\\n    new Assertion(exp, msg, assert.notNestedInclude, true)\\r\\n      .not.nested.include(inc);\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .deepNestedInclude(haystack, needle, [message])\\r\\n   *\\r\\n   * Asserts that 'haystack' includes 'needle'.\\r\\n   * Can be used to assert the inclusion of a subset of properties in an\\r\\n   * object while checking for deep equality.\\r\\n   * Enables the use of dot- and bracket-notation for referencing nested\\r\\n   * properties.\\r\\n   * '[]' and '.' in property names can be escaped using double backslashes.\\r\\n   *\\r\\n   *     assert.deepNestedInclude({a: {b: [{x: 1}]}}, {'a.b[0]': {x: 1}});\\r\\n   *     assert.deepNestedInclude({'.a': {'[b]': {x: 1}}}, {'\\\\\\\\.a.\\\\\\\\[b\\\\\\\\]': {x: 1}});\\r\\n   *\\r\\n   * @name deepNestedInclude\\r\\n   * @param {Object} haystack\\r\\n   * @param {Object} needle\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.deepNestedInclude = function(exp, inc, msg) {\\r\\n    new Assertion(exp, msg, assert.deepNestedInclude, true)\\r\\n      .deep.nested.include(inc);\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .notDeepNestedInclude(haystack, needle, [message])\\r\\n   *\\r\\n   * Asserts that 'haystack' does not include 'needle'.\\r\\n   * Can be used to assert the absence of a subset of properties in an\\r\\n   * object while checking for deep equality.\\r\\n   * Enables the use of dot- and bracket-notation for referencing nested\\r\\n   * properties.\\r\\n   * '[]' and '.' in property names can be escaped using double backslashes.\\r\\n   *\\r\\n   *     assert.notDeepNestedInclude({a: {b: [{x: 1}]}}, {'a.b[0]': {y: 1}})\\r\\n   *     assert.notDeepNestedInclude({'.a': {'[b]': {x: 1}}}, {'\\\\\\\\.a.\\\\\\\\[b\\\\\\\\]': {y: 2}});\\r\\n   *\\r\\n   * @name notDeepNestedInclude\\r\\n   * @param {Object} haystack\\r\\n   * @param {Object} needle\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.notDeepNestedInclude = function(exp, inc, msg) {\\r\\n    new Assertion(exp, msg, assert.notDeepNestedInclude, true)\\r\\n      .not.deep.nested.include(inc);\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .ownInclude(haystack, needle, [message])\\r\\n   *\\r\\n   * Asserts that 'haystack' includes 'needle'.\\r\\n   * Can be used to assert the inclusion of a subset of properties in an\\r\\n   * object while ignoring inherited properties.\\r\\n   *\\r\\n   *     assert.ownInclude({ a: 1 }, { a: 1 });\\r\\n   *\\r\\n   * @name ownInclude\\r\\n   * @param {Object} haystack\\r\\n   * @param {Object} needle\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.ownInclude = function(exp, inc, msg) {\\r\\n    new Assertion(exp, msg, assert.ownInclude, true).own.include(inc);\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .notOwnInclude(haystack, needle, [message])\\r\\n   *\\r\\n   * Asserts that 'haystack' includes 'needle'.\\r\\n   * Can be used to assert the absence of a subset of properties in an\\r\\n   * object while ignoring inherited properties.\\r\\n   *\\r\\n   *     Object.prototype.b = 2;\\r\\n   *\\r\\n   *     assert.notOwnInclude({ a: 1 }, { b: 2 });\\r\\n   *\\r\\n   * @name notOwnInclude\\r\\n   * @param {Object} haystack\\r\\n   * @param {Object} needle\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.notOwnInclude = function(exp, inc, msg) {\\r\\n    new Assertion(exp, msg, assert.notOwnInclude, true).not.own.include(inc);\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .deepOwnInclude(haystack, needle, [message])\\r\\n   *\\r\\n   * Asserts that 'haystack' includes 'needle'.\\r\\n   * Can be used to assert the inclusion of a subset of properties in an\\r\\n   * object while ignoring inherited properties and checking for deep equality.\\r\\n   *\\r\\n   *      assert.deepOwnInclude({a: {b: 2}}, {a: {b: 2}});\\r\\n   *\\r\\n   * @name deepOwnInclude\\r\\n   * @param {Object} haystack\\r\\n   * @param {Object} needle\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.deepOwnInclude = function(exp, inc, msg) {\\r\\n    new Assertion(exp, msg, assert.deepOwnInclude, true)\\r\\n      .deep.own.include(inc);\\r\\n  };\\r\\n\\r\\n   /**\\r\\n   * ### .notDeepOwnInclude(haystack, needle, [message])\\r\\n   *\\r\\n   * Asserts that 'haystack' includes 'needle'.\\r\\n   * Can be used to assert the absence of a subset of properties in an\\r\\n   * object while ignoring inherited properties and checking for deep equality.\\r\\n   *\\r\\n   *      assert.notDeepOwnInclude({a: {b: 2}}, {a: {c: 3}});\\r\\n   *\\r\\n   * @name notDeepOwnInclude\\r\\n   * @param {Object} haystack\\r\\n   * @param {Object} needle\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.notDeepOwnInclude = function(exp, inc, msg) {\\r\\n    new Assertion(exp, msg, assert.notDeepOwnInclude, true)\\r\\n      .not.deep.own.include(inc);\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .match(value, regexp, [message])\\r\\n   *\\r\\n   * Asserts that `value` matches the regular expression `regexp`.\\r\\n   *\\r\\n   *     assert.match('foobar', /^foo/, 'regexp matches');\\r\\n   *\\r\\n   * @name match\\r\\n   * @param {Mixed} value\\r\\n   * @param {RegExp} regexp\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.match = function (exp, re, msg) {\\r\\n    new Assertion(exp, msg, assert.match, true).to.match(re);\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .notMatch(value, regexp, [message])\\r\\n   *\\r\\n   * Asserts that `value` does not match the regular expression `regexp`.\\r\\n   *\\r\\n   *     assert.notMatch('foobar', /^foo/, 'regexp does not match');\\r\\n   *\\r\\n   * @name notMatch\\r\\n   * @param {Mixed} value\\r\\n   * @param {RegExp} regexp\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.notMatch = function (exp, re, msg) {\\r\\n    new Assertion(exp, msg, assert.notMatch, true).to.not.match(re);\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .property(object, property, [message])\\r\\n   *\\r\\n   * Asserts that `object` has a direct or inherited property named by\\r\\n   * `property`.\\r\\n   *\\r\\n   *     assert.property({ tea: { green: 'matcha' }}, 'tea');\\r\\n   *     assert.property({ tea: { green: 'matcha' }}, 'toString');\\r\\n   *\\r\\n   * @name property\\r\\n   * @param {Object} object\\r\\n   * @param {String} property\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.property = function (obj, prop, msg) {\\r\\n    new Assertion(obj, msg, assert.property, true).to.have.property(prop);\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .notProperty(object, property, [message])\\r\\n   *\\r\\n   * Asserts that `object` does _not_ have a direct or inherited property named\\r\\n   * by `property`.\\r\\n   *\\r\\n   *     assert.notProperty({ tea: { green: 'matcha' }}, 'coffee');\\r\\n   *\\r\\n   * @name notProperty\\r\\n   * @param {Object} object\\r\\n   * @param {String} property\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.notProperty = function (obj, prop, msg) {\\r\\n    new Assertion(obj, msg, assert.notProperty, true)\\r\\n      .to.not.have.property(prop);\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .propertyVal(object, property, value, [message])\\r\\n   *\\r\\n   * Asserts that `object` has a direct or inherited property named by\\r\\n   * `property` with a value given by `value`. Uses a strict equality check\\r\\n   * (===).\\r\\n   *\\r\\n   *     assert.propertyVal({ tea: 'is good' }, 'tea', 'is good');\\r\\n   *\\r\\n   * @name propertyVal\\r\\n   * @param {Object} object\\r\\n   * @param {String} property\\r\\n   * @param {Mixed} value\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.propertyVal = function (obj, prop, val, msg) {\\r\\n    new Assertion(obj, msg, assert.propertyVal, true)\\r\\n      .to.have.property(prop, val);\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .notPropertyVal(object, property, value, [message])\\r\\n   *\\r\\n   * Asserts that `object` does _not_ have a direct or inherited property named\\r\\n   * by `property` with value given by `value`. Uses a strict equality check\\r\\n   * (===).\\r\\n   *\\r\\n   *     assert.notPropertyVal({ tea: 'is good' }, 'tea', 'is bad');\\r\\n   *     assert.notPropertyVal({ tea: 'is good' }, 'coffee', 'is good');\\r\\n   *\\r\\n   * @name notPropertyVal\\r\\n   * @param {Object} object\\r\\n   * @param {String} property\\r\\n   * @param {Mixed} value\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.notPropertyVal = function (obj, prop, val, msg) {\\r\\n    new Assertion(obj, msg, assert.notPropertyVal, true)\\r\\n      .to.not.have.property(prop, val);\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .deepPropertyVal(object, property, value, [message])\\r\\n   *\\r\\n   * Asserts that `object` has a direct or inherited property named by\\r\\n   * `property` with a value given by `value`. Uses a deep equality check.\\r\\n   *\\r\\n   *     assert.deepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'matcha' });\\r\\n   *\\r\\n   * @name deepPropertyVal\\r\\n   * @param {Object} object\\r\\n   * @param {String} property\\r\\n   * @param {Mixed} value\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.deepPropertyVal = function (obj, prop, val, msg) {\\r\\n    new Assertion(obj, msg, assert.deepPropertyVal, true)\\r\\n      .to.have.deep.property(prop, val);\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .notDeepPropertyVal(object, property, value, [message])\\r\\n   *\\r\\n   * Asserts that `object` does _not_ have a direct or inherited property named\\r\\n   * by `property` with value given by `value`. Uses a deep equality check.\\r\\n   *\\r\\n   *     assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { black: 'matcha' });\\r\\n   *     assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'oolong' });\\r\\n   *     assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'coffee', { green: 'matcha' });\\r\\n   *\\r\\n   * @name notDeepPropertyVal\\r\\n   * @param {Object} object\\r\\n   * @param {String} property\\r\\n   * @param {Mixed} value\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.notDeepPropertyVal = function (obj, prop, val, msg) {\\r\\n    new Assertion(obj, msg, assert.notDeepPropertyVal, true)\\r\\n      .to.not.have.deep.property(prop, val);\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .ownProperty(object, property, [message])\\r\\n   *\\r\\n   * Asserts that `object` has a direct property named by `property`. Inherited\\r\\n   * properties aren't checked.\\r\\n   *\\r\\n   *     assert.ownProperty({ tea: { green: 'matcha' }}, 'tea');\\r\\n   *\\r\\n   * @name ownProperty\\r\\n   * @param {Object} object\\r\\n   * @param {String} property\\r\\n   * @param {String} message\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.ownProperty = function (obj, prop, msg) {\\r\\n    new Assertion(obj, msg, assert.ownProperty, true)\\r\\n      .to.have.own.property(prop);\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .notOwnProperty(object, property, [message])\\r\\n   *\\r\\n   * Asserts that `object` does _not_ have a direct property named by\\r\\n   * `property`. Inherited properties aren't checked.\\r\\n   *\\r\\n   *     assert.notOwnProperty({ tea: { green: 'matcha' }}, 'coffee');\\r\\n   *     assert.notOwnProperty({}, 'toString');\\r\\n   *\\r\\n   * @name notOwnProperty\\r\\n   * @param {Object} object\\r\\n   * @param {String} property\\r\\n   * @param {String} message\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.notOwnProperty = function (obj, prop, msg) {\\r\\n    new Assertion(obj, msg, assert.notOwnProperty, true)\\r\\n      .to.not.have.own.property(prop);\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .ownPropertyVal(object, property, value, [message])\\r\\n   *\\r\\n   * Asserts that `object` has a direct property named by `property` and a value\\r\\n   * equal to the provided `value`. Uses a strict equality check (===).\\r\\n   * Inherited properties aren't checked.\\r\\n   *\\r\\n   *     assert.ownPropertyVal({ coffee: 'is good'}, 'coffee', 'is good');\\r\\n   *\\r\\n   * @name ownPropertyVal\\r\\n   * @param {Object} object\\r\\n   * @param {String} property\\r\\n   * @param {Mixed} value\\r\\n   * @param {String} message\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.ownPropertyVal = function (obj, prop, value, msg) {\\r\\n    new Assertion(obj, msg, assert.ownPropertyVal, true)\\r\\n      .to.have.own.property(prop, value);\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .notOwnPropertyVal(object, property, value, [message])\\r\\n   *\\r\\n   * Asserts that `object` does _not_ have a direct property named by `property`\\r\\n   * with a value equal to the provided `value`. Uses a strict equality check\\r\\n   * (===). Inherited properties aren't checked.\\r\\n   *\\r\\n   *     assert.notOwnPropertyVal({ tea: 'is better'}, 'tea', 'is worse');\\r\\n   *     assert.notOwnPropertyVal({}, 'toString', Object.prototype.toString);\\r\\n   *\\r\\n   * @name notOwnPropertyVal\\r\\n   * @param {Object} object\\r\\n   * @param {String} property\\r\\n   * @param {Mixed} value\\r\\n   * @param {String} message\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.notOwnPropertyVal = function (obj, prop, value, msg) {\\r\\n    new Assertion(obj, msg, assert.notOwnPropertyVal, true)\\r\\n      .to.not.have.own.property(prop, value);\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .deepOwnPropertyVal(object, property, value, [message])\\r\\n   *\\r\\n   * Asserts that `object` has a direct property named by `property` and a value\\r\\n   * equal to the provided `value`. Uses a deep equality check. Inherited\\r\\n   * properties aren't checked.\\r\\n   *\\r\\n   *     assert.deepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'matcha' });\\r\\n   *\\r\\n   * @name deepOwnPropertyVal\\r\\n   * @param {Object} object\\r\\n   * @param {String} property\\r\\n   * @param {Mixed} value\\r\\n   * @param {String} message\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.deepOwnPropertyVal = function (obj, prop, value, msg) {\\r\\n    new Assertion(obj, msg, assert.deepOwnPropertyVal, true)\\r\\n      .to.have.deep.own.property(prop, value);\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .notDeepOwnPropertyVal(object, property, value, [message])\\r\\n   *\\r\\n   * Asserts that `object` does _not_ have a direct property named by `property`\\r\\n   * with a value equal to the provided `value`. Uses a deep equality check.\\r\\n   * Inherited properties aren't checked.\\r\\n   *\\r\\n   *     assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { black: 'matcha' });\\r\\n   *     assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'oolong' });\\r\\n   *     assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'coffee', { green: 'matcha' });\\r\\n   *     assert.notDeepOwnPropertyVal({}, 'toString', Object.prototype.toString);\\r\\n   *\\r\\n   * @name notDeepOwnPropertyVal\\r\\n   * @param {Object} object\\r\\n   * @param {String} property\\r\\n   * @param {Mixed} value\\r\\n   * @param {String} message\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.notDeepOwnPropertyVal = function (obj, prop, value, msg) {\\r\\n    new Assertion(obj, msg, assert.notDeepOwnPropertyVal, true)\\r\\n      .to.not.have.deep.own.property(prop, value);\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .nestedProperty(object, property, [message])\\r\\n   *\\r\\n   * Asserts that `object` has a direct or inherited property named by\\r\\n   * `property`, which can be a string using dot- and bracket-notation for\\r\\n   * nested reference.\\r\\n   *\\r\\n   *     assert.nestedProperty({ tea: { green: 'matcha' }}, 'tea.green');\\r\\n   *\\r\\n   * @name nestedProperty\\r\\n   * @param {Object} object\\r\\n   * @param {String} property\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.nestedProperty = function (obj, prop, msg) {\\r\\n    new Assertion(obj, msg, assert.nestedProperty, true)\\r\\n      .to.have.nested.property(prop);\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .notNestedProperty(object, property, [message])\\r\\n   *\\r\\n   * Asserts that `object` does _not_ have a property named by `property`, which\\r\\n   * can be a string using dot- and bracket-notation for nested reference. The\\r\\n   * property cannot exist on the object nor anywhere in its prototype chain.\\r\\n   *\\r\\n   *     assert.notNestedProperty({ tea: { green: 'matcha' }}, 'tea.oolong');\\r\\n   *\\r\\n   * @name notNestedProperty\\r\\n   * @param {Object} object\\r\\n   * @param {String} property\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.notNestedProperty = function (obj, prop, msg) {\\r\\n    new Assertion(obj, msg, assert.notNestedProperty, true)\\r\\n      .to.not.have.nested.property(prop);\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .nestedPropertyVal(object, property, value, [message])\\r\\n   *\\r\\n   * Asserts that `object` has a property named by `property` with value given\\r\\n   * by `value`. `property` can use dot- and bracket-notation for nested\\r\\n   * reference. Uses a strict equality check (===).\\r\\n   *\\r\\n   *     assert.nestedPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');\\r\\n   *\\r\\n   * @name nestedPropertyVal\\r\\n   * @param {Object} object\\r\\n   * @param {String} property\\r\\n   * @param {Mixed} value\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.nestedPropertyVal = function (obj, prop, val, msg) {\\r\\n    new Assertion(obj, msg, assert.nestedPropertyVal, true)\\r\\n      .to.have.nested.property(prop, val);\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .notNestedPropertyVal(object, property, value, [message])\\r\\n   *\\r\\n   * Asserts that `object` does _not_ have a property named by `property` with\\r\\n   * value given by `value`. `property` can use dot- and bracket-notation for\\r\\n   * nested reference. Uses a strict equality check (===).\\r\\n   *\\r\\n   *     assert.notNestedPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'konacha');\\r\\n   *     assert.notNestedPropertyVal({ tea: { green: 'matcha' }}, 'coffee.green', 'matcha');\\r\\n   *\\r\\n   * @name notNestedPropertyVal\\r\\n   * @param {Object} object\\r\\n   * @param {String} property\\r\\n   * @param {Mixed} value\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.notNestedPropertyVal = function (obj, prop, val, msg) {\\r\\n    new Assertion(obj, msg, assert.notNestedPropertyVal, true)\\r\\n      .to.not.have.nested.property(prop, val);\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .deepNestedPropertyVal(object, property, value, [message])\\r\\n   *\\r\\n   * Asserts that `object` has a property named by `property` with a value given\\r\\n   * by `value`. `property` can use dot- and bracket-notation for nested\\r\\n   * reference. Uses a deep equality check.\\r\\n   *\\r\\n   *     assert.deepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { matcha: 'yum' });\\r\\n   *\\r\\n   * @name deepNestedPropertyVal\\r\\n   * @param {Object} object\\r\\n   * @param {String} property\\r\\n   * @param {Mixed} value\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.deepNestedPropertyVal = function (obj, prop, val, msg) {\\r\\n    new Assertion(obj, msg, assert.deepNestedPropertyVal, true)\\r\\n      .to.have.deep.nested.property(prop, val);\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .notDeepNestedPropertyVal(object, property, value, [message])\\r\\n   *\\r\\n   * Asserts that `object` does _not_ have a property named by `property` with\\r\\n   * value given by `value`. `property` can use dot- and bracket-notation for\\r\\n   * nested reference. Uses a deep equality check.\\r\\n   *\\r\\n   *     assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { oolong: 'yum' });\\r\\n   *     assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { matcha: 'yuck' });\\r\\n   *     assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.black', { matcha: 'yum' });\\r\\n   *\\r\\n   * @name notDeepNestedPropertyVal\\r\\n   * @param {Object} object\\r\\n   * @param {String} property\\r\\n   * @param {Mixed} value\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.notDeepNestedPropertyVal = function (obj, prop, val, msg) {\\r\\n    new Assertion(obj, msg, assert.notDeepNestedPropertyVal, true)\\r\\n      .to.not.have.deep.nested.property(prop, val);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * ### .lengthOf(object, length, [message])\\r\\n   *\\r\\n   * Asserts that `object` has a `length` or `size` with the expected value.\\r\\n   *\\r\\n   *     assert.lengthOf([1,2,3], 3, 'array has length of 3');\\r\\n   *     assert.lengthOf('foobar', 6, 'string has length of 6');\\r\\n   *     assert.lengthOf(new Set([1,2,3]), 3, 'set has size of 3');\\r\\n   *     assert.lengthOf(new Map([['a',1],['b',2],['c',3]]), 3, 'map has size of 3');\\r\\n   *\\r\\n   * @name lengthOf\\r\\n   * @param {Mixed} object\\r\\n   * @param {Number} length\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.lengthOf = function (exp, len, msg) {\\r\\n    new Assertion(exp, msg, assert.lengthOf, true).to.have.lengthOf(len);\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .hasAnyKeys(object, [keys], [message])\\r\\n   *\\r\\n   * Asserts that `object` has at least one of the `keys` provided.\\r\\n   * You can also provide a single object instead of a `keys` array and its keys\\r\\n   * will be used as the expected set of keys.\\r\\n   *\\r\\n   *     assert.hasAnyKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'iDontExist', 'baz']);\\r\\n   *     assert.hasAnyKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, iDontExist: 99, baz: 1337});\\r\\n   *     assert.hasAnyKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);\\r\\n   *     assert.hasAnyKeys(new Set([{foo: 'bar'}, 'anotherKey']), [{foo: 'bar'}, 'anotherKey']);\\r\\n   *\\r\\n   * @name hasAnyKeys\\r\\n   * @param {Mixed} object\\r\\n   * @param {Array|Object} keys\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.hasAnyKeys = function (obj, keys, msg) {\\r\\n    new Assertion(obj, msg, assert.hasAnyKeys, true).to.have.any.keys(keys);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * ### .hasAllKeys(object, [keys], [message])\\r\\n   *\\r\\n   * Asserts that `object` has all and only all of the `keys` provided.\\r\\n   * You can also provide a single object instead of a `keys` array and its keys\\r\\n   * will be used as the expected set of keys.\\r\\n   *\\r\\n   *     assert.hasAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'bar', 'baz']);\\r\\n   *     assert.hasAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, bar: 99, baz: 1337]);\\r\\n   *     assert.hasAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);\\r\\n   *     assert.hasAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}, 'anotherKey']);\\r\\n   *\\r\\n   * @name hasAllKeys\\r\\n   * @param {Mixed} object\\r\\n   * @param {String[]} keys\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.hasAllKeys = function (obj, keys, msg) {\\r\\n    new Assertion(obj, msg, assert.hasAllKeys, true).to.have.all.keys(keys);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * ### .containsAllKeys(object, [keys], [message])\\r\\n   *\\r\\n   * Asserts that `object` has all of the `keys` provided but may have more keys not listed.\\r\\n   * You can also provide a single object instead of a `keys` array and its keys\\r\\n   * will be used as the expected set of keys.\\r\\n   *\\r\\n   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'baz']);\\r\\n   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'bar', 'baz']);\\r\\n   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, baz: 1337});\\r\\n   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, bar: 99, baz: 1337});\\r\\n   *     assert.containsAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}]);\\r\\n   *     assert.containsAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);\\r\\n   *     assert.containsAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}]);\\r\\n   *     assert.containsAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}, 'anotherKey']);\\r\\n   *\\r\\n   * @name containsAllKeys\\r\\n   * @param {Mixed} object\\r\\n   * @param {String[]} keys\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.containsAllKeys = function (obj, keys, msg) {\\r\\n    new Assertion(obj, msg, assert.containsAllKeys, true)\\r\\n      .to.contain.all.keys(keys);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * ### .doesNotHaveAnyKeys(object, [keys], [message])\\r\\n   *\\r\\n   * Asserts that `object` has none of the `keys` provided.\\r\\n   * You can also provide a single object instead of a `keys` array and its keys\\r\\n   * will be used as the expected set of keys.\\r\\n   *\\r\\n   *     assert.doesNotHaveAnyKeys({foo: 1, bar: 2, baz: 3}, ['one', 'two', 'example']);\\r\\n   *     assert.doesNotHaveAnyKeys({foo: 1, bar: 2, baz: 3}, {one: 1, two: 2, example: 'foo'});\\r\\n   *     assert.doesNotHaveAnyKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{one: 'two'}, 'example']);\\r\\n   *     assert.doesNotHaveAnyKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{one: 'two'}, 'example']);\\r\\n   *\\r\\n   * @name doesNotHaveAnyKeys\\r\\n   * @param {Mixed} object\\r\\n   * @param {String[]} keys\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.doesNotHaveAnyKeys = function (obj, keys, msg) {\\r\\n    new Assertion(obj, msg, assert.doesNotHaveAnyKeys, true)\\r\\n      .to.not.have.any.keys(keys);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * ### .doesNotHaveAllKeys(object, [keys], [message])\\r\\n   *\\r\\n   * Asserts that `object` does not have at least one of the `keys` provided.\\r\\n   * You can also provide a single object instead of a `keys` array and its keys\\r\\n   * will be used as the expected set of keys.\\r\\n   *\\r\\n   *     assert.doesNotHaveAllKeys({foo: 1, bar: 2, baz: 3}, ['one', 'two', 'example']);\\r\\n   *     assert.doesNotHaveAllKeys({foo: 1, bar: 2, baz: 3}, {one: 1, two: 2, example: 'foo'});\\r\\n   *     assert.doesNotHaveAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{one: 'two'}, 'example']);\\r\\n   *     assert.doesNotHaveAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{one: 'two'}, 'example']);\\r\\n   *\\r\\n   * @name doesNotHaveAllKeys\\r\\n   * @param {Mixed} object\\r\\n   * @param {String[]} keys\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.doesNotHaveAllKeys = function (obj, keys, msg) {\\r\\n    new Assertion(obj, msg, assert.doesNotHaveAllKeys, true)\\r\\n      .to.not.have.all.keys(keys);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * ### .hasAnyDeepKeys(object, [keys], [message])\\r\\n   *\\r\\n   * Asserts that `object` has at least one of the `keys` provided.\\r\\n   * Since Sets and Maps can have objects as keys you can use this assertion to perform\\r\\n   * a deep comparison.\\r\\n   * You can also provide a single object instead of a `keys` array and its keys\\r\\n   * will be used as the expected set of keys.\\r\\n   *\\r\\n   *     assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {one: 'one'});\\r\\n   *     assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), [{one: 'one'}, {two: 'two'}]);\\r\\n   *     assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);\\r\\n   *     assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {one: 'one'});\\r\\n   *     assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {three: 'three'}]);\\r\\n   *     assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);\\r\\n   *\\r\\n   * @name doesNotHaveAllKeys\\r\\n   * @param {Mixed} object\\r\\n   * @param {Array|Object} keys\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.hasAnyDeepKeys = function (obj, keys, msg) {\\r\\n    new Assertion(obj, msg, assert.hasAnyDeepKeys, true)\\r\\n      .to.have.any.deep.keys(keys);\\r\\n  }\\r\\n\\r\\n /**\\r\\n   * ### .hasAllDeepKeys(object, [keys], [message])\\r\\n   *\\r\\n   * Asserts that `object` has all and only all of the `keys` provided.\\r\\n   * Since Sets and Maps can have objects as keys you can use this assertion to perform\\r\\n   * a deep comparison.\\r\\n   * You can also provide a single object instead of a `keys` array and its keys\\r\\n   * will be used as the expected set of keys.\\r\\n   *\\r\\n   *     assert.hasAllDeepKeys(new Map([[{one: 'one'}, 'valueOne']]), {one: 'one'});\\r\\n   *     assert.hasAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);\\r\\n   *     assert.hasAllDeepKeys(new Set([{one: 'one'}]), {one: 'one'});\\r\\n   *     assert.hasAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);\\r\\n   *\\r\\n   * @name hasAllDeepKeys\\r\\n   * @param {Mixed} object\\r\\n   * @param {Array|Object} keys\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.hasAllDeepKeys = function (obj, keys, msg) {\\r\\n    new Assertion(obj, msg, assert.hasAllDeepKeys, true)\\r\\n      .to.have.all.deep.keys(keys);\\r\\n  }\\r\\n\\r\\n /**\\r\\n   * ### .containsAllDeepKeys(object, [keys], [message])\\r\\n   *\\r\\n   * Asserts that `object` contains all of the `keys` provided.\\r\\n   * Since Sets and Maps can have objects as keys you can use this assertion to perform\\r\\n   * a deep comparison.\\r\\n   * You can also provide a single object instead of a `keys` array and its keys\\r\\n   * will be used as the expected set of keys.\\r\\n   *\\r\\n   *     assert.containsAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {one: 'one'});\\r\\n   *     assert.containsAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);\\r\\n   *     assert.containsAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {one: 'one'});\\r\\n   *     assert.containsAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);\\r\\n   *\\r\\n   * @name containsAllDeepKeys\\r\\n   * @param {Mixed} object\\r\\n   * @param {Array|Object} keys\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.containsAllDeepKeys = function (obj, keys, msg) {\\r\\n    new Assertion(obj, msg, assert.containsAllDeepKeys, true)\\r\\n      .to.contain.all.deep.keys(keys);\\r\\n  }\\r\\n\\r\\n /**\\r\\n   * ### .doesNotHaveAnyDeepKeys(object, [keys], [message])\\r\\n   *\\r\\n   * Asserts that `object` has none of the `keys` provided.\\r\\n   * Since Sets and Maps can have objects as keys you can use this assertion to perform\\r\\n   * a deep comparison.\\r\\n   * You can also provide a single object instead of a `keys` array and its keys\\r\\n   * will be used as the expected set of keys.\\r\\n   *\\r\\n   *     assert.doesNotHaveAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {thisDoesNot: 'exist'});\\r\\n   *     assert.doesNotHaveAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{twenty: 'twenty'}, {fifty: 'fifty'}]);\\r\\n   *     assert.doesNotHaveAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {twenty: 'twenty'});\\r\\n   *     assert.doesNotHaveAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{twenty: 'twenty'}, {fifty: 'fifty'}]);\\r\\n   *\\r\\n   * @name doesNotHaveAnyDeepKeys\\r\\n   * @param {Mixed} object\\r\\n   * @param {Array|Object} keys\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.doesNotHaveAnyDeepKeys = function (obj, keys, msg) {\\r\\n    new Assertion(obj, msg, assert.doesNotHaveAnyDeepKeys, true)\\r\\n      .to.not.have.any.deep.keys(keys);\\r\\n  }\\r\\n\\r\\n /**\\r\\n   * ### .doesNotHaveAllDeepKeys(object, [keys], [message])\\r\\n   *\\r\\n   * Asserts that `object` does not have at least one of the `keys` provided.\\r\\n   * Since Sets and Maps can have objects as keys you can use this assertion to perform\\r\\n   * a deep comparison.\\r\\n   * You can also provide a single object instead of a `keys` array and its keys\\r\\n   * will be used as the expected set of keys.\\r\\n   *\\r\\n   *     assert.doesNotHaveAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {thisDoesNot: 'exist'});\\r\\n   *     assert.doesNotHaveAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{twenty: 'twenty'}, {one: 'one'}]);\\r\\n   *     assert.doesNotHaveAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {twenty: 'twenty'});\\r\\n   *     assert.doesNotHaveAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {fifty: 'fifty'}]);\\r\\n   *\\r\\n   * @name doesNotHaveAllDeepKeys\\r\\n   * @param {Mixed} object\\r\\n   * @param {Array|Object} keys\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.doesNotHaveAllDeepKeys = function (obj, keys, msg) {\\r\\n    new Assertion(obj, msg, assert.doesNotHaveAllDeepKeys, true)\\r\\n      .to.not.have.all.deep.keys(keys);\\r\\n  }\\r\\n\\r\\n /**\\r\\n   * ### .throws(fn, [errorLike/string/regexp], [string/regexp], [message])\\r\\n   *\\r\\n   * If `errorLike` is an `Error` constructor, asserts that `fn` will throw an error that is an\\r\\n   * instance of `errorLike`.\\r\\n   * If `errorLike` is an `Error` instance, asserts that the error thrown is the same\\r\\n   * instance as `errorLike`.\\r\\n   * If `errMsgMatcher` is provided, it also asserts that the error thrown will have a\\r\\n   * message matching `errMsgMatcher`.\\r\\n   *\\r\\n   *     assert.throws(fn, 'Error thrown must have this msg');\\r\\n   *     assert.throws(fn, /Error thrown must have a msg that matches this/);\\r\\n   *     assert.throws(fn, ReferenceError);\\r\\n   *     assert.throws(fn, errorInstance);\\r\\n   *     assert.throws(fn, ReferenceError, 'Error thrown must be a ReferenceError and have this msg');\\r\\n   *     assert.throws(fn, errorInstance, 'Error thrown must be the same errorInstance and have this msg');\\r\\n   *     assert.throws(fn, ReferenceError, /Error thrown must be a ReferenceError and match this/);\\r\\n   *     assert.throws(fn, errorInstance, /Error thrown must be the same errorInstance and match this/);\\r\\n   *\\r\\n   * @name throws\\r\\n   * @alias throw\\r\\n   * @alias Throw\\r\\n   * @param {Function} fn\\r\\n   * @param {ErrorConstructor|Error} errorLike\\r\\n   * @param {RegExp|String} errMsgMatcher\\r\\n   * @param {String} message\\r\\n   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.throws = function (fn, errorLike, errMsgMatcher, msg) {\\r\\n    if ('string' === typeof errorLike || errorLike instanceof RegExp) {\\r\\n      errMsgMatcher = errorLike;\\r\\n      errorLike = null;\\r\\n    }\\r\\n\\r\\n    var assertErr = new Assertion(fn, msg, assert.throws, true)\\r\\n      .to.throw(errorLike, errMsgMatcher);\\r\\n    return flag(assertErr, 'object');\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .doesNotThrow(fn, [errorLike/string/regexp], [string/regexp], [message])\\r\\n   *\\r\\n   * If `errorLike` is an `Error` constructor, asserts that `fn` will _not_ throw an error that is an\\r\\n   * instance of `errorLike`.\\r\\n   * If `errorLike` is an `Error` instance, asserts that the error thrown is _not_ the same\\r\\n   * instance as `errorLike`.\\r\\n   * If `errMsgMatcher` is provided, it also asserts that the error thrown will _not_ have a\\r\\n   * message matching `errMsgMatcher`.\\r\\n   *\\r\\n   *     assert.doesNotThrow(fn, 'Any Error thrown must not have this message');\\r\\n   *     assert.doesNotThrow(fn, /Any Error thrown must not match this/);\\r\\n   *     assert.doesNotThrow(fn, Error);\\r\\n   *     assert.doesNotThrow(fn, errorInstance);\\r\\n   *     assert.doesNotThrow(fn, Error, 'Error must not have this message');\\r\\n   *     assert.doesNotThrow(fn, errorInstance, 'Error must not have this message');\\r\\n   *     assert.doesNotThrow(fn, Error, /Error must not match this/);\\r\\n   *     assert.doesNotThrow(fn, errorInstance, /Error must not match this/);\\r\\n   *\\r\\n   * @name doesNotThrow\\r\\n   * @param {Function} fn\\r\\n   * @param {ErrorConstructor} errorLike\\r\\n   * @param {RegExp|String} errMsgMatcher\\r\\n   * @param {String} message\\r\\n   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.doesNotThrow = function (fn, errorLike, errMsgMatcher, msg) {\\r\\n    if ('string' === typeof errorLike || errorLike instanceof RegExp) {\\r\\n      errMsgMatcher = errorLike;\\r\\n      errorLike = null;\\r\\n    }\\r\\n\\r\\n    new Assertion(fn, msg, assert.doesNotThrow, true)\\r\\n      .to.not.throw(errorLike, errMsgMatcher);\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .operator(val1, operator, val2, [message])\\r\\n   *\\r\\n   * Compares two values using `operator`.\\r\\n   *\\r\\n   *     assert.operator(1, '<', 2, 'everything is ok');\\r\\n   *     assert.operator(1, '>', 2, 'this will fail');\\r\\n   *\\r\\n   * @name operator\\r\\n   * @param {Mixed} val1\\r\\n   * @param {String} operator\\r\\n   * @param {Mixed} val2\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.operator = function (val, operator, val2, msg) {\\r\\n    var ok;\\r\\n    switch(operator) {\\r\\n      case '==':\\r\\n        ok = val == val2;\\r\\n        break;\\r\\n      case '===':\\r\\n        ok = val === val2;\\r\\n        break;\\r\\n      case '>':\\r\\n        ok = val > val2;\\r\\n        break;\\r\\n      case '>=':\\r\\n        ok = val >= val2;\\r\\n        break;\\r\\n      case '<':\\r\\n        ok = val < val2;\\r\\n        break;\\r\\n      case '<=':\\r\\n        ok = val <= val2;\\r\\n        break;\\r\\n      case '!=':\\r\\n        ok = val != val2;\\r\\n        break;\\r\\n      case '!==':\\r\\n        ok = val !== val2;\\r\\n        break;\\r\\n      default:\\r\\n        msg = msg ? msg + ': ' : msg;\\r\\n        throw new chai.AssertionError(\\r\\n          msg + 'Invalid operator \\\"' + operator + '\\\"',\\r\\n          undefined,\\r\\n          assert.operator\\r\\n        );\\r\\n    }\\r\\n    var test = new Assertion(ok, msg, assert.operator, true);\\r\\n    test.assert(\\r\\n        true === flag(test, 'object')\\r\\n      , 'expected ' + util.inspect(val) + ' to be ' + operator + ' ' + util.inspect(val2)\\r\\n      , 'expected ' + util.inspect(val) + ' to not be ' + operator + ' ' + util.inspect(val2) );\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .closeTo(actual, expected, delta, [message])\\r\\n   *\\r\\n   * Asserts that the target is equal `expected`, to within a +/- `delta` range.\\r\\n   *\\r\\n   *     assert.closeTo(1.5, 1, 0.5, 'numbers are close');\\r\\n   *\\r\\n   * @name closeTo\\r\\n   * @param {Number} actual\\r\\n   * @param {Number} expected\\r\\n   * @param {Number} delta\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.closeTo = function (act, exp, delta, msg) {\\r\\n    new Assertion(act, msg, assert.closeTo, true).to.be.closeTo(exp, delta);\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .approximately(actual, expected, delta, [message])\\r\\n   *\\r\\n   * Asserts that the target is equal `expected`, to within a +/- `delta` range.\\r\\n   *\\r\\n   *     assert.approximately(1.5, 1, 0.5, 'numbers are close');\\r\\n   *\\r\\n   * @name approximately\\r\\n   * @param {Number} actual\\r\\n   * @param {Number} expected\\r\\n   * @param {Number} delta\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.approximately = function (act, exp, delta, msg) {\\r\\n    new Assertion(act, msg, assert.approximately, true)\\r\\n      .to.be.approximately(exp, delta);\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .sameMembers(set1, set2, [message])\\r\\n   *\\r\\n   * Asserts that `set1` and `set2` have the same members in any order. Uses a\\r\\n   * strict equality check (===).\\r\\n   *\\r\\n   *     assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'same members');\\r\\n   *\\r\\n   * @name sameMembers\\r\\n   * @param {Array} set1\\r\\n   * @param {Array} set2\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.sameMembers = function (set1, set2, msg) {\\r\\n    new Assertion(set1, msg, assert.sameMembers, true)\\r\\n      .to.have.same.members(set2);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * ### .notSameMembers(set1, set2, [message])\\r\\n   *\\r\\n   * Asserts that `set1` and `set2` don't have the same members in any order.\\r\\n   * Uses a strict equality check (===).\\r\\n   *\\r\\n   *     assert.notSameMembers([ 1, 2, 3 ], [ 5, 1, 3 ], 'not same members');\\r\\n   *\\r\\n   * @name notSameMembers\\r\\n   * @param {Array} set1\\r\\n   * @param {Array} set2\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.notSameMembers = function (set1, set2, msg) {\\r\\n    new Assertion(set1, msg, assert.notSameMembers, true)\\r\\n      .to.not.have.same.members(set2);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * ### .sameDeepMembers(set1, set2, [message])\\r\\n   *\\r\\n   * Asserts that `set1` and `set2` have the same members in any order. Uses a\\r\\n   * deep equality check.\\r\\n   *\\r\\n   *     assert.sameDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [{ b: 2 }, { a: 1 }, { c: 3 }], 'same deep members');\\r\\n   *\\r\\n   * @name sameDeepMembers\\r\\n   * @param {Array} set1\\r\\n   * @param {Array} set2\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.sameDeepMembers = function (set1, set2, msg) {\\r\\n    new Assertion(set1, msg, assert.sameDeepMembers, true)\\r\\n      .to.have.same.deep.members(set2);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * ### .notSameDeepMembers(set1, set2, [message])\\r\\n   *\\r\\n   * Asserts that `set1` and `set2` don't have the same members in any order.\\r\\n   * Uses a deep equality check.\\r\\n   *\\r\\n   *     assert.notSameDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [{ b: 2 }, { a: 1 }, { f: 5 }], 'not same deep members');\\r\\n   *\\r\\n   * @name notSameDeepMembers\\r\\n   * @param {Array} set1\\r\\n   * @param {Array} set2\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.notSameDeepMembers = function (set1, set2, msg) {\\r\\n    new Assertion(set1, msg, assert.notSameDeepMembers, true)\\r\\n      .to.not.have.same.deep.members(set2);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * ### .sameOrderedMembers(set1, set2, [message])\\r\\n   *\\r\\n   * Asserts that `set1` and `set2` have the same members in the same order.\\r\\n   * Uses a strict equality check (===).\\r\\n   *\\r\\n   *     assert.sameOrderedMembers([ 1, 2, 3 ], [ 1, 2, 3 ], 'same ordered members');\\r\\n   *\\r\\n   * @name sameOrderedMembers\\r\\n   * @param {Array} set1\\r\\n   * @param {Array} set2\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.sameOrderedMembers = function (set1, set2, msg) {\\r\\n    new Assertion(set1, msg, assert.sameOrderedMembers, true)\\r\\n      .to.have.same.ordered.members(set2);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * ### .notSameOrderedMembers(set1, set2, [message])\\r\\n   *\\r\\n   * Asserts that `set1` and `set2` don't have the same members in the same\\r\\n   * order. Uses a strict equality check (===).\\r\\n   *\\r\\n   *     assert.notSameOrderedMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'not same ordered members');\\r\\n   *\\r\\n   * @name notSameOrderedMembers\\r\\n   * @param {Array} set1\\r\\n   * @param {Array} set2\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.notSameOrderedMembers = function (set1, set2, msg) {\\r\\n    new Assertion(set1, msg, assert.notSameOrderedMembers, true)\\r\\n      .to.not.have.same.ordered.members(set2);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * ### .sameDeepOrderedMembers(set1, set2, [message])\\r\\n   *\\r\\n   * Asserts that `set1` and `set2` have the same members in the same order.\\r\\n   * Uses a deep equality check.\\r\\n   *\\r\\n   * assert.sameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 }, { c: 3 } ], 'same deep ordered members');\\r\\n   *\\r\\n   * @name sameDeepOrderedMembers\\r\\n   * @param {Array} set1\\r\\n   * @param {Array} set2\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.sameDeepOrderedMembers = function (set1, set2, msg) {\\r\\n    new Assertion(set1, msg, assert.sameDeepOrderedMembers, true)\\r\\n      .to.have.same.deep.ordered.members(set2);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * ### .notSameDeepOrderedMembers(set1, set2, [message])\\r\\n   *\\r\\n   * Asserts that `set1` and `set2` don't have the same members in the same\\r\\n   * order. Uses a deep equality check.\\r\\n   *\\r\\n   * assert.notSameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 }, { z: 5 } ], 'not same deep ordered members');\\r\\n   * assert.notSameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 }, { c: 3 } ], 'not same deep ordered members');\\r\\n   *\\r\\n   * @name notSameDeepOrderedMembers\\r\\n   * @param {Array} set1\\r\\n   * @param {Array} set2\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.notSameDeepOrderedMembers = function (set1, set2, msg) {\\r\\n    new Assertion(set1, msg, assert.notSameDeepOrderedMembers, true)\\r\\n      .to.not.have.same.deep.ordered.members(set2);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * ### .includeMembers(superset, subset, [message])\\r\\n   *\\r\\n   * Asserts that `subset` is included in `superset` in any order. Uses a\\r\\n   * strict equality check (===). Duplicates are ignored.\\r\\n   *\\r\\n   *     assert.includeMembers([ 1, 2, 3 ], [ 2, 1, 2 ], 'include members');\\r\\n   *\\r\\n   * @name includeMembers\\r\\n   * @param {Array} superset\\r\\n   * @param {Array} subset\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.includeMembers = function (superset, subset, msg) {\\r\\n    new Assertion(superset, msg, assert.includeMembers, true)\\r\\n      .to.include.members(subset);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * ### .notIncludeMembers(superset, subset, [message])\\r\\n   *\\r\\n   * Asserts that `subset` isn't included in `superset` in any order. Uses a\\r\\n   * strict equality check (===). Duplicates are ignored.\\r\\n   *\\r\\n   *     assert.notIncludeMembers([ 1, 2, 3 ], [ 5, 1 ], 'not include members');\\r\\n   *\\r\\n   * @name notIncludeMembers\\r\\n   * @param {Array} superset\\r\\n   * @param {Array} subset\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.notIncludeMembers = function (superset, subset, msg) {\\r\\n    new Assertion(superset, msg, assert.notIncludeMembers, true)\\r\\n      .to.not.include.members(subset);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * ### .includeDeepMembers(superset, subset, [message])\\r\\n   *\\r\\n   * Asserts that `subset` is included in `superset` in any order. Uses a deep\\r\\n   * equality check. Duplicates are ignored.\\r\\n   *\\r\\n   *     assert.includeDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 }, { b: 2 } ], 'include deep members');\\r\\n   *\\r\\n   * @name includeDeepMembers\\r\\n   * @param {Array} superset\\r\\n   * @param {Array} subset\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.includeDeepMembers = function (superset, subset, msg) {\\r\\n    new Assertion(superset, msg, assert.includeDeepMembers, true)\\r\\n      .to.include.deep.members(subset);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * ### .notIncludeDeepMembers(superset, subset, [message])\\r\\n   *\\r\\n   * Asserts that `subset` isn't included in `superset` in any order. Uses a\\r\\n   * deep equality check. Duplicates are ignored.\\r\\n   *\\r\\n   *     assert.notIncludeDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { f: 5 } ], 'not include deep members');\\r\\n   *\\r\\n   * @name notIncludeDeepMembers\\r\\n   * @param {Array} superset\\r\\n   * @param {Array} subset\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.notIncludeDeepMembers = function (superset, subset, msg) {\\r\\n    new Assertion(superset, msg, assert.notIncludeDeepMembers, true)\\r\\n      .to.not.include.deep.members(subset);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * ### .includeOrderedMembers(superset, subset, [message])\\r\\n   *\\r\\n   * Asserts that `subset` is included in `superset` in the same order\\r\\n   * beginning with the first element in `superset`. Uses a strict equality\\r\\n   * check (===).\\r\\n   *\\r\\n   *     assert.includeOrderedMembers([ 1, 2, 3 ], [ 1, 2 ], 'include ordered members');\\r\\n   *\\r\\n   * @name includeOrderedMembers\\r\\n   * @param {Array} superset\\r\\n   * @param {Array} subset\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.includeOrderedMembers = function (superset, subset, msg) {\\r\\n    new Assertion(superset, msg, assert.includeOrderedMembers, true)\\r\\n      .to.include.ordered.members(subset);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * ### .notIncludeOrderedMembers(superset, subset, [message])\\r\\n   *\\r\\n   * Asserts that `subset` isn't included in `superset` in the same order\\r\\n   * beginning with the first element in `superset`. Uses a strict equality\\r\\n   * check (===).\\r\\n   *\\r\\n   *     assert.notIncludeOrderedMembers([ 1, 2, 3 ], [ 2, 1 ], 'not include ordered members');\\r\\n   *     assert.notIncludeOrderedMembers([ 1, 2, 3 ], [ 2, 3 ], 'not include ordered members');\\r\\n   *\\r\\n   * @name notIncludeOrderedMembers\\r\\n   * @param {Array} superset\\r\\n   * @param {Array} subset\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.notIncludeOrderedMembers = function (superset, subset, msg) {\\r\\n    new Assertion(superset, msg, assert.notIncludeOrderedMembers, true)\\r\\n      .to.not.include.ordered.members(subset);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * ### .includeDeepOrderedMembers(superset, subset, [message])\\r\\n   *\\r\\n   * Asserts that `subset` is included in `superset` in the same order\\r\\n   * beginning with the first element in `superset`. Uses a deep equality\\r\\n   * check.\\r\\n   *\\r\\n   *     assert.includeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 } ], 'include deep ordered members');\\r\\n   *\\r\\n   * @name includeDeepOrderedMembers\\r\\n   * @param {Array} superset\\r\\n   * @param {Array} subset\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.includeDeepOrderedMembers = function (superset, subset, msg) {\\r\\n    new Assertion(superset, msg, assert.includeDeepOrderedMembers, true)\\r\\n      .to.include.deep.ordered.members(subset);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * ### .notIncludeDeepOrderedMembers(superset, subset, [message])\\r\\n   *\\r\\n   * Asserts that `subset` isn't included in `superset` in the same order\\r\\n   * beginning with the first element in `superset`. Uses a deep equality\\r\\n   * check.\\r\\n   *\\r\\n   *     assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { f: 5 } ], 'not include deep ordered members');\\r\\n   *     assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 } ], 'not include deep ordered members');\\r\\n   *     assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { c: 3 } ], 'not include deep ordered members');\\r\\n   *\\r\\n   * @name notIncludeDeepOrderedMembers\\r\\n   * @param {Array} superset\\r\\n   * @param {Array} subset\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.notIncludeDeepOrderedMembers = function (superset, subset, msg) {\\r\\n    new Assertion(superset, msg, assert.notIncludeDeepOrderedMembers, true)\\r\\n      .to.not.include.deep.ordered.members(subset);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * ### .oneOf(inList, list, [message])\\r\\n   *\\r\\n   * Asserts that non-object, non-array value `inList` appears in the flat array `list`.\\r\\n   *\\r\\n   *     assert.oneOf(1, [ 2, 1 ], 'Not found in list');\\r\\n   *\\r\\n   * @name oneOf\\r\\n   * @param {*} inList\\r\\n   * @param {Array<*>} list\\r\\n   * @param {String} message\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.oneOf = function (inList, list, msg) {\\r\\n    new Assertion(inList, msg, assert.oneOf, true).to.be.oneOf(list);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * ### .changes(function, object, property, [message])\\r\\n   *\\r\\n   * Asserts that a function changes the value of a property.\\r\\n   *\\r\\n   *     var obj = { val: 10 };\\r\\n   *     var fn = function() { obj.val = 22 };\\r\\n   *     assert.changes(fn, obj, 'val');\\r\\n   *\\r\\n   * @name changes\\r\\n   * @param {Function} modifier function\\r\\n   * @param {Object} object or getter function\\r\\n   * @param {String} property name _optional_\\r\\n   * @param {String} message _optional_\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.changes = function (fn, obj, prop, msg) {\\r\\n    if (arguments.length === 3 && typeof obj === 'function') {\\r\\n      msg = prop;\\r\\n      prop = null;\\r\\n    }\\r\\n\\r\\n    new Assertion(fn, msg, assert.changes, true).to.change(obj, prop);\\r\\n  }\\r\\n\\r\\n   /**\\r\\n   * ### .changesBy(function, object, property, delta, [message])\\r\\n   *\\r\\n   * Asserts that a function changes the value of a property by an amount (delta).\\r\\n   *\\r\\n   *     var obj = { val: 10 };\\r\\n   *     var fn = function() { obj.val += 2 };\\r\\n   *     assert.changesBy(fn, obj, 'val', 2);\\r\\n   *\\r\\n   * @name changesBy\\r\\n   * @param {Function} modifier function\\r\\n   * @param {Object} object or getter function\\r\\n   * @param {String} property name _optional_\\r\\n   * @param {Number} change amount (delta)\\r\\n   * @param {String} message _optional_\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.changesBy = function (fn, obj, prop, delta, msg) {\\r\\n    if (arguments.length === 4 && typeof obj === 'function') {\\r\\n      var tmpMsg = delta;\\r\\n      delta = prop;\\r\\n      msg = tmpMsg;\\r\\n    } else if (arguments.length === 3) {\\r\\n      delta = prop;\\r\\n      prop = null;\\r\\n    }\\r\\n\\r\\n    new Assertion(fn, msg, assert.changesBy, true)\\r\\n      .to.change(obj, prop).by(delta);\\r\\n  }\\r\\n\\r\\n   /**\\r\\n   * ### .doesNotChange(function, object, property, [message])\\r\\n   *\\r\\n   * Asserts that a function does not change the value of a property.\\r\\n   *\\r\\n   *     var obj = { val: 10 };\\r\\n   *     var fn = function() { console.log('foo'); };\\r\\n   *     assert.doesNotChange(fn, obj, 'val');\\r\\n   *\\r\\n   * @name doesNotChange\\r\\n   * @param {Function} modifier function\\r\\n   * @param {Object} object or getter function\\r\\n   * @param {String} property name _optional_\\r\\n   * @param {String} message _optional_\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.doesNotChange = function (fn, obj, prop, msg) {\\r\\n    if (arguments.length === 3 && typeof obj === 'function') {\\r\\n      msg = prop;\\r\\n      prop = null;\\r\\n    }\\r\\n\\r\\n    return new Assertion(fn, msg, assert.doesNotChange, true)\\r\\n      .to.not.change(obj, prop);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * ### .changesButNotBy(function, object, property, delta, [message])\\r\\n   *\\r\\n   * Asserts that a function does not change the value of a property or of a function's return value by an amount (delta)\\r\\n   *\\r\\n   *     var obj = { val: 10 };\\r\\n   *     var fn = function() { obj.val += 10 };\\r\\n   *     assert.changesButNotBy(fn, obj, 'val', 5);\\r\\n   *\\r\\n   * @name changesButNotBy\\r\\n   * @param {Function} modifier function\\r\\n   * @param {Object} object or getter function\\r\\n   * @param {String} property name _optional_\\r\\n   * @param {Number} change amount (delta)\\r\\n   * @param {String} message _optional_\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.changesButNotBy = function (fn, obj, prop, delta, msg) {\\r\\n    if (arguments.length === 4 && typeof obj === 'function') {\\r\\n      var tmpMsg = delta;\\r\\n      delta = prop;\\r\\n      msg = tmpMsg;\\r\\n    } else if (arguments.length === 3) {\\r\\n      delta = prop;\\r\\n      prop = null;\\r\\n    }\\r\\n\\r\\n    new Assertion(fn, msg, assert.changesButNotBy, true)\\r\\n      .to.change(obj, prop).but.not.by(delta);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * ### .increases(function, object, property, [message])\\r\\n   *\\r\\n   * Asserts that a function increases a numeric object property.\\r\\n   *\\r\\n   *     var obj = { val: 10 };\\r\\n   *     var fn = function() { obj.val = 13 };\\r\\n   *     assert.increases(fn, obj, 'val');\\r\\n   *\\r\\n   * @name increases\\r\\n   * @param {Function} modifier function\\r\\n   * @param {Object} object or getter function\\r\\n   * @param {String} property name _optional_\\r\\n   * @param {String} message _optional_\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.increases = function (fn, obj, prop, msg) {\\r\\n    if (arguments.length === 3 && typeof obj === 'function') {\\r\\n      msg = prop;\\r\\n      prop = null;\\r\\n    }\\r\\n\\r\\n    return new Assertion(fn, msg, assert.increases, true)\\r\\n      .to.increase(obj, prop);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * ### .increasesBy(function, object, property, delta, [message])\\r\\n   *\\r\\n   * Asserts that a function increases a numeric object property or a function's return value by an amount (delta).\\r\\n   *\\r\\n   *     var obj = { val: 10 };\\r\\n   *     var fn = function() { obj.val += 10 };\\r\\n   *     assert.increasesBy(fn, obj, 'val', 10);\\r\\n   *\\r\\n   * @name increasesBy\\r\\n   * @param {Function} modifier function\\r\\n   * @param {Object} object or getter function\\r\\n   * @param {String} property name _optional_\\r\\n   * @param {Number} change amount (delta)\\r\\n   * @param {String} message _optional_\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.increasesBy = function (fn, obj, prop, delta, msg) {\\r\\n    if (arguments.length === 4 && typeof obj === 'function') {\\r\\n      var tmpMsg = delta;\\r\\n      delta = prop;\\r\\n      msg = tmpMsg;\\r\\n    } else if (arguments.length === 3) {\\r\\n      delta = prop;\\r\\n      prop = null;\\r\\n    }\\r\\n\\r\\n    new Assertion(fn, msg, assert.increasesBy, true)\\r\\n      .to.increase(obj, prop).by(delta);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * ### .doesNotIncrease(function, object, property, [message])\\r\\n   *\\r\\n   * Asserts that a function does not increase a numeric object property.\\r\\n   *\\r\\n   *     var obj = { val: 10 };\\r\\n   *     var fn = function() { obj.val = 8 };\\r\\n   *     assert.doesNotIncrease(fn, obj, 'val');\\r\\n   *\\r\\n   * @name doesNotIncrease\\r\\n   * @param {Function} modifier function\\r\\n   * @param {Object} object or getter function\\r\\n   * @param {String} property name _optional_\\r\\n   * @param {String} message _optional_\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.doesNotIncrease = function (fn, obj, prop, msg) {\\r\\n    if (arguments.length === 3 && typeof obj === 'function') {\\r\\n      msg = prop;\\r\\n      prop = null;\\r\\n    }\\r\\n\\r\\n    return new Assertion(fn, msg, assert.doesNotIncrease, true)\\r\\n      .to.not.increase(obj, prop);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * ### .increasesButNotBy(function, object, property, [message])\\r\\n   *\\r\\n   * Asserts that a function does not increase a numeric object property or function's return value by an amount (delta).\\r\\n   *\\r\\n   *     var obj = { val: 10 };\\r\\n   *     var fn = function() { obj.val = 15 };\\r\\n   *     assert.increasesButNotBy(fn, obj, 'val', 10);\\r\\n   *\\r\\n   * @name increasesButNotBy\\r\\n   * @param {Function} modifier function\\r\\n   * @param {Object} object or getter function\\r\\n   * @param {String} property name _optional_\\r\\n   * @param {Number} change amount (delta)\\r\\n   * @param {String} message _optional_\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.increasesButNotBy = function (fn, obj, prop, delta, msg) {\\r\\n    if (arguments.length === 4 && typeof obj === 'function') {\\r\\n      var tmpMsg = delta;\\r\\n      delta = prop;\\r\\n      msg = tmpMsg;\\r\\n    } else if (arguments.length === 3) {\\r\\n      delta = prop;\\r\\n      prop = null;\\r\\n    }\\r\\n\\r\\n    new Assertion(fn, msg, assert.increasesButNotBy, true)\\r\\n      .to.increase(obj, prop).but.not.by(delta);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * ### .decreases(function, object, property, [message])\\r\\n   *\\r\\n   * Asserts that a function decreases a numeric object property.\\r\\n   *\\r\\n   *     var obj = { val: 10 };\\r\\n   *     var fn = function() { obj.val = 5 };\\r\\n   *     assert.decreases(fn, obj, 'val');\\r\\n   *\\r\\n   * @name decreases\\r\\n   * @param {Function} modifier function\\r\\n   * @param {Object} object or getter function\\r\\n   * @param {String} property name _optional_\\r\\n   * @param {String} message _optional_\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.decreases = function (fn, obj, prop, msg) {\\r\\n    if (arguments.length === 3 && typeof obj === 'function') {\\r\\n      msg = prop;\\r\\n      prop = null;\\r\\n    }\\r\\n\\r\\n    return new Assertion(fn, msg, assert.decreases, true)\\r\\n      .to.decrease(obj, prop);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * ### .decreasesBy(function, object, property, delta, [message])\\r\\n   *\\r\\n   * Asserts that a function decreases a numeric object property or a function's return value by an amount (delta)\\r\\n   *\\r\\n   *     var obj = { val: 10 };\\r\\n   *     var fn = function() { obj.val -= 5 };\\r\\n   *     assert.decreasesBy(fn, obj, 'val', 5);\\r\\n   *\\r\\n   * @name decreasesBy\\r\\n   * @param {Function} modifier function\\r\\n   * @param {Object} object or getter function\\r\\n   * @param {String} property name _optional_\\r\\n   * @param {Number} change amount (delta)\\r\\n   * @param {String} message _optional_\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.decreasesBy = function (fn, obj, prop, delta, msg) {\\r\\n    if (arguments.length === 4 && typeof obj === 'function') {\\r\\n      var tmpMsg = delta;\\r\\n      delta = prop;\\r\\n      msg = tmpMsg;\\r\\n    } else if (arguments.length === 3) {\\r\\n      delta = prop;\\r\\n      prop = null;\\r\\n    }\\r\\n\\r\\n    new Assertion(fn, msg, assert.decreasesBy, true)\\r\\n      .to.decrease(obj, prop).by(delta);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * ### .doesNotDecrease(function, object, property, [message])\\r\\n   *\\r\\n   * Asserts that a function does not decreases a numeric object property.\\r\\n   *\\r\\n   *     var obj = { val: 10 };\\r\\n   *     var fn = function() { obj.val = 15 };\\r\\n   *     assert.doesNotDecrease(fn, obj, 'val');\\r\\n   *\\r\\n   * @name doesNotDecrease\\r\\n   * @param {Function} modifier function\\r\\n   * @param {Object} object or getter function\\r\\n   * @param {String} property name _optional_\\r\\n   * @param {String} message _optional_\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.doesNotDecrease = function (fn, obj, prop, msg) {\\r\\n    if (arguments.length === 3 && typeof obj === 'function') {\\r\\n      msg = prop;\\r\\n      prop = null;\\r\\n    }\\r\\n\\r\\n    return new Assertion(fn, msg, assert.doesNotDecrease, true)\\r\\n      .to.not.decrease(obj, prop);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * ### .doesNotDecreaseBy(function, object, property, delta, [message])\\r\\n   *\\r\\n   * Asserts that a function does not decreases a numeric object property or a function's return value by an amount (delta)\\r\\n   *\\r\\n   *     var obj = { val: 10 };\\r\\n   *     var fn = function() { obj.val = 5 };\\r\\n   *     assert.doesNotDecreaseBy(fn, obj, 'val', 1);\\r\\n   *\\r\\n   * @name doesNotDecrease\\r\\n   * @param {Function} modifier function\\r\\n   * @param {Object} object or getter function\\r\\n   * @param {String} property name _optional_\\r\\n   * @param {Number} change amount (delta)\\r\\n   * @param {String} message _optional_\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.doesNotDecreaseBy = function (fn, obj, prop, delta, msg) {\\r\\n    if (arguments.length === 4 && typeof obj === 'function') {\\r\\n      var tmpMsg = delta;\\r\\n      delta = prop;\\r\\n      msg = tmpMsg;\\r\\n    } else if (arguments.length === 3) {\\r\\n      delta = prop;\\r\\n      prop = null;\\r\\n    }\\r\\n\\r\\n    return new Assertion(fn, msg, assert.doesNotDecreaseBy, true)\\r\\n      .to.not.decrease(obj, prop).by(delta);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * ### .decreasesButNotBy(function, object, property, delta, [message])\\r\\n   *\\r\\n   * Asserts that a function does not decreases a numeric object property or a function's return value by an amount (delta)\\r\\n   *\\r\\n   *     var obj = { val: 10 };\\r\\n   *     var fn = function() { obj.val = 5 };\\r\\n   *     assert.decreasesButNotBy(fn, obj, 'val', 1);\\r\\n   *\\r\\n   * @name decreasesButNotBy\\r\\n   * @param {Function} modifier function\\r\\n   * @param {Object} object or getter function\\r\\n   * @param {String} property name _optional_\\r\\n   * @param {Number} change amount (delta)\\r\\n   * @param {String} message _optional_\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.decreasesButNotBy = function (fn, obj, prop, delta, msg) {\\r\\n    if (arguments.length === 4 && typeof obj === 'function') {\\r\\n      var tmpMsg = delta;\\r\\n      delta = prop;\\r\\n      msg = tmpMsg;\\r\\n    } else if (arguments.length === 3) {\\r\\n      delta = prop;\\r\\n      prop = null;\\r\\n    }\\r\\n\\r\\n    new Assertion(fn, msg, assert.decreasesButNotBy, true)\\r\\n      .to.decrease(obj, prop).but.not.by(delta);\\r\\n  }\\r\\n\\r\\n  /*!\\r\\n   * ### .ifError(object)\\r\\n   *\\r\\n   * Asserts if value is not a false value, and throws if it is a true value.\\r\\n   * This is added to allow for chai to be a drop-in replacement for Node's\\r\\n   * assert class.\\r\\n   *\\r\\n   *     var err = new Error('I am a custom error');\\r\\n   *     assert.ifError(err); // Rethrows err!\\r\\n   *\\r\\n   * @name ifError\\r\\n   * @param {Object} object\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.ifError = function (val) {\\r\\n    if (val) {\\r\\n      throw(val);\\r\\n    }\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .isExtensible(object)\\r\\n   *\\r\\n   * Asserts that `object` is extensible (can have new properties added to it).\\r\\n   *\\r\\n   *     assert.isExtensible({});\\r\\n   *\\r\\n   * @name isExtensible\\r\\n   * @alias extensible\\r\\n   * @param {Object} object\\r\\n   * @param {String} message _optional_\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.isExtensible = function (obj, msg) {\\r\\n    new Assertion(obj, msg, assert.isExtensible, true).to.be.extensible;\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .isNotExtensible(object)\\r\\n   *\\r\\n   * Asserts that `object` is _not_ extensible.\\r\\n   *\\r\\n   *     var nonExtensibleObject = Object.preventExtensions({});\\r\\n   *     var sealedObject = Object.seal({});\\r\\n   *     var frozenObject = Object.freeze({});\\r\\n   *\\r\\n   *     assert.isNotExtensible(nonExtensibleObject);\\r\\n   *     assert.isNotExtensible(sealedObject);\\r\\n   *     assert.isNotExtensible(frozenObject);\\r\\n   *\\r\\n   * @name isNotExtensible\\r\\n   * @alias notExtensible\\r\\n   * @param {Object} object\\r\\n   * @param {String} message _optional_\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.isNotExtensible = function (obj, msg) {\\r\\n    new Assertion(obj, msg, assert.isNotExtensible, true).to.not.be.extensible;\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .isSealed(object)\\r\\n   *\\r\\n   * Asserts that `object` is sealed (cannot have new properties added to it\\r\\n   * and its existing properties cannot be removed).\\r\\n   *\\r\\n   *     var sealedObject = Object.seal({});\\r\\n   *     var frozenObject = Object.seal({});\\r\\n   *\\r\\n   *     assert.isSealed(sealedObject);\\r\\n   *     assert.isSealed(frozenObject);\\r\\n   *\\r\\n   * @name isSealed\\r\\n   * @alias sealed\\r\\n   * @param {Object} object\\r\\n   * @param {String} message _optional_\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.isSealed = function (obj, msg) {\\r\\n    new Assertion(obj, msg, assert.isSealed, true).to.be.sealed;\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .isNotSealed(object)\\r\\n   *\\r\\n   * Asserts that `object` is _not_ sealed.\\r\\n   *\\r\\n   *     assert.isNotSealed({});\\r\\n   *\\r\\n   * @name isNotSealed\\r\\n   * @alias notSealed\\r\\n   * @param {Object} object\\r\\n   * @param {String} message _optional_\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.isNotSealed = function (obj, msg) {\\r\\n    new Assertion(obj, msg, assert.isNotSealed, true).to.not.be.sealed;\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .isFrozen(object)\\r\\n   *\\r\\n   * Asserts that `object` is frozen (cannot have new properties added to it\\r\\n   * and its existing properties cannot be modified).\\r\\n   *\\r\\n   *     var frozenObject = Object.freeze({});\\r\\n   *     assert.frozen(frozenObject);\\r\\n   *\\r\\n   * @name isFrozen\\r\\n   * @alias frozen\\r\\n   * @param {Object} object\\r\\n   * @param {String} message _optional_\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.isFrozen = function (obj, msg) {\\r\\n    new Assertion(obj, msg, assert.isFrozen, true).to.be.frozen;\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .isNotFrozen(object)\\r\\n   *\\r\\n   * Asserts that `object` is _not_ frozen.\\r\\n   *\\r\\n   *     assert.isNotFrozen({});\\r\\n   *\\r\\n   * @name isNotFrozen\\r\\n   * @alias notFrozen\\r\\n   * @param {Object} object\\r\\n   * @param {String} message _optional_\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.isNotFrozen = function (obj, msg) {\\r\\n    new Assertion(obj, msg, assert.isNotFrozen, true).to.not.be.frozen;\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .isEmpty(target)\\r\\n   *\\r\\n   * Asserts that the target does not contain any values.\\r\\n   * For arrays and strings, it checks the `length` property.\\r\\n   * For `Map` and `Set` instances, it checks the `size` property.\\r\\n   * For non-function objects, it gets the count of own\\r\\n   * enumerable string keys.\\r\\n   *\\r\\n   *     assert.isEmpty([]);\\r\\n   *     assert.isEmpty('');\\r\\n   *     assert.isEmpty(new Map);\\r\\n   *     assert.isEmpty({});\\r\\n   *\\r\\n   * @name isEmpty\\r\\n   * @alias empty\\r\\n   * @param {Object|Array|String|Map|Set} target\\r\\n   * @param {String} message _optional_\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.isEmpty = function(val, msg) {\\r\\n    new Assertion(val, msg, assert.isEmpty, true).to.be.empty;\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .isNotEmpty(target)\\r\\n   *\\r\\n   * Asserts that the target contains values.\\r\\n   * For arrays and strings, it checks the `length` property.\\r\\n   * For `Map` and `Set` instances, it checks the `size` property.\\r\\n   * For non-function objects, it gets the count of own\\r\\n   * enumerable string keys.\\r\\n   *\\r\\n   *     assert.isNotEmpty([1, 2]);\\r\\n   *     assert.isNotEmpty('34');\\r\\n   *     assert.isNotEmpty(new Set([5, 6]));\\r\\n   *     assert.isNotEmpty({ key: 7 });\\r\\n   *\\r\\n   * @name isNotEmpty\\r\\n   * @alias notEmpty\\r\\n   * @param {Object|Array|String|Map|Set} target\\r\\n   * @param {String} message _optional_\\r\\n   * @namespace Assert\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  assert.isNotEmpty = function(val, msg) {\\r\\n    new Assertion(val, msg, assert.isNotEmpty, true).to.not.be.empty;\\r\\n  };\\r\\n\\r\\n  /*!\\r\\n   * Aliases.\\r\\n   */\\r\\n\\r\\n  (function alias(name, as){\\r\\n    assert[as] = assert[name];\\r\\n    return alias;\\r\\n  })\\r\\n  ('isOk', 'ok')\\r\\n  ('isNotOk', 'notOk')\\r\\n  ('throws', 'throw')\\r\\n  ('throws', 'Throw')\\r\\n  ('isExtensible', 'extensible')\\r\\n  ('isNotExtensible', 'notExtensible')\\r\\n  ('isSealed', 'sealed')\\r\\n  ('isNotSealed', 'notSealed')\\r\\n  ('isFrozen', 'frozen')\\r\\n  ('isNotFrozen', 'notFrozen')\\r\\n  ('isEmpty', 'empty')\\r\\n  ('isNotEmpty', 'notEmpty');\\r\\n};\\r\\n\\n\\n//# sourceURL=webpack:///./node_modules/chai/lib/chai/interface/assert.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/chai/lib/chai/interface/expect.js\":\n/*!********************************************************!*\\\n  !*** ./node_modules/chai/lib/chai/interface/expect.js ***!\n  \\********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\neval(\"/*!\\r\\n * chai\\r\\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\\r\\n * MIT Licensed\\r\\n */\\r\\n\\r\\nmodule.exports = function (chai, util) {\\r\\n  chai.expect = function (val, message) {\\r\\n    return new chai.Assertion(val, message);\\r\\n  };\\r\\n\\r\\n  /**\\r\\n   * ### .fail([message])\\r\\n   * ### .fail(actual, expected, [message], [operator])\\r\\n   *\\r\\n   * Throw a failure.\\r\\n   *\\r\\n   *     expect.fail();\\r\\n   *     expect.fail(\\\"custom error message\\\");\\r\\n   *     expect.fail(1, 2);\\r\\n   *     expect.fail(1, 2, \\\"custom error message\\\");\\r\\n   *     expect.fail(1, 2, \\\"custom error message\\\", \\\">\\\");\\r\\n   *     expect.fail(1, 2, undefined, \\\">\\\");\\r\\n   *\\r\\n   * @name fail\\r\\n   * @param {Mixed} actual\\r\\n   * @param {Mixed} expected\\r\\n   * @param {String} message\\r\\n   * @param {String} operator\\r\\n   * @namespace BDD\\r\\n   * @api public\\r\\n   */\\r\\n\\r\\n  chai.expect.fail = function (actual, expected, message, operator) {\\r\\n    if (arguments.length < 2) {\\r\\n        message = actual;\\r\\n        actual = undefined;\\r\\n    }\\r\\n\\r\\n    message = message || 'expect.fail()';\\r\\n    throw new chai.AssertionError(message, {\\r\\n        actual: actual\\r\\n      , expected: expected\\r\\n      , operator: operator\\r\\n    }, chai.expect.fail);\\r\\n  };\\r\\n};\\r\\n\\n\\n//# sourceURL=webpack:///./node_modules/chai/lib/chai/interface/expect.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/chai/lib/chai/interface/should.js\":\n/*!********************************************************!*\\\n  !*** ./node_modules/chai/lib/chai/interface/should.js ***!\n  \\********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\neval(\"/*!\\r\\n * chai\\r\\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\\r\\n * MIT Licensed\\r\\n */\\r\\n\\r\\nmodule.exports = function (chai, util) {\\r\\n  var Assertion = chai.Assertion;\\r\\n\\r\\n  function loadShould () {\\r\\n    // explicitly define this method as function as to have it's name to include as `ssfi`\\r\\n    function shouldGetter() {\\r\\n      if (this instanceof String\\r\\n          || this instanceof Number\\r\\n          || this instanceof Boolean\\r\\n          || typeof Symbol === 'function' && this instanceof Symbol) {\\r\\n        return new Assertion(this.valueOf(), null, shouldGetter);\\r\\n      }\\r\\n      return new Assertion(this, null, shouldGetter);\\r\\n    }\\r\\n    function shouldSetter(value) {\\r\\n      // See https://github.com/chaijs/chai/issues/86: this makes\\r\\n      // `whatever.should = someValue` actually set `someValue`, which is\\r\\n      // especially useful for `global.should = require('chai').should()`.\\r\\n      //\\r\\n      // Note that we have to use [[DefineProperty]] instead of [[Put]]\\r\\n      // since otherwise we would trigger this very setter!\\r\\n      Object.defineProperty(this, 'should', {\\r\\n        value: value,\\r\\n        enumerable: true,\\r\\n        configurable: true,\\r\\n        writable: true\\r\\n      });\\r\\n    }\\r\\n    // modify Object.prototype to have `should`\\r\\n    Object.defineProperty(Object.prototype, 'should', {\\r\\n      set: shouldSetter\\r\\n      , get: shouldGetter\\r\\n      , configurable: true\\r\\n    });\\r\\n\\r\\n    var should = {};\\r\\n\\r\\n    /**\\r\\n     * ### .fail([message])\\r\\n     * ### .fail(actual, expected, [message], [operator])\\r\\n     *\\r\\n     * Throw a failure.\\r\\n     *\\r\\n     *     should.fail();\\r\\n     *     should.fail(\\\"custom error message\\\");\\r\\n     *     should.fail(1, 2);\\r\\n     *     should.fail(1, 2, \\\"custom error message\\\");\\r\\n     *     should.fail(1, 2, \\\"custom error message\\\", \\\">\\\");\\r\\n     *     should.fail(1, 2, undefined, \\\">\\\");\\r\\n     *\\r\\n     *\\r\\n     * @name fail\\r\\n     * @param {Mixed} actual\\r\\n     * @param {Mixed} expected\\r\\n     * @param {String} message\\r\\n     * @param {String} operator\\r\\n     * @namespace BDD\\r\\n     * @api public\\r\\n     */\\r\\n\\r\\n    should.fail = function (actual, expected, message, operator) {\\r\\n      if (arguments.length < 2) {\\r\\n          message = actual;\\r\\n          actual = undefined;\\r\\n      }\\r\\n\\r\\n      message = message || 'should.fail()';\\r\\n      throw new chai.AssertionError(message, {\\r\\n          actual: actual\\r\\n        , expected: expected\\r\\n        , operator: operator\\r\\n      }, should.fail);\\r\\n    };\\r\\n\\r\\n    /**\\r\\n     * ### .equal(actual, expected, [message])\\r\\n     *\\r\\n     * Asserts non-strict equality (`==`) of `actual` and `expected`.\\r\\n     *\\r\\n     *     should.equal(3, '3', '== coerces values to strings');\\r\\n     *\\r\\n     * @name equal\\r\\n     * @param {Mixed} actual\\r\\n     * @param {Mixed} expected\\r\\n     * @param {String} message\\r\\n     * @namespace Should\\r\\n     * @api public\\r\\n     */\\r\\n\\r\\n    should.equal = function (val1, val2, msg) {\\r\\n      new Assertion(val1, msg).to.equal(val2);\\r\\n    };\\r\\n\\r\\n    /**\\r\\n     * ### .throw(function, [constructor/string/regexp], [string/regexp], [message])\\r\\n     *\\r\\n     * Asserts that `function` will throw an error that is an instance of\\r\\n     * `constructor`, or alternately that it will throw an error with message\\r\\n     * matching `regexp`.\\r\\n     *\\r\\n     *     should.throw(fn, 'function throws a reference error');\\r\\n     *     should.throw(fn, /function throws a reference error/);\\r\\n     *     should.throw(fn, ReferenceError);\\r\\n     *     should.throw(fn, ReferenceError, 'function throws a reference error');\\r\\n     *     should.throw(fn, ReferenceError, /function throws a reference error/);\\r\\n     *\\r\\n     * @name throw\\r\\n     * @alias Throw\\r\\n     * @param {Function} function\\r\\n     * @param {ErrorConstructor} constructor\\r\\n     * @param {RegExp} regexp\\r\\n     * @param {String} message\\r\\n     * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types\\r\\n     * @namespace Should\\r\\n     * @api public\\r\\n     */\\r\\n\\r\\n    should.Throw = function (fn, errt, errs, msg) {\\r\\n      new Assertion(fn, msg).to.Throw(errt, errs);\\r\\n    };\\r\\n\\r\\n    /**\\r\\n     * ### .exist\\r\\n     *\\r\\n     * Asserts that the target is neither `null` nor `undefined`.\\r\\n     *\\r\\n     *     var foo = 'hi';\\r\\n     *\\r\\n     *     should.exist(foo, 'foo exists');\\r\\n     *\\r\\n     * @name exist\\r\\n     * @namespace Should\\r\\n     * @api public\\r\\n     */\\r\\n\\r\\n    should.exist = function (val, msg) {\\r\\n      new Assertion(val, msg).to.exist;\\r\\n    }\\r\\n\\r\\n    // negation\\r\\n    should.not = {}\\r\\n\\r\\n    /**\\r\\n     * ### .not.equal(actual, expected, [message])\\r\\n     *\\r\\n     * Asserts non-strict inequality (`!=`) of `actual` and `expected`.\\r\\n     *\\r\\n     *     should.not.equal(3, 4, 'these numbers are not equal');\\r\\n     *\\r\\n     * @name not.equal\\r\\n     * @param {Mixed} actual\\r\\n     * @param {Mixed} expected\\r\\n     * @param {String} message\\r\\n     * @namespace Should\\r\\n     * @api public\\r\\n     */\\r\\n\\r\\n    should.not.equal = function (val1, val2, msg) {\\r\\n      new Assertion(val1, msg).to.not.equal(val2);\\r\\n    };\\r\\n\\r\\n    /**\\r\\n     * ### .throw(function, [constructor/regexp], [message])\\r\\n     *\\r\\n     * Asserts that `function` will _not_ throw an error that is an instance of\\r\\n     * `constructor`, or alternately that it will not throw an error with message\\r\\n     * matching `regexp`.\\r\\n     *\\r\\n     *     should.not.throw(fn, Error, 'function does not throw');\\r\\n     *\\r\\n     * @name not.throw\\r\\n     * @alias not.Throw\\r\\n     * @param {Function} function\\r\\n     * @param {ErrorConstructor} constructor\\r\\n     * @param {RegExp} regexp\\r\\n     * @param {String} message\\r\\n     * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types\\r\\n     * @namespace Should\\r\\n     * @api public\\r\\n     */\\r\\n\\r\\n    should.not.Throw = function (fn, errt, errs, msg) {\\r\\n      new Assertion(fn, msg).to.not.Throw(errt, errs);\\r\\n    };\\r\\n\\r\\n    /**\\r\\n     * ### .not.exist\\r\\n     *\\r\\n     * Asserts that the target is neither `null` nor `undefined`.\\r\\n     *\\r\\n     *     var bar = null;\\r\\n     *\\r\\n     *     should.not.exist(bar, 'bar does not exist');\\r\\n     *\\r\\n     * @name not.exist\\r\\n     * @namespace Should\\r\\n     * @api public\\r\\n     */\\r\\n\\r\\n    should.not.exist = function (val, msg) {\\r\\n      new Assertion(val, msg).to.not.exist;\\r\\n    }\\r\\n\\r\\n    should['throw'] = should['Throw'];\\r\\n    should.not['throw'] = should.not['Throw'];\\r\\n\\r\\n    return should;\\r\\n  };\\r\\n\\r\\n  chai.should = loadShould;\\r\\n  chai.Should = loadShould;\\r\\n};\\r\\n\\n\\n//# sourceURL=webpack:///./node_modules/chai/lib/chai/interface/should.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/chai/lib/chai/utils/addChainableMethod.js\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/chai/lib/chai/utils/addChainableMethod.js ***!\n  \\****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\neval(\"/*!\\r\\n * Chai - addChainingMethod utility\\r\\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\\r\\n * MIT Licensed\\r\\n */\\r\\n\\r\\n/*!\\r\\n * Module dependencies\\r\\n */\\r\\n\\r\\nvar addLengthGuard = __webpack_require__(/*! ./addLengthGuard */ \\\"./node_modules/chai/lib/chai/utils/addLengthGuard.js\\\");\\r\\nvar chai = __webpack_require__(/*! ../../chai */ \\\"./node_modules/chai/lib/chai.js\\\");\\r\\nvar flag = __webpack_require__(/*! ./flag */ \\\"./node_modules/chai/lib/chai/utils/flag.js\\\");\\r\\nvar proxify = __webpack_require__(/*! ./proxify */ \\\"./node_modules/chai/lib/chai/utils/proxify.js\\\");\\r\\nvar transferFlags = __webpack_require__(/*! ./transferFlags */ \\\"./node_modules/chai/lib/chai/utils/transferFlags.js\\\");\\r\\n\\r\\n/*!\\r\\n * Module variables\\r\\n */\\r\\n\\r\\n// Check whether `Object.setPrototypeOf` is supported\\r\\nvar canSetPrototype = typeof Object.setPrototypeOf === 'function';\\r\\n\\r\\n// Without `Object.setPrototypeOf` support, this module will need to add properties to a function.\\r\\n// However, some of functions' own props are not configurable and should be skipped.\\r\\nvar testFn = function() {};\\r\\nvar excludeNames = Object.getOwnPropertyNames(testFn).filter(function(name) {\\r\\n  var propDesc = Object.getOwnPropertyDescriptor(testFn, name);\\r\\n\\r\\n  // Note: PhantomJS 1.x includes `callee` as one of `testFn`'s own properties,\\r\\n  // but then returns `undefined` as the property descriptor for `callee`. As a\\r\\n  // workaround, we perform an otherwise unnecessary type-check for `propDesc`,\\r\\n  // and then filter it out if it's not an object as it should be.\\r\\n  if (typeof propDesc !== 'object')\\r\\n    return true;\\r\\n\\r\\n  return !propDesc.configurable;\\r\\n});\\r\\n\\r\\n// Cache `Function` properties\\r\\nvar call  = Function.prototype.call,\\r\\n    apply = Function.prototype.apply;\\r\\n\\r\\n/**\\r\\n * ### .addChainableMethod(ctx, name, method, chainingBehavior)\\r\\n *\\r\\n * Adds a method to an object, such that the method can also be chained.\\r\\n *\\r\\n *     utils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) {\\r\\n *       var obj = utils.flag(this, 'object');\\r\\n *       new chai.Assertion(obj).to.be.equal(str);\\r\\n *     });\\r\\n *\\r\\n * Can also be accessed directly from `chai.Assertion`.\\r\\n *\\r\\n *     chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);\\r\\n *\\r\\n * The result can then be used as both a method assertion, executing both `method` and\\r\\n * `chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.\\r\\n *\\r\\n *     expect(fooStr).to.be.foo('bar');\\r\\n *     expect(fooStr).to.be.foo.equal('foo');\\r\\n *\\r\\n * @param {Object} ctx object to which the method is added\\r\\n * @param {String} name of method to add\\r\\n * @param {Function} method function to be used for `name`, when called\\r\\n * @param {Function} chainingBehavior function to be called every time the property is accessed\\r\\n * @namespace Utils\\r\\n * @name addChainableMethod\\r\\n * @api public\\r\\n */\\r\\n\\r\\nmodule.exports = function addChainableMethod(ctx, name, method, chainingBehavior) {\\r\\n  if (typeof chainingBehavior !== 'function') {\\r\\n    chainingBehavior = function () { };\\r\\n  }\\r\\n\\r\\n  var chainableBehavior = {\\r\\n      method: method\\r\\n    , chainingBehavior: chainingBehavior\\r\\n  };\\r\\n\\r\\n  // save the methods so we can overwrite them later, if we need to.\\r\\n  if (!ctx.__methods) {\\r\\n    ctx.__methods = {};\\r\\n  }\\r\\n  ctx.__methods[name] = chainableBehavior;\\r\\n\\r\\n  Object.defineProperty(ctx, name,\\r\\n    { get: function chainableMethodGetter() {\\r\\n        chainableBehavior.chainingBehavior.call(this);\\r\\n\\r\\n        var chainableMethodWrapper = function () {\\r\\n          // Setting the `ssfi` flag to `chainableMethodWrapper` causes this\\r\\n          // function to be the starting point for removing implementation\\r\\n          // frames from the stack trace of a failed assertion.\\r\\n          //\\r\\n          // However, we only want to use this function as the starting point if\\r\\n          // the `lockSsfi` flag isn't set.\\r\\n          //\\r\\n          // If the `lockSsfi` flag is set, then this assertion is being\\r\\n          // invoked from inside of another assertion. In this case, the `ssfi`\\r\\n          // flag has already been set by the outer assertion.\\r\\n          //\\r\\n          // Note that overwriting a chainable method merely replaces the saved\\r\\n          // methods in `ctx.__methods` instead of completely replacing the\\r\\n          // overwritten assertion. Therefore, an overwriting assertion won't\\r\\n          // set the `ssfi` or `lockSsfi` flags.\\r\\n          if (!flag(this, 'lockSsfi')) {\\r\\n            flag(this, 'ssfi', chainableMethodWrapper);\\r\\n          }\\r\\n\\r\\n          var result = chainableBehavior.method.apply(this, arguments);\\r\\n          if (result !== undefined) {\\r\\n            return result;\\r\\n          }\\r\\n\\r\\n          var newAssertion = new chai.Assertion();\\r\\n          transferFlags(this, newAssertion);\\r\\n          return newAssertion;\\r\\n        };\\r\\n\\r\\n        addLengthGuard(chainableMethodWrapper, name, true);\\r\\n\\r\\n        // Use `Object.setPrototypeOf` if available\\r\\n        if (canSetPrototype) {\\r\\n          // Inherit all properties from the object by replacing the `Function` prototype\\r\\n          var prototype = Object.create(this);\\r\\n          // Restore the `call` and `apply` methods from `Function`\\r\\n          prototype.call = call;\\r\\n          prototype.apply = apply;\\r\\n          Object.setPrototypeOf(chainableMethodWrapper, prototype);\\r\\n        }\\r\\n        // Otherwise, redefine all properties (slow!)\\r\\n        else {\\r\\n          var asserterNames = Object.getOwnPropertyNames(ctx);\\r\\n          asserterNames.forEach(function (asserterName) {\\r\\n            if (excludeNames.indexOf(asserterName) !== -1) {\\r\\n              return;\\r\\n            }\\r\\n\\r\\n            var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);\\r\\n            Object.defineProperty(chainableMethodWrapper, asserterName, pd);\\r\\n          });\\r\\n        }\\r\\n\\r\\n        transferFlags(this, chainableMethodWrapper);\\r\\n        return proxify(chainableMethodWrapper);\\r\\n      }\\r\\n    , configurable: true\\r\\n  });\\r\\n};\\r\\n\\n\\n//# sourceURL=webpack:///./node_modules/chai/lib/chai/utils/addChainableMethod.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/chai/lib/chai/utils/addLengthGuard.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/chai/lib/chai/utils/addLengthGuard.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\neval(\"var fnLengthDesc = Object.getOwnPropertyDescriptor(function () {}, 'length');\\r\\n\\r\\n/*!\\r\\n * Chai - addLengthGuard utility\\r\\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\\r\\n * MIT Licensed\\r\\n */\\r\\n\\r\\n/**\\r\\n * ### .addLengthGuard(fn, assertionName, isChainable)\\r\\n *\\r\\n * Define `length` as a getter on the given uninvoked method assertion. The\\r\\n * getter acts as a guard against chaining `length` directly off of an uninvoked\\r\\n * method assertion, which is a problem because it references `function`'s\\r\\n * built-in `length` property instead of Chai's `length` assertion. When the\\r\\n * getter catches the user making this mistake, it throws an error with a\\r\\n * helpful message.\\r\\n *\\r\\n * There are two ways in which this mistake can be made. The first way is by\\r\\n * chaining the `length` assertion directly off of an uninvoked chainable\\r\\n * method. In this case, Chai suggests that the user use `lengthOf` instead. The\\r\\n * second way is by chaining the `length` assertion directly off of an uninvoked\\r\\n * non-chainable method. Non-chainable methods must be invoked prior to\\r\\n * chaining. In this case, Chai suggests that the user consult the docs for the\\r\\n * given assertion.\\r\\n *\\r\\n * If the `length` property of functions is unconfigurable, then return `fn`\\r\\n * without modification.\\r\\n *\\r\\n * Note that in ES6, the function's `length` property is configurable, so once\\r\\n * support for legacy environments is dropped, Chai's `length` property can\\r\\n * replace the built-in function's `length` property, and this length guard will\\r\\n * no longer be necessary. In the mean time, maintaining consistency across all\\r\\n * environments is the priority.\\r\\n *\\r\\n * @param {Function} fn\\r\\n * @param {String} assertionName\\r\\n * @param {Boolean} isChainable\\r\\n * @namespace Utils\\r\\n * @name addLengthGuard\\r\\n */\\r\\n\\r\\nmodule.exports = function addLengthGuard (fn, assertionName, isChainable) {\\r\\n  if (!fnLengthDesc.configurable) return fn;\\r\\n\\r\\n  Object.defineProperty(fn, 'length', {\\r\\n    get: function () {\\r\\n      if (isChainable) {\\r\\n        throw Error('Invalid Chai property: ' + assertionName + '.length. Due' +\\r\\n          ' to a compatibility issue, \\\"length\\\" cannot directly follow \\\"' +\\r\\n          assertionName + '\\\". Use \\\"' + assertionName + '.lengthOf\\\" instead.');\\r\\n      }\\r\\n\\r\\n      throw Error('Invalid Chai property: ' + assertionName + '.length. See' +\\r\\n        ' docs for proper usage of \\\"' + assertionName + '\\\".');\\r\\n    }\\r\\n  });\\r\\n\\r\\n  return fn;\\r\\n};\\r\\n\\n\\n//# sourceURL=webpack:///./node_modules/chai/lib/chai/utils/addLengthGuard.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/chai/lib/chai/utils/addMethod.js\":\n/*!*******************************************************!*\\\n  !*** ./node_modules/chai/lib/chai/utils/addMethod.js ***!\n  \\*******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\neval(\"/*!\\r\\n * Chai - addMethod utility\\r\\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\\r\\n * MIT Licensed\\r\\n */\\r\\n\\r\\nvar addLengthGuard = __webpack_require__(/*! ./addLengthGuard */ \\\"./node_modules/chai/lib/chai/utils/addLengthGuard.js\\\");\\r\\nvar chai = __webpack_require__(/*! ../../chai */ \\\"./node_modules/chai/lib/chai.js\\\");\\r\\nvar flag = __webpack_require__(/*! ./flag */ \\\"./node_modules/chai/lib/chai/utils/flag.js\\\");\\r\\nvar proxify = __webpack_require__(/*! ./proxify */ \\\"./node_modules/chai/lib/chai/utils/proxify.js\\\");\\r\\nvar transferFlags = __webpack_require__(/*! ./transferFlags */ \\\"./node_modules/chai/lib/chai/utils/transferFlags.js\\\");\\r\\n\\r\\n/**\\r\\n * ### .addMethod(ctx, name, method)\\r\\n *\\r\\n * Adds a method to the prototype of an object.\\r\\n *\\r\\n *     utils.addMethod(chai.Assertion.prototype, 'foo', function (str) {\\r\\n *       var obj = utils.flag(this, 'object');\\r\\n *       new chai.Assertion(obj).to.be.equal(str);\\r\\n *     });\\r\\n *\\r\\n * Can also be accessed directly from `chai.Assertion`.\\r\\n *\\r\\n *     chai.Assertion.addMethod('foo', fn);\\r\\n *\\r\\n * Then can be used as any other assertion.\\r\\n *\\r\\n *     expect(fooStr).to.be.foo('bar');\\r\\n *\\r\\n * @param {Object} ctx object to which the method is added\\r\\n * @param {String} name of method to add\\r\\n * @param {Function} method function to be used for name\\r\\n * @namespace Utils\\r\\n * @name addMethod\\r\\n * @api public\\r\\n */\\r\\n\\r\\nmodule.exports = function addMethod(ctx, name, method) {\\r\\n  var methodWrapper = function () {\\r\\n    // Setting the `ssfi` flag to `methodWrapper` causes this function to be the\\r\\n    // starting point for removing implementation frames from the stack trace of\\r\\n    // a failed assertion.\\r\\n    //\\r\\n    // However, we only want to use this function as the starting point if the\\r\\n    // `lockSsfi` flag isn't set.\\r\\n    //\\r\\n    // If the `lockSsfi` flag is set, then either this assertion has been\\r\\n    // overwritten by another assertion, or this assertion is being invoked from\\r\\n    // inside of another assertion. In the first case, the `ssfi` flag has\\r\\n    // already been set by the overwriting assertion. In the second case, the\\r\\n    // `ssfi` flag has already been set by the outer assertion.\\r\\n    if (!flag(this, 'lockSsfi')) {\\r\\n      flag(this, 'ssfi', methodWrapper);\\r\\n    }\\r\\n\\r\\n    var result = method.apply(this, arguments);\\r\\n    if (result !== undefined)\\r\\n      return result;\\r\\n\\r\\n    var newAssertion = new chai.Assertion();\\r\\n    transferFlags(this, newAssertion);\\r\\n    return newAssertion;\\r\\n  };\\r\\n\\r\\n  addLengthGuard(methodWrapper, name, false);\\r\\n  ctx[name] = proxify(methodWrapper, name);\\r\\n};\\r\\n\\n\\n//# sourceURL=webpack:///./node_modules/chai/lib/chai/utils/addMethod.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/chai/lib/chai/utils/addProperty.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/chai/lib/chai/utils/addProperty.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\neval(\"/*!\\r\\n * Chai - addProperty utility\\r\\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\\r\\n * MIT Licensed\\r\\n */\\r\\n\\r\\nvar chai = __webpack_require__(/*! ../../chai */ \\\"./node_modules/chai/lib/chai.js\\\");\\r\\nvar flag = __webpack_require__(/*! ./flag */ \\\"./node_modules/chai/lib/chai/utils/flag.js\\\");\\r\\nvar isProxyEnabled = __webpack_require__(/*! ./isProxyEnabled */ \\\"./node_modules/chai/lib/chai/utils/isProxyEnabled.js\\\");\\r\\nvar transferFlags = __webpack_require__(/*! ./transferFlags */ \\\"./node_modules/chai/lib/chai/utils/transferFlags.js\\\");\\r\\n\\r\\n/**\\r\\n * ### .addProperty(ctx, name, getter)\\r\\n *\\r\\n * Adds a property to the prototype of an object.\\r\\n *\\r\\n *     utils.addProperty(chai.Assertion.prototype, 'foo', function () {\\r\\n *       var obj = utils.flag(this, 'object');\\r\\n *       new chai.Assertion(obj).to.be.instanceof(Foo);\\r\\n *     });\\r\\n *\\r\\n * Can also be accessed directly from `chai.Assertion`.\\r\\n *\\r\\n *     chai.Assertion.addProperty('foo', fn);\\r\\n *\\r\\n * Then can be used as any other assertion.\\r\\n *\\r\\n *     expect(myFoo).to.be.foo;\\r\\n *\\r\\n * @param {Object} ctx object to which the property is added\\r\\n * @param {String} name of property to add\\r\\n * @param {Function} getter function to be used for name\\r\\n * @namespace Utils\\r\\n * @name addProperty\\r\\n * @api public\\r\\n */\\r\\n\\r\\nmodule.exports = function addProperty(ctx, name, getter) {\\r\\n  getter = getter === undefined ? function () {} : getter;\\r\\n\\r\\n  Object.defineProperty(ctx, name,\\r\\n    { get: function propertyGetter() {\\r\\n        // Setting the `ssfi` flag to `propertyGetter` causes this function to\\r\\n        // be the starting point for removing implementation frames from the\\r\\n        // stack trace of a failed assertion.\\r\\n        //\\r\\n        // However, we only want to use this function as the starting point if\\r\\n        // the `lockSsfi` flag isn't set and proxy protection is disabled.\\r\\n        //\\r\\n        // If the `lockSsfi` flag is set, then either this assertion has been\\r\\n        // overwritten by another assertion, or this assertion is being invoked\\r\\n        // from inside of another assertion. In the first case, the `ssfi` flag\\r\\n        // has already been set by the overwriting assertion. In the second\\r\\n        // case, the `ssfi` flag has already been set by the outer assertion.\\r\\n        //\\r\\n        // If proxy protection is enabled, then the `ssfi` flag has already been\\r\\n        // set by the proxy getter.\\r\\n        if (!isProxyEnabled() && !flag(this, 'lockSsfi')) {\\r\\n          flag(this, 'ssfi', propertyGetter);\\r\\n        }\\r\\n\\r\\n        var result = getter.call(this);\\r\\n        if (result !== undefined)\\r\\n          return result;\\r\\n\\r\\n        var newAssertion = new chai.Assertion();\\r\\n        transferFlags(this, newAssertion);\\r\\n        return newAssertion;\\r\\n      }\\r\\n    , configurable: true\\r\\n  });\\r\\n};\\r\\n\\n\\n//# sourceURL=webpack:///./node_modules/chai/lib/chai/utils/addProperty.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/chai/lib/chai/utils/compareByInspect.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/chai/lib/chai/utils/compareByInspect.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\neval(\"/*!\\r\\n * Chai - compareByInspect utility\\r\\n * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>\\r\\n * MIT Licensed\\r\\n */\\r\\n\\r\\n/*!\\r\\n * Module dependencies\\r\\n */\\r\\n\\r\\nvar inspect = __webpack_require__(/*! ./inspect */ \\\"./node_modules/chai/lib/chai/utils/inspect.js\\\");\\r\\n\\r\\n/**\\r\\n * ### .compareByInspect(mixed, mixed)\\r\\n *\\r\\n * To be used as a compareFunction with Array.prototype.sort. Compares elements\\r\\n * using inspect instead of default behavior of using toString so that Symbols\\r\\n * and objects with irregular/missing toString can still be sorted without a\\r\\n * TypeError.\\r\\n *\\r\\n * @param {Mixed} first element to compare\\r\\n * @param {Mixed} second element to compare\\r\\n * @returns {Number} -1 if 'a' should come before 'b'; otherwise 1\\r\\n * @name compareByInspect\\r\\n * @namespace Utils\\r\\n * @api public\\r\\n */\\r\\n\\r\\nmodule.exports = function compareByInspect(a, b) {\\r\\n  return inspect(a) < inspect(b) ? -1 : 1;\\r\\n};\\r\\n\\n\\n//# sourceURL=webpack:///./node_modules/chai/lib/chai/utils/compareByInspect.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/chai/lib/chai/utils/expectTypes.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/chai/lib/chai/utils/expectTypes.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\neval(\"/*!\\r\\n * Chai - expectTypes utility\\r\\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\\r\\n * MIT Licensed\\r\\n */\\r\\n\\r\\n/**\\r\\n * ### .expectTypes(obj, types)\\r\\n *\\r\\n * Ensures that the object being tested against is of a valid type.\\r\\n *\\r\\n *     utils.expectTypes(this, ['array', 'object', 'string']);\\r\\n *\\r\\n * @param {Mixed} obj constructed Assertion\\r\\n * @param {Array} type A list of allowed types for this assertion\\r\\n * @namespace Utils\\r\\n * @name expectTypes\\r\\n * @api public\\r\\n */\\r\\n\\r\\nvar AssertionError = __webpack_require__(/*! assertion-error */ \\\"./node_modules/assertion-error/index.js\\\");\\r\\nvar flag = __webpack_require__(/*! ./flag */ \\\"./node_modules/chai/lib/chai/utils/flag.js\\\");\\r\\nvar type = __webpack_require__(/*! type-detect */ \\\"./node_modules/type-detect/type-detect.js\\\");\\r\\n\\r\\nmodule.exports = function expectTypes(obj, types) {\\r\\n  var flagMsg = flag(obj, 'message');\\r\\n  var ssfi = flag(obj, 'ssfi');\\r\\n\\r\\n  flagMsg = flagMsg ? flagMsg + ': ' : '';\\r\\n\\r\\n  obj = flag(obj, 'object');\\r\\n  types = types.map(function (t) { return t.toLowerCase(); });\\r\\n  types.sort();\\r\\n\\r\\n  // Transforms ['lorem', 'ipsum'] into 'a lorem, or an ipsum'\\r\\n  var str = types.map(function (t, index) {\\r\\n    var art = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(t.charAt(0)) ? 'an' : 'a';\\r\\n    var or = types.length > 1 && index === types.length - 1 ? 'or ' : '';\\r\\n    return or + art + ' ' + t;\\r\\n  }).join(', ');\\r\\n\\r\\n  var objType = type(obj).toLowerCase();\\r\\n\\r\\n  if (!types.some(function (expected) { return objType === expected; })) {\\r\\n    throw new AssertionError(\\r\\n      flagMsg + 'object tested must be ' + str + ', but ' + objType + ' given',\\r\\n      undefined,\\r\\n      ssfi\\r\\n    );\\r\\n  }\\r\\n};\\r\\n\\n\\n//# sourceURL=webpack:///./node_modules/chai/lib/chai/utils/expectTypes.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/chai/lib/chai/utils/flag.js\":\n/*!**************************************************!*\\\n  !*** ./node_modules/chai/lib/chai/utils/flag.js ***!\n  \\**************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\neval(\"/*!\\r\\n * Chai - flag utility\\r\\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\\r\\n * MIT Licensed\\r\\n */\\r\\n\\r\\n/**\\r\\n * ### .flag(object, key, [value])\\r\\n *\\r\\n * Get or set a flag value on an object. If a\\r\\n * value is provided it will be set, else it will\\r\\n * return the currently set value or `undefined` if\\r\\n * the value is not set.\\r\\n *\\r\\n *     utils.flag(this, 'foo', 'bar'); // setter\\r\\n *     utils.flag(this, 'foo'); // getter, returns `bar`\\r\\n *\\r\\n * @param {Object} object constructed Assertion\\r\\n * @param {String} key\\r\\n * @param {Mixed} value (optional)\\r\\n * @namespace Utils\\r\\n * @name flag\\r\\n * @api private\\r\\n */\\r\\n\\r\\nmodule.exports = function flag(obj, key, value) {\\r\\n  var flags = obj.__flags || (obj.__flags = Object.create(null));\\r\\n  if (arguments.length === 3) {\\r\\n    flags[key] = value;\\r\\n  } else {\\r\\n    return flags[key];\\r\\n  }\\r\\n};\\r\\n\\n\\n//# sourceURL=webpack:///./node_modules/chai/lib/chai/utils/flag.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/chai/lib/chai/utils/getActual.js\":\n/*!*******************************************************!*\\\n  !*** ./node_modules/chai/lib/chai/utils/getActual.js ***!\n  \\*******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\neval(\"/*!\\r\\n * Chai - getActual utility\\r\\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\\r\\n * MIT Licensed\\r\\n */\\r\\n\\r\\n/**\\r\\n * ### .getActual(object, [actual])\\r\\n *\\r\\n * Returns the `actual` value for an Assertion.\\r\\n *\\r\\n * @param {Object} object (constructed Assertion)\\r\\n * @param {Arguments} chai.Assertion.prototype.assert arguments\\r\\n * @namespace Utils\\r\\n * @name getActual\\r\\n */\\r\\n\\r\\nmodule.exports = function getActual(obj, args) {\\r\\n  return args.length > 4 ? args[4] : obj._obj;\\r\\n};\\r\\n\\n\\n//# sourceURL=webpack:///./node_modules/chai/lib/chai/utils/getActual.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/chai/lib/chai/utils/getEnumerableProperties.js\":\n/*!*********************************************************************!*\\\n  !*** ./node_modules/chai/lib/chai/utils/getEnumerableProperties.js ***!\n  \\*********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\neval(\"/*!\\r\\n * Chai - getEnumerableProperties utility\\r\\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\\r\\n * MIT Licensed\\r\\n */\\r\\n\\r\\n/**\\r\\n * ### .getEnumerableProperties(object)\\r\\n *\\r\\n * This allows the retrieval of enumerable property names of an object,\\r\\n * inherited or not.\\r\\n *\\r\\n * @param {Object} object\\r\\n * @returns {Array}\\r\\n * @namespace Utils\\r\\n * @name getEnumerableProperties\\r\\n * @api public\\r\\n */\\r\\n\\r\\nmodule.exports = function getEnumerableProperties(object) {\\r\\n  var result = [];\\r\\n  for (var name in object) {\\r\\n    result.push(name);\\r\\n  }\\r\\n  return result;\\r\\n};\\r\\n\\n\\n//# sourceURL=webpack:///./node_modules/chai/lib/chai/utils/getEnumerableProperties.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/chai/lib/chai/utils/getMessage.js\":\n/*!********************************************************!*\\\n  !*** ./node_modules/chai/lib/chai/utils/getMessage.js ***!\n  \\********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\neval(\"/*!\\r\\n * Chai - message composition utility\\r\\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\\r\\n * MIT Licensed\\r\\n */\\r\\n\\r\\n/*!\\r\\n * Module dependencies\\r\\n */\\r\\n\\r\\nvar flag = __webpack_require__(/*! ./flag */ \\\"./node_modules/chai/lib/chai/utils/flag.js\\\")\\r\\n  , getActual = __webpack_require__(/*! ./getActual */ \\\"./node_modules/chai/lib/chai/utils/getActual.js\\\")\\r\\n  , objDisplay = __webpack_require__(/*! ./objDisplay */ \\\"./node_modules/chai/lib/chai/utils/objDisplay.js\\\");\\r\\n\\r\\n/**\\r\\n * ### .getMessage(object, message, negateMessage)\\r\\n *\\r\\n * Construct the error message based on flags\\r\\n * and template tags. Template tags will return\\r\\n * a stringified inspection of the object referenced.\\r\\n *\\r\\n * Message template tags:\\r\\n * - `#{this}` current asserted object\\r\\n * - `#{act}` actual value\\r\\n * - `#{exp}` expected value\\r\\n *\\r\\n * @param {Object} object (constructed Assertion)\\r\\n * @param {Arguments} chai.Assertion.prototype.assert arguments\\r\\n * @namespace Utils\\r\\n * @name getMessage\\r\\n * @api public\\r\\n */\\r\\n\\r\\nmodule.exports = function getMessage(obj, args) {\\r\\n  var negate = flag(obj, 'negate')\\r\\n    , val = flag(obj, 'object')\\r\\n    , expected = args[3]\\r\\n    , actual = getActual(obj, args)\\r\\n    , msg = negate ? args[2] : args[1]\\r\\n    , flagMsg = flag(obj, 'message');\\r\\n\\r\\n  if(typeof msg === \\\"function\\\") msg = msg();\\r\\n  msg = msg || '';\\r\\n  msg = msg\\r\\n    .replace(/#\\\\{this\\\\}/g, function () { return objDisplay(val); })\\r\\n    .replace(/#\\\\{act\\\\}/g, function () { return objDisplay(actual); })\\r\\n    .replace(/#\\\\{exp\\\\}/g, function () { return objDisplay(expected); });\\r\\n\\r\\n  return flagMsg ? flagMsg + ': ' + msg : msg;\\r\\n};\\r\\n\\n\\n//# sourceURL=webpack:///./node_modules/chai/lib/chai/utils/getMessage.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/chai/lib/chai/utils/getOwnEnumerableProperties.js\":\n/*!************************************************************************!*\\\n  !*** ./node_modules/chai/lib/chai/utils/getOwnEnumerableProperties.js ***!\n  \\************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\neval(\"/*!\\r\\n * Chai - getOwnEnumerableProperties utility\\r\\n * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>\\r\\n * MIT Licensed\\r\\n */\\r\\n\\r\\n/*!\\r\\n * Module dependencies\\r\\n */\\r\\n\\r\\nvar getOwnEnumerablePropertySymbols = __webpack_require__(/*! ./getOwnEnumerablePropertySymbols */ \\\"./node_modules/chai/lib/chai/utils/getOwnEnumerablePropertySymbols.js\\\");\\r\\n\\r\\n/**\\r\\n * ### .getOwnEnumerableProperties(object)\\r\\n *\\r\\n * This allows the retrieval of directly-owned enumerable property names and\\r\\n * symbols of an object. This function is necessary because Object.keys only\\r\\n * returns enumerable property names, not enumerable property symbols.\\r\\n *\\r\\n * @param {Object} object\\r\\n * @returns {Array}\\r\\n * @namespace Utils\\r\\n * @name getOwnEnumerableProperties\\r\\n * @api public\\r\\n */\\r\\n\\r\\nmodule.exports = function getOwnEnumerableProperties(obj) {\\r\\n  return Object.keys(obj).concat(getOwnEnumerablePropertySymbols(obj));\\r\\n};\\r\\n\\n\\n//# sourceURL=webpack:///./node_modules/chai/lib/chai/utils/getOwnEnumerableProperties.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/chai/lib/chai/utils/getOwnEnumerablePropertySymbols.js\":\n/*!*****************************************************************************!*\\\n  !*** ./node_modules/chai/lib/chai/utils/getOwnEnumerablePropertySymbols.js ***!\n  \\*****************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\neval(\"/*!\\r\\n * Chai - getOwnEnumerablePropertySymbols utility\\r\\n * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>\\r\\n * MIT Licensed\\r\\n */\\r\\n\\r\\n/**\\r\\n * ### .getOwnEnumerablePropertySymbols(object)\\r\\n *\\r\\n * This allows the retrieval of directly-owned enumerable property symbols of an\\r\\n * object. This function is necessary because Object.getOwnPropertySymbols\\r\\n * returns both enumerable and non-enumerable property symbols.\\r\\n *\\r\\n * @param {Object} object\\r\\n * @returns {Array}\\r\\n * @namespace Utils\\r\\n * @name getOwnEnumerablePropertySymbols\\r\\n * @api public\\r\\n */\\r\\n\\r\\nmodule.exports = function getOwnEnumerablePropertySymbols(obj) {\\r\\n  if (typeof Object.getOwnPropertySymbols !== 'function') return [];\\r\\n\\r\\n  return Object.getOwnPropertySymbols(obj).filter(function (sym) {\\r\\n    return Object.getOwnPropertyDescriptor(obj, sym).enumerable;\\r\\n  });\\r\\n};\\r\\n\\n\\n//# sourceURL=webpack:///./node_modules/chai/lib/chai/utils/getOwnEnumerablePropertySymbols.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/chai/lib/chai/utils/getProperties.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/chai/lib/chai/utils/getProperties.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\neval(\"/*!\\r\\n * Chai - getProperties utility\\r\\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\\r\\n * MIT Licensed\\r\\n */\\r\\n\\r\\n/**\\r\\n * ### .getProperties(object)\\r\\n *\\r\\n * This allows the retrieval of property names of an object, enumerable or not,\\r\\n * inherited or not.\\r\\n *\\r\\n * @param {Object} object\\r\\n * @returns {Array}\\r\\n * @namespace Utils\\r\\n * @name getProperties\\r\\n * @api public\\r\\n */\\r\\n\\r\\nmodule.exports = function getProperties(object) {\\r\\n  var result = Object.getOwnPropertyNames(object);\\r\\n\\r\\n  function addProperty(property) {\\r\\n    if (result.indexOf(property) === -1) {\\r\\n      result.push(property);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  var proto = Object.getPrototypeOf(object);\\r\\n  while (proto !== null) {\\r\\n    Object.getOwnPropertyNames(proto).forEach(addProperty);\\r\\n    proto = Object.getPrototypeOf(proto);\\r\\n  }\\r\\n\\r\\n  return result;\\r\\n};\\r\\n\\n\\n//# sourceURL=webpack:///./node_modules/chai/lib/chai/utils/getProperties.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/chai/lib/chai/utils/index.js\":\n/*!***************************************************!*\\\n  !*** ./node_modules/chai/lib/chai/utils/index.js ***!\n  \\***************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\neval(\"/*!\\r\\n * chai\\r\\n * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>\\r\\n * MIT Licensed\\r\\n */\\r\\n\\r\\n/*!\\r\\n * Dependencies that are used for multiple exports are required here only once\\r\\n */\\r\\n\\r\\nvar pathval = __webpack_require__(/*! pathval */ \\\"./node_modules/pathval/index.js\\\");\\r\\n\\r\\n/*!\\r\\n * test utility\\r\\n */\\r\\n\\r\\nexports.test = __webpack_require__(/*! ./test */ \\\"./node_modules/chai/lib/chai/utils/test.js\\\");\\r\\n\\r\\n/*!\\r\\n * type utility\\r\\n */\\r\\n\\r\\nexports.type = __webpack_require__(/*! type-detect */ \\\"./node_modules/type-detect/type-detect.js\\\");\\r\\n\\r\\n/*!\\r\\n * expectTypes utility\\r\\n */\\r\\nexports.expectTypes = __webpack_require__(/*! ./expectTypes */ \\\"./node_modules/chai/lib/chai/utils/expectTypes.js\\\");\\r\\n\\r\\n/*!\\r\\n * message utility\\r\\n */\\r\\n\\r\\nexports.getMessage = __webpack_require__(/*! ./getMessage */ \\\"./node_modules/chai/lib/chai/utils/getMessage.js\\\");\\r\\n\\r\\n/*!\\r\\n * actual utility\\r\\n */\\r\\n\\r\\nexports.getActual = __webpack_require__(/*! ./getActual */ \\\"./node_modules/chai/lib/chai/utils/getActual.js\\\");\\r\\n\\r\\n/*!\\r\\n * Inspect util\\r\\n */\\r\\n\\r\\nexports.inspect = __webpack_require__(/*! ./inspect */ \\\"./node_modules/chai/lib/chai/utils/inspect.js\\\");\\r\\n\\r\\n/*!\\r\\n * Object Display util\\r\\n */\\r\\n\\r\\nexports.objDisplay = __webpack_require__(/*! ./objDisplay */ \\\"./node_modules/chai/lib/chai/utils/objDisplay.js\\\");\\r\\n\\r\\n/*!\\r\\n * Flag utility\\r\\n */\\r\\n\\r\\nexports.flag = __webpack_require__(/*! ./flag */ \\\"./node_modules/chai/lib/chai/utils/flag.js\\\");\\r\\n\\r\\n/*!\\r\\n * Flag transferring utility\\r\\n */\\r\\n\\r\\nexports.transferFlags = __webpack_require__(/*! ./transferFlags */ \\\"./node_modules/chai/lib/chai/utils/transferFlags.js\\\");\\r\\n\\r\\n/*!\\r\\n * Deep equal utility\\r\\n */\\r\\n\\r\\nexports.eql = __webpack_require__(/*! deep-eql */ \\\"./node_modules/deep-eql/index.js\\\");\\r\\n\\r\\n/*!\\r\\n * Deep path info\\r\\n */\\r\\n\\r\\nexports.getPathInfo = pathval.getPathInfo;\\r\\n\\r\\n/*!\\r\\n * Check if a property exists\\r\\n */\\r\\n\\r\\nexports.hasProperty = pathval.hasProperty;\\r\\n\\r\\n/*!\\r\\n * Function name\\r\\n */\\r\\n\\r\\nexports.getName = __webpack_require__(/*! get-func-name */ \\\"./node_modules/get-func-name/index.js\\\");\\r\\n\\r\\n/*!\\r\\n * add Property\\r\\n */\\r\\n\\r\\nexports.addProperty = __webpack_require__(/*! ./addProperty */ \\\"./node_modules/chai/lib/chai/utils/addProperty.js\\\");\\r\\n\\r\\n/*!\\r\\n * add Method\\r\\n */\\r\\n\\r\\nexports.addMethod = __webpack_require__(/*! ./addMethod */ \\\"./node_modules/chai/lib/chai/utils/addMethod.js\\\");\\r\\n\\r\\n/*!\\r\\n * overwrite Property\\r\\n */\\r\\n\\r\\nexports.overwriteProperty = __webpack_require__(/*! ./overwriteProperty */ \\\"./node_modules/chai/lib/chai/utils/overwriteProperty.js\\\");\\r\\n\\r\\n/*!\\r\\n * overwrite Method\\r\\n */\\r\\n\\r\\nexports.overwriteMethod = __webpack_require__(/*! ./overwriteMethod */ \\\"./node_modules/chai/lib/chai/utils/overwriteMethod.js\\\");\\r\\n\\r\\n/*!\\r\\n * Add a chainable method\\r\\n */\\r\\n\\r\\nexports.addChainableMethod = __webpack_require__(/*! ./addChainableMethod */ \\\"./node_modules/chai/lib/chai/utils/addChainableMethod.js\\\");\\r\\n\\r\\n/*!\\r\\n * Overwrite chainable method\\r\\n */\\r\\n\\r\\nexports.overwriteChainableMethod = __webpack_require__(/*! ./overwriteChainableMethod */ \\\"./node_modules/chai/lib/chai/utils/overwriteChainableMethod.js\\\");\\r\\n\\r\\n/*!\\r\\n * Compare by inspect method\\r\\n */\\r\\n\\r\\nexports.compareByInspect = __webpack_require__(/*! ./compareByInspect */ \\\"./node_modules/chai/lib/chai/utils/compareByInspect.js\\\");\\r\\n\\r\\n/*!\\r\\n * Get own enumerable property symbols method\\r\\n */\\r\\n\\r\\nexports.getOwnEnumerablePropertySymbols = __webpack_require__(/*! ./getOwnEnumerablePropertySymbols */ \\\"./node_modules/chai/lib/chai/utils/getOwnEnumerablePropertySymbols.js\\\");\\r\\n\\r\\n/*!\\r\\n * Get own enumerable properties method\\r\\n */\\r\\n\\r\\nexports.getOwnEnumerableProperties = __webpack_require__(/*! ./getOwnEnumerableProperties */ \\\"./node_modules/chai/lib/chai/utils/getOwnEnumerableProperties.js\\\");\\r\\n\\r\\n/*!\\r\\n * Checks error against a given set of criteria\\r\\n */\\r\\n\\r\\nexports.checkError = __webpack_require__(/*! check-error */ \\\"./node_modules/check-error/index.js\\\");\\r\\n\\r\\n/*!\\r\\n * Proxify util\\r\\n */\\r\\n\\r\\nexports.proxify = __webpack_require__(/*! ./proxify */ \\\"./node_modules/chai/lib/chai/utils/proxify.js\\\");\\r\\n\\r\\n/*!\\r\\n * addLengthGuard util\\r\\n */\\r\\n\\r\\nexports.addLengthGuard = __webpack_require__(/*! ./addLengthGuard */ \\\"./node_modules/chai/lib/chai/utils/addLengthGuard.js\\\");\\r\\n\\r\\n/*!\\r\\n * isProxyEnabled helper\\r\\n */\\r\\n\\r\\nexports.isProxyEnabled = __webpack_require__(/*! ./isProxyEnabled */ \\\"./node_modules/chai/lib/chai/utils/isProxyEnabled.js\\\");\\r\\n\\r\\n/*!\\r\\n * isNaN method\\r\\n */\\r\\n\\r\\nexports.isNaN = __webpack_require__(/*! ./isNaN */ \\\"./node_modules/chai/lib/chai/utils/isNaN.js\\\");\\r\\n\\n\\n//# sourceURL=webpack:///./node_modules/chai/lib/chai/utils/index.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/chai/lib/chai/utils/inspect.js\":\n/*!*****************************************************!*\\\n  !*** ./node_modules/chai/lib/chai/utils/inspect.js ***!\n  \\*****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\neval(\"// This is (almost) directly from Node.js utils\\r\\n// https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/util.js\\r\\n\\r\\nvar getName = __webpack_require__(/*! get-func-name */ \\\"./node_modules/get-func-name/index.js\\\");\\r\\nvar getProperties = __webpack_require__(/*! ./getProperties */ \\\"./node_modules/chai/lib/chai/utils/getProperties.js\\\");\\r\\nvar getEnumerableProperties = __webpack_require__(/*! ./getEnumerableProperties */ \\\"./node_modules/chai/lib/chai/utils/getEnumerableProperties.js\\\");\\r\\nvar config = __webpack_require__(/*! ../config */ \\\"./node_modules/chai/lib/chai/config.js\\\");\\r\\n\\r\\nmodule.exports = inspect;\\r\\n\\r\\n/**\\r\\n * ### .inspect(obj, [showHidden], [depth], [colors])\\r\\n *\\r\\n * Echoes the value of a value. Tries to print the value out\\r\\n * in the best way possible given the different types.\\r\\n *\\r\\n * @param {Object} obj The object to print out.\\r\\n * @param {Boolean} showHidden Flag that shows hidden (not enumerable)\\r\\n *    properties of objects. Default is false.\\r\\n * @param {Number} depth Depth in which to descend in object. Default is 2.\\r\\n * @param {Boolean} colors Flag to turn on ANSI escape codes to color the\\r\\n *    output. Default is false (no coloring).\\r\\n * @namespace Utils\\r\\n * @name inspect\\r\\n */\\r\\nfunction inspect(obj, showHidden, depth, colors) {\\r\\n  var ctx = {\\r\\n    showHidden: showHidden,\\r\\n    seen: [],\\r\\n    stylize: function (str) { return str; }\\r\\n  };\\r\\n  return formatValue(ctx, obj, (typeof depth === 'undefined' ? 2 : depth));\\r\\n}\\r\\n\\r\\n// Returns true if object is a DOM element.\\r\\nvar isDOMElement = function (object) {\\r\\n  if (typeof HTMLElement === 'object') {\\r\\n    return object instanceof HTMLElement;\\r\\n  } else {\\r\\n    return object &&\\r\\n      typeof object === 'object' &&\\r\\n      'nodeType' in object &&\\r\\n      object.nodeType === 1 &&\\r\\n      typeof object.nodeName === 'string';\\r\\n  }\\r\\n};\\r\\n\\r\\nfunction formatValue(ctx, value, recurseTimes) {\\r\\n  // Provide a hook for user-specified inspect functions.\\r\\n  // Check that value is an object with an inspect function on it\\r\\n  if (value && typeof value.inspect === 'function' &&\\r\\n      // Filter out the util module, it's inspect function is special\\r\\n      value.inspect !== exports.inspect &&\\r\\n      // Also filter out any prototype objects using the circular check.\\r\\n      !(value.constructor && value.constructor.prototype === value)) {\\r\\n    var ret = value.inspect(recurseTimes, ctx);\\r\\n    if (typeof ret !== 'string') {\\r\\n      ret = formatValue(ctx, ret, recurseTimes);\\r\\n    }\\r\\n    return ret;\\r\\n  }\\r\\n\\r\\n  // Primitive types cannot have properties\\r\\n  var primitive = formatPrimitive(ctx, value);\\r\\n  if (primitive) {\\r\\n    return primitive;\\r\\n  }\\r\\n\\r\\n  // If this is a DOM element, try to get the outer HTML.\\r\\n  if (isDOMElement(value)) {\\r\\n    if ('outerHTML' in value) {\\r\\n      return value.outerHTML;\\r\\n      // This value does not have an outerHTML attribute,\\r\\n      //   it could still be an XML element\\r\\n    } else {\\r\\n      // Attempt to serialize it\\r\\n      try {\\r\\n        if (document.xmlVersion) {\\r\\n          var xmlSerializer = new XMLSerializer();\\r\\n          return xmlSerializer.serializeToString(value);\\r\\n        } else {\\r\\n          // Firefox 11- do not support outerHTML\\r\\n          //   It does, however, support innerHTML\\r\\n          //   Use the following to render the element\\r\\n          var ns = \\\"http://www.w3.org/1999/xhtml\\\";\\r\\n          var container = document.createElementNS(ns, '_');\\r\\n\\r\\n          container.appendChild(value.cloneNode(false));\\r\\n          var html = container.innerHTML\\r\\n            .replace('><', '>' + value.innerHTML + '<');\\r\\n          container.innerHTML = '';\\r\\n          return html;\\r\\n        }\\r\\n      } catch (err) {\\r\\n        // This could be a non-native DOM implementation,\\r\\n        //   continue with the normal flow:\\r\\n        //   printing the element as if it is an object.\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  // Look up the keys of the object.\\r\\n  var visibleKeys = getEnumerableProperties(value);\\r\\n  var keys = ctx.showHidden ? getProperties(value) : visibleKeys;\\r\\n\\r\\n  var name, nameSuffix;\\r\\n\\r\\n  // Some type of object without properties can be shortcut.\\r\\n  // In IE, errors have a single `stack` property, or if they are vanilla `Error`,\\r\\n  // a `stack` plus `description` property; ignore those for consistency.\\r\\n  if (keys.length === 0 || (isError(value) && (\\r\\n      (keys.length === 1 && keys[0] === 'stack') ||\\r\\n      (keys.length === 2 && keys[0] === 'description' && keys[1] === 'stack')\\r\\n     ))) {\\r\\n    if (typeof value === 'function') {\\r\\n      name = getName(value);\\r\\n      nameSuffix = name ? ': ' + name : '';\\r\\n      return ctx.stylize('[Function' + nameSuffix + ']', 'special');\\r\\n    }\\r\\n    if (isRegExp(value)) {\\r\\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\\r\\n    }\\r\\n    if (isDate(value)) {\\r\\n      return ctx.stylize(Date.prototype.toUTCString.call(value), 'date');\\r\\n    }\\r\\n    if (isError(value)) {\\r\\n      return formatError(value);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  var base = ''\\r\\n    , array = false\\r\\n    , typedArray = false\\r\\n    , braces = ['{', '}'];\\r\\n\\r\\n  if (isTypedArray(value)) {\\r\\n    typedArray = true;\\r\\n    braces = ['[', ']'];\\r\\n  }\\r\\n\\r\\n  // Make Array say that they are Array\\r\\n  if (isArray(value)) {\\r\\n    array = true;\\r\\n    braces = ['[', ']'];\\r\\n  }\\r\\n\\r\\n  // Make functions say that they are functions\\r\\n  if (typeof value === 'function') {\\r\\n    name = getName(value);\\r\\n    nameSuffix = name ? ': ' + name : '';\\r\\n    base = ' [Function' + nameSuffix + ']';\\r\\n  }\\r\\n\\r\\n  // Make RegExps say that they are RegExps\\r\\n  if (isRegExp(value)) {\\r\\n    base = ' ' + RegExp.prototype.toString.call(value);\\r\\n  }\\r\\n\\r\\n  // Make dates with properties first say the date\\r\\n  if (isDate(value)) {\\r\\n    base = ' ' + Date.prototype.toUTCString.call(value);\\r\\n  }\\r\\n\\r\\n  // Make error with message first say the error\\r\\n  if (isError(value)) {\\r\\n    return formatError(value);\\r\\n  }\\r\\n\\r\\n  if (keys.length === 0 && (!array || value.length == 0)) {\\r\\n    return braces[0] + base + braces[1];\\r\\n  }\\r\\n\\r\\n  if (recurseTimes < 0) {\\r\\n    if (isRegExp(value)) {\\r\\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\\r\\n    } else {\\r\\n      return ctx.stylize('[Object]', 'special');\\r\\n    }\\r\\n  }\\r\\n\\r\\n  ctx.seen.push(value);\\r\\n\\r\\n  var output;\\r\\n  if (array) {\\r\\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\\r\\n  } else if (typedArray) {\\r\\n    return formatTypedArray(value);\\r\\n  } else {\\r\\n    output = keys.map(function(key) {\\r\\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\\r\\n    });\\r\\n  }\\r\\n\\r\\n  ctx.seen.pop();\\r\\n\\r\\n  return reduceToSingleString(output, base, braces);\\r\\n}\\r\\n\\r\\nfunction formatPrimitive(ctx, value) {\\r\\n  switch (typeof value) {\\r\\n    case 'undefined':\\r\\n      return ctx.stylize('undefined', 'undefined');\\r\\n\\r\\n    case 'string':\\r\\n      var simple = '\\\\'' + JSON.stringify(value).replace(/^\\\"|\\\"$/g, '')\\r\\n                                               .replace(/'/g, \\\"\\\\\\\\'\\\")\\r\\n                                               .replace(/\\\\\\\\\\\"/g, '\\\"') + '\\\\'';\\r\\n      return ctx.stylize(simple, 'string');\\r\\n\\r\\n    case 'number':\\r\\n      if (value === 0 && (1/value) === -Infinity) {\\r\\n        return ctx.stylize('-0', 'number');\\r\\n      }\\r\\n      return ctx.stylize('' + value, 'number');\\r\\n\\r\\n    case 'boolean':\\r\\n      return ctx.stylize('' + value, 'boolean');\\r\\n\\r\\n    case 'symbol':\\r\\n      return ctx.stylize(value.toString(), 'symbol');\\r\\n  }\\r\\n  // For some reason typeof null is \\\"object\\\", so special case here.\\r\\n  if (value === null) {\\r\\n    return ctx.stylize('null', 'null');\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction formatError(value) {\\r\\n  return '[' + Error.prototype.toString.call(value) + ']';\\r\\n}\\r\\n\\r\\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\\r\\n  var output = [];\\r\\n  for (var i = 0, l = value.length; i < l; ++i) {\\r\\n    if (Object.prototype.hasOwnProperty.call(value, String(i))) {\\r\\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\\r\\n          String(i), true));\\r\\n    } else {\\r\\n      output.push('');\\r\\n    }\\r\\n  }\\r\\n\\r\\n  keys.forEach(function(key) {\\r\\n    if (!key.match(/^\\\\d+$/)) {\\r\\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\\r\\n          key, true));\\r\\n    }\\r\\n  });\\r\\n  return output;\\r\\n}\\r\\n\\r\\nfunction formatTypedArray(value) {\\r\\n  var str = '[ ';\\r\\n\\r\\n  for (var i = 0; i < value.length; ++i) {\\r\\n    if (str.length >= config.truncateThreshold - 7) {\\r\\n      str += '...';\\r\\n      break;\\r\\n    }\\r\\n    str += value[i] + ', ';\\r\\n  }\\r\\n  str += ' ]';\\r\\n\\r\\n  // Removing trailing `, ` if the array was not truncated\\r\\n  if (str.indexOf(',  ]') !== -1) {\\r\\n    str = str.replace(',  ]', ' ]');\\r\\n  }\\r\\n\\r\\n  return str;\\r\\n}\\r\\n\\r\\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\\r\\n  var name;\\r\\n  var propDescriptor = Object.getOwnPropertyDescriptor(value, key);\\r\\n  var str;\\r\\n\\r\\n  if (propDescriptor) {\\r\\n    if (propDescriptor.get) {\\r\\n      if (propDescriptor.set) {\\r\\n        str = ctx.stylize('[Getter/Setter]', 'special');\\r\\n      } else {\\r\\n        str = ctx.stylize('[Getter]', 'special');\\r\\n      }\\r\\n    } else {\\r\\n      if (propDescriptor.set) {\\r\\n        str = ctx.stylize('[Setter]', 'special');\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n  if (visibleKeys.indexOf(key) < 0) {\\r\\n    name = '[' + key + ']';\\r\\n  }\\r\\n  if (!str) {\\r\\n    if (ctx.seen.indexOf(value[key]) < 0) {\\r\\n      if (recurseTimes === null) {\\r\\n        str = formatValue(ctx, value[key], null);\\r\\n      } else {\\r\\n        str = formatValue(ctx, value[key], recurseTimes - 1);\\r\\n      }\\r\\n      if (str.indexOf('\\\\n') > -1) {\\r\\n        if (array) {\\r\\n          str = str.split('\\\\n').map(function(line) {\\r\\n            return '  ' + line;\\r\\n          }).join('\\\\n').substr(2);\\r\\n        } else {\\r\\n          str = '\\\\n' + str.split('\\\\n').map(function(line) {\\r\\n            return '   ' + line;\\r\\n          }).join('\\\\n');\\r\\n        }\\r\\n      }\\r\\n    } else {\\r\\n      str = ctx.stylize('[Circular]', 'special');\\r\\n    }\\r\\n  }\\r\\n  if (typeof name === 'undefined') {\\r\\n    if (array && key.match(/^\\\\d+$/)) {\\r\\n      return str;\\r\\n    }\\r\\n    name = JSON.stringify('' + key);\\r\\n    if (name.match(/^\\\"([a-zA-Z_][a-zA-Z_0-9]*)\\\"$/)) {\\r\\n      name = name.substr(1, name.length - 2);\\r\\n      name = ctx.stylize(name, 'name');\\r\\n    } else {\\r\\n      name = name.replace(/'/g, \\\"\\\\\\\\'\\\")\\r\\n                 .replace(/\\\\\\\\\\\"/g, '\\\"')\\r\\n                 .replace(/(^\\\"|\\\"$)/g, \\\"'\\\");\\r\\n      name = ctx.stylize(name, 'string');\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return name + ': ' + str;\\r\\n}\\r\\n\\r\\nfunction reduceToSingleString(output, base, braces) {\\r\\n  var length = output.reduce(function(prev, cur) {\\r\\n    return prev + cur.length + 1;\\r\\n  }, 0);\\r\\n\\r\\n  if (length > 60) {\\r\\n    return braces[0] +\\r\\n           (base === '' ? '' : base + '\\\\n ') +\\r\\n           ' ' +\\r\\n           output.join(',\\\\n  ') +\\r\\n           ' ' +\\r\\n           braces[1];\\r\\n  }\\r\\n\\r\\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\\r\\n}\\r\\n\\r\\nfunction isTypedArray(ar) {\\r\\n  // Unfortunately there's no way to check if an object is a TypedArray\\r\\n  // We have to check if it's one of these types\\r\\n  return (typeof ar === 'object' && /\\\\w+Array]$/.test(objectToString(ar)));\\r\\n}\\r\\n\\r\\nfunction isArray(ar) {\\r\\n  return Array.isArray(ar) ||\\r\\n         (typeof ar === 'object' && objectToString(ar) === '[object Array]');\\r\\n}\\r\\n\\r\\nfunction isRegExp(re) {\\r\\n  return typeof re === 'object' && objectToString(re) === '[object RegExp]';\\r\\n}\\r\\n\\r\\nfunction isDate(d) {\\r\\n  return typeof d === 'object' && objectToString(d) === '[object Date]';\\r\\n}\\r\\n\\r\\nfunction isError(e) {\\r\\n  return typeof e === 'object' && objectToString(e) === '[object Error]';\\r\\n}\\r\\n\\r\\nfunction objectToString(o) {\\r\\n  return Object.prototype.toString.call(o);\\r\\n}\\r\\n\\n\\n//# sourceURL=webpack:///./node_modules/chai/lib/chai/utils/inspect.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/chai/lib/chai/utils/isNaN.js\":\n/*!***************************************************!*\\\n  !*** ./node_modules/chai/lib/chai/utils/isNaN.js ***!\n  \\***************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\neval(\"/*!\\r\\n * Chai - isNaN utility\\r\\n * Copyright(c) 2012-2015 Sakthipriyan Vairamani <thechargingvolcano@gmail.com>\\r\\n * MIT Licensed\\r\\n */\\r\\n\\r\\n/**\\r\\n * ### .isNaN(value)\\r\\n *\\r\\n * Checks if the given value is NaN or not.\\r\\n *\\r\\n *     utils.isNaN(NaN); // true\\r\\n *\\r\\n * @param {Value} The value which has to be checked if it is NaN\\r\\n * @name isNaN\\r\\n * @api private\\r\\n */\\r\\n\\r\\nfunction isNaN(value) {\\r\\n  // Refer http://www.ecma-international.org/ecma-262/6.0/#sec-isnan-number\\r\\n  // section's NOTE.\\r\\n  return value !== value;\\r\\n}\\r\\n\\r\\n// If ECMAScript 6's Number.isNaN is present, prefer that.\\r\\nmodule.exports = Number.isNaN || isNaN;\\r\\n\\n\\n//# sourceURL=webpack:///./node_modules/chai/lib/chai/utils/isNaN.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/chai/lib/chai/utils/isProxyEnabled.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/chai/lib/chai/utils/isProxyEnabled.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\neval(\"var config = __webpack_require__(/*! ../config */ \\\"./node_modules/chai/lib/chai/config.js\\\");\\r\\n\\r\\n/*!\\r\\n * Chai - isProxyEnabled helper\\r\\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\\r\\n * MIT Licensed\\r\\n */\\r\\n\\r\\n/**\\r\\n * ### .isProxyEnabled()\\r\\n *\\r\\n * Helper function to check if Chai's proxy protection feature is enabled. If\\r\\n * proxies are unsupported or disabled via the user's Chai config, then return\\r\\n * false. Otherwise, return true.\\r\\n *\\r\\n * @namespace Utils\\r\\n * @name isProxyEnabled\\r\\n */\\r\\n\\r\\nmodule.exports = function isProxyEnabled() {\\r\\n  return config.useProxy &&\\r\\n    typeof Proxy !== 'undefined' &&\\r\\n    typeof Reflect !== 'undefined';\\r\\n};\\r\\n\\n\\n//# sourceURL=webpack:///./node_modules/chai/lib/chai/utils/isProxyEnabled.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/chai/lib/chai/utils/objDisplay.js\":\n/*!********************************************************!*\\\n  !*** ./node_modules/chai/lib/chai/utils/objDisplay.js ***!\n  \\********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\neval(\"/*!\\r\\n * Chai - flag utility\\r\\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\\r\\n * MIT Licensed\\r\\n */\\r\\n\\r\\n/*!\\r\\n * Module dependencies\\r\\n */\\r\\n\\r\\nvar inspect = __webpack_require__(/*! ./inspect */ \\\"./node_modules/chai/lib/chai/utils/inspect.js\\\");\\r\\nvar config = __webpack_require__(/*! ../config */ \\\"./node_modules/chai/lib/chai/config.js\\\");\\r\\n\\r\\n/**\\r\\n * ### .objDisplay(object)\\r\\n *\\r\\n * Determines if an object or an array matches\\r\\n * criteria to be inspected in-line for error\\r\\n * messages or should be truncated.\\r\\n *\\r\\n * @param {Mixed} javascript object to inspect\\r\\n * @name objDisplay\\r\\n * @namespace Utils\\r\\n * @api public\\r\\n */\\r\\n\\r\\nmodule.exports = function objDisplay(obj) {\\r\\n  var str = inspect(obj)\\r\\n    , type = Object.prototype.toString.call(obj);\\r\\n\\r\\n  if (config.truncateThreshold && str.length >= config.truncateThreshold) {\\r\\n    if (type === '[object Function]') {\\r\\n      return !obj.name || obj.name === ''\\r\\n        ? '[Function]'\\r\\n        : '[Function: ' + obj.name + ']';\\r\\n    } else if (type === '[object Array]') {\\r\\n      return '[ Array(' + obj.length + ') ]';\\r\\n    } else if (type === '[object Object]') {\\r\\n      var keys = Object.keys(obj)\\r\\n        , kstr = keys.length > 2\\r\\n          ? keys.splice(0, 2).join(', ') + ', ...'\\r\\n          : keys.join(', ');\\r\\n      return '{ Object (' + kstr + ') }';\\r\\n    } else {\\r\\n      return str;\\r\\n    }\\r\\n  } else {\\r\\n    return str;\\r\\n  }\\r\\n};\\r\\n\\n\\n//# sourceURL=webpack:///./node_modules/chai/lib/chai/utils/objDisplay.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/chai/lib/chai/utils/overwriteChainableMethod.js\":\n/*!**********************************************************************!*\\\n  !*** ./node_modules/chai/lib/chai/utils/overwriteChainableMethod.js ***!\n  \\**********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\neval(\"/*!\\r\\n * Chai - overwriteChainableMethod utility\\r\\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\\r\\n * MIT Licensed\\r\\n */\\r\\n\\r\\nvar chai = __webpack_require__(/*! ../../chai */ \\\"./node_modules/chai/lib/chai.js\\\");\\r\\nvar transferFlags = __webpack_require__(/*! ./transferFlags */ \\\"./node_modules/chai/lib/chai/utils/transferFlags.js\\\");\\r\\n\\r\\n/**\\r\\n * ### .overwriteChainableMethod(ctx, name, method, chainingBehavior)\\r\\n *\\r\\n * Overwrites an already existing chainable method\\r\\n * and provides access to the previous function or\\r\\n * property.  Must return functions to be used for\\r\\n * name.\\r\\n *\\r\\n *     utils.overwriteChainableMethod(chai.Assertion.prototype, 'lengthOf',\\r\\n *       function (_super) {\\r\\n *       }\\r\\n *     , function (_super) {\\r\\n *       }\\r\\n *     );\\r\\n *\\r\\n * Can also be accessed directly from `chai.Assertion`.\\r\\n *\\r\\n *     chai.Assertion.overwriteChainableMethod('foo', fn, fn);\\r\\n *\\r\\n * Then can be used as any other assertion.\\r\\n *\\r\\n *     expect(myFoo).to.have.lengthOf(3);\\r\\n *     expect(myFoo).to.have.lengthOf.above(3);\\r\\n *\\r\\n * @param {Object} ctx object whose method / property is to be overwritten\\r\\n * @param {String} name of method / property to overwrite\\r\\n * @param {Function} method function that returns a function to be used for name\\r\\n * @param {Function} chainingBehavior function that returns a function to be used for property\\r\\n * @namespace Utils\\r\\n * @name overwriteChainableMethod\\r\\n * @api public\\r\\n */\\r\\n\\r\\nmodule.exports = function overwriteChainableMethod(ctx, name, method, chainingBehavior) {\\r\\n  var chainableBehavior = ctx.__methods[name];\\r\\n\\r\\n  var _chainingBehavior = chainableBehavior.chainingBehavior;\\r\\n  chainableBehavior.chainingBehavior = function overwritingChainableMethodGetter() {\\r\\n    var result = chainingBehavior(_chainingBehavior).call(this);\\r\\n    if (result !== undefined) {\\r\\n      return result;\\r\\n    }\\r\\n\\r\\n    var newAssertion = new chai.Assertion();\\r\\n    transferFlags(this, newAssertion);\\r\\n    return newAssertion;\\r\\n  };\\r\\n\\r\\n  var _method = chainableBehavior.method;\\r\\n  chainableBehavior.method = function overwritingChainableMethodWrapper() {\\r\\n    var result = method(_method).apply(this, arguments);\\r\\n    if (result !== undefined) {\\r\\n      return result;\\r\\n    }\\r\\n\\r\\n    var newAssertion = new chai.Assertion();\\r\\n    transferFlags(this, newAssertion);\\r\\n    return newAssertion;\\r\\n  };\\r\\n};\\r\\n\\n\\n//# sourceURL=webpack:///./node_modules/chai/lib/chai/utils/overwriteChainableMethod.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/chai/lib/chai/utils/overwriteMethod.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/chai/lib/chai/utils/overwriteMethod.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\neval(\"/*!\\r\\n * Chai - overwriteMethod utility\\r\\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\\r\\n * MIT Licensed\\r\\n */\\r\\n\\r\\nvar addLengthGuard = __webpack_require__(/*! ./addLengthGuard */ \\\"./node_modules/chai/lib/chai/utils/addLengthGuard.js\\\");\\r\\nvar chai = __webpack_require__(/*! ../../chai */ \\\"./node_modules/chai/lib/chai.js\\\");\\r\\nvar flag = __webpack_require__(/*! ./flag */ \\\"./node_modules/chai/lib/chai/utils/flag.js\\\");\\r\\nvar proxify = __webpack_require__(/*! ./proxify */ \\\"./node_modules/chai/lib/chai/utils/proxify.js\\\");\\r\\nvar transferFlags = __webpack_require__(/*! ./transferFlags */ \\\"./node_modules/chai/lib/chai/utils/transferFlags.js\\\");\\r\\n\\r\\n/**\\r\\n * ### .overwriteMethod(ctx, name, fn)\\r\\n *\\r\\n * Overwrites an already existing method and provides\\r\\n * access to previous function. Must return function\\r\\n * to be used for name.\\r\\n *\\r\\n *     utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {\\r\\n *       return function (str) {\\r\\n *         var obj = utils.flag(this, 'object');\\r\\n *         if (obj instanceof Foo) {\\r\\n *           new chai.Assertion(obj.value).to.equal(str);\\r\\n *         } else {\\r\\n *           _super.apply(this, arguments);\\r\\n *         }\\r\\n *       }\\r\\n *     });\\r\\n *\\r\\n * Can also be accessed directly from `chai.Assertion`.\\r\\n *\\r\\n *     chai.Assertion.overwriteMethod('foo', fn);\\r\\n *\\r\\n * Then can be used as any other assertion.\\r\\n *\\r\\n *     expect(myFoo).to.equal('bar');\\r\\n *\\r\\n * @param {Object} ctx object whose method is to be overwritten\\r\\n * @param {String} name of method to overwrite\\r\\n * @param {Function} method function that returns a function to be used for name\\r\\n * @namespace Utils\\r\\n * @name overwriteMethod\\r\\n * @api public\\r\\n */\\r\\n\\r\\nmodule.exports = function overwriteMethod(ctx, name, method) {\\r\\n  var _method = ctx[name]\\r\\n    , _super = function () {\\r\\n      throw new Error(name + ' is not a function');\\r\\n    };\\r\\n\\r\\n  if (_method && 'function' === typeof _method)\\r\\n    _super = _method;\\r\\n\\r\\n  var overwritingMethodWrapper = function () {\\r\\n    // Setting the `ssfi` flag to `overwritingMethodWrapper` causes this\\r\\n    // function to be the starting point for removing implementation frames from\\r\\n    // the stack trace of a failed assertion.\\r\\n    //\\r\\n    // However, we only want to use this function as the starting point if the\\r\\n    // `lockSsfi` flag isn't set.\\r\\n    //\\r\\n    // If the `lockSsfi` flag is set, then either this assertion has been\\r\\n    // overwritten by another assertion, or this assertion is being invoked from\\r\\n    // inside of another assertion. In the first case, the `ssfi` flag has\\r\\n    // already been set by the overwriting assertion. In the second case, the\\r\\n    // `ssfi` flag has already been set by the outer assertion.\\r\\n    if (!flag(this, 'lockSsfi')) {\\r\\n      flag(this, 'ssfi', overwritingMethodWrapper);\\r\\n    }\\r\\n\\r\\n    // Setting the `lockSsfi` flag to `true` prevents the overwritten assertion\\r\\n    // from changing the `ssfi` flag. By this point, the `ssfi` flag is already\\r\\n    // set to the correct starting point for this assertion.\\r\\n    var origLockSsfi = flag(this, 'lockSsfi');\\r\\n    flag(this, 'lockSsfi', true);\\r\\n    var result = method(_super).apply(this, arguments);\\r\\n    flag(this, 'lockSsfi', origLockSsfi);\\r\\n\\r\\n    if (result !== undefined) {\\r\\n      return result;\\r\\n    }\\r\\n\\r\\n    var newAssertion = new chai.Assertion();\\r\\n    transferFlags(this, newAssertion);\\r\\n    return newAssertion;\\r\\n  }\\r\\n\\r\\n  addLengthGuard(overwritingMethodWrapper, name, false);\\r\\n  ctx[name] = proxify(overwritingMethodWrapper, name);\\r\\n};\\r\\n\\n\\n//# sourceURL=webpack:///./node_modules/chai/lib/chai/utils/overwriteMethod.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/chai/lib/chai/utils/overwriteProperty.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/chai/lib/chai/utils/overwriteProperty.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\neval(\"/*!\\r\\n * Chai - overwriteProperty utility\\r\\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\\r\\n * MIT Licensed\\r\\n */\\r\\n\\r\\nvar chai = __webpack_require__(/*! ../../chai */ \\\"./node_modules/chai/lib/chai.js\\\");\\r\\nvar flag = __webpack_require__(/*! ./flag */ \\\"./node_modules/chai/lib/chai/utils/flag.js\\\");\\r\\nvar isProxyEnabled = __webpack_require__(/*! ./isProxyEnabled */ \\\"./node_modules/chai/lib/chai/utils/isProxyEnabled.js\\\");\\r\\nvar transferFlags = __webpack_require__(/*! ./transferFlags */ \\\"./node_modules/chai/lib/chai/utils/transferFlags.js\\\");\\r\\n\\r\\n/**\\r\\n * ### .overwriteProperty(ctx, name, fn)\\r\\n *\\r\\n * Overwrites an already existing property getter and provides\\r\\n * access to previous value. Must return function to use as getter.\\r\\n *\\r\\n *     utils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) {\\r\\n *       return function () {\\r\\n *         var obj = utils.flag(this, 'object');\\r\\n *         if (obj instanceof Foo) {\\r\\n *           new chai.Assertion(obj.name).to.equal('bar');\\r\\n *         } else {\\r\\n *           _super.call(this);\\r\\n *         }\\r\\n *       }\\r\\n *     });\\r\\n *\\r\\n *\\r\\n * Can also be accessed directly from `chai.Assertion`.\\r\\n *\\r\\n *     chai.Assertion.overwriteProperty('foo', fn);\\r\\n *\\r\\n * Then can be used as any other assertion.\\r\\n *\\r\\n *     expect(myFoo).to.be.ok;\\r\\n *\\r\\n * @param {Object} ctx object whose property is to be overwritten\\r\\n * @param {String} name of property to overwrite\\r\\n * @param {Function} getter function that returns a getter function to be used for name\\r\\n * @namespace Utils\\r\\n * @name overwriteProperty\\r\\n * @api public\\r\\n */\\r\\n\\r\\nmodule.exports = function overwriteProperty(ctx, name, getter) {\\r\\n  var _get = Object.getOwnPropertyDescriptor(ctx, name)\\r\\n    , _super = function () {};\\r\\n\\r\\n  if (_get && 'function' === typeof _get.get)\\r\\n    _super = _get.get\\r\\n\\r\\n  Object.defineProperty(ctx, name,\\r\\n    { get: function overwritingPropertyGetter() {\\r\\n        // Setting the `ssfi` flag to `overwritingPropertyGetter` causes this\\r\\n        // function to be the starting point for removing implementation frames\\r\\n        // from the stack trace of a failed assertion.\\r\\n        //\\r\\n        // However, we only want to use this function as the starting point if\\r\\n        // the `lockSsfi` flag isn't set and proxy protection is disabled.\\r\\n        //\\r\\n        // If the `lockSsfi` flag is set, then either this assertion has been\\r\\n        // overwritten by another assertion, or this assertion is being invoked\\r\\n        // from inside of another assertion. In the first case, the `ssfi` flag\\r\\n        // has already been set by the overwriting assertion. In the second\\r\\n        // case, the `ssfi` flag has already been set by the outer assertion.\\r\\n        //\\r\\n        // If proxy protection is enabled, then the `ssfi` flag has already been\\r\\n        // set by the proxy getter.\\r\\n        if (!isProxyEnabled() && !flag(this, 'lockSsfi')) {\\r\\n          flag(this, 'ssfi', overwritingPropertyGetter);\\r\\n        }\\r\\n\\r\\n        // Setting the `lockSsfi` flag to `true` prevents the overwritten\\r\\n        // assertion from changing the `ssfi` flag. By this point, the `ssfi`\\r\\n        // flag is already set to the correct starting point for this assertion.\\r\\n        var origLockSsfi = flag(this, 'lockSsfi');\\r\\n        flag(this, 'lockSsfi', true);\\r\\n        var result = getter(_super).call(this);\\r\\n        flag(this, 'lockSsfi', origLockSsfi);\\r\\n\\r\\n        if (result !== undefined) {\\r\\n          return result;\\r\\n        }\\r\\n\\r\\n        var newAssertion = new chai.Assertion();\\r\\n        transferFlags(this, newAssertion);\\r\\n        return newAssertion;\\r\\n      }\\r\\n    , configurable: true\\r\\n  });\\r\\n};\\r\\n\\n\\n//# sourceURL=webpack:///./node_modules/chai/lib/chai/utils/overwriteProperty.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/chai/lib/chai/utils/proxify.js\":\n/*!*****************************************************!*\\\n  !*** ./node_modules/chai/lib/chai/utils/proxify.js ***!\n  \\*****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\neval(\"var config = __webpack_require__(/*! ../config */ \\\"./node_modules/chai/lib/chai/config.js\\\");\\r\\nvar flag = __webpack_require__(/*! ./flag */ \\\"./node_modules/chai/lib/chai/utils/flag.js\\\");\\r\\nvar getProperties = __webpack_require__(/*! ./getProperties */ \\\"./node_modules/chai/lib/chai/utils/getProperties.js\\\");\\r\\nvar isProxyEnabled = __webpack_require__(/*! ./isProxyEnabled */ \\\"./node_modules/chai/lib/chai/utils/isProxyEnabled.js\\\");\\r\\n\\r\\n/*!\\r\\n * Chai - proxify utility\\r\\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\\r\\n * MIT Licensed\\r\\n */\\r\\n\\r\\n/**\\r\\n * ### .proxify(object)\\r\\n *\\r\\n * Return a proxy of given object that throws an error when a non-existent\\r\\n * property is read. By default, the root cause is assumed to be a misspelled\\r\\n * property, and thus an attempt is made to offer a reasonable suggestion from\\r\\n * the list of existing properties. However, if a nonChainableMethodName is\\r\\n * provided, then the root cause is instead a failure to invoke a non-chainable\\r\\n * method prior to reading the non-existent property.\\r\\n *\\r\\n * If proxies are unsupported or disabled via the user's Chai config, then\\r\\n * return object without modification.\\r\\n *\\r\\n * @param {Object} obj\\r\\n * @param {String} nonChainableMethodName\\r\\n * @namespace Utils\\r\\n * @name proxify\\r\\n */\\r\\n\\r\\nvar builtins = ['__flags', '__methods', '_obj', 'assert'];\\r\\n\\r\\nmodule.exports = function proxify(obj, nonChainableMethodName) {\\r\\n  if (!isProxyEnabled()) return obj;\\r\\n\\r\\n  return new Proxy(obj, {\\r\\n    get: function proxyGetter(target, property) {\\r\\n      // This check is here because we should not throw errors on Symbol properties\\r\\n      // such as `Symbol.toStringTag`.\\r\\n      // The values for which an error should be thrown can be configured using\\r\\n      // the `config.proxyExcludedKeys` setting.\\r\\n      if (typeof property === 'string' &&\\r\\n          config.proxyExcludedKeys.indexOf(property) === -1 &&\\r\\n          !Reflect.has(target, property)) {\\r\\n        // Special message for invalid property access of non-chainable methods.\\r\\n        if (nonChainableMethodName) {\\r\\n          throw Error('Invalid Chai property: ' + nonChainableMethodName + '.' +\\r\\n            property + '. See docs for proper usage of \\\"' +\\r\\n            nonChainableMethodName + '\\\".');\\r\\n        }\\r\\n\\r\\n        // If the property is reasonably close to an existing Chai property,\\r\\n        // suggest that property to the user. Only suggest properties with a\\r\\n        // distance less than 4.\\r\\n        var suggestion = null;\\r\\n        var suggestionDistance = 4;\\r\\n        getProperties(target).forEach(function(prop) {\\r\\n          if (\\r\\n            !Object.prototype.hasOwnProperty(prop) &&\\r\\n            builtins.indexOf(prop) === -1\\r\\n          ) {\\r\\n            var dist = stringDistanceCapped(\\r\\n              property,\\r\\n              prop,\\r\\n              suggestionDistance\\r\\n            );\\r\\n            if (dist < suggestionDistance) {\\r\\n              suggestion = prop;\\r\\n              suggestionDistance = dist;\\r\\n            }\\r\\n          }\\r\\n        });\\r\\n\\r\\n        if (suggestion !== null) {\\r\\n          throw Error('Invalid Chai property: ' + property +\\r\\n            '. Did you mean \\\"' + suggestion + '\\\"?');\\r\\n        } else {\\r\\n          throw Error('Invalid Chai property: ' + property);\\r\\n        }\\r\\n      }\\r\\n\\r\\n      // Use this proxy getter as the starting point for removing implementation\\r\\n      // frames from the stack trace of a failed assertion. For property\\r\\n      // assertions, this prevents the proxy getter from showing up in the stack\\r\\n      // trace since it's invoked before the property getter. For method and\\r\\n      // chainable method assertions, this flag will end up getting changed to\\r\\n      // the method wrapper, which is good since this frame will no longer be in\\r\\n      // the stack once the method is invoked. Note that Chai builtin assertion\\r\\n      // properties such as `__flags` are skipped since this is only meant to\\r\\n      // capture the starting point of an assertion. This step is also skipped\\r\\n      // if the `lockSsfi` flag is set, thus indicating that this assertion is\\r\\n      // being called from within another assertion. In that case, the `ssfi`\\r\\n      // flag is already set to the outer assertion's starting point.\\r\\n      if (builtins.indexOf(property) === -1 && !flag(target, 'lockSsfi')) {\\r\\n        flag(target, 'ssfi', proxyGetter);\\r\\n      }\\r\\n\\r\\n      return Reflect.get(target, property);\\r\\n    }\\r\\n  });\\r\\n};\\r\\n\\r\\n/**\\r\\n * # stringDistanceCapped(strA, strB, cap)\\r\\n * Return the Levenshtein distance between two strings, but no more than cap.\\r\\n * @param {string} strA\\r\\n * @param {string} strB\\r\\n * @param {number} number\\r\\n * @return {number} min(string distance between strA and strB, cap)\\r\\n * @api private\\r\\n */\\r\\n\\r\\nfunction stringDistanceCapped(strA, strB, cap) {\\r\\n  if (Math.abs(strA.length - strB.length) >= cap) {\\r\\n    return cap;\\r\\n  }\\r\\n\\r\\n  var memo = [];\\r\\n  // `memo` is a two-dimensional array containing distances.\\r\\n  // memo[i][j] is the distance between strA.slice(0, i) and\\r\\n  // strB.slice(0, j).\\r\\n  for (var i = 0; i <= strA.length; i++) {\\r\\n    memo[i] = Array(strB.length + 1).fill(0);\\r\\n    memo[i][0] = i;\\r\\n  }\\r\\n  for (var j = 0; j < strB.length; j++) {\\r\\n    memo[0][j] = j;\\r\\n  }\\r\\n\\r\\n  for (var i = 1; i <= strA.length; i++) {\\r\\n    var ch = strA.charCodeAt(i - 1);\\r\\n    for (var j = 1; j <= strB.length; j++) {\\r\\n      if (Math.abs(i - j) >= cap) {\\r\\n        memo[i][j] = cap;\\r\\n        continue;\\r\\n      }\\r\\n      memo[i][j] = Math.min(\\r\\n        memo[i - 1][j] + 1,\\r\\n        memo[i][j - 1] + 1,\\r\\n        memo[i - 1][j - 1] +\\r\\n          (ch === strB.charCodeAt(j - 1) ? 0 : 1)\\r\\n      );\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return memo[strA.length][strB.length];\\r\\n}\\r\\n\\n\\n//# sourceURL=webpack:///./node_modules/chai/lib/chai/utils/proxify.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/chai/lib/chai/utils/test.js\":\n/*!**************************************************!*\\\n  !*** ./node_modules/chai/lib/chai/utils/test.js ***!\n  \\**************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\neval(\"/*!\\r\\n * Chai - test utility\\r\\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\\r\\n * MIT Licensed\\r\\n */\\r\\n\\r\\n/*!\\r\\n * Module dependencies\\r\\n */\\r\\n\\r\\nvar flag = __webpack_require__(/*! ./flag */ \\\"./node_modules/chai/lib/chai/utils/flag.js\\\");\\r\\n\\r\\n/**\\r\\n * ### .test(object, expression)\\r\\n *\\r\\n * Test and object for expression.\\r\\n *\\r\\n * @param {Object} object (constructed Assertion)\\r\\n * @param {Arguments} chai.Assertion.prototype.assert arguments\\r\\n * @namespace Utils\\r\\n * @name test\\r\\n */\\r\\n\\r\\nmodule.exports = function test(obj, args) {\\r\\n  var negate = flag(obj, 'negate')\\r\\n    , expr = args[0];\\r\\n  return negate ? !expr : expr;\\r\\n};\\r\\n\\n\\n//# sourceURL=webpack:///./node_modules/chai/lib/chai/utils/test.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/chai/lib/chai/utils/transferFlags.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/chai/lib/chai/utils/transferFlags.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\neval(\"/*!\\r\\n * Chai - transferFlags utility\\r\\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\\r\\n * MIT Licensed\\r\\n */\\r\\n\\r\\n/**\\r\\n * ### .transferFlags(assertion, object, includeAll = true)\\r\\n *\\r\\n * Transfer all the flags for `assertion` to `object`. If\\r\\n * `includeAll` is set to `false`, then the base Chai\\r\\n * assertion flags (namely `object`, `ssfi`, `lockSsfi`,\\r\\n * and `message`) will not be transferred.\\r\\n *\\r\\n *\\r\\n *     var newAssertion = new Assertion();\\r\\n *     utils.transferFlags(assertion, newAssertion);\\r\\n *\\r\\n *     var anotherAssertion = new Assertion(myObj);\\r\\n *     utils.transferFlags(assertion, anotherAssertion, false);\\r\\n *\\r\\n * @param {Assertion} assertion the assertion to transfer the flags from\\r\\n * @param {Object} object the object to transfer the flags to; usually a new assertion\\r\\n * @param {Boolean} includeAll\\r\\n * @namespace Utils\\r\\n * @name transferFlags\\r\\n * @api private\\r\\n */\\r\\n\\r\\nmodule.exports = function transferFlags(assertion, object, includeAll) {\\r\\n  var flags = assertion.__flags || (assertion.__flags = Object.create(null));\\r\\n\\r\\n  if (!object.__flags) {\\r\\n    object.__flags = Object.create(null);\\r\\n  }\\r\\n\\r\\n  includeAll = arguments.length === 3 ? includeAll : true;\\r\\n\\r\\n  for (var flag in flags) {\\r\\n    if (includeAll ||\\r\\n        (flag !== 'object' && flag !== 'ssfi' && flag !== 'lockSsfi' && flag != 'message')) {\\r\\n      object.__flags[flag] = flags[flag];\\r\\n    }\\r\\n  }\\r\\n};\\r\\n\\n\\n//# sourceURL=webpack:///./node_modules/chai/lib/chai/utils/transferFlags.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/check-error/index.js\":\n/*!*******************************************!*\\\n  !*** ./node_modules/check-error/index.js ***!\n  \\*******************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"\\r\\n\\r\\n/* !\\r\\n * Chai - checkError utility\\r\\n * Copyright(c) 2012-2016 Jake Luer <jake@alogicalparadox.com>\\r\\n * MIT Licensed\\r\\n */\\r\\n\\r\\n/**\\r\\n * ### .checkError\\r\\n *\\r\\n * Checks that an error conforms to a given set of criteria and/or retrieves information about it.\\r\\n *\\r\\n * @api public\\r\\n */\\r\\n\\r\\n/**\\r\\n * ### .compatibleInstance(thrown, errorLike)\\r\\n *\\r\\n * Checks if two instances are compatible (strict equal).\\r\\n * Returns false if errorLike is not an instance of Error, because instances\\r\\n * can only be compatible if they're both error instances.\\r\\n *\\r\\n * @name compatibleInstance\\r\\n * @param {Error} thrown error\\r\\n * @param {Error|ErrorConstructor} errorLike object to compare against\\r\\n * @namespace Utils\\r\\n * @api public\\r\\n */\\r\\n\\r\\nfunction compatibleInstance(thrown, errorLike) {\\r\\n  return errorLike instanceof Error && thrown === errorLike;\\r\\n}\\r\\n\\r\\n/**\\r\\n * ### .compatibleConstructor(thrown, errorLike)\\r\\n *\\r\\n * Checks if two constructors are compatible.\\r\\n * This function can receive either an error constructor or\\r\\n * an error instance as the `errorLike` argument.\\r\\n * Constructors are compatible if they're the same or if one is\\r\\n * an instance of another.\\r\\n *\\r\\n * @name compatibleConstructor\\r\\n * @param {Error} thrown error\\r\\n * @param {Error|ErrorConstructor} errorLike object to compare against\\r\\n * @namespace Utils\\r\\n * @api public\\r\\n */\\r\\n\\r\\nfunction compatibleConstructor(thrown, errorLike) {\\r\\n  if (errorLike instanceof Error) {\\r\\n    // If `errorLike` is an instance of any error we compare their constructors\\r\\n    return thrown.constructor === errorLike.constructor || thrown instanceof errorLike.constructor;\\r\\n  } else if (errorLike.prototype instanceof Error || errorLike === Error) {\\r\\n    // If `errorLike` is a constructor that inherits from Error, we compare `thrown` to `errorLike` directly\\r\\n    return thrown.constructor === errorLike || thrown instanceof errorLike;\\r\\n  }\\r\\n\\r\\n  return false;\\r\\n}\\r\\n\\r\\n/**\\r\\n * ### .compatibleMessage(thrown, errMatcher)\\r\\n *\\r\\n * Checks if an error's message is compatible with a matcher (String or RegExp).\\r\\n * If the message contains the String or passes the RegExp test,\\r\\n * it is considered compatible.\\r\\n *\\r\\n * @name compatibleMessage\\r\\n * @param {Error} thrown error\\r\\n * @param {String|RegExp} errMatcher to look for into the message\\r\\n * @namespace Utils\\r\\n * @api public\\r\\n */\\r\\n\\r\\nfunction compatibleMessage(thrown, errMatcher) {\\r\\n  var comparisonString = typeof thrown === 'string' ? thrown : thrown.message;\\r\\n  if (errMatcher instanceof RegExp) {\\r\\n    return errMatcher.test(comparisonString);\\r\\n  } else if (typeof errMatcher === 'string') {\\r\\n    return comparisonString.indexOf(errMatcher) !== -1; // eslint-disable-line no-magic-numbers\\r\\n  }\\r\\n\\r\\n  return false;\\r\\n}\\r\\n\\r\\n/**\\r\\n * ### .getFunctionName(constructorFn)\\r\\n *\\r\\n * Returns the name of a function.\\r\\n * This also includes a polyfill function if `constructorFn.name` is not defined.\\r\\n *\\r\\n * @name getFunctionName\\r\\n * @param {Function} constructorFn\\r\\n * @namespace Utils\\r\\n * @api private\\r\\n */\\r\\n\\r\\nvar functionNameMatch = /\\\\s*function(?:\\\\s|\\\\s*\\\\/\\\\*[^(?:*\\\\/)]+\\\\*\\\\/\\\\s*)*([^\\\\(\\\\/]+)/;\\r\\nfunction getFunctionName(constructorFn) {\\r\\n  var name = '';\\r\\n  if (typeof constructorFn.name === 'undefined') {\\r\\n    // Here we run a polyfill if constructorFn.name is not defined\\r\\n    var match = String(constructorFn).match(functionNameMatch);\\r\\n    if (match) {\\r\\n      name = match[1];\\r\\n    }\\r\\n  } else {\\r\\n    name = constructorFn.name;\\r\\n  }\\r\\n\\r\\n  return name;\\r\\n}\\r\\n\\r\\n/**\\r\\n * ### .getConstructorName(errorLike)\\r\\n *\\r\\n * Gets the constructor name for an Error instance or constructor itself.\\r\\n *\\r\\n * @name getConstructorName\\r\\n * @param {Error|ErrorConstructor} errorLike\\r\\n * @namespace Utils\\r\\n * @api public\\r\\n */\\r\\n\\r\\nfunction getConstructorName(errorLike) {\\r\\n  var constructorName = errorLike;\\r\\n  if (errorLike instanceof Error) {\\r\\n    constructorName = getFunctionName(errorLike.constructor);\\r\\n  } else if (typeof errorLike === 'function') {\\r\\n    // If `err` is not an instance of Error it is an error constructor itself or another function.\\r\\n    // If we've got a common function we get its name, otherwise we may need to create a new instance\\r\\n    // of the error just in case it's a poorly-constructed error. Please see chaijs/chai/issues/45 to know more.\\r\\n    constructorName = getFunctionName(errorLike).trim() ||\\r\\n        getFunctionName(new errorLike()); // eslint-disable-line new-cap\\r\\n  }\\r\\n\\r\\n  return constructorName;\\r\\n}\\r\\n\\r\\n/**\\r\\n * ### .getMessage(errorLike)\\r\\n *\\r\\n * Gets the error message from an error.\\r\\n * If `err` is a String itself, we return it.\\r\\n * If the error has no message, we return an empty string.\\r\\n *\\r\\n * @name getMessage\\r\\n * @param {Error|String} errorLike\\r\\n * @namespace Utils\\r\\n * @api public\\r\\n */\\r\\n\\r\\nfunction getMessage(errorLike) {\\r\\n  var msg = '';\\r\\n  if (errorLike && errorLike.message) {\\r\\n    msg = errorLike.message;\\r\\n  } else if (typeof errorLike === 'string') {\\r\\n    msg = errorLike;\\r\\n  }\\r\\n\\r\\n  return msg;\\r\\n}\\r\\n\\r\\nmodule.exports = {\\r\\n  compatibleInstance: compatibleInstance,\\r\\n  compatibleConstructor: compatibleConstructor,\\r\\n  compatibleMessage: compatibleMessage,\\r\\n  getMessage: getMessage,\\r\\n  getConstructorName: getConstructorName,\\r\\n};\\r\\n\\n\\n//# sourceURL=webpack:///./node_modules/check-error/index.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/deep-eql/index.js\":\n/*!****************************************!*\\\n  !*** ./node_modules/deep-eql/index.js ***!\n  \\****************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"\\r\\n/* globals Symbol: false, Uint8Array: false, WeakMap: false */\\r\\n/*!\\r\\n * deep-eql\\r\\n * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>\\r\\n * MIT Licensed\\r\\n */\\r\\n\\r\\nvar type = __webpack_require__(/*! type-detect */ \\\"./node_modules/type-detect/type-detect.js\\\");\\r\\nfunction FakeMap() {\\r\\n  this._key = 'chai/deep-eql__' + Math.random() + Date.now();\\r\\n}\\r\\n\\r\\nFakeMap.prototype = {\\r\\n  get: function getMap(key) {\\r\\n    return key[this._key];\\r\\n  },\\r\\n  set: function setMap(key, value) {\\r\\n    if (Object.isExtensible(key)) {\\r\\n      Object.defineProperty(key, this._key, {\\r\\n        value: value,\\r\\n        configurable: true,\\r\\n      });\\r\\n    }\\r\\n  },\\r\\n};\\r\\n\\r\\nvar MemoizeMap = typeof WeakMap === 'function' ? WeakMap : FakeMap;\\r\\n/*!\\r\\n * Check to see if the MemoizeMap has recorded a result of the two operands\\r\\n *\\r\\n * @param {Mixed} leftHandOperand\\r\\n * @param {Mixed} rightHandOperand\\r\\n * @param {MemoizeMap} memoizeMap\\r\\n * @returns {Boolean|null} result\\r\\n*/\\r\\nfunction memoizeCompare(leftHandOperand, rightHandOperand, memoizeMap) {\\r\\n  // Technically, WeakMap keys can *only* be objects, not primitives.\\r\\n  if (!memoizeMap || isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {\\r\\n    return null;\\r\\n  }\\r\\n  var leftHandMap = memoizeMap.get(leftHandOperand);\\r\\n  if (leftHandMap) {\\r\\n    var result = leftHandMap.get(rightHandOperand);\\r\\n    if (typeof result === 'boolean') {\\r\\n      return result;\\r\\n    }\\r\\n  }\\r\\n  return null;\\r\\n}\\r\\n\\r\\n/*!\\r\\n * Set the result of the equality into the MemoizeMap\\r\\n *\\r\\n * @param {Mixed} leftHandOperand\\r\\n * @param {Mixed} rightHandOperand\\r\\n * @param {MemoizeMap} memoizeMap\\r\\n * @param {Boolean} result\\r\\n*/\\r\\nfunction memoizeSet(leftHandOperand, rightHandOperand, memoizeMap, result) {\\r\\n  // Technically, WeakMap keys can *only* be objects, not primitives.\\r\\n  if (!memoizeMap || isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {\\r\\n    return;\\r\\n  }\\r\\n  var leftHandMap = memoizeMap.get(leftHandOperand);\\r\\n  if (leftHandMap) {\\r\\n    leftHandMap.set(rightHandOperand, result);\\r\\n  } else {\\r\\n    leftHandMap = new MemoizeMap();\\r\\n    leftHandMap.set(rightHandOperand, result);\\r\\n    memoizeMap.set(leftHandOperand, leftHandMap);\\r\\n  }\\r\\n}\\r\\n\\r\\n/*!\\r\\n * Primary Export\\r\\n */\\r\\n\\r\\nmodule.exports = deepEqual;\\r\\nmodule.exports.MemoizeMap = MemoizeMap;\\r\\n\\r\\n/**\\r\\n * Assert deeply nested sameValue equality between two objects of any type.\\r\\n *\\r\\n * @param {Mixed} leftHandOperand\\r\\n * @param {Mixed} rightHandOperand\\r\\n * @param {Object} [options] (optional) Additional options\\r\\n * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.\\r\\n * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of\\r\\n    complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular\\r\\n    references to blow the stack.\\r\\n * @return {Boolean} equal match\\r\\n */\\r\\nfunction deepEqual(leftHandOperand, rightHandOperand, options) {\\r\\n  // If we have a comparator, we can't assume anything; so bail to its check first.\\r\\n  if (options && options.comparator) {\\r\\n    return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);\\r\\n  }\\r\\n\\r\\n  var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);\\r\\n  if (simpleResult !== null) {\\r\\n    return simpleResult;\\r\\n  }\\r\\n\\r\\n  // Deeper comparisons are pushed through to a larger function\\r\\n  return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);\\r\\n}\\r\\n\\r\\n/**\\r\\n * Many comparisons can be canceled out early via simple equality or primitive checks.\\r\\n * @param {Mixed} leftHandOperand\\r\\n * @param {Mixed} rightHandOperand\\r\\n * @return {Boolean|null} equal match\\r\\n */\\r\\nfunction simpleEqual(leftHandOperand, rightHandOperand) {\\r\\n  // Equal references (except for Numbers) can be returned early\\r\\n  if (leftHandOperand === rightHandOperand) {\\r\\n    // Handle +-0 cases\\r\\n    return leftHandOperand !== 0 || 1 / leftHandOperand === 1 / rightHandOperand;\\r\\n  }\\r\\n\\r\\n  // handle NaN cases\\r\\n  if (\\r\\n    leftHandOperand !== leftHandOperand && // eslint-disable-line no-self-compare\\r\\n    rightHandOperand !== rightHandOperand // eslint-disable-line no-self-compare\\r\\n  ) {\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  // Anything that is not an 'object', i.e. symbols, functions, booleans, numbers,\\r\\n  // strings, and undefined, can be compared by reference.\\r\\n  if (isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {\\r\\n    // Easy out b/c it would have passed the first equality check\\r\\n    return false;\\r\\n  }\\r\\n  return null;\\r\\n}\\r\\n\\r\\n/*!\\r\\n * The main logic of the `deepEqual` function.\\r\\n *\\r\\n * @param {Mixed} leftHandOperand\\r\\n * @param {Mixed} rightHandOperand\\r\\n * @param {Object} [options] (optional) Additional options\\r\\n * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.\\r\\n * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of\\r\\n    complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular\\r\\n    references to blow the stack.\\r\\n * @return {Boolean} equal match\\r\\n*/\\r\\nfunction extensiveDeepEqual(leftHandOperand, rightHandOperand, options) {\\r\\n  options = options || {};\\r\\n  options.memoize = options.memoize === false ? false : options.memoize || new MemoizeMap();\\r\\n  var comparator = options && options.comparator;\\r\\n\\r\\n  // Check if a memoized result exists.\\r\\n  var memoizeResultLeft = memoizeCompare(leftHandOperand, rightHandOperand, options.memoize);\\r\\n  if (memoizeResultLeft !== null) {\\r\\n    return memoizeResultLeft;\\r\\n  }\\r\\n  var memoizeResultRight = memoizeCompare(rightHandOperand, leftHandOperand, options.memoize);\\r\\n  if (memoizeResultRight !== null) {\\r\\n    return memoizeResultRight;\\r\\n  }\\r\\n\\r\\n  // If a comparator is present, use it.\\r\\n  if (comparator) {\\r\\n    var comparatorResult = comparator(leftHandOperand, rightHandOperand);\\r\\n    // Comparators may return null, in which case we want to go back to default behavior.\\r\\n    if (comparatorResult === false || comparatorResult === true) {\\r\\n      memoizeSet(leftHandOperand, rightHandOperand, options.memoize, comparatorResult);\\r\\n      return comparatorResult;\\r\\n    }\\r\\n    // To allow comparators to override *any* behavior, we ran them first. Since it didn't decide\\r\\n    // what to do, we need to make sure to return the basic tests first before we move on.\\r\\n    var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);\\r\\n    if (simpleResult !== null) {\\r\\n      // Don't memoize this, it takes longer to set/retrieve than to just compare.\\r\\n      return simpleResult;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  var leftHandType = type(leftHandOperand);\\r\\n  if (leftHandType !== type(rightHandOperand)) {\\r\\n    memoizeSet(leftHandOperand, rightHandOperand, options.memoize, false);\\r\\n    return false;\\r\\n  }\\r\\n\\r\\n  // Temporarily set the operands in the memoize object to prevent blowing the stack\\r\\n  memoizeSet(leftHandOperand, rightHandOperand, options.memoize, true);\\r\\n\\r\\n  var result = extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options);\\r\\n  memoizeSet(leftHandOperand, rightHandOperand, options.memoize, result);\\r\\n  return result;\\r\\n}\\r\\n\\r\\nfunction extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options) {\\r\\n  switch (leftHandType) {\\r\\n    case 'String':\\r\\n    case 'Number':\\r\\n    case 'Boolean':\\r\\n    case 'Date':\\r\\n      // If these types are their instance types (e.g. `new Number`) then re-deepEqual against their values\\r\\n      return deepEqual(leftHandOperand.valueOf(), rightHandOperand.valueOf());\\r\\n    case 'Promise':\\r\\n    case 'Symbol':\\r\\n    case 'function':\\r\\n    case 'WeakMap':\\r\\n    case 'WeakSet':\\r\\n    case 'Error':\\r\\n      return leftHandOperand === rightHandOperand;\\r\\n    case 'Arguments':\\r\\n    case 'Int8Array':\\r\\n    case 'Uint8Array':\\r\\n    case 'Uint8ClampedArray':\\r\\n    case 'Int16Array':\\r\\n    case 'Uint16Array':\\r\\n    case 'Int32Array':\\r\\n    case 'Uint32Array':\\r\\n    case 'Float32Array':\\r\\n    case 'Float64Array':\\r\\n    case 'Array':\\r\\n      return iterableEqual(leftHandOperand, rightHandOperand, options);\\r\\n    case 'RegExp':\\r\\n      return regexpEqual(leftHandOperand, rightHandOperand);\\r\\n    case 'Generator':\\r\\n      return generatorEqual(leftHandOperand, rightHandOperand, options);\\r\\n    case 'DataView':\\r\\n      return iterableEqual(new Uint8Array(leftHandOperand.buffer), new Uint8Array(rightHandOperand.buffer), options);\\r\\n    case 'ArrayBuffer':\\r\\n      return iterableEqual(new Uint8Array(leftHandOperand), new Uint8Array(rightHandOperand), options);\\r\\n    case 'Set':\\r\\n      return entriesEqual(leftHandOperand, rightHandOperand, options);\\r\\n    case 'Map':\\r\\n      return entriesEqual(leftHandOperand, rightHandOperand, options);\\r\\n    default:\\r\\n      return objectEqual(leftHandOperand, rightHandOperand, options);\\r\\n  }\\r\\n}\\r\\n\\r\\n/*!\\r\\n * Compare two Regular Expressions for equality.\\r\\n *\\r\\n * @param {RegExp} leftHandOperand\\r\\n * @param {RegExp} rightHandOperand\\r\\n * @return {Boolean} result\\r\\n */\\r\\n\\r\\nfunction regexpEqual(leftHandOperand, rightHandOperand) {\\r\\n  return leftHandOperand.toString() === rightHandOperand.toString();\\r\\n}\\r\\n\\r\\n/*!\\r\\n * Compare two Sets/Maps for equality. Faster than other equality functions.\\r\\n *\\r\\n * @param {Set} leftHandOperand\\r\\n * @param {Set} rightHandOperand\\r\\n * @param {Object} [options] (Optional)\\r\\n * @return {Boolean} result\\r\\n */\\r\\n\\r\\nfunction entriesEqual(leftHandOperand, rightHandOperand, options) {\\r\\n  // IE11 doesn't support Set#entries or Set#@@iterator, so we need manually populate using Set#forEach\\r\\n  if (leftHandOperand.size !== rightHandOperand.size) {\\r\\n    return false;\\r\\n  }\\r\\n  if (leftHandOperand.size === 0) {\\r\\n    return true;\\r\\n  }\\r\\n  var leftHandItems = [];\\r\\n  var rightHandItems = [];\\r\\n  leftHandOperand.forEach(function gatherEntries(key, value) {\\r\\n    leftHandItems.push([ key, value ]);\\r\\n  });\\r\\n  rightHandOperand.forEach(function gatherEntries(key, value) {\\r\\n    rightHandItems.push([ key, value ]);\\r\\n  });\\r\\n  return iterableEqual(leftHandItems.sort(), rightHandItems.sort(), options);\\r\\n}\\r\\n\\r\\n/*!\\r\\n * Simple equality for flat iterable objects such as Arrays, TypedArrays or Node.js buffers.\\r\\n *\\r\\n * @param {Iterable} leftHandOperand\\r\\n * @param {Iterable} rightHandOperand\\r\\n * @param {Object} [options] (Optional)\\r\\n * @return {Boolean} result\\r\\n */\\r\\n\\r\\nfunction iterableEqual(leftHandOperand, rightHandOperand, options) {\\r\\n  var length = leftHandOperand.length;\\r\\n  if (length !== rightHandOperand.length) {\\r\\n    return false;\\r\\n  }\\r\\n  if (length === 0) {\\r\\n    return true;\\r\\n  }\\r\\n  var index = -1;\\r\\n  while (++index < length) {\\r\\n    if (deepEqual(leftHandOperand[index], rightHandOperand[index], options) === false) {\\r\\n      return false;\\r\\n    }\\r\\n  }\\r\\n  return true;\\r\\n}\\r\\n\\r\\n/*!\\r\\n * Simple equality for generator objects such as those returned by generator functions.\\r\\n *\\r\\n * @param {Iterable} leftHandOperand\\r\\n * @param {Iterable} rightHandOperand\\r\\n * @param {Object} [options] (Optional)\\r\\n * @return {Boolean} result\\r\\n */\\r\\n\\r\\nfunction generatorEqual(leftHandOperand, rightHandOperand, options) {\\r\\n  return iterableEqual(getGeneratorEntries(leftHandOperand), getGeneratorEntries(rightHandOperand), options);\\r\\n}\\r\\n\\r\\n/*!\\r\\n * Determine if the given object has an @@iterator function.\\r\\n *\\r\\n * @param {Object} target\\r\\n * @return {Boolean} `true` if the object has an @@iterator function.\\r\\n */\\r\\nfunction hasIteratorFunction(target) {\\r\\n  return typeof Symbol !== 'undefined' &&\\r\\n    typeof target === 'object' &&\\r\\n    typeof Symbol.iterator !== 'undefined' &&\\r\\n    typeof target[Symbol.iterator] === 'function';\\r\\n}\\r\\n\\r\\n/*!\\r\\n * Gets all iterator entries from the given Object. If the Object has no @@iterator function, returns an empty array.\\r\\n * This will consume the iterator - which could have side effects depending on the @@iterator implementation.\\r\\n *\\r\\n * @param {Object} target\\r\\n * @returns {Array} an array of entries from the @@iterator function\\r\\n */\\r\\nfunction getIteratorEntries(target) {\\r\\n  if (hasIteratorFunction(target)) {\\r\\n    try {\\r\\n      return getGeneratorEntries(target[Symbol.iterator]());\\r\\n    } catch (iteratorError) {\\r\\n      return [];\\r\\n    }\\r\\n  }\\r\\n  return [];\\r\\n}\\r\\n\\r\\n/*!\\r\\n * Gets all entries from a Generator. This will consume the generator - which could have side effects.\\r\\n *\\r\\n * @param {Generator} target\\r\\n * @returns {Array} an array of entries from the Generator.\\r\\n */\\r\\nfunction getGeneratorEntries(generator) {\\r\\n  var generatorResult = generator.next();\\r\\n  var accumulator = [ generatorResult.value ];\\r\\n  while (generatorResult.done === false) {\\r\\n    generatorResult = generator.next();\\r\\n    accumulator.push(generatorResult.value);\\r\\n  }\\r\\n  return accumulator;\\r\\n}\\r\\n\\r\\n/*!\\r\\n * Gets all own and inherited enumerable keys from a target.\\r\\n *\\r\\n * @param {Object} target\\r\\n * @returns {Array} an array of own and inherited enumerable keys from the target.\\r\\n */\\r\\nfunction getEnumerableKeys(target) {\\r\\n  var keys = [];\\r\\n  for (var key in target) {\\r\\n    keys.push(key);\\r\\n  }\\r\\n  return keys;\\r\\n}\\r\\n\\r\\n/*!\\r\\n * Determines if two objects have matching values, given a set of keys. Defers to deepEqual for the equality check of\\r\\n * each key. If any value of the given key is not equal, the function will return false (early).\\r\\n *\\r\\n * @param {Mixed} leftHandOperand\\r\\n * @param {Mixed} rightHandOperand\\r\\n * @param {Array} keys An array of keys to compare the values of leftHandOperand and rightHandOperand against\\r\\n * @param {Object} [options] (Optional)\\r\\n * @return {Boolean} result\\r\\n */\\r\\nfunction keysEqual(leftHandOperand, rightHandOperand, keys, options) {\\r\\n  var length = keys.length;\\r\\n  if (length === 0) {\\r\\n    return true;\\r\\n  }\\r\\n  for (var i = 0; i < length; i += 1) {\\r\\n    if (deepEqual(leftHandOperand[keys[i]], rightHandOperand[keys[i]], options) === false) {\\r\\n      return false;\\r\\n    }\\r\\n  }\\r\\n  return true;\\r\\n}\\r\\n\\r\\n/*!\\r\\n * Recursively check the equality of two Objects. Once basic sameness has been established it will defer to `deepEqual`\\r\\n * for each enumerable key in the object.\\r\\n *\\r\\n * @param {Mixed} leftHandOperand\\r\\n * @param {Mixed} rightHandOperand\\r\\n * @param {Object} [options] (Optional)\\r\\n * @return {Boolean} result\\r\\n */\\r\\n\\r\\nfunction objectEqual(leftHandOperand, rightHandOperand, options) {\\r\\n  var leftHandKeys = getEnumerableKeys(leftHandOperand);\\r\\n  var rightHandKeys = getEnumerableKeys(rightHandOperand);\\r\\n  if (leftHandKeys.length && leftHandKeys.length === rightHandKeys.length) {\\r\\n    leftHandKeys.sort();\\r\\n    rightHandKeys.sort();\\r\\n    if (iterableEqual(leftHandKeys, rightHandKeys) === false) {\\r\\n      return false;\\r\\n    }\\r\\n    return keysEqual(leftHandOperand, rightHandOperand, leftHandKeys, options);\\r\\n  }\\r\\n\\r\\n  var leftHandEntries = getIteratorEntries(leftHandOperand);\\r\\n  var rightHandEntries = getIteratorEntries(rightHandOperand);\\r\\n  if (leftHandEntries.length && leftHandEntries.length === rightHandEntries.length) {\\r\\n    leftHandEntries.sort();\\r\\n    rightHandEntries.sort();\\r\\n    return iterableEqual(leftHandEntries, rightHandEntries, options);\\r\\n  }\\r\\n\\r\\n  if (leftHandKeys.length === 0 &&\\r\\n      leftHandEntries.length === 0 &&\\r\\n      rightHandKeys.length === 0 &&\\r\\n      rightHandEntries.length === 0) {\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  return false;\\r\\n}\\r\\n\\r\\n/*!\\r\\n * Returns true if the argument is a primitive.\\r\\n *\\r\\n * This intentionally returns true for all objects that can be compared by reference,\\r\\n * including functions and symbols.\\r\\n *\\r\\n * @param {Mixed} value\\r\\n * @return {Boolean} result\\r\\n */\\r\\nfunction isPrimitive(value) {\\r\\n  return value === null || typeof value !== 'object';\\r\\n}\\r\\n\\n\\n//# sourceURL=webpack:///./node_modules/deep-eql/index.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/events/events.js\":\n/*!***************************************!*\\\n  !*** ./node_modules/events/events.js ***!\n  \\***************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"// Copyright Joyent, Inc. and other Node contributors.\\r\\n//\\r\\n// Permission is hereby granted, free of charge, to any person obtaining a\\r\\n// copy of this software and associated documentation files (the\\r\\n// \\\"Software\\\"), to deal in the Software without restriction, including\\r\\n// without limitation the rights to use, copy, modify, merge, publish,\\r\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\r\\n// persons to whom the Software is furnished to do so, subject to the\\r\\n// following conditions:\\r\\n//\\r\\n// The above copyright notice and this permission notice shall be included\\r\\n// in all copies or substantial portions of the Software.\\r\\n//\\r\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\r\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\r\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\r\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\r\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\r\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\r\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\r\\n\\r\\n\\r\\n\\r\\nvar R = typeof Reflect === 'object' ? Reflect : null\\r\\nvar ReflectApply = R && typeof R.apply === 'function'\\r\\n  ? R.apply\\r\\n  : function ReflectApply(target, receiver, args) {\\r\\n    return Function.prototype.apply.call(target, receiver, args);\\r\\n  }\\r\\n\\r\\nvar ReflectOwnKeys\\r\\nif (R && typeof R.ownKeys === 'function') {\\r\\n  ReflectOwnKeys = R.ownKeys\\r\\n} else if (Object.getOwnPropertySymbols) {\\r\\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\\r\\n    return Object.getOwnPropertyNames(target)\\r\\n      .concat(Object.getOwnPropertySymbols(target));\\r\\n  };\\r\\n} else {\\r\\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\\r\\n    return Object.getOwnPropertyNames(target);\\r\\n  };\\r\\n}\\r\\n\\r\\nfunction ProcessEmitWarning(warning) {\\r\\n  if (console && console.warn) console.warn(warning);\\r\\n}\\r\\n\\r\\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\\r\\n  return value !== value;\\r\\n}\\r\\n\\r\\nfunction EventEmitter() {\\r\\n  EventEmitter.init.call(this);\\r\\n}\\r\\nmodule.exports = EventEmitter;\\r\\n\\r\\n// Backwards-compat with node 0.10.x\\r\\nEventEmitter.EventEmitter = EventEmitter;\\r\\n\\r\\nEventEmitter.prototype._events = undefined;\\r\\nEventEmitter.prototype._eventsCount = 0;\\r\\nEventEmitter.prototype._maxListeners = undefined;\\r\\n\\r\\n// By default EventEmitters will print a warning if more than 10 listeners are\\r\\n// added to it. This is a useful default which helps finding memory leaks.\\r\\nvar defaultMaxListeners = 10;\\r\\n\\r\\nfunction checkListener(listener) {\\r\\n  if (typeof listener !== 'function') {\\r\\n    throw new TypeError('The \\\"listener\\\" argument must be of type Function. Received type ' + typeof listener);\\r\\n  }\\r\\n}\\r\\n\\r\\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\\r\\n  enumerable: true,\\r\\n  get: function() {\\r\\n    return defaultMaxListeners;\\r\\n  },\\r\\n  set: function(arg) {\\r\\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\\r\\n      throw new RangeError('The value of \\\"defaultMaxListeners\\\" is out of range. It must be a non-negative number. Received ' + arg + '.');\\r\\n    }\\r\\n    defaultMaxListeners = arg;\\r\\n  }\\r\\n});\\r\\n\\r\\nEventEmitter.init = function() {\\r\\n\\r\\n  if (this._events === undefined ||\\r\\n      this._events === Object.getPrototypeOf(this)._events) {\\r\\n    this._events = Object.create(null);\\r\\n    this._eventsCount = 0;\\r\\n  }\\r\\n\\r\\n  this._maxListeners = this._maxListeners || undefined;\\r\\n};\\r\\n\\r\\n// Obviously not all Emitters should be limited to 10. This function allows\\r\\n// that to be increased. Set to zero for unlimited.\\r\\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\\r\\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\\r\\n    throw new RangeError('The value of \\\"n\\\" is out of range. It must be a non-negative number. Received ' + n + '.');\\r\\n  }\\r\\n  this._maxListeners = n;\\r\\n  return this;\\r\\n};\\r\\n\\r\\nfunction _getMaxListeners(that) {\\r\\n  if (that._maxListeners === undefined)\\r\\n    return EventEmitter.defaultMaxListeners;\\r\\n  return that._maxListeners;\\r\\n}\\r\\n\\r\\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\\r\\n  return _getMaxListeners(this);\\r\\n};\\r\\n\\r\\nEventEmitter.prototype.emit = function emit(type) {\\r\\n  var args = [];\\r\\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\\r\\n  var doError = (type === 'error');\\r\\n\\r\\n  var events = this._events;\\r\\n  if (events !== undefined)\\r\\n    doError = (doError && events.error === undefined);\\r\\n  else if (!doError)\\r\\n    return false;\\r\\n\\r\\n  // If there is no 'error' event listener then throw.\\r\\n  if (doError) {\\r\\n    var er;\\r\\n    if (args.length > 0)\\r\\n      er = args[0];\\r\\n    if (er instanceof Error) {\\r\\n      // Note: The comments on the `throw` lines are intentional, they show\\r\\n      // up in Node's output if this results in an unhandled exception.\\r\\n      throw er; // Unhandled 'error' event\\r\\n    }\\r\\n    // At least give some kind of context to the user\\r\\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\\r\\n    err.context = er;\\r\\n    throw err; // Unhandled 'error' event\\r\\n  }\\r\\n\\r\\n  var handler = events[type];\\r\\n\\r\\n  if (handler === undefined)\\r\\n    return false;\\r\\n\\r\\n  if (typeof handler === 'function') {\\r\\n    ReflectApply(handler, this, args);\\r\\n  } else {\\r\\n    var len = handler.length;\\r\\n    var listeners = arrayClone(handler, len);\\r\\n    for (var i = 0; i < len; ++i)\\r\\n      ReflectApply(listeners[i], this, args);\\r\\n  }\\r\\n\\r\\n  return true;\\r\\n};\\r\\n\\r\\nfunction _addListener(target, type, listener, prepend) {\\r\\n  var m;\\r\\n  var events;\\r\\n  var existing;\\r\\n\\r\\n  checkListener(listener);\\r\\n\\r\\n  events = target._events;\\r\\n  if (events === undefined) {\\r\\n    events = target._events = Object.create(null);\\r\\n    target._eventsCount = 0;\\r\\n  } else {\\r\\n    // To avoid recursion in the case that type === \\\"newListener\\\"! Before\\r\\n    // adding it to the listeners, first emit \\\"newListener\\\".\\r\\n    if (events.newListener !== undefined) {\\r\\n      target.emit('newListener', type,\\r\\n                  listener.listener ? listener.listener : listener);\\r\\n\\r\\n      // Re-assign `events` because a newListener handler could have caused the\\r\\n      // this._events to be assigned to a new object\\r\\n      events = target._events;\\r\\n    }\\r\\n    existing = events[type];\\r\\n  }\\r\\n\\r\\n  if (existing === undefined) {\\r\\n    // Optimize the case of one listener. Don't need the extra array object.\\r\\n    existing = events[type] = listener;\\r\\n    ++target._eventsCount;\\r\\n  } else {\\r\\n    if (typeof existing === 'function') {\\r\\n      // Adding the second element, need to change to array.\\r\\n      existing = events[type] =\\r\\n        prepend ? [listener, existing] : [existing, listener];\\r\\n      // If we've already got an array, just append.\\r\\n    } else if (prepend) {\\r\\n      existing.unshift(listener);\\r\\n    } else {\\r\\n      existing.push(listener);\\r\\n    }\\r\\n\\r\\n    // Check for listener leak\\r\\n    m = _getMaxListeners(target);\\r\\n    if (m > 0 && existing.length > m && !existing.warned) {\\r\\n      existing.warned = true;\\r\\n      // No error code for this since it is a Warning\\r\\n      // eslint-disable-next-line no-restricted-syntax\\r\\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\\r\\n                          existing.length + ' ' + String(type) + ' listeners ' +\\r\\n                          'added. Use emitter.setMaxListeners() to ' +\\r\\n                          'increase limit');\\r\\n      w.name = 'MaxListenersExceededWarning';\\r\\n      w.emitter = target;\\r\\n      w.type = type;\\r\\n      w.count = existing.length;\\r\\n      ProcessEmitWarning(w);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return target;\\r\\n}\\r\\n\\r\\nEventEmitter.prototype.addListener = function addListener(type, listener) {\\r\\n  return _addListener(this, type, listener, false);\\r\\n};\\r\\n\\r\\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\\r\\n\\r\\nEventEmitter.prototype.prependListener =\\r\\n    function prependListener(type, listener) {\\r\\n      return _addListener(this, type, listener, true);\\r\\n    };\\r\\n\\r\\nfunction onceWrapper() {\\r\\n  if (!this.fired) {\\r\\n    this.target.removeListener(this.type, this.wrapFn);\\r\\n    this.fired = true;\\r\\n    if (arguments.length === 0)\\r\\n      return this.listener.call(this.target);\\r\\n    return this.listener.apply(this.target, arguments);\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction _onceWrap(target, type, listener) {\\r\\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\\r\\n  var wrapped = onceWrapper.bind(state);\\r\\n  wrapped.listener = listener;\\r\\n  state.wrapFn = wrapped;\\r\\n  return wrapped;\\r\\n}\\r\\n\\r\\nEventEmitter.prototype.once = function once(type, listener) {\\r\\n  checkListener(listener);\\r\\n  this.on(type, _onceWrap(this, type, listener));\\r\\n  return this;\\r\\n};\\r\\n\\r\\nEventEmitter.prototype.prependOnceListener =\\r\\n    function prependOnceListener(type, listener) {\\r\\n      checkListener(listener);\\r\\n      this.prependListener(type, _onceWrap(this, type, listener));\\r\\n      return this;\\r\\n    };\\r\\n\\r\\n// Emits a 'removeListener' event if and only if the listener was removed.\\r\\nEventEmitter.prototype.removeListener =\\r\\n    function removeListener(type, listener) {\\r\\n      var list, events, position, i, originalListener;\\r\\n\\r\\n      checkListener(listener);\\r\\n\\r\\n      events = this._events;\\r\\n      if (events === undefined)\\r\\n        return this;\\r\\n\\r\\n      list = events[type];\\r\\n      if (list === undefined)\\r\\n        return this;\\r\\n\\r\\n      if (list === listener || list.listener === listener) {\\r\\n        if (--this._eventsCount === 0)\\r\\n          this._events = Object.create(null);\\r\\n        else {\\r\\n          delete events[type];\\r\\n          if (events.removeListener)\\r\\n            this.emit('removeListener', type, list.listener || listener);\\r\\n        }\\r\\n      } else if (typeof list !== 'function') {\\r\\n        position = -1;\\r\\n\\r\\n        for (i = list.length - 1; i >= 0; i--) {\\r\\n          if (list[i] === listener || list[i].listener === listener) {\\r\\n            originalListener = list[i].listener;\\r\\n            position = i;\\r\\n            break;\\r\\n          }\\r\\n        }\\r\\n\\r\\n        if (position < 0)\\r\\n          return this;\\r\\n\\r\\n        if (position === 0)\\r\\n          list.shift();\\r\\n        else {\\r\\n          spliceOne(list, position);\\r\\n        }\\r\\n\\r\\n        if (list.length === 1)\\r\\n          events[type] = list[0];\\r\\n\\r\\n        if (events.removeListener !== undefined)\\r\\n          this.emit('removeListener', type, originalListener || listener);\\r\\n      }\\r\\n\\r\\n      return this;\\r\\n    };\\r\\n\\r\\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\\r\\n\\r\\nEventEmitter.prototype.removeAllListeners =\\r\\n    function removeAllListeners(type) {\\r\\n      var listeners, events, i;\\r\\n\\r\\n      events = this._events;\\r\\n      if (events === undefined)\\r\\n        return this;\\r\\n\\r\\n      // not listening for removeListener, no need to emit\\r\\n      if (events.removeListener === undefined) {\\r\\n        if (arguments.length === 0) {\\r\\n          this._events = Object.create(null);\\r\\n          this._eventsCount = 0;\\r\\n        } else if (events[type] !== undefined) {\\r\\n          if (--this._eventsCount === 0)\\r\\n            this._events = Object.create(null);\\r\\n          else\\r\\n            delete events[type];\\r\\n        }\\r\\n        return this;\\r\\n      }\\r\\n\\r\\n      // emit removeListener for all listeners on all events\\r\\n      if (arguments.length === 0) {\\r\\n        var keys = Object.keys(events);\\r\\n        var key;\\r\\n        for (i = 0; i < keys.length; ++i) {\\r\\n          key = keys[i];\\r\\n          if (key === 'removeListener') continue;\\r\\n          this.removeAllListeners(key);\\r\\n        }\\r\\n        this.removeAllListeners('removeListener');\\r\\n        this._events = Object.create(null);\\r\\n        this._eventsCount = 0;\\r\\n        return this;\\r\\n      }\\r\\n\\r\\n      listeners = events[type];\\r\\n\\r\\n      if (typeof listeners === 'function') {\\r\\n        this.removeListener(type, listeners);\\r\\n      } else if (listeners !== undefined) {\\r\\n        // LIFO order\\r\\n        for (i = listeners.length - 1; i >= 0; i--) {\\r\\n          this.removeListener(type, listeners[i]);\\r\\n        }\\r\\n      }\\r\\n\\r\\n      return this;\\r\\n    };\\r\\n\\r\\nfunction _listeners(target, type, unwrap) {\\r\\n  var events = target._events;\\r\\n\\r\\n  if (events === undefined)\\r\\n    return [];\\r\\n\\r\\n  var evlistener = events[type];\\r\\n  if (evlistener === undefined)\\r\\n    return [];\\r\\n\\r\\n  if (typeof evlistener === 'function')\\r\\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\\r\\n\\r\\n  return unwrap ?\\r\\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\\r\\n}\\r\\n\\r\\nEventEmitter.prototype.listeners = function listeners(type) {\\r\\n  return _listeners(this, type, true);\\r\\n};\\r\\n\\r\\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\\r\\n  return _listeners(this, type, false);\\r\\n};\\r\\n\\r\\nEventEmitter.listenerCount = function(emitter, type) {\\r\\n  if (typeof emitter.listenerCount === 'function') {\\r\\n    return emitter.listenerCount(type);\\r\\n  } else {\\r\\n    return listenerCount.call(emitter, type);\\r\\n  }\\r\\n};\\r\\n\\r\\nEventEmitter.prototype.listenerCount = listenerCount;\\r\\nfunction listenerCount(type) {\\r\\n  var events = this._events;\\r\\n\\r\\n  if (events !== undefined) {\\r\\n    var evlistener = events[type];\\r\\n\\r\\n    if (typeof evlistener === 'function') {\\r\\n      return 1;\\r\\n    } else if (evlistener !== undefined) {\\r\\n      return evlistener.length;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return 0;\\r\\n}\\r\\n\\r\\nEventEmitter.prototype.eventNames = function eventNames() {\\r\\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\\r\\n};\\r\\n\\r\\nfunction arrayClone(arr, n) {\\r\\n  var copy = new Array(n);\\r\\n  for (var i = 0; i < n; ++i)\\r\\n    copy[i] = arr[i];\\r\\n  return copy;\\r\\n}\\r\\n\\r\\nfunction spliceOne(list, index) {\\r\\n  for (; index + 1 < list.length; index++)\\r\\n    list[index] = list[index + 1];\\r\\n  list.pop();\\r\\n}\\r\\n\\r\\nfunction unwrapListeners(arr) {\\r\\n  var ret = new Array(arr.length);\\r\\n  for (var i = 0; i < ret.length; ++i) {\\r\\n    ret[i] = arr[i].listener || arr[i];\\r\\n  }\\r\\n  return ret;\\r\\n}\\r\\n\\n\\n//# sourceURL=webpack:///./node_modules/events/events.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/get-func-name/index.js\":\n/*!*********************************************!*\\\n  !*** ./node_modules/get-func-name/index.js ***!\n  \\*********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"\\r\\n\\r\\n/* !\\r\\n * Chai - getFuncName utility\\r\\n * Copyright(c) 2012-2016 Jake Luer <jake@alogicalparadox.com>\\r\\n * MIT Licensed\\r\\n */\\r\\n\\r\\n/**\\r\\n * ### .getFuncName(constructorFn)\\r\\n *\\r\\n * Returns the name of a function.\\r\\n * When a non-function instance is passed, returns `null`.\\r\\n * This also includes a polyfill function if `aFunc.name` is not defined.\\r\\n *\\r\\n * @name getFuncName\\r\\n * @param {Function} funct\\r\\n * @namespace Utils\\r\\n * @api public\\r\\n */\\r\\n\\r\\nvar toString = Function.prototype.toString;\\r\\nvar functionNameMatch = /\\\\s*function(?:\\\\s|\\\\s*\\\\/\\\\*[^(?:*\\\\/)]+\\\\*\\\\/\\\\s*)*([^\\\\s\\\\(\\\\/]+)/;\\r\\nfunction getFuncName(aFunc) {\\r\\n  if (typeof aFunc !== 'function') {\\r\\n    return null;\\r\\n  }\\r\\n\\r\\n  var name = '';\\r\\n  if (typeof Function.prototype.name === 'undefined' && typeof aFunc.name === 'undefined') {\\r\\n    // Here we run a polyfill if Function does not support the `name` property and if aFunc.name is not defined\\r\\n    var match = toString.call(aFunc).match(functionNameMatch);\\r\\n    if (match) {\\r\\n      name = match[1];\\r\\n    }\\r\\n  } else {\\r\\n    // If we've got a `name` property we just use it\\r\\n    name = aFunc.name;\\r\\n  }\\r\\n\\r\\n  return name;\\r\\n}\\r\\n\\r\\nmodule.exports = getFuncName;\\r\\n\\n\\n//# sourceURL=webpack:///./node_modules/get-func-name/index.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/pathval/index.js\":\n/*!***************************************!*\\\n  !*** ./node_modules/pathval/index.js ***!\n  \\***************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"\\r\\n\\r\\n/* !\\r\\n * Chai - pathval utility\\r\\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\\r\\n * @see https://github.com/logicalparadox/filtr\\r\\n * MIT Licensed\\r\\n */\\r\\n\\r\\n/**\\r\\n * ### .hasProperty(object, name)\\r\\n *\\r\\n * This allows checking whether an object has own\\r\\n * or inherited from prototype chain named property.\\r\\n *\\r\\n * Basically does the same thing as the `in`\\r\\n * operator but works properly with null/undefined values\\r\\n * and other primitives.\\r\\n *\\r\\n *     var obj = {\\r\\n *         arr: ['a', 'b', 'c']\\r\\n *       , str: 'Hello'\\r\\n *     }\\r\\n *\\r\\n * The following would be the results.\\r\\n *\\r\\n *     hasProperty(obj, 'str');  // true\\r\\n *     hasProperty(obj, 'constructor');  // true\\r\\n *     hasProperty(obj, 'bar');  // false\\r\\n *\\r\\n *     hasProperty(obj.str, 'length'); // true\\r\\n *     hasProperty(obj.str, 1);  // true\\r\\n *     hasProperty(obj.str, 5);  // false\\r\\n *\\r\\n *     hasProperty(obj.arr, 'length');  // true\\r\\n *     hasProperty(obj.arr, 2);  // true\\r\\n *     hasProperty(obj.arr, 3);  // false\\r\\n *\\r\\n * @param {Object} object\\r\\n * @param {String|Symbol} name\\r\\n * @returns {Boolean} whether it exists\\r\\n * @namespace Utils\\r\\n * @name hasProperty\\r\\n * @api public\\r\\n */\\r\\n\\r\\nfunction hasProperty(obj, name) {\\r\\n  if (typeof obj === 'undefined' || obj === null) {\\r\\n    return false;\\r\\n  }\\r\\n\\r\\n  // The `in` operator does not work with primitives.\\r\\n  return name in Object(obj);\\r\\n}\\r\\n\\r\\n/* !\\r\\n * ## parsePath(path)\\r\\n *\\r\\n * Helper function used to parse string object\\r\\n * paths. Use in conjunction with `internalGetPathValue`.\\r\\n *\\r\\n *      var parsed = parsePath('myobject.property.subprop');\\r\\n *\\r\\n * ### Paths:\\r\\n *\\r\\n * * Can be infinitely deep and nested.\\r\\n * * Arrays are also valid using the formal `myobject.document[3].property`.\\r\\n * * Literal dots and brackets (not delimiter) must be backslash-escaped.\\r\\n *\\r\\n * @param {String} path\\r\\n * @returns {Object} parsed\\r\\n * @api private\\r\\n */\\r\\n\\r\\nfunction parsePath(path) {\\r\\n  var str = path.replace(/([^\\\\\\\\])\\\\[/g, '$1.[');\\r\\n  var parts = str.match(/(\\\\\\\\\\\\.|[^.]+?)+/g);\\r\\n  return parts.map(function mapMatches(value) {\\r\\n    var regexp = /^\\\\[(\\\\d+)\\\\]$/;\\r\\n    var mArr = regexp.exec(value);\\r\\n    var parsed = null;\\r\\n    if (mArr) {\\r\\n      parsed = { i: parseFloat(mArr[1]) };\\r\\n    } else {\\r\\n      parsed = { p: value.replace(/\\\\\\\\([.\\\\[\\\\]])/g, '$1') };\\r\\n    }\\r\\n\\r\\n    return parsed;\\r\\n  });\\r\\n}\\r\\n\\r\\n/* !\\r\\n * ## internalGetPathValue(obj, parsed[, pathDepth])\\r\\n *\\r\\n * Helper companion function for `.parsePath` that returns\\r\\n * the value located at the parsed address.\\r\\n *\\r\\n *      var value = getPathValue(obj, parsed);\\r\\n *\\r\\n * @param {Object} object to search against\\r\\n * @param {Object} parsed definition from `parsePath`.\\r\\n * @param {Number} depth (nesting level) of the property we want to retrieve\\r\\n * @returns {Object|Undefined} value\\r\\n * @api private\\r\\n */\\r\\n\\r\\nfunction internalGetPathValue(obj, parsed, pathDepth) {\\r\\n  var temporaryValue = obj;\\r\\n  var res = null;\\r\\n  pathDepth = (typeof pathDepth === 'undefined' ? parsed.length : pathDepth);\\r\\n\\r\\n  for (var i = 0; i < pathDepth; i++) {\\r\\n    var part = parsed[i];\\r\\n    if (temporaryValue) {\\r\\n      if (typeof part.p === 'undefined') {\\r\\n        temporaryValue = temporaryValue[part.i];\\r\\n      } else {\\r\\n        temporaryValue = temporaryValue[part.p];\\r\\n      }\\r\\n\\r\\n      if (i === (pathDepth - 1)) {\\r\\n        res = temporaryValue;\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return res;\\r\\n}\\r\\n\\r\\n/* !\\r\\n * ## internalSetPathValue(obj, value, parsed)\\r\\n *\\r\\n * Companion function for `parsePath` that sets\\r\\n * the value located at a parsed address.\\r\\n *\\r\\n *  internalSetPathValue(obj, 'value', parsed);\\r\\n *\\r\\n * @param {Object} object to search and define on\\r\\n * @param {*} value to use upon set\\r\\n * @param {Object} parsed definition from `parsePath`\\r\\n * @api private\\r\\n */\\r\\n\\r\\nfunction internalSetPathValue(obj, val, parsed) {\\r\\n  var tempObj = obj;\\r\\n  var pathDepth = parsed.length;\\r\\n  var part = null;\\r\\n  // Here we iterate through every part of the path\\r\\n  for (var i = 0; i < pathDepth; i++) {\\r\\n    var propName = null;\\r\\n    var propVal = null;\\r\\n    part = parsed[i];\\r\\n\\r\\n    // If it's the last part of the path, we set the 'propName' value with the property name\\r\\n    if (i === (pathDepth - 1)) {\\r\\n      propName = typeof part.p === 'undefined' ? part.i : part.p;\\r\\n      // Now we set the property with the name held by 'propName' on object with the desired val\\r\\n      tempObj[propName] = val;\\r\\n    } else if (typeof part.p !== 'undefined' && tempObj[part.p]) {\\r\\n      tempObj = tempObj[part.p];\\r\\n    } else if (typeof part.i !== 'undefined' && tempObj[part.i]) {\\r\\n      tempObj = tempObj[part.i];\\r\\n    } else {\\r\\n      // If the obj doesn't have the property we create one with that name to define it\\r\\n      var next = parsed[i + 1];\\r\\n      // Here we set the name of the property which will be defined\\r\\n      propName = typeof part.p === 'undefined' ? part.i : part.p;\\r\\n      // Here we decide if this property will be an array or a new object\\r\\n      propVal = typeof next.p === 'undefined' ? [] : {};\\r\\n      tempObj[propName] = propVal;\\r\\n      tempObj = tempObj[propName];\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\n/**\\r\\n * ### .getPathInfo(object, path)\\r\\n *\\r\\n * This allows the retrieval of property info in an\\r\\n * object given a string path.\\r\\n *\\r\\n * The path info consists of an object with the\\r\\n * following properties:\\r\\n *\\r\\n * * parent - The parent object of the property referenced by `path`\\r\\n * * name - The name of the final property, a number if it was an array indexer\\r\\n * * value - The value of the property, if it exists, otherwise `undefined`\\r\\n * * exists - Whether the property exists or not\\r\\n *\\r\\n * @param {Object} object\\r\\n * @param {String} path\\r\\n * @returns {Object} info\\r\\n * @namespace Utils\\r\\n * @name getPathInfo\\r\\n * @api public\\r\\n */\\r\\n\\r\\nfunction getPathInfo(obj, path) {\\r\\n  var parsed = parsePath(path);\\r\\n  var last = parsed[parsed.length - 1];\\r\\n  var info = {\\r\\n    parent: parsed.length > 1 ? internalGetPathValue(obj, parsed, parsed.length - 1) : obj,\\r\\n    name: last.p || last.i,\\r\\n    value: internalGetPathValue(obj, parsed),\\r\\n  };\\r\\n  info.exists = hasProperty(info.parent, info.name);\\r\\n\\r\\n  return info;\\r\\n}\\r\\n\\r\\n/**\\r\\n * ### .getPathValue(object, path)\\r\\n *\\r\\n * This allows the retrieval of values in an\\r\\n * object given a string path.\\r\\n *\\r\\n *     var obj = {\\r\\n *         prop1: {\\r\\n *             arr: ['a', 'b', 'c']\\r\\n *           , str: 'Hello'\\r\\n *         }\\r\\n *       , prop2: {\\r\\n *             arr: [ { nested: 'Universe' } ]\\r\\n *           , str: 'Hello again!'\\r\\n *         }\\r\\n *     }\\r\\n *\\r\\n * The following would be the results.\\r\\n *\\r\\n *     getPathValue(obj, 'prop1.str'); // Hello\\r\\n *     getPathValue(obj, 'prop1.att[2]'); // b\\r\\n *     getPathValue(obj, 'prop2.arr[0].nested'); // Universe\\r\\n *\\r\\n * @param {Object} object\\r\\n * @param {String} path\\r\\n * @returns {Object} value or `undefined`\\r\\n * @namespace Utils\\r\\n * @name getPathValue\\r\\n * @api public\\r\\n */\\r\\n\\r\\nfunction getPathValue(obj, path) {\\r\\n  var info = getPathInfo(obj, path);\\r\\n  return info.value;\\r\\n}\\r\\n\\r\\n/**\\r\\n * ### .setPathValue(object, path, value)\\r\\n *\\r\\n * Define the value in an object at a given string path.\\r\\n *\\r\\n * ```js\\r\\n * var obj = {\\r\\n *     prop1: {\\r\\n *         arr: ['a', 'b', 'c']\\r\\n *       , str: 'Hello'\\r\\n *     }\\r\\n *   , prop2: {\\r\\n *         arr: [ { nested: 'Universe' } ]\\r\\n *       , str: 'Hello again!'\\r\\n *     }\\r\\n * };\\r\\n * ```\\r\\n *\\r\\n * The following would be acceptable.\\r\\n *\\r\\n * ```js\\r\\n * var properties = require('tea-properties');\\r\\n * properties.set(obj, 'prop1.str', 'Hello Universe!');\\r\\n * properties.set(obj, 'prop1.arr[2]', 'B');\\r\\n * properties.set(obj, 'prop2.arr[0].nested.value', { hello: 'universe' });\\r\\n * ```\\r\\n *\\r\\n * @param {Object} object\\r\\n * @param {String} path\\r\\n * @param {Mixed} value\\r\\n * @api private\\r\\n */\\r\\n\\r\\nfunction setPathValue(obj, path, val) {\\r\\n  var parsed = parsePath(path);\\r\\n  internalSetPathValue(obj, val, parsed);\\r\\n  return obj;\\r\\n}\\r\\n\\r\\nmodule.exports = {\\r\\n  hasProperty: hasProperty,\\r\\n  getPathInfo: getPathInfo,\\r\\n  getPathValue: getPathValue,\\r\\n  setPathValue: setPathValue,\\r\\n};\\r\\n\\n\\n//# sourceURL=webpack:///./node_modules/pathval/index.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/three/build/three.module.js\":\n/*!**************************************************!*\\\n  !*** ./node_modules/three/build/three.module.js ***!\n  \\**************************************************/\n/*! exports provided: ACESFilmicToneMapping, AddEquation, AddOperation, AdditiveAnimationBlendMode, AdditiveBlending, AlphaFormat, AlwaysDepth, AlwaysStencilFunc, AmbientLight, AmbientLightProbe, AnimationClip, AnimationLoader, AnimationMixer, AnimationObjectGroup, AnimationUtils, ArcCurve, ArrayCamera, ArrowHelper, Audio, AudioAnalyser, AudioContext, AudioListener, AudioLoader, AxesHelper, AxisHelper, BackSide, BasicDepthPacking, BasicShadowMap, BinaryTextureLoader, Bone, BooleanKeyframeTrack, BoundingBoxHelper, Box2, Box3, Box3Helper, BoxBufferGeometry, BoxGeometry, BoxHelper, BufferAttribute, BufferGeometry, BufferGeometryLoader, ByteType, Cache, Camera, CameraHelper, CanvasRenderer, CanvasTexture, CatmullRomCurve3, CineonToneMapping, CircleBufferGeometry, CircleGeometry, ClampToEdgeWrapping, Clock, ClosedSplineCurve3, Color, ColorKeyframeTrack, CompressedTexture, CompressedTextureLoader, ConeBufferGeometry, ConeGeometry, CubeCamera, CubeGeometry, CubeReflectionMapping, CubeRefractionMapping, CubeTexture, CubeTextureLoader, CubeUVReflectionMapping, CubeUVRefractionMapping, CubicBezierCurve, CubicBezierCurve3, CubicInterpolant, CullFaceBack, CullFaceFront, CullFaceFrontBack, CullFaceNone, Curve, CurvePath, CustomBlending, CylinderBufferGeometry, CylinderGeometry, Cylindrical, DataTexture, DataTexture2DArray, DataTexture3D, DataTextureLoader, DecrementStencilOp, DecrementWrapStencilOp, DefaultLoadingManager, DepthFormat, DepthStencilFormat, DepthTexture, DirectionalLight, DirectionalLightHelper, DirectionalLightShadow, DiscreteInterpolant, DodecahedronBufferGeometry, DodecahedronGeometry, DoubleSide, DstAlphaFactor, DstColorFactor, DynamicBufferAttribute, DynamicCopyUsage, DynamicDrawUsage, DynamicReadUsage, EdgesGeometry, EdgesHelper, EllipseCurve, EqualDepth, EqualStencilFunc, EquirectangularReflectionMapping, EquirectangularRefractionMapping, Euler, EventDispatcher, ExtrudeBufferGeometry, ExtrudeGeometry, Face3, Face4, FaceColors, FileLoader, FlatShading, Float32Attribute, Float32BufferAttribute, Float64Attribute, Float64BufferAttribute, FloatType, Fog, FogExp2, Font, FontLoader, FrontFaceDirectionCCW, FrontFaceDirectionCW, FrontSide, Frustum, GammaEncoding, Geometry, GeometryUtils, GreaterDepth, GreaterEqualDepth, GreaterEqualStencilFunc, GreaterStencilFunc, GridHelper, Group, HalfFloatType, HemisphereLight, HemisphereLightHelper, HemisphereLightProbe, IcosahedronBufferGeometry, IcosahedronGeometry, ImageBitmapLoader, ImageLoader, ImageUtils, ImmediateRenderObject, IncrementStencilOp, IncrementWrapStencilOp, InstancedBufferAttribute, InstancedBufferGeometry, InstancedInterleavedBuffer, InstancedMesh, Int16Attribute, Int16BufferAttribute, Int32Attribute, Int32BufferAttribute, Int8Attribute, Int8BufferAttribute, IntType, InterleavedBuffer, InterleavedBufferAttribute, Interpolant, InterpolateDiscrete, InterpolateLinear, InterpolateSmooth, InvertStencilOp, JSONLoader, KeepStencilOp, KeyframeTrack, LOD, LatheBufferGeometry, LatheGeometry, Layers, LensFlare, LessDepth, LessEqualDepth, LessEqualStencilFunc, LessStencilFunc, Light, LightProbe, LightShadow, Line, Line3, LineBasicMaterial, LineCurve, LineCurve3, LineDashedMaterial, LineLoop, LinePieces, LineSegments, LineStrip, LinearEncoding, LinearFilter, LinearInterpolant, LinearMipMapLinearFilter, LinearMipMapNearestFilter, LinearMipmapLinearFilter, LinearMipmapNearestFilter, LinearToneMapping, Loader, LoaderUtils, LoadingManager, LogLuvEncoding, LoopOnce, LoopPingPong, LoopRepeat, LuminanceAlphaFormat, LuminanceFormat, MOUSE, Material, MaterialLoader, Math, MathUtils, Matrix3, Matrix4, MaxEquation, Mesh, MeshBasicMaterial, MeshDepthMaterial, MeshDistanceMaterial, MeshFaceMaterial, MeshLambertMaterial, MeshMatcapMaterial, MeshNormalMaterial, MeshPhongMaterial, MeshPhysicalMaterial, MeshStandardMaterial, MeshToonMaterial, MinEquation, MirroredRepeatWrapping, MixOperation, MultiMaterial, MultiplyBlending, MultiplyOperation, NearestFilter, NearestMipMapLinearFilter, NearestMipMapNearestFilter, NearestMipmapLinearFilter, NearestMipmapNearestFilter, NeverDepth, NeverStencilFunc, NoBlending, NoColors, NoToneMapping, NormalAnimationBlendMode, NormalBlending, NotEqualDepth, NotEqualStencilFunc, NumberKeyframeTrack, Object3D, ObjectLoader, ObjectSpaceNormalMap, OctahedronBufferGeometry, OctahedronGeometry, OneFactor, OneMinusDstAlphaFactor, OneMinusDstColorFactor, OneMinusSrcAlphaFactor, OneMinusSrcColorFactor, OrthographicCamera, PCFShadowMap, PCFSoftShadowMap, PMREMGenerator, ParametricBufferGeometry, ParametricGeometry, Particle, ParticleBasicMaterial, ParticleSystem, ParticleSystemMaterial, Path, PerspectiveCamera, Plane, PlaneBufferGeometry, PlaneGeometry, PlaneHelper, PointCloud, PointCloudMaterial, PointLight, PointLightHelper, Points, PointsMaterial, PolarGridHelper, PolyhedronBufferGeometry, PolyhedronGeometry, PositionalAudio, PropertyBinding, PropertyMixer, QuadraticBezierCurve, QuadraticBezierCurve3, Quaternion, QuaternionKeyframeTrack, QuaternionLinearInterpolant, REVISION, RGBADepthPacking, RGBAFormat, RGBAIntegerFormat, RGBA_ASTC_10x10_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_BPTC_Format, RGBA_ETC2_EAC_Format, RGBA_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGBDEncoding, RGBEEncoding, RGBEFormat, RGBFormat, RGBIntegerFormat, RGBM16Encoding, RGBM7Encoding, RGB_ETC1_Format, RGB_ETC2_Format, RGB_PVRTC_2BPPV1_Format, RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format, RGFormat, RGIntegerFormat, RawShaderMaterial, Ray, Raycaster, RectAreaLight, RedFormat, RedIntegerFormat, ReinhardToneMapping, RepeatWrapping, ReplaceStencilOp, ReverseSubtractEquation, RingBufferGeometry, RingGeometry, SRGB8_ALPHA8_ASTC_10x10_Format, SRGB8_ALPHA8_ASTC_10x5_Format, SRGB8_ALPHA8_ASTC_10x6_Format, SRGB8_ALPHA8_ASTC_10x8_Format, SRGB8_ALPHA8_ASTC_12x10_Format, SRGB8_ALPHA8_ASTC_12x12_Format, SRGB8_ALPHA8_ASTC_4x4_Format, SRGB8_ALPHA8_ASTC_5x4_Format, SRGB8_ALPHA8_ASTC_5x5_Format, SRGB8_ALPHA8_ASTC_6x5_Format, SRGB8_ALPHA8_ASTC_6x6_Format, SRGB8_ALPHA8_ASTC_8x5_Format, SRGB8_ALPHA8_ASTC_8x6_Format, SRGB8_ALPHA8_ASTC_8x8_Format, Scene, SceneUtils, ShaderChunk, ShaderLib, ShaderMaterial, ShadowMaterial, Shape, ShapeBufferGeometry, ShapeGeometry, ShapePath, ShapeUtils, ShortType, Skeleton, SkeletonHelper, SkinnedMesh, SmoothShading, Sphere, SphereBufferGeometry, SphereGeometry, Spherical, SphericalHarmonics3, SphericalReflectionMapping, Spline, SplineCurve, SplineCurve3, SpotLight, SpotLightHelper, SpotLightShadow, Sprite, SpriteMaterial, SrcAlphaFactor, SrcAlphaSaturateFactor, SrcColorFactor, StaticCopyUsage, StaticDrawUsage, StaticReadUsage, StereoCamera, StreamCopyUsage, StreamDrawUsage, StreamReadUsage, StringKeyframeTrack, SubtractEquation, SubtractiveBlending, TOUCH, TangentSpaceNormalMap, TetrahedronBufferGeometry, TetrahedronGeometry, TextBufferGeometry, TextGeometry, Texture, TextureLoader, TorusBufferGeometry, TorusGeometry, TorusKnotBufferGeometry, TorusKnotGeometry, Triangle, TriangleFanDrawMode, TriangleStripDrawMode, TrianglesDrawMode, TubeBufferGeometry, TubeGeometry, UVMapping, Uint16Attribute, Uint16BufferAttribute, Uint32Attribute, Uint32BufferAttribute, Uint8Attribute, Uint8BufferAttribute, Uint8ClampedAttribute, Uint8ClampedBufferAttribute, Uncharted2ToneMapping, Uniform, UniformsLib, UniformsUtils, UnsignedByteType, UnsignedInt248Type, UnsignedIntType, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedShort565Type, UnsignedShortType, VSMShadowMap, Vector2, Vector3, Vector4, VectorKeyframeTrack, Vertex, VertexColors, VideoTexture, WebGLCubeRenderTarget, WebGLMultisampleRenderTarget, WebGLRenderTarget, WebGLRenderTargetCube, WebGLRenderer, WebGLUtils, WireframeGeometry, WireframeHelper, WrapAroundEnding, XHRLoader, ZeroCurvatureEnding, ZeroFactor, ZeroSlopeEnding, ZeroStencilOp, sRGBEncoding */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ACESFilmicToneMapping\\\", function() { return ACESFilmicToneMapping; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"AddEquation\\\", function() { return AddEquation; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"AddOperation\\\", function() { return AddOperation; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"AdditiveAnimationBlendMode\\\", function() { return AdditiveAnimationBlendMode; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"AdditiveBlending\\\", function() { return AdditiveBlending; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"AlphaFormat\\\", function() { return AlphaFormat; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"AlwaysDepth\\\", function() { return AlwaysDepth; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"AlwaysStencilFunc\\\", function() { return AlwaysStencilFunc; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"AmbientLight\\\", function() { return AmbientLight; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"AmbientLightProbe\\\", function() { return AmbientLightProbe; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"AnimationClip\\\", function() { return AnimationClip; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"AnimationLoader\\\", function() { return AnimationLoader; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"AnimationMixer\\\", function() { return AnimationMixer; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"AnimationObjectGroup\\\", function() { return AnimationObjectGroup; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"AnimationUtils\\\", function() { return AnimationUtils; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ArcCurve\\\", function() { return ArcCurve; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ArrayCamera\\\", function() { return ArrayCamera; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ArrowHelper\\\", function() { return ArrowHelper; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Audio\\\", function() { return Audio; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"AudioAnalyser\\\", function() { return AudioAnalyser; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"AudioContext\\\", function() { return AudioContext; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"AudioListener\\\", function() { return AudioListener; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"AudioLoader\\\", function() { return AudioLoader; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"AxesHelper\\\", function() { return AxesHelper; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"AxisHelper\\\", function() { return AxisHelper; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"BackSide\\\", function() { return BackSide; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"BasicDepthPacking\\\", function() { return BasicDepthPacking; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"BasicShadowMap\\\", function() { return BasicShadowMap; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"BinaryTextureLoader\\\", function() { return BinaryTextureLoader; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Bone\\\", function() { return Bone; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"BooleanKeyframeTrack\\\", function() { return BooleanKeyframeTrack; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"BoundingBoxHelper\\\", function() { return BoundingBoxHelper; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Box2\\\", function() { return Box2; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Box3\\\", function() { return Box3; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Box3Helper\\\", function() { return Box3Helper; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"BoxBufferGeometry\\\", function() { return BoxBufferGeometry; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"BoxGeometry\\\", function() { return BoxGeometry; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"BoxHelper\\\", function() { return BoxHelper; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"BufferAttribute\\\", function() { return BufferAttribute; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"BufferGeometry\\\", function() { return BufferGeometry; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"BufferGeometryLoader\\\", function() { return BufferGeometryLoader; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ByteType\\\", function() { return ByteType; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Cache\\\", function() { return Cache; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Camera\\\", function() { return Camera; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"CameraHelper\\\", function() { return CameraHelper; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"CanvasRenderer\\\", function() { return CanvasRenderer; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"CanvasTexture\\\", function() { return CanvasTexture; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"CatmullRomCurve3\\\", function() { return CatmullRomCurve3; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"CineonToneMapping\\\", function() { return CineonToneMapping; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"CircleBufferGeometry\\\", function() { return CircleBufferGeometry; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"CircleGeometry\\\", function() { return CircleGeometry; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ClampToEdgeWrapping\\\", function() { return ClampToEdgeWrapping; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Clock\\\", function() { return Clock; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ClosedSplineCurve3\\\", function() { return ClosedSplineCurve3; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Color\\\", function() { return Color; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ColorKeyframeTrack\\\", function() { return ColorKeyframeTrack; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"CompressedTexture\\\", function() { return CompressedTexture; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"CompressedTextureLoader\\\", function() { return CompressedTextureLoader; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ConeBufferGeometry\\\", function() { return ConeBufferGeometry; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ConeGeometry\\\", function() { return ConeGeometry; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"CubeCamera\\\", function() { return CubeCamera; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"CubeGeometry\\\", function() { return BoxGeometry; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"CubeReflectionMapping\\\", function() { return CubeReflectionMapping; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"CubeRefractionMapping\\\", function() { return CubeRefractionMapping; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"CubeTexture\\\", function() { return CubeTexture; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"CubeTextureLoader\\\", function() { return CubeTextureLoader; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"CubeUVReflectionMapping\\\", function() { return CubeUVReflectionMapping; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"CubeUVRefractionMapping\\\", function() { return CubeUVRefractionMapping; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"CubicBezierCurve\\\", function() { return CubicBezierCurve; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"CubicBezierCurve3\\\", function() { return CubicBezierCurve3; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"CubicInterpolant\\\", function() { return CubicInterpolant; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"CullFaceBack\\\", function() { return CullFaceBack; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"CullFaceFront\\\", function() { return CullFaceFront; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"CullFaceFrontBack\\\", function() { return CullFaceFrontBack; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"CullFaceNone\\\", function() { return CullFaceNone; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Curve\\\", function() { return Curve; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"CurvePath\\\", function() { return CurvePath; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"CustomBlending\\\", function() { return CustomBlending; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"CylinderBufferGeometry\\\", function() { return CylinderBufferGeometry; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"CylinderGeometry\\\", function() { return CylinderGeometry; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Cylindrical\\\", function() { return Cylindrical; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"DataTexture\\\", function() { return DataTexture; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"DataTexture2DArray\\\", function() { return DataTexture2DArray; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"DataTexture3D\\\", function() { return DataTexture3D; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"DataTextureLoader\\\", function() { return DataTextureLoader; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"DecrementStencilOp\\\", function() { return DecrementStencilOp; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"DecrementWrapStencilOp\\\", function() { return DecrementWrapStencilOp; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"DefaultLoadingManager\\\", function() { return DefaultLoadingManager; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"DepthFormat\\\", function() { return DepthFormat; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"DepthStencilFormat\\\", function() { return DepthStencilFormat; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"DepthTexture\\\", function() { return DepthTexture; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"DirectionalLight\\\", function() { return DirectionalLight; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"DirectionalLightHelper\\\", function() { return DirectionalLightHelper; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"DirectionalLightShadow\\\", function() { return DirectionalLightShadow; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"DiscreteInterpolant\\\", function() { return DiscreteInterpolant; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"DodecahedronBufferGeometry\\\", function() { return DodecahedronBufferGeometry; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"DodecahedronGeometry\\\", function() { return DodecahedronGeometry; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"DoubleSide\\\", function() { return DoubleSide; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"DstAlphaFactor\\\", function() { return DstAlphaFactor; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"DstColorFactor\\\", function() { return DstColorFactor; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"DynamicBufferAttribute\\\", function() { return DynamicBufferAttribute; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"DynamicCopyUsage\\\", function() { return DynamicCopyUsage; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"DynamicDrawUsage\\\", function() { return DynamicDrawUsage; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"DynamicReadUsage\\\", function() { return DynamicReadUsage; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"EdgesGeometry\\\", function() { return EdgesGeometry; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"EdgesHelper\\\", function() { return EdgesHelper; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"EllipseCurve\\\", function() { return EllipseCurve; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"EqualDepth\\\", function() { return EqualDepth; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"EqualStencilFunc\\\", function() { return EqualStencilFunc; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"EquirectangularReflectionMapping\\\", function() { return EquirectangularReflectionMapping; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"EquirectangularRefractionMapping\\\", function() { return EquirectangularRefractionMapping; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Euler\\\", function() { return Euler; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"EventDispatcher\\\", function() { return EventDispatcher; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ExtrudeBufferGeometry\\\", function() { return ExtrudeBufferGeometry; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ExtrudeGeometry\\\", function() { return ExtrudeGeometry; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Face3\\\", function() { return Face3; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Face4\\\", function() { return Face4; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"FaceColors\\\", function() { return FaceColors; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"FileLoader\\\", function() { return FileLoader; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"FlatShading\\\", function() { return FlatShading; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Float32Attribute\\\", function() { return Float32Attribute; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Float32BufferAttribute\\\", function() { return Float32BufferAttribute; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Float64Attribute\\\", function() { return Float64Attribute; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Float64BufferAttribute\\\", function() { return Float64BufferAttribute; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"FloatType\\\", function() { return FloatType; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Fog\\\", function() { return Fog; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"FogExp2\\\", function() { return FogExp2; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Font\\\", function() { return Font; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"FontLoader\\\", function() { return FontLoader; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"FrontFaceDirectionCCW\\\", function() { return FrontFaceDirectionCCW; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"FrontFaceDirectionCW\\\", function() { return FrontFaceDirectionCW; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"FrontSide\\\", function() { return FrontSide; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Frustum\\\", function() { return Frustum; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"GammaEncoding\\\", function() { return GammaEncoding; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Geometry\\\", function() { return Geometry; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"GeometryUtils\\\", function() { return GeometryUtils; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"GreaterDepth\\\", function() { return GreaterDepth; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"GreaterEqualDepth\\\", function() { return GreaterEqualDepth; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"GreaterEqualStencilFunc\\\", function() { return GreaterEqualStencilFunc; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"GreaterStencilFunc\\\", function() { return GreaterStencilFunc; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"GridHelper\\\", function() { return GridHelper; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Group\\\", function() { return Group; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"HalfFloatType\\\", function() { return HalfFloatType; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"HemisphereLight\\\", function() { return HemisphereLight; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"HemisphereLightHelper\\\", function() { return HemisphereLightHelper; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"HemisphereLightProbe\\\", function() { return HemisphereLightProbe; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"IcosahedronBufferGeometry\\\", function() { return IcosahedronBufferGeometry; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"IcosahedronGeometry\\\", function() { return IcosahedronGeometry; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ImageBitmapLoader\\\", function() { return ImageBitmapLoader; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ImageLoader\\\", function() { return ImageLoader; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ImageUtils\\\", function() { return ImageUtils; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ImmediateRenderObject\\\", function() { return ImmediateRenderObject; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"IncrementStencilOp\\\", function() { return IncrementStencilOp; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"IncrementWrapStencilOp\\\", function() { return IncrementWrapStencilOp; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"InstancedBufferAttribute\\\", function() { return InstancedBufferAttribute; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"InstancedBufferGeometry\\\", function() { return InstancedBufferGeometry; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"InstancedInterleavedBuffer\\\", function() { return InstancedInterleavedBuffer; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"InstancedMesh\\\", function() { return InstancedMesh; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Int16Attribute\\\", function() { return Int16Attribute; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Int16BufferAttribute\\\", function() { return Int16BufferAttribute; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Int32Attribute\\\", function() { return Int32Attribute; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Int32BufferAttribute\\\", function() { return Int32BufferAttribute; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Int8Attribute\\\", function() { return Int8Attribute; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Int8BufferAttribute\\\", function() { return Int8BufferAttribute; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"IntType\\\", function() { return IntType; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"InterleavedBuffer\\\", function() { return InterleavedBuffer; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"InterleavedBufferAttribute\\\", function() { return InterleavedBufferAttribute; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Interpolant\\\", function() { return Interpolant; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"InterpolateDiscrete\\\", function() { return InterpolateDiscrete; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"InterpolateLinear\\\", function() { return InterpolateLinear; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"InterpolateSmooth\\\", function() { return InterpolateSmooth; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"InvertStencilOp\\\", function() { return InvertStencilOp; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"JSONLoader\\\", function() { return JSONLoader; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"KeepStencilOp\\\", function() { return KeepStencilOp; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"KeyframeTrack\\\", function() { return KeyframeTrack; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"LOD\\\", function() { return LOD; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"LatheBufferGeometry\\\", function() { return LatheBufferGeometry; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"LatheGeometry\\\", function() { return LatheGeometry; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Layers\\\", function() { return Layers; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"LensFlare\\\", function() { return LensFlare; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"LessDepth\\\", function() { return LessDepth; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"LessEqualDepth\\\", function() { return LessEqualDepth; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"LessEqualStencilFunc\\\", function() { return LessEqualStencilFunc; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"LessStencilFunc\\\", function() { return LessStencilFunc; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Light\\\", function() { return Light; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"LightProbe\\\", function() { return LightProbe; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"LightShadow\\\", function() { return LightShadow; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Line\\\", function() { return Line; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Line3\\\", function() { return Line3; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"LineBasicMaterial\\\", function() { return LineBasicMaterial; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"LineCurve\\\", function() { return LineCurve; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"LineCurve3\\\", function() { return LineCurve3; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"LineDashedMaterial\\\", function() { return LineDashedMaterial; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"LineLoop\\\", function() { return LineLoop; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"LinePieces\\\", function() { return LinePieces; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"LineSegments\\\", function() { return LineSegments; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"LineStrip\\\", function() { return LineStrip; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"LinearEncoding\\\", function() { return LinearEncoding; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"LinearFilter\\\", function() { return LinearFilter; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"LinearInterpolant\\\", function() { return LinearInterpolant; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"LinearMipMapLinearFilter\\\", function() { return LinearMipMapLinearFilter; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"LinearMipMapNearestFilter\\\", function() { return LinearMipMapNearestFilter; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"LinearMipmapLinearFilter\\\", function() { return LinearMipmapLinearFilter; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"LinearMipmapNearestFilter\\\", function() { return LinearMipmapNearestFilter; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"LinearToneMapping\\\", function() { return LinearToneMapping; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Loader\\\", function() { return Loader; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"LoaderUtils\\\", function() { return LoaderUtils; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"LoadingManager\\\", function() { return LoadingManager; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"LogLuvEncoding\\\", function() { return LogLuvEncoding; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"LoopOnce\\\", function() { return LoopOnce; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"LoopPingPong\\\", function() { return LoopPingPong; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"LoopRepeat\\\", function() { return LoopRepeat; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"LuminanceAlphaFormat\\\", function() { return LuminanceAlphaFormat; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"LuminanceFormat\\\", function() { return LuminanceFormat; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"MOUSE\\\", function() { return MOUSE; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Material\\\", function() { return Material; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"MaterialLoader\\\", function() { return MaterialLoader; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Math\\\", function() { return MathUtils; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"MathUtils\\\", function() { return MathUtils; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Matrix3\\\", function() { return Matrix3; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Matrix4\\\", function() { return Matrix4; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"MaxEquation\\\", function() { return MaxEquation; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Mesh\\\", function() { return Mesh; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"MeshBasicMaterial\\\", function() { return MeshBasicMaterial; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"MeshDepthMaterial\\\", function() { return MeshDepthMaterial; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"MeshDistanceMaterial\\\", function() { return MeshDistanceMaterial; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"MeshFaceMaterial\\\", function() { return MeshFaceMaterial; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"MeshLambertMaterial\\\", function() { return MeshLambertMaterial; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"MeshMatcapMaterial\\\", function() { return MeshMatcapMaterial; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"MeshNormalMaterial\\\", function() { return MeshNormalMaterial; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"MeshPhongMaterial\\\", function() { return MeshPhongMaterial; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"MeshPhysicalMaterial\\\", function() { return MeshPhysicalMaterial; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"MeshStandardMaterial\\\", function() { return MeshStandardMaterial; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"MeshToonMaterial\\\", function() { return MeshToonMaterial; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"MinEquation\\\", function() { return MinEquation; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"MirroredRepeatWrapping\\\", function() { return MirroredRepeatWrapping; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"MixOperation\\\", function() { return MixOperation; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"MultiMaterial\\\", function() { return MultiMaterial; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"MultiplyBlending\\\", function() { return MultiplyBlending; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"MultiplyOperation\\\", function() { return MultiplyOperation; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"NearestFilter\\\", function() { return NearestFilter; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"NearestMipMapLinearFilter\\\", function() { return NearestMipMapLinearFilter; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"NearestMipMapNearestFilter\\\", function() { return NearestMipMapNearestFilter; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"NearestMipmapLinearFilter\\\", function() { return NearestMipmapLinearFilter; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"NearestMipmapNearestFilter\\\", function() { return NearestMipmapNearestFilter; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"NeverDepth\\\", function() { return NeverDepth; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"NeverStencilFunc\\\", function() { return NeverStencilFunc; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"NoBlending\\\", function() { return NoBlending; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"NoColors\\\", function() { return NoColors; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"NoToneMapping\\\", function() { return NoToneMapping; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"NormalAnimationBlendMode\\\", function() { return NormalAnimationBlendMode; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"NormalBlending\\\", function() { return NormalBlending; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"NotEqualDepth\\\", function() { return NotEqualDepth; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"NotEqualStencilFunc\\\", function() { return NotEqualStencilFunc; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"NumberKeyframeTrack\\\", function() { return NumberKeyframeTrack; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Object3D\\\", function() { return Object3D; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ObjectLoader\\\", function() { return ObjectLoader; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ObjectSpaceNormalMap\\\", function() { return ObjectSpaceNormalMap; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"OctahedronBufferGeometry\\\", function() { return OctahedronBufferGeometry; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"OctahedronGeometry\\\", function() { return OctahedronGeometry; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"OneFactor\\\", function() { return OneFactor; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"OneMinusDstAlphaFactor\\\", function() { return OneMinusDstAlphaFactor; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"OneMinusDstColorFactor\\\", function() { return OneMinusDstColorFactor; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"OneMinusSrcAlphaFactor\\\", function() { return OneMinusSrcAlphaFactor; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"OneMinusSrcColorFactor\\\", function() { return OneMinusSrcColorFactor; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"OrthographicCamera\\\", function() { return OrthographicCamera; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"PCFShadowMap\\\", function() { return PCFShadowMap; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"PCFSoftShadowMap\\\", function() { return PCFSoftShadowMap; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"PMREMGenerator\\\", function() { return PMREMGenerator; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ParametricBufferGeometry\\\", function() { return ParametricBufferGeometry; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ParametricGeometry\\\", function() { return ParametricGeometry; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Particle\\\", function() { return Particle; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ParticleBasicMaterial\\\", function() { return ParticleBasicMaterial; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ParticleSystem\\\", function() { return ParticleSystem; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ParticleSystemMaterial\\\", function() { return ParticleSystemMaterial; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Path\\\", function() { return Path; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"PerspectiveCamera\\\", function() { return PerspectiveCamera; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Plane\\\", function() { return Plane; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"PlaneBufferGeometry\\\", function() { return PlaneBufferGeometry; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"PlaneGeometry\\\", function() { return PlaneGeometry; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"PlaneHelper\\\", function() { return PlaneHelper; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"PointCloud\\\", function() { return PointCloud; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"PointCloudMaterial\\\", function() { return PointCloudMaterial; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"PointLight\\\", function() { return PointLight; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"PointLightHelper\\\", function() { return PointLightHelper; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Points\\\", function() { return Points; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"PointsMaterial\\\", function() { return PointsMaterial; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"PolarGridHelper\\\", function() { return PolarGridHelper; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"PolyhedronBufferGeometry\\\", function() { return PolyhedronBufferGeometry; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"PolyhedronGeometry\\\", function() { return PolyhedronGeometry; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"PositionalAudio\\\", function() { return PositionalAudio; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"PropertyBinding\\\", function() { return PropertyBinding; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"PropertyMixer\\\", function() { return PropertyMixer; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"QuadraticBezierCurve\\\", function() { return QuadraticBezierCurve; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"QuadraticBezierCurve3\\\", function() { return QuadraticBezierCurve3; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Quaternion\\\", function() { return Quaternion; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"QuaternionKeyframeTrack\\\", function() { return QuaternionKeyframeTrack; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"QuaternionLinearInterpolant\\\", function() { return QuaternionLinearInterpolant; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"REVISION\\\", function() { return REVISION; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RGBADepthPacking\\\", function() { return RGBADepthPacking; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RGBAFormat\\\", function() { return RGBAFormat; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RGBAIntegerFormat\\\", function() { return RGBAIntegerFormat; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RGBA_ASTC_10x10_Format\\\", function() { return RGBA_ASTC_10x10_Format; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RGBA_ASTC_10x5_Format\\\", function() { return RGBA_ASTC_10x5_Format; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RGBA_ASTC_10x6_Format\\\", function() { return RGBA_ASTC_10x6_Format; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RGBA_ASTC_10x8_Format\\\", function() { return RGBA_ASTC_10x8_Format; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RGBA_ASTC_12x10_Format\\\", function() { return RGBA_ASTC_12x10_Format; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RGBA_ASTC_12x12_Format\\\", function() { return RGBA_ASTC_12x12_Format; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RGBA_ASTC_4x4_Format\\\", function() { return RGBA_ASTC_4x4_Format; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RGBA_ASTC_5x4_Format\\\", function() { return RGBA_ASTC_5x4_Format; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RGBA_ASTC_5x5_Format\\\", function() { return RGBA_ASTC_5x5_Format; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RGBA_ASTC_6x5_Format\\\", function() { return RGBA_ASTC_6x5_Format; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RGBA_ASTC_6x6_Format\\\", function() { return RGBA_ASTC_6x6_Format; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RGBA_ASTC_8x5_Format\\\", function() { return RGBA_ASTC_8x5_Format; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RGBA_ASTC_8x6_Format\\\", function() { return RGBA_ASTC_8x6_Format; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RGBA_ASTC_8x8_Format\\\", function() { return RGBA_ASTC_8x8_Format; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RGBA_BPTC_Format\\\", function() { return RGBA_BPTC_Format; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RGBA_ETC2_EAC_Format\\\", function() { return RGBA_ETC2_EAC_Format; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RGBA_PVRTC_2BPPV1_Format\\\", function() { return RGBA_PVRTC_2BPPV1_Format; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RGBA_PVRTC_4BPPV1_Format\\\", function() { return RGBA_PVRTC_4BPPV1_Format; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RGBA_S3TC_DXT1_Format\\\", function() { return RGBA_S3TC_DXT1_Format; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RGBA_S3TC_DXT3_Format\\\", function() { return RGBA_S3TC_DXT3_Format; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RGBA_S3TC_DXT5_Format\\\", function() { return RGBA_S3TC_DXT5_Format; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RGBDEncoding\\\", function() { return RGBDEncoding; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RGBEEncoding\\\", function() { return RGBEEncoding; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RGBEFormat\\\", function() { return RGBEFormat; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RGBFormat\\\", function() { return RGBFormat; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RGBIntegerFormat\\\", function() { return RGBIntegerFormat; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RGBM16Encoding\\\", function() { return RGBM16Encoding; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RGBM7Encoding\\\", function() { return RGBM7Encoding; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RGB_ETC1_Format\\\", function() { return RGB_ETC1_Format; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RGB_ETC2_Format\\\", function() { return RGB_ETC2_Format; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RGB_PVRTC_2BPPV1_Format\\\", function() { return RGB_PVRTC_2BPPV1_Format; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RGB_PVRTC_4BPPV1_Format\\\", function() { return RGB_PVRTC_4BPPV1_Format; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RGB_S3TC_DXT1_Format\\\", function() { return RGB_S3TC_DXT1_Format; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RGFormat\\\", function() { return RGFormat; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RGIntegerFormat\\\", function() { return RGIntegerFormat; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RawShaderMaterial\\\", function() { return RawShaderMaterial; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Ray\\\", function() { return Ray; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Raycaster\\\", function() { return Raycaster; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RectAreaLight\\\", function() { return RectAreaLight; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RedFormat\\\", function() { return RedFormat; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RedIntegerFormat\\\", function() { return RedIntegerFormat; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ReinhardToneMapping\\\", function() { return ReinhardToneMapping; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RepeatWrapping\\\", function() { return RepeatWrapping; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ReplaceStencilOp\\\", function() { return ReplaceStencilOp; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ReverseSubtractEquation\\\", function() { return ReverseSubtractEquation; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RingBufferGeometry\\\", function() { return RingBufferGeometry; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RingGeometry\\\", function() { return RingGeometry; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"SRGB8_ALPHA8_ASTC_10x10_Format\\\", function() { return SRGB8_ALPHA8_ASTC_10x10_Format; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"SRGB8_ALPHA8_ASTC_10x5_Format\\\", function() { return SRGB8_ALPHA8_ASTC_10x5_Format; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"SRGB8_ALPHA8_ASTC_10x6_Format\\\", function() { return SRGB8_ALPHA8_ASTC_10x6_Format; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"SRGB8_ALPHA8_ASTC_10x8_Format\\\", function() { return SRGB8_ALPHA8_ASTC_10x8_Format; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"SRGB8_ALPHA8_ASTC_12x10_Format\\\", function() { return SRGB8_ALPHA8_ASTC_12x10_Format; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"SRGB8_ALPHA8_ASTC_12x12_Format\\\", function() { return SRGB8_ALPHA8_ASTC_12x12_Format; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"SRGB8_ALPHA8_ASTC_4x4_Format\\\", function() { return SRGB8_ALPHA8_ASTC_4x4_Format; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"SRGB8_ALPHA8_ASTC_5x4_Format\\\", function() { return SRGB8_ALPHA8_ASTC_5x4_Format; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"SRGB8_ALPHA8_ASTC_5x5_Format\\\", function() { return SRGB8_ALPHA8_ASTC_5x5_Format; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"SRGB8_ALPHA8_ASTC_6x5_Format\\\", function() { return SRGB8_ALPHA8_ASTC_6x5_Format; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"SRGB8_ALPHA8_ASTC_6x6_Format\\\", function() { return SRGB8_ALPHA8_ASTC_6x6_Format; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"SRGB8_ALPHA8_ASTC_8x5_Format\\\", function() { return SRGB8_ALPHA8_ASTC_8x5_Format; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"SRGB8_ALPHA8_ASTC_8x6_Format\\\", function() { return SRGB8_ALPHA8_ASTC_8x6_Format; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"SRGB8_ALPHA8_ASTC_8x8_Format\\\", function() { return SRGB8_ALPHA8_ASTC_8x8_Format; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Scene\\\", function() { return Scene; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"SceneUtils\\\", function() { return SceneUtils; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ShaderChunk\\\", function() { return ShaderChunk; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ShaderLib\\\", function() { return ShaderLib; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ShaderMaterial\\\", function() { return ShaderMaterial; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ShadowMaterial\\\", function() { return ShadowMaterial; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Shape\\\", function() { return Shape; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ShapeBufferGeometry\\\", function() { return ShapeBufferGeometry; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ShapeGeometry\\\", function() { return ShapeGeometry; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ShapePath\\\", function() { return ShapePath; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ShapeUtils\\\", function() { return ShapeUtils; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ShortType\\\", function() { return ShortType; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Skeleton\\\", function() { return Skeleton; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"SkeletonHelper\\\", function() { return SkeletonHelper; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"SkinnedMesh\\\", function() { return SkinnedMesh; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"SmoothShading\\\", function() { return SmoothShading; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Sphere\\\", function() { return Sphere; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"SphereBufferGeometry\\\", function() { return SphereBufferGeometry; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"SphereGeometry\\\", function() { return SphereGeometry; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Spherical\\\", function() { return Spherical; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"SphericalHarmonics3\\\", function() { return SphericalHarmonics3; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"SphericalReflectionMapping\\\", function() { return SphericalReflectionMapping; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Spline\\\", function() { return Spline; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"SplineCurve\\\", function() { return SplineCurve; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"SplineCurve3\\\", function() { return SplineCurve3; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"SpotLight\\\", function() { return SpotLight; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"SpotLightHelper\\\", function() { return SpotLightHelper; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"SpotLightShadow\\\", function() { return SpotLightShadow; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Sprite\\\", function() { return Sprite; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"SpriteMaterial\\\", function() { return SpriteMaterial; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"SrcAlphaFactor\\\", function() { return SrcAlphaFactor; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"SrcAlphaSaturateFactor\\\", function() { return SrcAlphaSaturateFactor; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"SrcColorFactor\\\", function() { return SrcColorFactor; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"StaticCopyUsage\\\", function() { return StaticCopyUsage; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"StaticDrawUsage\\\", function() { return StaticDrawUsage; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"StaticReadUsage\\\", function() { return StaticReadUsage; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"StereoCamera\\\", function() { return StereoCamera; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"StreamCopyUsage\\\", function() { return StreamCopyUsage; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"StreamDrawUsage\\\", function() { return StreamDrawUsage; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"StreamReadUsage\\\", function() { return StreamReadUsage; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"StringKeyframeTrack\\\", function() { return StringKeyframeTrack; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"SubtractEquation\\\", function() { return SubtractEquation; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"SubtractiveBlending\\\", function() { return SubtractiveBlending; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"TOUCH\\\", function() { return TOUCH; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"TangentSpaceNormalMap\\\", function() { return TangentSpaceNormalMap; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"TetrahedronBufferGeometry\\\", function() { return TetrahedronBufferGeometry; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"TetrahedronGeometry\\\", function() { return TetrahedronGeometry; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"TextBufferGeometry\\\", function() { return TextBufferGeometry; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"TextGeometry\\\", function() { return TextGeometry; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Texture\\\", function() { return Texture; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"TextureLoader\\\", function() { return TextureLoader; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"TorusBufferGeometry\\\", function() { return TorusBufferGeometry; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"TorusGeometry\\\", function() { return TorusGeometry; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"TorusKnotBufferGeometry\\\", function() { return TorusKnotBufferGeometry; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"TorusKnotGeometry\\\", function() { return TorusKnotGeometry; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Triangle\\\", function() { return Triangle; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"TriangleFanDrawMode\\\", function() { return TriangleFanDrawMode; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"TriangleStripDrawMode\\\", function() { return TriangleStripDrawMode; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"TrianglesDrawMode\\\", function() { return TrianglesDrawMode; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"TubeBufferGeometry\\\", function() { return TubeBufferGeometry; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"TubeGeometry\\\", function() { return TubeGeometry; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"UVMapping\\\", function() { return UVMapping; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Uint16Attribute\\\", function() { return Uint16Attribute; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Uint16BufferAttribute\\\", function() { return Uint16BufferAttribute; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Uint32Attribute\\\", function() { return Uint32Attribute; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Uint32BufferAttribute\\\", function() { return Uint32BufferAttribute; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Uint8Attribute\\\", function() { return Uint8Attribute; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Uint8BufferAttribute\\\", function() { return Uint8BufferAttribute; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Uint8ClampedAttribute\\\", function() { return Uint8ClampedAttribute; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Uint8ClampedBufferAttribute\\\", function() { return Uint8ClampedBufferAttribute; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Uncharted2ToneMapping\\\", function() { return Uncharted2ToneMapping; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Uniform\\\", function() { return Uniform; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"UniformsLib\\\", function() { return UniformsLib; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"UniformsUtils\\\", function() { return UniformsUtils; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"UnsignedByteType\\\", function() { return UnsignedByteType; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"UnsignedInt248Type\\\", function() { return UnsignedInt248Type; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"UnsignedIntType\\\", function() { return UnsignedIntType; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"UnsignedShort4444Type\\\", function() { return UnsignedShort4444Type; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"UnsignedShort5551Type\\\", function() { return UnsignedShort5551Type; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"UnsignedShort565Type\\\", function() { return UnsignedShort565Type; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"UnsignedShortType\\\", function() { return UnsignedShortType; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"VSMShadowMap\\\", function() { return VSMShadowMap; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Vector2\\\", function() { return Vector2; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Vector3\\\", function() { return Vector3; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Vector4\\\", function() { return Vector4; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"VectorKeyframeTrack\\\", function() { return VectorKeyframeTrack; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Vertex\\\", function() { return Vertex; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"VertexColors\\\", function() { return VertexColors; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"VideoTexture\\\", function() { return VideoTexture; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"WebGLCubeRenderTarget\\\", function() { return WebGLCubeRenderTarget; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"WebGLMultisampleRenderTarget\\\", function() { return WebGLMultisampleRenderTarget; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"WebGLRenderTarget\\\", function() { return WebGLRenderTarget; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"WebGLRenderTargetCube\\\", function() { return WebGLRenderTargetCube; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"WebGLRenderer\\\", function() { return WebGLRenderer; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"WebGLUtils\\\", function() { return WebGLUtils; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"WireframeGeometry\\\", function() { return WireframeGeometry; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"WireframeHelper\\\", function() { return WireframeHelper; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"WrapAroundEnding\\\", function() { return WrapAroundEnding; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"XHRLoader\\\", function() { return XHRLoader; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ZeroCurvatureEnding\\\", function() { return ZeroCurvatureEnding; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ZeroFactor\\\", function() { return ZeroFactor; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ZeroSlopeEnding\\\", function() { return ZeroSlopeEnding; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ZeroStencilOp\\\", function() { return ZeroStencilOp; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"sRGBEncoding\\\", function() { return sRGBEncoding; });\\n// Polyfills\\r\\n\\r\\nif ( Number.EPSILON === undefined ) {\\r\\n\\r\\n\\tNumber.EPSILON = Math.pow( 2, - 52 );\\r\\n\\r\\n}\\r\\n\\r\\nif ( Number.isInteger === undefined ) {\\r\\n\\r\\n\\t// Missing in IE\\r\\n\\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger\\r\\n\\r\\n\\tNumber.isInteger = function ( value ) {\\r\\n\\r\\n\\t\\treturn typeof value === 'number' && isFinite( value ) && Math.floor( value ) === value;\\r\\n\\r\\n\\t};\\r\\n\\r\\n}\\r\\n\\r\\n//\\r\\n\\r\\nif ( Math.sign === undefined ) {\\r\\n\\r\\n\\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign\\r\\n\\r\\n\\tMath.sign = function ( x ) {\\r\\n\\r\\n\\t\\treturn ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;\\r\\n\\r\\n\\t};\\r\\n\\r\\n}\\r\\n\\r\\nif ( 'name' in Function.prototype === false ) {\\r\\n\\r\\n\\t// Missing in IE\\r\\n\\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\\r\\n\\r\\n\\tObject.defineProperty( Function.prototype, 'name', {\\r\\n\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\treturn this.toString().match( /^\\\\s*function\\\\s*([^\\\\(\\\\s]*)/ )[ 1 ];\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} );\\r\\n\\r\\n}\\r\\n\\r\\nif ( Object.assign === undefined ) {\\r\\n\\r\\n\\t// Missing in IE\\r\\n\\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\\r\\n\\r\\n\\tObject.assign = function ( target ) {\\r\\n\\r\\n\\t\\tif ( target === undefined || target === null ) {\\r\\n\\r\\n\\t\\t\\tthrow new TypeError( 'Cannot convert undefined or null to object' );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tconst output = Object( target );\\r\\n\\r\\n\\t\\tfor ( let index = 1; index < arguments.length; index ++ ) {\\r\\n\\r\\n\\t\\t\\tconst source = arguments[ index ];\\r\\n\\r\\n\\t\\t\\tif ( source !== undefined && source !== null ) {\\r\\n\\r\\n\\t\\t\\t\\tfor ( const nextKey in source ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\toutput[ nextKey ] = source[ nextKey ];\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn output;\\r\\n\\r\\n\\t};\\r\\n\\r\\n}\\r\\n\\r\\nconst REVISION = '117';\\r\\nconst MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };\\r\\nconst TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };\\r\\nconst CullFaceNone = 0;\\r\\nconst CullFaceBack = 1;\\r\\nconst CullFaceFront = 2;\\r\\nconst CullFaceFrontBack = 3;\\r\\nconst FrontFaceDirectionCW = 0;\\r\\nconst FrontFaceDirectionCCW = 1;\\r\\nconst BasicShadowMap = 0;\\r\\nconst PCFShadowMap = 1;\\r\\nconst PCFSoftShadowMap = 2;\\r\\nconst VSMShadowMap = 3;\\r\\nconst FrontSide = 0;\\r\\nconst BackSide = 1;\\r\\nconst DoubleSide = 2;\\r\\nconst FlatShading = 1;\\r\\nconst SmoothShading = 2;\\r\\nconst NoBlending = 0;\\r\\nconst NormalBlending = 1;\\r\\nconst AdditiveBlending = 2;\\r\\nconst SubtractiveBlending = 3;\\r\\nconst MultiplyBlending = 4;\\r\\nconst CustomBlending = 5;\\r\\nconst AddEquation = 100;\\r\\nconst SubtractEquation = 101;\\r\\nconst ReverseSubtractEquation = 102;\\r\\nconst MinEquation = 103;\\r\\nconst MaxEquation = 104;\\r\\nconst ZeroFactor = 200;\\r\\nconst OneFactor = 201;\\r\\nconst SrcColorFactor = 202;\\r\\nconst OneMinusSrcColorFactor = 203;\\r\\nconst SrcAlphaFactor = 204;\\r\\nconst OneMinusSrcAlphaFactor = 205;\\r\\nconst DstAlphaFactor = 206;\\r\\nconst OneMinusDstAlphaFactor = 207;\\r\\nconst DstColorFactor = 208;\\r\\nconst OneMinusDstColorFactor = 209;\\r\\nconst SrcAlphaSaturateFactor = 210;\\r\\nconst NeverDepth = 0;\\r\\nconst AlwaysDepth = 1;\\r\\nconst LessDepth = 2;\\r\\nconst LessEqualDepth = 3;\\r\\nconst EqualDepth = 4;\\r\\nconst GreaterEqualDepth = 5;\\r\\nconst GreaterDepth = 6;\\r\\nconst NotEqualDepth = 7;\\r\\nconst MultiplyOperation = 0;\\r\\nconst MixOperation = 1;\\r\\nconst AddOperation = 2;\\r\\nconst NoToneMapping = 0;\\r\\nconst LinearToneMapping = 1;\\r\\nconst ReinhardToneMapping = 2;\\r\\nconst Uncharted2ToneMapping = 3;\\r\\nconst CineonToneMapping = 4;\\r\\nconst ACESFilmicToneMapping = 5;\\r\\n\\r\\nconst UVMapping = 300;\\r\\nconst CubeReflectionMapping = 301;\\r\\nconst CubeRefractionMapping = 302;\\r\\nconst EquirectangularReflectionMapping = 303;\\r\\nconst EquirectangularRefractionMapping = 304;\\r\\nconst SphericalReflectionMapping = 305;\\r\\nconst CubeUVReflectionMapping = 306;\\r\\nconst CubeUVRefractionMapping = 307;\\r\\nconst RepeatWrapping = 1000;\\r\\nconst ClampToEdgeWrapping = 1001;\\r\\nconst MirroredRepeatWrapping = 1002;\\r\\nconst NearestFilter = 1003;\\r\\nconst NearestMipmapNearestFilter = 1004;\\r\\nconst NearestMipMapNearestFilter = 1004;\\r\\nconst NearestMipmapLinearFilter = 1005;\\r\\nconst NearestMipMapLinearFilter = 1005;\\r\\nconst LinearFilter = 1006;\\r\\nconst LinearMipmapNearestFilter = 1007;\\r\\nconst LinearMipMapNearestFilter = 1007;\\r\\nconst LinearMipmapLinearFilter = 1008;\\r\\nconst LinearMipMapLinearFilter = 1008;\\r\\nconst UnsignedByteType = 1009;\\r\\nconst ByteType = 1010;\\r\\nconst ShortType = 1011;\\r\\nconst UnsignedShortType = 1012;\\r\\nconst IntType = 1013;\\r\\nconst UnsignedIntType = 1014;\\r\\nconst FloatType = 1015;\\r\\nconst HalfFloatType = 1016;\\r\\nconst UnsignedShort4444Type = 1017;\\r\\nconst UnsignedShort5551Type = 1018;\\r\\nconst UnsignedShort565Type = 1019;\\r\\nconst UnsignedInt248Type = 1020;\\r\\nconst AlphaFormat = 1021;\\r\\nconst RGBFormat = 1022;\\r\\nconst RGBAFormat = 1023;\\r\\nconst LuminanceFormat = 1024;\\r\\nconst LuminanceAlphaFormat = 1025;\\r\\nconst RGBEFormat = RGBAFormat;\\r\\nconst DepthFormat = 1026;\\r\\nconst DepthStencilFormat = 1027;\\r\\nconst RedFormat = 1028;\\r\\nconst RedIntegerFormat = 1029;\\r\\nconst RGFormat = 1030;\\r\\nconst RGIntegerFormat = 1031;\\r\\nconst RGBIntegerFormat = 1032;\\r\\nconst RGBAIntegerFormat = 1033;\\r\\n\\r\\nconst RGB_S3TC_DXT1_Format = 33776;\\r\\nconst RGBA_S3TC_DXT1_Format = 33777;\\r\\nconst RGBA_S3TC_DXT3_Format = 33778;\\r\\nconst RGBA_S3TC_DXT5_Format = 33779;\\r\\nconst RGB_PVRTC_4BPPV1_Format = 35840;\\r\\nconst RGB_PVRTC_2BPPV1_Format = 35841;\\r\\nconst RGBA_PVRTC_4BPPV1_Format = 35842;\\r\\nconst RGBA_PVRTC_2BPPV1_Format = 35843;\\r\\nconst RGB_ETC1_Format = 36196;\\r\\nconst RGB_ETC2_Format = 37492;\\r\\nconst RGBA_ETC2_EAC_Format = 37496;\\r\\nconst RGBA_ASTC_4x4_Format = 37808;\\r\\nconst RGBA_ASTC_5x4_Format = 37809;\\r\\nconst RGBA_ASTC_5x5_Format = 37810;\\r\\nconst RGBA_ASTC_6x5_Format = 37811;\\r\\nconst RGBA_ASTC_6x6_Format = 37812;\\r\\nconst RGBA_ASTC_8x5_Format = 37813;\\r\\nconst RGBA_ASTC_8x6_Format = 37814;\\r\\nconst RGBA_ASTC_8x8_Format = 37815;\\r\\nconst RGBA_ASTC_10x5_Format = 37816;\\r\\nconst RGBA_ASTC_10x6_Format = 37817;\\r\\nconst RGBA_ASTC_10x8_Format = 37818;\\r\\nconst RGBA_ASTC_10x10_Format = 37819;\\r\\nconst RGBA_ASTC_12x10_Format = 37820;\\r\\nconst RGBA_ASTC_12x12_Format = 37821;\\r\\nconst RGBA_BPTC_Format = 36492;\\r\\nconst SRGB8_ALPHA8_ASTC_4x4_Format = 37840;\\r\\nconst SRGB8_ALPHA8_ASTC_5x4_Format = 37841;\\r\\nconst SRGB8_ALPHA8_ASTC_5x5_Format = 37842;\\r\\nconst SRGB8_ALPHA8_ASTC_6x5_Format = 37843;\\r\\nconst SRGB8_ALPHA8_ASTC_6x6_Format = 37844;\\r\\nconst SRGB8_ALPHA8_ASTC_8x5_Format = 37845;\\r\\nconst SRGB8_ALPHA8_ASTC_8x6_Format = 37846;\\r\\nconst SRGB8_ALPHA8_ASTC_8x8_Format = 37847;\\r\\nconst SRGB8_ALPHA8_ASTC_10x5_Format = 37848;\\r\\nconst SRGB8_ALPHA8_ASTC_10x6_Format = 37849;\\r\\nconst SRGB8_ALPHA8_ASTC_10x8_Format = 37850;\\r\\nconst SRGB8_ALPHA8_ASTC_10x10_Format = 37851;\\r\\nconst SRGB8_ALPHA8_ASTC_12x10_Format = 37852;\\r\\nconst SRGB8_ALPHA8_ASTC_12x12_Format = 37853;\\r\\nconst LoopOnce = 2200;\\r\\nconst LoopRepeat = 2201;\\r\\nconst LoopPingPong = 2202;\\r\\nconst InterpolateDiscrete = 2300;\\r\\nconst InterpolateLinear = 2301;\\r\\nconst InterpolateSmooth = 2302;\\r\\nconst ZeroCurvatureEnding = 2400;\\r\\nconst ZeroSlopeEnding = 2401;\\r\\nconst WrapAroundEnding = 2402;\\r\\nconst NormalAnimationBlendMode = 2500;\\r\\nconst AdditiveAnimationBlendMode = 2501;\\r\\nconst TrianglesDrawMode = 0;\\r\\nconst TriangleStripDrawMode = 1;\\r\\nconst TriangleFanDrawMode = 2;\\r\\nconst LinearEncoding = 3000;\\r\\nconst sRGBEncoding = 3001;\\r\\nconst GammaEncoding = 3007;\\r\\nconst RGBEEncoding = 3002;\\r\\nconst LogLuvEncoding = 3003;\\r\\nconst RGBM7Encoding = 3004;\\r\\nconst RGBM16Encoding = 3005;\\r\\nconst RGBDEncoding = 3006;\\r\\nconst BasicDepthPacking = 3200;\\r\\nconst RGBADepthPacking = 3201;\\r\\nconst TangentSpaceNormalMap = 0;\\r\\nconst ObjectSpaceNormalMap = 1;\\r\\n\\r\\nconst ZeroStencilOp = 0;\\r\\nconst KeepStencilOp = 7680;\\r\\nconst ReplaceStencilOp = 7681;\\r\\nconst IncrementStencilOp = 7682;\\r\\nconst DecrementStencilOp = 7683;\\r\\nconst IncrementWrapStencilOp = 34055;\\r\\nconst DecrementWrapStencilOp = 34056;\\r\\nconst InvertStencilOp = 5386;\\r\\n\\r\\nconst NeverStencilFunc = 512;\\r\\nconst LessStencilFunc = 513;\\r\\nconst EqualStencilFunc = 514;\\r\\nconst LessEqualStencilFunc = 515;\\r\\nconst GreaterStencilFunc = 516;\\r\\nconst NotEqualStencilFunc = 517;\\r\\nconst GreaterEqualStencilFunc = 518;\\r\\nconst AlwaysStencilFunc = 519;\\r\\n\\r\\nconst StaticDrawUsage = 35044;\\r\\nconst DynamicDrawUsage = 35048;\\r\\nconst StreamDrawUsage = 35040;\\r\\nconst StaticReadUsage = 35045;\\r\\nconst DynamicReadUsage = 35049;\\r\\nconst StreamReadUsage = 35041;\\r\\nconst StaticCopyUsage = 35046;\\r\\nconst DynamicCopyUsage = 35050;\\r\\nconst StreamCopyUsage = 35042;\\r\\n\\r\\n/**\\r\\n * https://github.com/mrdoob/eventdispatcher.js/\\r\\n */\\r\\n\\r\\nfunction EventDispatcher() {}\\r\\n\\r\\nObject.assign( EventDispatcher.prototype, {\\r\\n\\r\\n\\taddEventListener: function ( type, listener ) {\\r\\n\\r\\n\\t\\tif ( this._listeners === undefined ) this._listeners = {};\\r\\n\\r\\n\\t\\tvar listeners = this._listeners;\\r\\n\\r\\n\\t\\tif ( listeners[ type ] === undefined ) {\\r\\n\\r\\n\\t\\t\\tlisteners[ type ] = [];\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\\r\\n\\r\\n\\t\\t\\tlisteners[ type ].push( listener );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\thasEventListener: function ( type, listener ) {\\r\\n\\r\\n\\t\\tif ( this._listeners === undefined ) return false;\\r\\n\\r\\n\\t\\tvar listeners = this._listeners;\\r\\n\\r\\n\\t\\treturn listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tremoveEventListener: function ( type, listener ) {\\r\\n\\r\\n\\t\\tif ( this._listeners === undefined ) return;\\r\\n\\r\\n\\t\\tvar listeners = this._listeners;\\r\\n\\t\\tvar listenerArray = listeners[ type ];\\r\\n\\r\\n\\t\\tif ( listenerArray !== undefined ) {\\r\\n\\r\\n\\t\\t\\tvar index = listenerArray.indexOf( listener );\\r\\n\\r\\n\\t\\t\\tif ( index !== - 1 ) {\\r\\n\\r\\n\\t\\t\\t\\tlistenerArray.splice( index, 1 );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tdispatchEvent: function ( event ) {\\r\\n\\r\\n\\t\\tif ( this._listeners === undefined ) return;\\r\\n\\r\\n\\t\\tvar listeners = this._listeners;\\r\\n\\t\\tvar listenerArray = listeners[ event.type ];\\r\\n\\r\\n\\t\\tif ( listenerArray !== undefined ) {\\r\\n\\r\\n\\t\\t\\tevent.target = this;\\r\\n\\r\\n\\t\\t\\t// Make a copy, in case listeners are removed while iterating.\\r\\n\\t\\t\\tvar array = listenerArray.slice( 0 );\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = array.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tarray[ i ].call( this, event );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n * @author WestLangley / http://github.com/WestLangley\\r\\n * @author thezwap\\r\\n */\\r\\n\\r\\nvar _lut = [];\\r\\n\\r\\nfor ( var i = 0; i < 256; i ++ ) {\\r\\n\\r\\n\\t_lut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 );\\r\\n\\r\\n}\\r\\n\\r\\nvar MathUtils = {\\r\\n\\r\\n\\tDEG2RAD: Math.PI / 180,\\r\\n\\tRAD2DEG: 180 / Math.PI,\\r\\n\\r\\n\\tgenerateUUID: function () {\\r\\n\\r\\n\\t\\t// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\\r\\n\\r\\n\\t\\tvar d0 = Math.random() * 0xffffffff | 0;\\r\\n\\t\\tvar d1 = Math.random() * 0xffffffff | 0;\\r\\n\\t\\tvar d2 = Math.random() * 0xffffffff | 0;\\r\\n\\t\\tvar d3 = Math.random() * 0xffffffff | 0;\\r\\n\\t\\tvar uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +\\r\\n\\t\\t\\t_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +\\r\\n\\t\\t\\t_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +\\r\\n\\t\\t\\t_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];\\r\\n\\r\\n\\t\\t// .toUpperCase() here flattens concatenated strings to save heap memory space.\\r\\n\\t\\treturn uuid.toUpperCase();\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclamp: function ( value, min, max ) {\\r\\n\\r\\n\\t\\treturn Math.max( min, Math.min( max, value ) );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// compute euclidian modulo of m % n\\r\\n\\t// https://en.wikipedia.org/wiki/Modulo_operation\\r\\n\\r\\n\\teuclideanModulo: function ( n, m ) {\\r\\n\\r\\n\\t\\treturn ( ( n % m ) + m ) % m;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// Linear mapping from range <a1, a2> to range <b1, b2>\\r\\n\\r\\n\\tmapLinear: function ( x, a1, a2, b1, b2 ) {\\r\\n\\r\\n\\t\\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// https://en.wikipedia.org/wiki/Linear_interpolation\\r\\n\\r\\n\\tlerp: function ( x, y, t ) {\\r\\n\\r\\n\\t\\treturn ( 1 - t ) * x + t * y;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// http://en.wikipedia.org/wiki/Smoothstep\\r\\n\\r\\n\\tsmoothstep: function ( x, min, max ) {\\r\\n\\r\\n\\t\\tif ( x <= min ) return 0;\\r\\n\\t\\tif ( x >= max ) return 1;\\r\\n\\r\\n\\t\\tx = ( x - min ) / ( max - min );\\r\\n\\r\\n\\t\\treturn x * x * ( 3 - 2 * x );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsmootherstep: function ( x, min, max ) {\\r\\n\\r\\n\\t\\tif ( x <= min ) return 0;\\r\\n\\t\\tif ( x >= max ) return 1;\\r\\n\\r\\n\\t\\tx = ( x - min ) / ( max - min );\\r\\n\\r\\n\\t\\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// Random integer from <low, high> interval\\r\\n\\r\\n\\trandInt: function ( low, high ) {\\r\\n\\r\\n\\t\\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// Random float from <low, high> interval\\r\\n\\r\\n\\trandFloat: function ( low, high ) {\\r\\n\\r\\n\\t\\treturn low + Math.random() * ( high - low );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// Random float from <-range/2, range/2> interval\\r\\n\\r\\n\\trandFloatSpread: function ( range ) {\\r\\n\\r\\n\\t\\treturn range * ( 0.5 - Math.random() );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tdegToRad: function ( degrees ) {\\r\\n\\r\\n\\t\\treturn degrees * MathUtils.DEG2RAD;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tradToDeg: function ( radians ) {\\r\\n\\r\\n\\t\\treturn radians * MathUtils.RAD2DEG;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tisPowerOfTwo: function ( value ) {\\r\\n\\r\\n\\t\\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tceilPowerOfTwo: function ( value ) {\\r\\n\\r\\n\\t\\treturn Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tfloorPowerOfTwo: function ( value ) {\\r\\n\\r\\n\\t\\treturn Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetQuaternionFromProperEuler: function ( q, a, b, c, order ) {\\r\\n\\r\\n\\t\\t// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles\\r\\n\\r\\n\\t\\t// rotations are applied to the axes in the order specified by 'order'\\r\\n\\t\\t// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'\\r\\n\\t\\t// angles are in radians\\r\\n\\r\\n\\t\\tvar cos = Math.cos;\\r\\n\\t\\tvar sin = Math.sin;\\r\\n\\r\\n\\t\\tvar c2 = cos( b / 2 );\\r\\n\\t\\tvar s2 = sin( b / 2 );\\r\\n\\r\\n\\t\\tvar c13 = cos( ( a + c ) / 2 );\\r\\n\\t\\tvar s13 = sin( ( a + c ) / 2 );\\r\\n\\r\\n\\t\\tvar c1_3 = cos( ( a - c ) / 2 );\\r\\n\\t\\tvar s1_3 = sin( ( a - c ) / 2 );\\r\\n\\r\\n\\t\\tvar c3_1 = cos( ( c - a ) / 2 );\\r\\n\\t\\tvar s3_1 = sin( ( c - a ) / 2 );\\r\\n\\r\\n\\t\\tswitch ( order ) {\\r\\n\\r\\n\\t\\t\\tcase 'XYX':\\r\\n\\t\\t\\t\\tq.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tcase 'YZY':\\r\\n\\t\\t\\t\\tq.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tcase 'ZXZ':\\r\\n\\t\\t\\t\\tq.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tcase 'XZX':\\r\\n\\t\\t\\t\\tq.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tcase 'YXY':\\r\\n\\t\\t\\t\\tq.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tcase 'ZYZ':\\r\\n\\t\\t\\t\\tq.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tdefault:\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n};\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n * @author philogb / http://blog.thejit.org/\\r\\n * @author egraether / http://egraether.com/\\r\\n * @author zz85 / http://www.lab4games.net/zz85/blog\\r\\n */\\r\\n\\r\\nfunction Vector2( x, y ) {\\r\\n\\r\\n\\tthis.x = x || 0;\\r\\n\\tthis.y = y || 0;\\r\\n\\r\\n}\\r\\n\\r\\nObject.defineProperties( Vector2.prototype, {\\r\\n\\r\\n\\t\\\"width\\\": {\\r\\n\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\treturn this.x;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\tthis.x = value;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t\\\"height\\\": {\\r\\n\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\treturn this.y;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\tthis.y = value;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nObject.assign( Vector2.prototype, {\\r\\n\\r\\n\\tisVector2: true,\\r\\n\\r\\n\\tset: function ( x, y ) {\\r\\n\\r\\n\\t\\tthis.x = x;\\r\\n\\t\\tthis.y = y;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetScalar: function ( scalar ) {\\r\\n\\r\\n\\t\\tthis.x = scalar;\\r\\n\\t\\tthis.y = scalar;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetX: function ( x ) {\\r\\n\\r\\n\\t\\tthis.x = x;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetY: function ( y ) {\\r\\n\\r\\n\\t\\tthis.y = y;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetComponent: function ( index, value ) {\\r\\n\\r\\n\\t\\tswitch ( index ) {\\r\\n\\r\\n\\t\\t\\tcase 0: this.x = value; break;\\r\\n\\t\\t\\tcase 1: this.y = value; break;\\r\\n\\t\\t\\tdefault: throw new Error( 'index is out of range: ' + index );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetComponent: function ( index ) {\\r\\n\\r\\n\\t\\tswitch ( index ) {\\r\\n\\r\\n\\t\\t\\tcase 0: return this.x;\\r\\n\\t\\t\\tcase 1: return this.y;\\r\\n\\t\\t\\tdefault: throw new Error( 'index is out of range: ' + index );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclone: function () {\\r\\n\\r\\n\\t\\treturn new this.constructor( this.x, this.y );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcopy: function ( v ) {\\r\\n\\r\\n\\t\\tthis.x = v.x;\\r\\n\\t\\tthis.y = v.y;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tadd: function ( v, w ) {\\r\\n\\r\\n\\t\\tif ( w !== undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\\r\\n\\t\\t\\treturn this.addVectors( v, w );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.x += v.x;\\r\\n\\t\\tthis.y += v.y;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\taddScalar: function ( s ) {\\r\\n\\r\\n\\t\\tthis.x += s;\\r\\n\\t\\tthis.y += s;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\taddVectors: function ( a, b ) {\\r\\n\\r\\n\\t\\tthis.x = a.x + b.x;\\r\\n\\t\\tthis.y = a.y + b.y;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\taddScaledVector: function ( v, s ) {\\r\\n\\r\\n\\t\\tthis.x += v.x * s;\\r\\n\\t\\tthis.y += v.y * s;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsub: function ( v, w ) {\\r\\n\\r\\n\\t\\tif ( w !== undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\\r\\n\\t\\t\\treturn this.subVectors( v, w );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.x -= v.x;\\r\\n\\t\\tthis.y -= v.y;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsubScalar: function ( s ) {\\r\\n\\r\\n\\t\\tthis.x -= s;\\r\\n\\t\\tthis.y -= s;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsubVectors: function ( a, b ) {\\r\\n\\r\\n\\t\\tthis.x = a.x - b.x;\\r\\n\\t\\tthis.y = a.y - b.y;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tmultiply: function ( v ) {\\r\\n\\r\\n\\t\\tthis.x *= v.x;\\r\\n\\t\\tthis.y *= v.y;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tmultiplyScalar: function ( scalar ) {\\r\\n\\r\\n\\t\\tthis.x *= scalar;\\r\\n\\t\\tthis.y *= scalar;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tdivide: function ( v ) {\\r\\n\\r\\n\\t\\tthis.x /= v.x;\\r\\n\\t\\tthis.y /= v.y;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tdivideScalar: function ( scalar ) {\\r\\n\\r\\n\\t\\treturn this.multiplyScalar( 1 / scalar );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tapplyMatrix3: function ( m ) {\\r\\n\\r\\n\\t\\tvar x = this.x, y = this.y;\\r\\n\\t\\tvar e = m.elements;\\r\\n\\r\\n\\t\\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];\\r\\n\\t\\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tmin: function ( v ) {\\r\\n\\r\\n\\t\\tthis.x = Math.min( this.x, v.x );\\r\\n\\t\\tthis.y = Math.min( this.y, v.y );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tmax: function ( v ) {\\r\\n\\r\\n\\t\\tthis.x = Math.max( this.x, v.x );\\r\\n\\t\\tthis.y = Math.max( this.y, v.y );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclamp: function ( min, max ) {\\r\\n\\r\\n\\t\\t// assumes min < max, componentwise\\r\\n\\r\\n\\t\\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\\r\\n\\t\\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclampScalar: function ( minVal, maxVal ) {\\r\\n\\r\\n\\t\\tthis.x = Math.max( minVal, Math.min( maxVal, this.x ) );\\r\\n\\t\\tthis.y = Math.max( minVal, Math.min( maxVal, this.y ) );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclampLength: function ( min, max ) {\\r\\n\\r\\n\\t\\tvar length = this.length();\\r\\n\\r\\n\\t\\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tfloor: function () {\\r\\n\\r\\n\\t\\tthis.x = Math.floor( this.x );\\r\\n\\t\\tthis.y = Math.floor( this.y );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tceil: function () {\\r\\n\\r\\n\\t\\tthis.x = Math.ceil( this.x );\\r\\n\\t\\tthis.y = Math.ceil( this.y );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tround: function () {\\r\\n\\r\\n\\t\\tthis.x = Math.round( this.x );\\r\\n\\t\\tthis.y = Math.round( this.y );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\troundToZero: function () {\\r\\n\\r\\n\\t\\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\\r\\n\\t\\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tnegate: function () {\\r\\n\\r\\n\\t\\tthis.x = - this.x;\\r\\n\\t\\tthis.y = - this.y;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tdot: function ( v ) {\\r\\n\\r\\n\\t\\treturn this.x * v.x + this.y * v.y;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcross: function ( v ) {\\r\\n\\r\\n\\t\\treturn this.x * v.y - this.y * v.x;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tlengthSq: function () {\\r\\n\\r\\n\\t\\treturn this.x * this.x + this.y * this.y;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tlength: function () {\\r\\n\\r\\n\\t\\treturn Math.sqrt( this.x * this.x + this.y * this.y );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tmanhattanLength: function () {\\r\\n\\r\\n\\t\\treturn Math.abs( this.x ) + Math.abs( this.y );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tnormalize: function () {\\r\\n\\r\\n\\t\\treturn this.divideScalar( this.length() || 1 );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tangle: function () {\\r\\n\\r\\n\\t\\t// computes the angle in radians with respect to the positive x-axis\\r\\n\\r\\n\\t\\tvar angle = Math.atan2( - this.y, - this.x ) + Math.PI;\\r\\n\\r\\n\\t\\treturn angle;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tdistanceTo: function ( v ) {\\r\\n\\r\\n\\t\\treturn Math.sqrt( this.distanceToSquared( v ) );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tdistanceToSquared: function ( v ) {\\r\\n\\r\\n\\t\\tvar dx = this.x - v.x, dy = this.y - v.y;\\r\\n\\t\\treturn dx * dx + dy * dy;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tmanhattanDistanceTo: function ( v ) {\\r\\n\\r\\n\\t\\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetLength: function ( length ) {\\r\\n\\r\\n\\t\\treturn this.normalize().multiplyScalar( length );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tlerp: function ( v, alpha ) {\\r\\n\\r\\n\\t\\tthis.x += ( v.x - this.x ) * alpha;\\r\\n\\t\\tthis.y += ( v.y - this.y ) * alpha;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tlerpVectors: function ( v1, v2, alpha ) {\\r\\n\\r\\n\\t\\tthis.x = v1.x + ( v2.x - v1.x ) * alpha;\\r\\n\\t\\tthis.y = v1.y + ( v2.y - v1.y ) * alpha;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tequals: function ( v ) {\\r\\n\\r\\n\\t\\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tfromArray: function ( array, offset ) {\\r\\n\\r\\n\\t\\tif ( offset === undefined ) offset = 0;\\r\\n\\r\\n\\t\\tthis.x = array[ offset ];\\r\\n\\t\\tthis.y = array[ offset + 1 ];\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttoArray: function ( array, offset ) {\\r\\n\\r\\n\\t\\tif ( array === undefined ) array = [];\\r\\n\\t\\tif ( offset === undefined ) offset = 0;\\r\\n\\r\\n\\t\\tarray[ offset ] = this.x;\\r\\n\\t\\tarray[ offset + 1 ] = this.y;\\r\\n\\r\\n\\t\\treturn array;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tfromBufferAttribute: function ( attribute, index, offset ) {\\r\\n\\r\\n\\t\\tif ( offset !== undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.x = attribute.getX( index );\\r\\n\\t\\tthis.y = attribute.getY( index );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\trotateAround: function ( center, angle ) {\\r\\n\\r\\n\\t\\tvar c = Math.cos( angle ), s = Math.sin( angle );\\r\\n\\r\\n\\t\\tvar x = this.x - center.x;\\r\\n\\t\\tvar y = this.y - center.y;\\r\\n\\r\\n\\t\\tthis.x = x * c - y * s + center.x;\\r\\n\\t\\tthis.y = x * s + y * c + center.y;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\trandom: function () {\\r\\n\\r\\n\\t\\tthis.x = Math.random();\\r\\n\\t\\tthis.y = Math.random();\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n * @author WestLangley / http://github.com/WestLangley\\r\\n * @author bhouston / http://clara.io\\r\\n * @author tschw\\r\\n */\\r\\n\\r\\nfunction Matrix3() {\\r\\n\\r\\n\\tthis.elements = [\\r\\n\\r\\n\\t\\t1, 0, 0,\\r\\n\\t\\t0, 1, 0,\\r\\n\\t\\t0, 0, 1\\r\\n\\r\\n\\t];\\r\\n\\r\\n\\tif ( arguments.length > 0 ) {\\r\\n\\r\\n\\t\\tconsole.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );\\r\\n\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\\r\\nObject.assign( Matrix3.prototype, {\\r\\n\\r\\n\\tisMatrix3: true,\\r\\n\\r\\n\\tset: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\\r\\n\\r\\n\\t\\tvar te = this.elements;\\r\\n\\r\\n\\t\\tte[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;\\r\\n\\t\\tte[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;\\r\\n\\t\\tte[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tidentity: function () {\\r\\n\\r\\n\\t\\tthis.set(\\r\\n\\r\\n\\t\\t\\t1, 0, 0,\\r\\n\\t\\t\\t0, 1, 0,\\r\\n\\t\\t\\t0, 0, 1\\r\\n\\r\\n\\t\\t);\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclone: function () {\\r\\n\\r\\n\\t\\treturn new this.constructor().fromArray( this.elements );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcopy: function ( m ) {\\r\\n\\r\\n\\t\\tvar te = this.elements;\\r\\n\\t\\tvar me = m.elements;\\r\\n\\r\\n\\t\\tte[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];\\r\\n\\t\\tte[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];\\r\\n\\t\\tte[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\textractBasis: function ( xAxis, yAxis, zAxis ) {\\r\\n\\r\\n\\t\\txAxis.setFromMatrix3Column( this, 0 );\\r\\n\\t\\tyAxis.setFromMatrix3Column( this, 1 );\\r\\n\\t\\tzAxis.setFromMatrix3Column( this, 2 );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetFromMatrix4: function ( m ) {\\r\\n\\r\\n\\t\\tvar me = m.elements;\\r\\n\\r\\n\\t\\tthis.set(\\r\\n\\r\\n\\t\\t\\tme[ 0 ], me[ 4 ], me[ 8 ],\\r\\n\\t\\t\\tme[ 1 ], me[ 5 ], me[ 9 ],\\r\\n\\t\\t\\tme[ 2 ], me[ 6 ], me[ 10 ]\\r\\n\\r\\n\\t\\t);\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tmultiply: function ( m ) {\\r\\n\\r\\n\\t\\treturn this.multiplyMatrices( this, m );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tpremultiply: function ( m ) {\\r\\n\\r\\n\\t\\treturn this.multiplyMatrices( m, this );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tmultiplyMatrices: function ( a, b ) {\\r\\n\\r\\n\\t\\tvar ae = a.elements;\\r\\n\\t\\tvar be = b.elements;\\r\\n\\t\\tvar te = this.elements;\\r\\n\\r\\n\\t\\tvar a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];\\r\\n\\t\\tvar a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];\\r\\n\\t\\tvar a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];\\r\\n\\r\\n\\t\\tvar b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];\\r\\n\\t\\tvar b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];\\r\\n\\t\\tvar b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];\\r\\n\\r\\n\\t\\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;\\r\\n\\t\\tte[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;\\r\\n\\t\\tte[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;\\r\\n\\r\\n\\t\\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;\\r\\n\\t\\tte[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;\\r\\n\\t\\tte[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;\\r\\n\\r\\n\\t\\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;\\r\\n\\t\\tte[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;\\r\\n\\t\\tte[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tmultiplyScalar: function ( s ) {\\r\\n\\r\\n\\t\\tvar te = this.elements;\\r\\n\\r\\n\\t\\tte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\\r\\n\\t\\tte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\\r\\n\\t\\tte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tdeterminant: function () {\\r\\n\\r\\n\\t\\tvar te = this.elements;\\r\\n\\r\\n\\t\\tvar a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\\r\\n\\t\\t\\td = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\\r\\n\\t\\t\\tg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\\r\\n\\r\\n\\t\\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetInverse: function ( matrix, throwOnDegenerate ) {\\r\\n\\r\\n\\t\\tif ( throwOnDegenerate !== undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( \\\"THREE.Matrix3: .getInverse() can no longer be configured to throw on degenerate.\\\" );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar me = matrix.elements,\\r\\n\\t\\t\\tte = this.elements,\\r\\n\\r\\n\\t\\t\\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],\\r\\n\\t\\t\\tn12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],\\r\\n\\t\\t\\tn13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],\\r\\n\\r\\n\\t\\t\\tt11 = n33 * n22 - n32 * n23,\\r\\n\\t\\t\\tt12 = n32 * n13 - n33 * n12,\\r\\n\\t\\t\\tt13 = n23 * n12 - n22 * n13,\\r\\n\\r\\n\\t\\t\\tdet = n11 * t11 + n21 * t12 + n31 * t13;\\r\\n\\r\\n\\t\\tif ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );\\r\\n\\r\\n\\t\\tvar detInv = 1 / det;\\r\\n\\r\\n\\t\\tte[ 0 ] = t11 * detInv;\\r\\n\\t\\tte[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;\\r\\n\\t\\tte[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;\\r\\n\\r\\n\\t\\tte[ 3 ] = t12 * detInv;\\r\\n\\t\\tte[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;\\r\\n\\t\\tte[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;\\r\\n\\r\\n\\t\\tte[ 6 ] = t13 * detInv;\\r\\n\\t\\tte[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;\\r\\n\\t\\tte[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttranspose: function () {\\r\\n\\r\\n\\t\\tvar tmp, m = this.elements;\\r\\n\\r\\n\\t\\ttmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\\r\\n\\t\\ttmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\\r\\n\\t\\ttmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetNormalMatrix: function ( matrix4 ) {\\r\\n\\r\\n\\t\\treturn this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttransposeIntoArray: function ( r ) {\\r\\n\\r\\n\\t\\tvar m = this.elements;\\r\\n\\r\\n\\t\\tr[ 0 ] = m[ 0 ];\\r\\n\\t\\tr[ 1 ] = m[ 3 ];\\r\\n\\t\\tr[ 2 ] = m[ 6 ];\\r\\n\\t\\tr[ 3 ] = m[ 1 ];\\r\\n\\t\\tr[ 4 ] = m[ 4 ];\\r\\n\\t\\tr[ 5 ] = m[ 7 ];\\r\\n\\t\\tr[ 6 ] = m[ 2 ];\\r\\n\\t\\tr[ 7 ] = m[ 5 ];\\r\\n\\t\\tr[ 8 ] = m[ 8 ];\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetUvTransform: function ( tx, ty, sx, sy, rotation, cx, cy ) {\\r\\n\\r\\n\\t\\tvar c = Math.cos( rotation );\\r\\n\\t\\tvar s = Math.sin( rotation );\\r\\n\\r\\n\\t\\tthis.set(\\r\\n\\t\\t\\tsx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,\\r\\n\\t\\t\\t- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,\\r\\n\\t\\t\\t0, 0, 1\\r\\n\\t\\t);\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tscale: function ( sx, sy ) {\\r\\n\\r\\n\\t\\tvar te = this.elements;\\r\\n\\r\\n\\t\\tte[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;\\r\\n\\t\\tte[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\trotate: function ( theta ) {\\r\\n\\r\\n\\t\\tvar c = Math.cos( theta );\\r\\n\\t\\tvar s = Math.sin( theta );\\r\\n\\r\\n\\t\\tvar te = this.elements;\\r\\n\\r\\n\\t\\tvar a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];\\r\\n\\t\\tvar a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];\\r\\n\\r\\n\\t\\tte[ 0 ] = c * a11 + s * a21;\\r\\n\\t\\tte[ 3 ] = c * a12 + s * a22;\\r\\n\\t\\tte[ 6 ] = c * a13 + s * a23;\\r\\n\\r\\n\\t\\tte[ 1 ] = - s * a11 + c * a21;\\r\\n\\t\\tte[ 4 ] = - s * a12 + c * a22;\\r\\n\\t\\tte[ 7 ] = - s * a13 + c * a23;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttranslate: function ( tx, ty ) {\\r\\n\\r\\n\\t\\tvar te = this.elements;\\r\\n\\r\\n\\t\\tte[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];\\r\\n\\t\\tte[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tequals: function ( matrix ) {\\r\\n\\r\\n\\t\\tvar te = this.elements;\\r\\n\\t\\tvar me = matrix.elements;\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < 9; i ++ ) {\\r\\n\\r\\n\\t\\t\\tif ( te[ i ] !== me[ i ] ) return false;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn true;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tfromArray: function ( array, offset ) {\\r\\n\\r\\n\\t\\tif ( offset === undefined ) offset = 0;\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < 9; i ++ ) {\\r\\n\\r\\n\\t\\t\\tthis.elements[ i ] = array[ i + offset ];\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttoArray: function ( array, offset ) {\\r\\n\\r\\n\\t\\tif ( array === undefined ) array = [];\\r\\n\\t\\tif ( offset === undefined ) offset = 0;\\r\\n\\r\\n\\t\\tvar te = this.elements;\\r\\n\\r\\n\\t\\tarray[ offset ] = te[ 0 ];\\r\\n\\t\\tarray[ offset + 1 ] = te[ 1 ];\\r\\n\\t\\tarray[ offset + 2 ] = te[ 2 ];\\r\\n\\r\\n\\t\\tarray[ offset + 3 ] = te[ 3 ];\\r\\n\\t\\tarray[ offset + 4 ] = te[ 4 ];\\r\\n\\t\\tarray[ offset + 5 ] = te[ 5 ];\\r\\n\\r\\n\\t\\tarray[ offset + 6 ] = te[ 6 ];\\r\\n\\t\\tarray[ offset + 7 ] = te[ 7 ];\\r\\n\\t\\tarray[ offset + 8 ] = te[ 8 ];\\r\\n\\r\\n\\t\\treturn array;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n * @author szimek / https://github.com/szimek/\\r\\n */\\r\\n\\r\\nvar _canvas;\\r\\n\\r\\nvar ImageUtils = {\\r\\n\\r\\n\\tgetDataURL: function ( image ) {\\r\\n\\r\\n\\t\\tvar canvas;\\r\\n\\r\\n\\t\\tif ( typeof HTMLCanvasElement == 'undefined' ) {\\r\\n\\r\\n\\t\\t\\treturn image.src;\\r\\n\\r\\n\\t\\t} else if ( image instanceof HTMLCanvasElement ) {\\r\\n\\r\\n\\t\\t\\tcanvas = image;\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tif ( _canvas === undefined ) _canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\\r\\n\\r\\n\\t\\t\\t_canvas.width = image.width;\\r\\n\\t\\t\\t_canvas.height = image.height;\\r\\n\\r\\n\\t\\t\\tvar context = _canvas.getContext( '2d' );\\r\\n\\r\\n\\t\\t\\tif ( image instanceof ImageData ) {\\r\\n\\r\\n\\t\\t\\t\\tcontext.putImageData( image, 0, 0 );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tcontext.drawImage( image, 0, 0, image.width, image.height );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tcanvas = _canvas;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( canvas.width > 2048 || canvas.height > 2048 ) {\\r\\n\\r\\n\\t\\t\\treturn canvas.toDataURL( 'image/jpeg', 0.6 );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\treturn canvas.toDataURL( 'image/png' );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n};\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n * @author szimek / https://github.com/szimek/\\r\\n */\\r\\n\\r\\nvar textureId = 0;\\r\\n\\r\\nfunction Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\\r\\n\\r\\n\\tObject.defineProperty( this, 'id', { value: textureId ++ } );\\r\\n\\r\\n\\tthis.uuid = MathUtils.generateUUID();\\r\\n\\r\\n\\tthis.name = '';\\r\\n\\r\\n\\tthis.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;\\r\\n\\tthis.mipmaps = [];\\r\\n\\r\\n\\tthis.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;\\r\\n\\r\\n\\tthis.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;\\r\\n\\tthis.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;\\r\\n\\r\\n\\tthis.magFilter = magFilter !== undefined ? magFilter : LinearFilter;\\r\\n\\tthis.minFilter = minFilter !== undefined ? minFilter : LinearMipmapLinearFilter;\\r\\n\\r\\n\\tthis.anisotropy = anisotropy !== undefined ? anisotropy : 1;\\r\\n\\r\\n\\tthis.format = format !== undefined ? format : RGBAFormat;\\r\\n\\tthis.internalFormat = null;\\r\\n\\tthis.type = type !== undefined ? type : UnsignedByteType;\\r\\n\\r\\n\\tthis.offset = new Vector2( 0, 0 );\\r\\n\\tthis.repeat = new Vector2( 1, 1 );\\r\\n\\tthis.center = new Vector2( 0, 0 );\\r\\n\\tthis.rotation = 0;\\r\\n\\r\\n\\tthis.matrixAutoUpdate = true;\\r\\n\\tthis.matrix = new Matrix3();\\r\\n\\r\\n\\tthis.generateMipmaps = true;\\r\\n\\tthis.premultiplyAlpha = false;\\r\\n\\tthis.flipY = true;\\r\\n\\tthis.unpackAlignment = 4;\\t// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\\r\\n\\r\\n\\t// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.\\r\\n\\t//\\r\\n\\t// Also changing the encoding after already used by a Material will not automatically make the Material\\r\\n\\t// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.\\r\\n\\tthis.encoding = encoding !== undefined ? encoding : LinearEncoding;\\r\\n\\r\\n\\tthis.version = 0;\\r\\n\\tthis.onUpdate = null;\\r\\n\\r\\n}\\r\\n\\r\\nTexture.DEFAULT_IMAGE = undefined;\\r\\nTexture.DEFAULT_MAPPING = UVMapping;\\r\\n\\r\\nTexture.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\\r\\n\\r\\n\\tconstructor: Texture,\\r\\n\\r\\n\\tisTexture: true,\\r\\n\\r\\n\\tupdateMatrix: function () {\\r\\n\\r\\n\\t\\tthis.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclone: function () {\\r\\n\\r\\n\\t\\treturn new this.constructor().copy( this );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\tthis.name = source.name;\\r\\n\\r\\n\\t\\tthis.image = source.image;\\r\\n\\t\\tthis.mipmaps = source.mipmaps.slice( 0 );\\r\\n\\r\\n\\t\\tthis.mapping = source.mapping;\\r\\n\\r\\n\\t\\tthis.wrapS = source.wrapS;\\r\\n\\t\\tthis.wrapT = source.wrapT;\\r\\n\\r\\n\\t\\tthis.magFilter = source.magFilter;\\r\\n\\t\\tthis.minFilter = source.minFilter;\\r\\n\\r\\n\\t\\tthis.anisotropy = source.anisotropy;\\r\\n\\r\\n\\t\\tthis.format = source.format;\\r\\n\\t\\tthis.internalFormat = source.internalFormat;\\r\\n\\t\\tthis.type = source.type;\\r\\n\\r\\n\\t\\tthis.offset.copy( source.offset );\\r\\n\\t\\tthis.repeat.copy( source.repeat );\\r\\n\\t\\tthis.center.copy( source.center );\\r\\n\\t\\tthis.rotation = source.rotation;\\r\\n\\r\\n\\t\\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\\r\\n\\t\\tthis.matrix.copy( source.matrix );\\r\\n\\r\\n\\t\\tthis.generateMipmaps = source.generateMipmaps;\\r\\n\\t\\tthis.premultiplyAlpha = source.premultiplyAlpha;\\r\\n\\t\\tthis.flipY = source.flipY;\\r\\n\\t\\tthis.unpackAlignment = source.unpackAlignment;\\r\\n\\t\\tthis.encoding = source.encoding;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttoJSON: function ( meta ) {\\r\\n\\r\\n\\t\\tvar isRootObject = ( meta === undefined || typeof meta === 'string' );\\r\\n\\r\\n\\t\\tif ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {\\r\\n\\r\\n\\t\\t\\treturn meta.textures[ this.uuid ];\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar output = {\\r\\n\\r\\n\\t\\t\\tmetadata: {\\r\\n\\t\\t\\t\\tversion: 4.5,\\r\\n\\t\\t\\t\\ttype: 'Texture',\\r\\n\\t\\t\\t\\tgenerator: 'Texture.toJSON'\\r\\n\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\tuuid: this.uuid,\\r\\n\\t\\t\\tname: this.name,\\r\\n\\r\\n\\t\\t\\tmapping: this.mapping,\\r\\n\\r\\n\\t\\t\\trepeat: [ this.repeat.x, this.repeat.y ],\\r\\n\\t\\t\\toffset: [ this.offset.x, this.offset.y ],\\r\\n\\t\\t\\tcenter: [ this.center.x, this.center.y ],\\r\\n\\t\\t\\trotation: this.rotation,\\r\\n\\r\\n\\t\\t\\twrap: [ this.wrapS, this.wrapT ],\\r\\n\\r\\n\\t\\t\\tformat: this.format,\\r\\n\\t\\t\\ttype: this.type,\\r\\n\\t\\t\\tencoding: this.encoding,\\r\\n\\r\\n\\t\\t\\tminFilter: this.minFilter,\\r\\n\\t\\t\\tmagFilter: this.magFilter,\\r\\n\\t\\t\\tanisotropy: this.anisotropy,\\r\\n\\r\\n\\t\\t\\tflipY: this.flipY,\\r\\n\\r\\n\\t\\t\\tpremultiplyAlpha: this.premultiplyAlpha,\\r\\n\\t\\t\\tunpackAlignment: this.unpackAlignment\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tif ( this.image !== undefined ) {\\r\\n\\r\\n\\t\\t\\t// TODO: Move to THREE.Image\\r\\n\\r\\n\\t\\t\\tvar image = this.image;\\r\\n\\r\\n\\t\\t\\tif ( image.uuid === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\timage.uuid = MathUtils.generateUUID(); // UGH\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( ! isRootObject && meta.images[ image.uuid ] === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tvar url;\\r\\n\\r\\n\\t\\t\\t\\tif ( Array.isArray( image ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// process array of images e.g. CubeTexture\\r\\n\\r\\n\\t\\t\\t\\t\\turl = [];\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var i = 0, l = image.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\turl.push( ImageUtils.getDataURL( image[ i ] ) );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t// process single image\\r\\n\\r\\n\\t\\t\\t\\t\\turl = ImageUtils.getDataURL( image );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tmeta.images[ image.uuid ] = {\\r\\n\\t\\t\\t\\t\\tuuid: image.uuid,\\r\\n\\t\\t\\t\\t\\turl: url\\r\\n\\t\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\toutput.image = image.uuid;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( ! isRootObject ) {\\r\\n\\r\\n\\t\\t\\tmeta.textures[ this.uuid ] = output;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn output;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tdispose: function () {\\r\\n\\r\\n\\t\\tthis.dispatchEvent( { type: 'dispose' } );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttransformUv: function ( uv ) {\\r\\n\\r\\n\\t\\tif ( this.mapping !== UVMapping ) return uv;\\r\\n\\r\\n\\t\\tuv.applyMatrix3( this.matrix );\\r\\n\\r\\n\\t\\tif ( uv.x < 0 || uv.x > 1 ) {\\r\\n\\r\\n\\t\\t\\tswitch ( this.wrapS ) {\\r\\n\\r\\n\\t\\t\\t\\tcase RepeatWrapping:\\r\\n\\r\\n\\t\\t\\t\\t\\tuv.x = uv.x - Math.floor( uv.x );\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\tcase ClampToEdgeWrapping:\\r\\n\\r\\n\\t\\t\\t\\t\\tuv.x = uv.x < 0 ? 0 : 1;\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\tcase MirroredRepeatWrapping:\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tuv.x = Math.ceil( uv.x ) - uv.x;\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tuv.x = uv.x - Math.floor( uv.x );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( uv.y < 0 || uv.y > 1 ) {\\r\\n\\r\\n\\t\\t\\tswitch ( this.wrapT ) {\\r\\n\\r\\n\\t\\t\\t\\tcase RepeatWrapping:\\r\\n\\r\\n\\t\\t\\t\\t\\tuv.y = uv.y - Math.floor( uv.y );\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\tcase ClampToEdgeWrapping:\\r\\n\\r\\n\\t\\t\\t\\t\\tuv.y = uv.y < 0 ? 0 : 1;\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\tcase MirroredRepeatWrapping:\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tuv.y = Math.ceil( uv.y ) - uv.y;\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tuv.y = uv.y - Math.floor( uv.y );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( this.flipY ) {\\r\\n\\r\\n\\t\\t\\tuv.y = 1 - uv.y;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn uv;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nObject.defineProperty( Texture.prototype, \\\"needsUpdate\\\", {\\r\\n\\r\\n\\tset: function ( value ) {\\r\\n\\r\\n\\t\\tif ( value === true ) this.version ++;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author supereggbert / http://www.paulbrunt.co.uk/\\r\\n * @author philogb / http://blog.thejit.org/\\r\\n * @author mikael emtinger / http://gomo.se/\\r\\n * @author egraether / http://egraether.com/\\r\\n * @author WestLangley / http://github.com/WestLangley\\r\\n */\\r\\n\\r\\nfunction Vector4( x, y, z, w ) {\\r\\n\\r\\n\\tthis.x = x || 0;\\r\\n\\tthis.y = y || 0;\\r\\n\\tthis.z = z || 0;\\r\\n\\tthis.w = ( w !== undefined ) ? w : 1;\\r\\n\\r\\n}\\r\\n\\r\\nObject.defineProperties( Vector4.prototype, {\\r\\n\\r\\n\\t\\\"width\\\": {\\r\\n\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\treturn this.z;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\tthis.z = value;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t\\\"height\\\": {\\r\\n\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\treturn this.w;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\tthis.w = value;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nObject.assign( Vector4.prototype, {\\r\\n\\r\\n\\tisVector4: true,\\r\\n\\r\\n\\tset: function ( x, y, z, w ) {\\r\\n\\r\\n\\t\\tthis.x = x;\\r\\n\\t\\tthis.y = y;\\r\\n\\t\\tthis.z = z;\\r\\n\\t\\tthis.w = w;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetScalar: function ( scalar ) {\\r\\n\\r\\n\\t\\tthis.x = scalar;\\r\\n\\t\\tthis.y = scalar;\\r\\n\\t\\tthis.z = scalar;\\r\\n\\t\\tthis.w = scalar;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetX: function ( x ) {\\r\\n\\r\\n\\t\\tthis.x = x;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetY: function ( y ) {\\r\\n\\r\\n\\t\\tthis.y = y;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetZ: function ( z ) {\\r\\n\\r\\n\\t\\tthis.z = z;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetW: function ( w ) {\\r\\n\\r\\n\\t\\tthis.w = w;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetComponent: function ( index, value ) {\\r\\n\\r\\n\\t\\tswitch ( index ) {\\r\\n\\r\\n\\t\\t\\tcase 0: this.x = value; break;\\r\\n\\t\\t\\tcase 1: this.y = value; break;\\r\\n\\t\\t\\tcase 2: this.z = value; break;\\r\\n\\t\\t\\tcase 3: this.w = value; break;\\r\\n\\t\\t\\tdefault: throw new Error( 'index is out of range: ' + index );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetComponent: function ( index ) {\\r\\n\\r\\n\\t\\tswitch ( index ) {\\r\\n\\r\\n\\t\\t\\tcase 0: return this.x;\\r\\n\\t\\t\\tcase 1: return this.y;\\r\\n\\t\\t\\tcase 2: return this.z;\\r\\n\\t\\t\\tcase 3: return this.w;\\r\\n\\t\\t\\tdefault: throw new Error( 'index is out of range: ' + index );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclone: function () {\\r\\n\\r\\n\\t\\treturn new this.constructor( this.x, this.y, this.z, this.w );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcopy: function ( v ) {\\r\\n\\r\\n\\t\\tthis.x = v.x;\\r\\n\\t\\tthis.y = v.y;\\r\\n\\t\\tthis.z = v.z;\\r\\n\\t\\tthis.w = ( v.w !== undefined ) ? v.w : 1;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tadd: function ( v, w ) {\\r\\n\\r\\n\\t\\tif ( w !== undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\\r\\n\\t\\t\\treturn this.addVectors( v, w );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.x += v.x;\\r\\n\\t\\tthis.y += v.y;\\r\\n\\t\\tthis.z += v.z;\\r\\n\\t\\tthis.w += v.w;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\taddScalar: function ( s ) {\\r\\n\\r\\n\\t\\tthis.x += s;\\r\\n\\t\\tthis.y += s;\\r\\n\\t\\tthis.z += s;\\r\\n\\t\\tthis.w += s;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\taddVectors: function ( a, b ) {\\r\\n\\r\\n\\t\\tthis.x = a.x + b.x;\\r\\n\\t\\tthis.y = a.y + b.y;\\r\\n\\t\\tthis.z = a.z + b.z;\\r\\n\\t\\tthis.w = a.w + b.w;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\taddScaledVector: function ( v, s ) {\\r\\n\\r\\n\\t\\tthis.x += v.x * s;\\r\\n\\t\\tthis.y += v.y * s;\\r\\n\\t\\tthis.z += v.z * s;\\r\\n\\t\\tthis.w += v.w * s;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsub: function ( v, w ) {\\r\\n\\r\\n\\t\\tif ( w !== undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\\r\\n\\t\\t\\treturn this.subVectors( v, w );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.x -= v.x;\\r\\n\\t\\tthis.y -= v.y;\\r\\n\\t\\tthis.z -= v.z;\\r\\n\\t\\tthis.w -= v.w;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsubScalar: function ( s ) {\\r\\n\\r\\n\\t\\tthis.x -= s;\\r\\n\\t\\tthis.y -= s;\\r\\n\\t\\tthis.z -= s;\\r\\n\\t\\tthis.w -= s;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsubVectors: function ( a, b ) {\\r\\n\\r\\n\\t\\tthis.x = a.x - b.x;\\r\\n\\t\\tthis.y = a.y - b.y;\\r\\n\\t\\tthis.z = a.z - b.z;\\r\\n\\t\\tthis.w = a.w - b.w;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tmultiplyScalar: function ( scalar ) {\\r\\n\\r\\n\\t\\tthis.x *= scalar;\\r\\n\\t\\tthis.y *= scalar;\\r\\n\\t\\tthis.z *= scalar;\\r\\n\\t\\tthis.w *= scalar;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tapplyMatrix4: function ( m ) {\\r\\n\\r\\n\\t\\tvar x = this.x, y = this.y, z = this.z, w = this.w;\\r\\n\\t\\tvar e = m.elements;\\r\\n\\r\\n\\t\\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;\\r\\n\\t\\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;\\r\\n\\t\\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;\\r\\n\\t\\tthis.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tdivideScalar: function ( scalar ) {\\r\\n\\r\\n\\t\\treturn this.multiplyScalar( 1 / scalar );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetAxisAngleFromQuaternion: function ( q ) {\\r\\n\\r\\n\\t\\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\\r\\n\\r\\n\\t\\t// q is assumed to be normalized\\r\\n\\r\\n\\t\\tthis.w = 2 * Math.acos( q.w );\\r\\n\\r\\n\\t\\tvar s = Math.sqrt( 1 - q.w * q.w );\\r\\n\\r\\n\\t\\tif ( s < 0.0001 ) {\\r\\n\\r\\n\\t\\t\\tthis.x = 1;\\r\\n\\t\\t\\tthis.y = 0;\\r\\n\\t\\t\\tthis.z = 0;\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tthis.x = q.x / s;\\r\\n\\t\\t\\tthis.y = q.y / s;\\r\\n\\t\\t\\tthis.z = q.z / s;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetAxisAngleFromRotationMatrix: function ( m ) {\\r\\n\\r\\n\\t\\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\\r\\n\\r\\n\\t\\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\\r\\n\\r\\n\\t\\tvar angle, x, y, z,\\t\\t// variables for result\\r\\n\\t\\t\\tepsilon = 0.01,\\t\\t// margin to allow for rounding errors\\r\\n\\t\\t\\tepsilon2 = 0.1,\\t\\t// margin to distinguish between 0 and 180 degrees\\r\\n\\r\\n\\t\\t\\tte = m.elements,\\r\\n\\r\\n\\t\\t\\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\\r\\n\\t\\t\\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\\r\\n\\t\\t\\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\\r\\n\\r\\n\\t\\tif ( ( Math.abs( m12 - m21 ) < epsilon ) &&\\r\\n\\t\\t     ( Math.abs( m13 - m31 ) < epsilon ) &&\\r\\n\\t\\t     ( Math.abs( m23 - m32 ) < epsilon ) ) {\\r\\n\\r\\n\\t\\t\\t// singularity found\\r\\n\\t\\t\\t// first check for identity matrix which must have +1 for all terms\\r\\n\\t\\t\\t// in leading diagonal and zero in other terms\\r\\n\\r\\n\\t\\t\\tif ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&\\r\\n\\t\\t\\t     ( Math.abs( m13 + m31 ) < epsilon2 ) &&\\r\\n\\t\\t\\t     ( Math.abs( m23 + m32 ) < epsilon2 ) &&\\r\\n\\t\\t\\t     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\\r\\n\\r\\n\\t\\t\\t\\t// this singularity is identity matrix so angle = 0\\r\\n\\r\\n\\t\\t\\t\\tthis.set( 1, 0, 0, 0 );\\r\\n\\r\\n\\t\\t\\t\\treturn this; // zero angle, arbitrary axis\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// otherwise this singularity is angle = 180\\r\\n\\r\\n\\t\\t\\tangle = Math.PI;\\r\\n\\r\\n\\t\\t\\tvar xx = ( m11 + 1 ) / 2;\\r\\n\\t\\t\\tvar yy = ( m22 + 1 ) / 2;\\r\\n\\t\\t\\tvar zz = ( m33 + 1 ) / 2;\\r\\n\\t\\t\\tvar xy = ( m12 + m21 ) / 4;\\r\\n\\t\\t\\tvar xz = ( m13 + m31 ) / 4;\\r\\n\\t\\t\\tvar yz = ( m23 + m32 ) / 4;\\r\\n\\r\\n\\t\\t\\tif ( ( xx > yy ) && ( xx > zz ) ) {\\r\\n\\r\\n\\t\\t\\t\\t// m11 is the largest diagonal term\\r\\n\\r\\n\\t\\t\\t\\tif ( xx < epsilon ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tx = 0;\\r\\n\\t\\t\\t\\t\\ty = 0.707106781;\\r\\n\\t\\t\\t\\t\\tz = 0.707106781;\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tx = Math.sqrt( xx );\\r\\n\\t\\t\\t\\t\\ty = xy / x;\\r\\n\\t\\t\\t\\t\\tz = xz / x;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} else if ( yy > zz ) {\\r\\n\\r\\n\\t\\t\\t\\t// m22 is the largest diagonal term\\r\\n\\r\\n\\t\\t\\t\\tif ( yy < epsilon ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tx = 0.707106781;\\r\\n\\t\\t\\t\\t\\ty = 0;\\r\\n\\t\\t\\t\\t\\tz = 0.707106781;\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\ty = Math.sqrt( yy );\\r\\n\\t\\t\\t\\t\\tx = xy / y;\\r\\n\\t\\t\\t\\t\\tz = yz / y;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t// m33 is the largest diagonal term so base result on this\\r\\n\\r\\n\\t\\t\\t\\tif ( zz < epsilon ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tx = 0.707106781;\\r\\n\\t\\t\\t\\t\\ty = 0.707106781;\\r\\n\\t\\t\\t\\t\\tz = 0;\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tz = Math.sqrt( zz );\\r\\n\\t\\t\\t\\t\\tx = xz / z;\\r\\n\\t\\t\\t\\t\\ty = yz / z;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.set( x, y, z, angle );\\r\\n\\r\\n\\t\\t\\treturn this; // return 180 deg rotation\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// as we have reached here there are no singularities so we can handle normally\\r\\n\\r\\n\\t\\tvar s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +\\r\\n\\t\\t                   ( m13 - m31 ) * ( m13 - m31 ) +\\r\\n\\t\\t                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\\r\\n\\r\\n\\t\\tif ( Math.abs( s ) < 0.001 ) s = 1;\\r\\n\\r\\n\\t\\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\\r\\n\\t\\t// caught by singularity test above, but I've left it in just in case\\r\\n\\r\\n\\t\\tthis.x = ( m32 - m23 ) / s;\\r\\n\\t\\tthis.y = ( m13 - m31 ) / s;\\r\\n\\t\\tthis.z = ( m21 - m12 ) / s;\\r\\n\\t\\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tmin: function ( v ) {\\r\\n\\r\\n\\t\\tthis.x = Math.min( this.x, v.x );\\r\\n\\t\\tthis.y = Math.min( this.y, v.y );\\r\\n\\t\\tthis.z = Math.min( this.z, v.z );\\r\\n\\t\\tthis.w = Math.min( this.w, v.w );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tmax: function ( v ) {\\r\\n\\r\\n\\t\\tthis.x = Math.max( this.x, v.x );\\r\\n\\t\\tthis.y = Math.max( this.y, v.y );\\r\\n\\t\\tthis.z = Math.max( this.z, v.z );\\r\\n\\t\\tthis.w = Math.max( this.w, v.w );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclamp: function ( min, max ) {\\r\\n\\r\\n\\t\\t// assumes min < max, componentwise\\r\\n\\r\\n\\t\\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\\r\\n\\t\\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\\r\\n\\t\\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\\r\\n\\t\\tthis.w = Math.max( min.w, Math.min( max.w, this.w ) );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclampScalar: function ( minVal, maxVal ) {\\r\\n\\r\\n\\t\\tthis.x = Math.max( minVal, Math.min( maxVal, this.x ) );\\r\\n\\t\\tthis.y = Math.max( minVal, Math.min( maxVal, this.y ) );\\r\\n\\t\\tthis.z = Math.max( minVal, Math.min( maxVal, this.z ) );\\r\\n\\t\\tthis.w = Math.max( minVal, Math.min( maxVal, this.w ) );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclampLength: function ( min, max ) {\\r\\n\\r\\n\\t\\tvar length = this.length();\\r\\n\\r\\n\\t\\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tfloor: function () {\\r\\n\\r\\n\\t\\tthis.x = Math.floor( this.x );\\r\\n\\t\\tthis.y = Math.floor( this.y );\\r\\n\\t\\tthis.z = Math.floor( this.z );\\r\\n\\t\\tthis.w = Math.floor( this.w );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tceil: function () {\\r\\n\\r\\n\\t\\tthis.x = Math.ceil( this.x );\\r\\n\\t\\tthis.y = Math.ceil( this.y );\\r\\n\\t\\tthis.z = Math.ceil( this.z );\\r\\n\\t\\tthis.w = Math.ceil( this.w );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tround: function () {\\r\\n\\r\\n\\t\\tthis.x = Math.round( this.x );\\r\\n\\t\\tthis.y = Math.round( this.y );\\r\\n\\t\\tthis.z = Math.round( this.z );\\r\\n\\t\\tthis.w = Math.round( this.w );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\troundToZero: function () {\\r\\n\\r\\n\\t\\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\\r\\n\\t\\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\\r\\n\\t\\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\\r\\n\\t\\tthis.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tnegate: function () {\\r\\n\\r\\n\\t\\tthis.x = - this.x;\\r\\n\\t\\tthis.y = - this.y;\\r\\n\\t\\tthis.z = - this.z;\\r\\n\\t\\tthis.w = - this.w;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tdot: function ( v ) {\\r\\n\\r\\n\\t\\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tlengthSq: function () {\\r\\n\\r\\n\\t\\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tlength: function () {\\r\\n\\r\\n\\t\\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tmanhattanLength: function () {\\r\\n\\r\\n\\t\\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tnormalize: function () {\\r\\n\\r\\n\\t\\treturn this.divideScalar( this.length() || 1 );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetLength: function ( length ) {\\r\\n\\r\\n\\t\\treturn this.normalize().multiplyScalar( length );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tlerp: function ( v, alpha ) {\\r\\n\\r\\n\\t\\tthis.x += ( v.x - this.x ) * alpha;\\r\\n\\t\\tthis.y += ( v.y - this.y ) * alpha;\\r\\n\\t\\tthis.z += ( v.z - this.z ) * alpha;\\r\\n\\t\\tthis.w += ( v.w - this.w ) * alpha;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tlerpVectors: function ( v1, v2, alpha ) {\\r\\n\\r\\n\\t\\tthis.x = v1.x + ( v2.x - v1.x ) * alpha;\\r\\n\\t\\tthis.y = v1.y + ( v2.y - v1.y ) * alpha;\\r\\n\\t\\tthis.z = v1.z + ( v2.z - v1.z ) * alpha;\\r\\n\\t\\tthis.w = v1.w + ( v2.w - v1.w ) * alpha;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tequals: function ( v ) {\\r\\n\\r\\n\\t\\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tfromArray: function ( array, offset ) {\\r\\n\\r\\n\\t\\tif ( offset === undefined ) offset = 0;\\r\\n\\r\\n\\t\\tthis.x = array[ offset ];\\r\\n\\t\\tthis.y = array[ offset + 1 ];\\r\\n\\t\\tthis.z = array[ offset + 2 ];\\r\\n\\t\\tthis.w = array[ offset + 3 ];\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttoArray: function ( array, offset ) {\\r\\n\\r\\n\\t\\tif ( array === undefined ) array = [];\\r\\n\\t\\tif ( offset === undefined ) offset = 0;\\r\\n\\r\\n\\t\\tarray[ offset ] = this.x;\\r\\n\\t\\tarray[ offset + 1 ] = this.y;\\r\\n\\t\\tarray[ offset + 2 ] = this.z;\\r\\n\\t\\tarray[ offset + 3 ] = this.w;\\r\\n\\r\\n\\t\\treturn array;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tfromBufferAttribute: function ( attribute, index, offset ) {\\r\\n\\r\\n\\t\\tif ( offset !== undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.x = attribute.getX( index );\\r\\n\\t\\tthis.y = attribute.getY( index );\\r\\n\\t\\tthis.z = attribute.getZ( index );\\r\\n\\t\\tthis.w = attribute.getW( index );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\trandom: function () {\\r\\n\\r\\n\\t\\tthis.x = Math.random();\\r\\n\\t\\tthis.y = Math.random();\\r\\n\\t\\tthis.z = Math.random();\\r\\n\\t\\tthis.w = Math.random();\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author szimek / https://github.com/szimek/\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n * @author Marius Kintel / https://github.com/kintel\\r\\n */\\r\\n\\r\\n/*\\r\\n In options, we can specify:\\r\\n * Texture parameters for an auto-generated target texture\\r\\n * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers\\r\\n*/\\r\\nfunction WebGLRenderTarget( width, height, options ) {\\r\\n\\r\\n\\tthis.width = width;\\r\\n\\tthis.height = height;\\r\\n\\r\\n\\tthis.scissor = new Vector4( 0, 0, width, height );\\r\\n\\tthis.scissorTest = false;\\r\\n\\r\\n\\tthis.viewport = new Vector4( 0, 0, width, height );\\r\\n\\r\\n\\toptions = options || {};\\r\\n\\r\\n\\tthis.texture = new Texture( undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );\\r\\n\\r\\n\\tthis.texture.image = {};\\r\\n\\tthis.texture.image.width = width;\\r\\n\\tthis.texture.image.height = height;\\r\\n\\r\\n\\tthis.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;\\r\\n\\tthis.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;\\r\\n\\r\\n\\tthis.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\\r\\n\\tthis.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;\\r\\n\\tthis.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;\\r\\n\\r\\n}\\r\\n\\r\\nWebGLRenderTarget.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\\r\\n\\r\\n\\tconstructor: WebGLRenderTarget,\\r\\n\\r\\n\\tisWebGLRenderTarget: true,\\r\\n\\r\\n\\tsetSize: function ( width, height ) {\\r\\n\\r\\n\\t\\tif ( this.width !== width || this.height !== height ) {\\r\\n\\r\\n\\t\\t\\tthis.width = width;\\r\\n\\t\\t\\tthis.height = height;\\r\\n\\r\\n\\t\\t\\tthis.texture.image.width = width;\\r\\n\\t\\t\\tthis.texture.image.height = height;\\r\\n\\r\\n\\t\\t\\tthis.dispose();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.viewport.set( 0, 0, width, height );\\r\\n\\t\\tthis.scissor.set( 0, 0, width, height );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclone: function () {\\r\\n\\r\\n\\t\\treturn new this.constructor().copy( this );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\tthis.width = source.width;\\r\\n\\t\\tthis.height = source.height;\\r\\n\\r\\n\\t\\tthis.viewport.copy( source.viewport );\\r\\n\\r\\n\\t\\tthis.texture = source.texture.clone();\\r\\n\\r\\n\\t\\tthis.depthBuffer = source.depthBuffer;\\r\\n\\t\\tthis.stencilBuffer = source.stencilBuffer;\\r\\n\\t\\tthis.depthTexture = source.depthTexture;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tdispose: function () {\\r\\n\\r\\n\\t\\tthis.dispatchEvent( { type: 'dispose' } );\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author Mugen87 / https://github.com/Mugen87\\r\\n * @author Matt DesLauriers / @mattdesl\\r\\n */\\r\\n\\r\\nfunction WebGLMultisampleRenderTarget( width, height, options ) {\\r\\n\\r\\n\\tWebGLRenderTarget.call( this, width, height, options );\\r\\n\\r\\n\\tthis.samples = 4;\\r\\n\\r\\n}\\r\\n\\r\\nWebGLMultisampleRenderTarget.prototype = Object.assign( Object.create( WebGLRenderTarget.prototype ), {\\r\\n\\r\\n\\tconstructor: WebGLMultisampleRenderTarget,\\r\\n\\r\\n\\tisWebGLMultisampleRenderTarget: true,\\r\\n\\r\\n\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\tWebGLRenderTarget.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\tthis.samples = source.samples;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author mikael emtinger / http://gomo.se/\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n * @author WestLangley / http://github.com/WestLangley\\r\\n * @author bhouston / http://clara.io\\r\\n */\\r\\n\\r\\nfunction Quaternion( x, y, z, w ) {\\r\\n\\r\\n\\tthis._x = x || 0;\\r\\n\\tthis._y = y || 0;\\r\\n\\tthis._z = z || 0;\\r\\n\\tthis._w = ( w !== undefined ) ? w : 1;\\r\\n\\r\\n}\\r\\n\\r\\nObject.assign( Quaternion, {\\r\\n\\r\\n\\tslerp: function ( qa, qb, qm, t ) {\\r\\n\\r\\n\\t\\treturn qm.copy( qa ).slerp( qb, t );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tslerpFlat: function ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {\\r\\n\\r\\n\\t\\t// fuzz-free, array-based Quaternion SLERP operation\\r\\n\\r\\n\\t\\tvar x0 = src0[ srcOffset0 + 0 ],\\r\\n\\t\\t\\ty0 = src0[ srcOffset0 + 1 ],\\r\\n\\t\\t\\tz0 = src0[ srcOffset0 + 2 ],\\r\\n\\t\\t\\tw0 = src0[ srcOffset0 + 3 ],\\r\\n\\r\\n\\t\\t\\tx1 = src1[ srcOffset1 + 0 ],\\r\\n\\t\\t\\ty1 = src1[ srcOffset1 + 1 ],\\r\\n\\t\\t\\tz1 = src1[ srcOffset1 + 2 ],\\r\\n\\t\\t\\tw1 = src1[ srcOffset1 + 3 ];\\r\\n\\r\\n\\t\\tif ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {\\r\\n\\r\\n\\t\\t\\tvar s = 1 - t,\\r\\n\\r\\n\\t\\t\\t\\tcos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\\r\\n\\r\\n\\t\\t\\t\\tdir = ( cos >= 0 ? 1 : - 1 ),\\r\\n\\t\\t\\t\\tsqrSin = 1 - cos * cos;\\r\\n\\r\\n\\t\\t\\t// Skip the Slerp for tiny steps to avoid numeric problems:\\r\\n\\t\\t\\tif ( sqrSin > Number.EPSILON ) {\\r\\n\\r\\n\\t\\t\\t\\tvar sin = Math.sqrt( sqrSin ),\\r\\n\\t\\t\\t\\t\\tlen = Math.atan2( sin, cos * dir );\\r\\n\\r\\n\\t\\t\\t\\ts = Math.sin( s * len ) / sin;\\r\\n\\t\\t\\t\\tt = Math.sin( t * len ) / sin;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar tDir = t * dir;\\r\\n\\r\\n\\t\\t\\tx0 = x0 * s + x1 * tDir;\\r\\n\\t\\t\\ty0 = y0 * s + y1 * tDir;\\r\\n\\t\\t\\tz0 = z0 * s + z1 * tDir;\\r\\n\\t\\t\\tw0 = w0 * s + w1 * tDir;\\r\\n\\r\\n\\t\\t\\t// Normalize in case we just did a lerp:\\r\\n\\t\\t\\tif ( s === 1 - t ) {\\r\\n\\r\\n\\t\\t\\t\\tvar f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );\\r\\n\\r\\n\\t\\t\\t\\tx0 *= f;\\r\\n\\t\\t\\t\\ty0 *= f;\\r\\n\\t\\t\\t\\tz0 *= f;\\r\\n\\t\\t\\t\\tw0 *= f;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tdst[ dstOffset ] = x0;\\r\\n\\t\\tdst[ dstOffset + 1 ] = y0;\\r\\n\\t\\tdst[ dstOffset + 2 ] = z0;\\r\\n\\t\\tdst[ dstOffset + 3 ] = w0;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tmultiplyQuaternionsFlat: function ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) {\\r\\n\\r\\n\\t\\tvar x0 = src0[ srcOffset0 ];\\r\\n\\t\\tvar y0 = src0[ srcOffset0 + 1 ];\\r\\n\\t\\tvar z0 = src0[ srcOffset0 + 2 ];\\r\\n\\t\\tvar w0 = src0[ srcOffset0 + 3 ];\\r\\n\\r\\n\\t\\tvar x1 = src1[ srcOffset1 ];\\r\\n\\t\\tvar y1 = src1[ srcOffset1 + 1 ];\\r\\n\\t\\tvar z1 = src1[ srcOffset1 + 2 ];\\r\\n\\t\\tvar w1 = src1[ srcOffset1 + 3 ];\\r\\n\\r\\n\\t\\tdst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;\\r\\n\\t\\tdst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;\\r\\n\\t\\tdst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;\\r\\n\\t\\tdst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;\\r\\n\\r\\n\\t\\treturn dst;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nObject.defineProperties( Quaternion.prototype, {\\r\\n\\r\\n\\tx: {\\r\\n\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\treturn this._x;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\tthis._x = value;\\r\\n\\t\\t\\tthis._onChangeCallback();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ty: {\\r\\n\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\treturn this._y;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\tthis._y = value;\\r\\n\\t\\t\\tthis._onChangeCallback();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tz: {\\r\\n\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\treturn this._z;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\tthis._z = value;\\r\\n\\t\\t\\tthis._onChangeCallback();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tw: {\\r\\n\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\treturn this._w;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\tthis._w = value;\\r\\n\\t\\t\\tthis._onChangeCallback();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nObject.assign( Quaternion.prototype, {\\r\\n\\r\\n\\tisQuaternion: true,\\r\\n\\r\\n\\tset: function ( x, y, z, w ) {\\r\\n\\r\\n\\t\\tthis._x = x;\\r\\n\\t\\tthis._y = y;\\r\\n\\t\\tthis._z = z;\\r\\n\\t\\tthis._w = w;\\r\\n\\r\\n\\t\\tthis._onChangeCallback();\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclone: function () {\\r\\n\\r\\n\\t\\treturn new this.constructor( this._x, this._y, this._z, this._w );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcopy: function ( quaternion ) {\\r\\n\\r\\n\\t\\tthis._x = quaternion.x;\\r\\n\\t\\tthis._y = quaternion.y;\\r\\n\\t\\tthis._z = quaternion.z;\\r\\n\\t\\tthis._w = quaternion.w;\\r\\n\\r\\n\\t\\tthis._onChangeCallback();\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetFromEuler: function ( euler, update ) {\\r\\n\\r\\n\\t\\tif ( ! ( euler && euler.isEuler ) ) {\\r\\n\\r\\n\\t\\t\\tthrow new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar x = euler._x, y = euler._y, z = euler._z, order = euler.order;\\r\\n\\r\\n\\t\\t// http://www.mathworks.com/matlabcentral/fileexchange/\\r\\n\\t\\t// \\t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\\r\\n\\t\\t//\\tcontent/SpinCalc.m\\r\\n\\r\\n\\t\\tvar cos = Math.cos;\\r\\n\\t\\tvar sin = Math.sin;\\r\\n\\r\\n\\t\\tvar c1 = cos( x / 2 );\\r\\n\\t\\tvar c2 = cos( y / 2 );\\r\\n\\t\\tvar c3 = cos( z / 2 );\\r\\n\\r\\n\\t\\tvar s1 = sin( x / 2 );\\r\\n\\t\\tvar s2 = sin( y / 2 );\\r\\n\\t\\tvar s3 = sin( z / 2 );\\r\\n\\r\\n\\t\\tswitch ( order ) {\\r\\n\\r\\n\\t\\t\\tcase 'XYZ':\\r\\n\\t\\t\\t\\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\\r\\n\\t\\t\\t\\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\\r\\n\\t\\t\\t\\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\\r\\n\\t\\t\\t\\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tcase 'YXZ':\\r\\n\\t\\t\\t\\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\\r\\n\\t\\t\\t\\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\\r\\n\\t\\t\\t\\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\\r\\n\\t\\t\\t\\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tcase 'ZXY':\\r\\n\\t\\t\\t\\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\\r\\n\\t\\t\\t\\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\\r\\n\\t\\t\\t\\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\\r\\n\\t\\t\\t\\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tcase 'ZYX':\\r\\n\\t\\t\\t\\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\\r\\n\\t\\t\\t\\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\\r\\n\\t\\t\\t\\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\\r\\n\\t\\t\\t\\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tcase 'YZX':\\r\\n\\t\\t\\t\\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\\r\\n\\t\\t\\t\\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\\r\\n\\t\\t\\t\\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\\r\\n\\t\\t\\t\\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tcase 'XZY':\\r\\n\\t\\t\\t\\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\\r\\n\\t\\t\\t\\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\\r\\n\\t\\t\\t\\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\\r\\n\\t\\t\\t\\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tdefault:\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( update !== false ) this._onChangeCallback();\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetFromAxisAngle: function ( axis, angle ) {\\r\\n\\r\\n\\t\\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\\r\\n\\r\\n\\t\\t// assumes axis is normalized\\r\\n\\r\\n\\t\\tvar halfAngle = angle / 2, s = Math.sin( halfAngle );\\r\\n\\r\\n\\t\\tthis._x = axis.x * s;\\r\\n\\t\\tthis._y = axis.y * s;\\r\\n\\t\\tthis._z = axis.z * s;\\r\\n\\t\\tthis._w = Math.cos( halfAngle );\\r\\n\\r\\n\\t\\tthis._onChangeCallback();\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetFromRotationMatrix: function ( m ) {\\r\\n\\r\\n\\t\\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\\r\\n\\r\\n\\t\\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\\r\\n\\r\\n\\t\\tvar te = m.elements,\\r\\n\\r\\n\\t\\t\\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\\r\\n\\t\\t\\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\\r\\n\\t\\t\\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\\r\\n\\r\\n\\t\\t\\ttrace = m11 + m22 + m33,\\r\\n\\t\\t\\ts;\\r\\n\\r\\n\\t\\tif ( trace > 0 ) {\\r\\n\\r\\n\\t\\t\\ts = 0.5 / Math.sqrt( trace + 1.0 );\\r\\n\\r\\n\\t\\t\\tthis._w = 0.25 / s;\\r\\n\\t\\t\\tthis._x = ( m32 - m23 ) * s;\\r\\n\\t\\t\\tthis._y = ( m13 - m31 ) * s;\\r\\n\\t\\t\\tthis._z = ( m21 - m12 ) * s;\\r\\n\\r\\n\\t\\t} else if ( m11 > m22 && m11 > m33 ) {\\r\\n\\r\\n\\t\\t\\ts = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\\r\\n\\r\\n\\t\\t\\tthis._w = ( m32 - m23 ) / s;\\r\\n\\t\\t\\tthis._x = 0.25 * s;\\r\\n\\t\\t\\tthis._y = ( m12 + m21 ) / s;\\r\\n\\t\\t\\tthis._z = ( m13 + m31 ) / s;\\r\\n\\r\\n\\t\\t} else if ( m22 > m33 ) {\\r\\n\\r\\n\\t\\t\\ts = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\\r\\n\\r\\n\\t\\t\\tthis._w = ( m13 - m31 ) / s;\\r\\n\\t\\t\\tthis._x = ( m12 + m21 ) / s;\\r\\n\\t\\t\\tthis._y = 0.25 * s;\\r\\n\\t\\t\\tthis._z = ( m23 + m32 ) / s;\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\ts = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\\r\\n\\r\\n\\t\\t\\tthis._w = ( m21 - m12 ) / s;\\r\\n\\t\\t\\tthis._x = ( m13 + m31 ) / s;\\r\\n\\t\\t\\tthis._y = ( m23 + m32 ) / s;\\r\\n\\t\\t\\tthis._z = 0.25 * s;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis._onChangeCallback();\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetFromUnitVectors: function ( vFrom, vTo ) {\\r\\n\\r\\n\\t\\t// assumes direction vectors vFrom and vTo are normalized\\r\\n\\r\\n\\t\\tvar EPS = 0.000001;\\r\\n\\r\\n\\t\\tvar r = vFrom.dot( vTo ) + 1;\\r\\n\\r\\n\\t\\tif ( r < EPS ) {\\r\\n\\r\\n\\t\\t\\tr = 0;\\r\\n\\r\\n\\t\\t\\tif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\\r\\n\\r\\n\\t\\t\\t\\tthis._x = - vFrom.y;\\r\\n\\t\\t\\t\\tthis._y = vFrom.x;\\r\\n\\t\\t\\t\\tthis._z = 0;\\r\\n\\t\\t\\t\\tthis._w = r;\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tthis._x = 0;\\r\\n\\t\\t\\t\\tthis._y = - vFrom.z;\\r\\n\\t\\t\\t\\tthis._z = vFrom.y;\\r\\n\\t\\t\\t\\tthis._w = r;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3\\r\\n\\r\\n\\t\\t\\tthis._x = vFrom.y * vTo.z - vFrom.z * vTo.y;\\r\\n\\t\\t\\tthis._y = vFrom.z * vTo.x - vFrom.x * vTo.z;\\r\\n\\t\\t\\tthis._z = vFrom.x * vTo.y - vFrom.y * vTo.x;\\r\\n\\t\\t\\tthis._w = r;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this.normalize();\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tangleTo: function ( q ) {\\r\\n\\r\\n\\t\\treturn 2 * Math.acos( Math.abs( MathUtils.clamp( this.dot( q ), - 1, 1 ) ) );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\trotateTowards: function ( q, step ) {\\r\\n\\r\\n\\t\\tvar angle = this.angleTo( q );\\r\\n\\r\\n\\t\\tif ( angle === 0 ) return this;\\r\\n\\r\\n\\t\\tvar t = Math.min( 1, step / angle );\\r\\n\\r\\n\\t\\tthis.slerp( q, t );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tinverse: function () {\\r\\n\\r\\n\\t\\t// quaternion is assumed to have unit length\\r\\n\\r\\n\\t\\treturn this.conjugate();\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tconjugate: function () {\\r\\n\\r\\n\\t\\tthis._x *= - 1;\\r\\n\\t\\tthis._y *= - 1;\\r\\n\\t\\tthis._z *= - 1;\\r\\n\\r\\n\\t\\tthis._onChangeCallback();\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tdot: function ( v ) {\\r\\n\\r\\n\\t\\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tlengthSq: function () {\\r\\n\\r\\n\\t\\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tlength: function () {\\r\\n\\r\\n\\t\\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tnormalize: function () {\\r\\n\\r\\n\\t\\tvar l = this.length();\\r\\n\\r\\n\\t\\tif ( l === 0 ) {\\r\\n\\r\\n\\t\\t\\tthis._x = 0;\\r\\n\\t\\t\\tthis._y = 0;\\r\\n\\t\\t\\tthis._z = 0;\\r\\n\\t\\t\\tthis._w = 1;\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tl = 1 / l;\\r\\n\\r\\n\\t\\t\\tthis._x = this._x * l;\\r\\n\\t\\t\\tthis._y = this._y * l;\\r\\n\\t\\t\\tthis._z = this._z * l;\\r\\n\\t\\t\\tthis._w = this._w * l;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis._onChangeCallback();\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tmultiply: function ( q, p ) {\\r\\n\\r\\n\\t\\tif ( p !== undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\\r\\n\\t\\t\\treturn this.multiplyQuaternions( q, p );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this.multiplyQuaternions( this, q );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tpremultiply: function ( q ) {\\r\\n\\r\\n\\t\\treturn this.multiplyQuaternions( q, this );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tmultiplyQuaternions: function ( a, b ) {\\r\\n\\r\\n\\t\\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\\r\\n\\r\\n\\t\\tvar qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\\r\\n\\t\\tvar qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\\r\\n\\r\\n\\t\\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\\r\\n\\t\\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\\r\\n\\t\\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\\r\\n\\t\\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\\r\\n\\r\\n\\t\\tthis._onChangeCallback();\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tslerp: function ( qb, t ) {\\r\\n\\r\\n\\t\\tif ( t === 0 ) return this;\\r\\n\\t\\tif ( t === 1 ) return this.copy( qb );\\r\\n\\r\\n\\t\\tvar x = this._x, y = this._y, z = this._z, w = this._w;\\r\\n\\r\\n\\t\\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\\r\\n\\r\\n\\t\\tvar cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\\r\\n\\r\\n\\t\\tif ( cosHalfTheta < 0 ) {\\r\\n\\r\\n\\t\\t\\tthis._w = - qb._w;\\r\\n\\t\\t\\tthis._x = - qb._x;\\r\\n\\t\\t\\tthis._y = - qb._y;\\r\\n\\t\\t\\tthis._z = - qb._z;\\r\\n\\r\\n\\t\\t\\tcosHalfTheta = - cosHalfTheta;\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tthis.copy( qb );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( cosHalfTheta >= 1.0 ) {\\r\\n\\r\\n\\t\\t\\tthis._w = w;\\r\\n\\t\\t\\tthis._x = x;\\r\\n\\t\\t\\tthis._y = y;\\r\\n\\t\\t\\tthis._z = z;\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;\\r\\n\\r\\n\\t\\tif ( sqrSinHalfTheta <= Number.EPSILON ) {\\r\\n\\r\\n\\t\\t\\tvar s = 1 - t;\\r\\n\\t\\t\\tthis._w = s * w + t * this._w;\\r\\n\\t\\t\\tthis._x = s * x + t * this._x;\\r\\n\\t\\t\\tthis._y = s * y + t * this._y;\\r\\n\\t\\t\\tthis._z = s * z + t * this._z;\\r\\n\\r\\n\\t\\t\\tthis.normalize();\\r\\n\\t\\t\\tthis._onChangeCallback();\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar sinHalfTheta = Math.sqrt( sqrSinHalfTheta );\\r\\n\\t\\tvar halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );\\r\\n\\t\\tvar ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\\r\\n\\t\\t\\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\\r\\n\\r\\n\\t\\tthis._w = ( w * ratioA + this._w * ratioB );\\r\\n\\t\\tthis._x = ( x * ratioA + this._x * ratioB );\\r\\n\\t\\tthis._y = ( y * ratioA + this._y * ratioB );\\r\\n\\t\\tthis._z = ( z * ratioA + this._z * ratioB );\\r\\n\\r\\n\\t\\tthis._onChangeCallback();\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tequals: function ( quaternion ) {\\r\\n\\r\\n\\t\\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tfromArray: function ( array, offset ) {\\r\\n\\r\\n\\t\\tif ( offset === undefined ) offset = 0;\\r\\n\\r\\n\\t\\tthis._x = array[ offset ];\\r\\n\\t\\tthis._y = array[ offset + 1 ];\\r\\n\\t\\tthis._z = array[ offset + 2 ];\\r\\n\\t\\tthis._w = array[ offset + 3 ];\\r\\n\\r\\n\\t\\tthis._onChangeCallback();\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttoArray: function ( array, offset ) {\\r\\n\\r\\n\\t\\tif ( array === undefined ) array = [];\\r\\n\\t\\tif ( offset === undefined ) offset = 0;\\r\\n\\r\\n\\t\\tarray[ offset ] = this._x;\\r\\n\\t\\tarray[ offset + 1 ] = this._y;\\r\\n\\t\\tarray[ offset + 2 ] = this._z;\\r\\n\\t\\tarray[ offset + 3 ] = this._w;\\r\\n\\r\\n\\t\\treturn array;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tfromBufferAttribute: function ( attribute, index ) {\\r\\n\\r\\n\\t\\tthis._x = attribute.getX( index );\\r\\n\\t\\tthis._y = attribute.getY( index );\\r\\n\\t\\tthis._z = attribute.getZ( index );\\r\\n\\t\\tthis._w = attribute.getW( index );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t_onChange: function ( callback ) {\\r\\n\\r\\n\\t\\tthis._onChangeCallback = callback;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t_onChangeCallback: function () {}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n * @author kile / http://kile.stravaganza.org/\\r\\n * @author philogb / http://blog.thejit.org/\\r\\n * @author mikael emtinger / http://gomo.se/\\r\\n * @author egraether / http://egraether.com/\\r\\n * @author WestLangley / http://github.com/WestLangley\\r\\n */\\r\\n\\r\\nvar _vector = new Vector3();\\r\\nvar _quaternion = new Quaternion();\\r\\n\\r\\nfunction Vector3( x, y, z ) {\\r\\n\\r\\n\\tthis.x = x || 0;\\r\\n\\tthis.y = y || 0;\\r\\n\\tthis.z = z || 0;\\r\\n\\r\\n}\\r\\n\\r\\nObject.assign( Vector3.prototype, {\\r\\n\\r\\n\\tisVector3: true,\\r\\n\\r\\n\\tset: function ( x, y, z ) {\\r\\n\\r\\n\\t\\tthis.x = x;\\r\\n\\t\\tthis.y = y;\\r\\n\\t\\tthis.z = z;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetScalar: function ( scalar ) {\\r\\n\\r\\n\\t\\tthis.x = scalar;\\r\\n\\t\\tthis.y = scalar;\\r\\n\\t\\tthis.z = scalar;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetX: function ( x ) {\\r\\n\\r\\n\\t\\tthis.x = x;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetY: function ( y ) {\\r\\n\\r\\n\\t\\tthis.y = y;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetZ: function ( z ) {\\r\\n\\r\\n\\t\\tthis.z = z;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetComponent: function ( index, value ) {\\r\\n\\r\\n\\t\\tswitch ( index ) {\\r\\n\\r\\n\\t\\t\\tcase 0: this.x = value; break;\\r\\n\\t\\t\\tcase 1: this.y = value; break;\\r\\n\\t\\t\\tcase 2: this.z = value; break;\\r\\n\\t\\t\\tdefault: throw new Error( 'index is out of range: ' + index );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetComponent: function ( index ) {\\r\\n\\r\\n\\t\\tswitch ( index ) {\\r\\n\\r\\n\\t\\t\\tcase 0: return this.x;\\r\\n\\t\\t\\tcase 1: return this.y;\\r\\n\\t\\t\\tcase 2: return this.z;\\r\\n\\t\\t\\tdefault: throw new Error( 'index is out of range: ' + index );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclone: function () {\\r\\n\\r\\n\\t\\treturn new this.constructor( this.x, this.y, this.z );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcopy: function ( v ) {\\r\\n\\r\\n\\t\\tthis.x = v.x;\\r\\n\\t\\tthis.y = v.y;\\r\\n\\t\\tthis.z = v.z;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tadd: function ( v, w ) {\\r\\n\\r\\n\\t\\tif ( w !== undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\\r\\n\\t\\t\\treturn this.addVectors( v, w );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.x += v.x;\\r\\n\\t\\tthis.y += v.y;\\r\\n\\t\\tthis.z += v.z;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\taddScalar: function ( s ) {\\r\\n\\r\\n\\t\\tthis.x += s;\\r\\n\\t\\tthis.y += s;\\r\\n\\t\\tthis.z += s;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\taddVectors: function ( a, b ) {\\r\\n\\r\\n\\t\\tthis.x = a.x + b.x;\\r\\n\\t\\tthis.y = a.y + b.y;\\r\\n\\t\\tthis.z = a.z + b.z;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\taddScaledVector: function ( v, s ) {\\r\\n\\r\\n\\t\\tthis.x += v.x * s;\\r\\n\\t\\tthis.y += v.y * s;\\r\\n\\t\\tthis.z += v.z * s;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsub: function ( v, w ) {\\r\\n\\r\\n\\t\\tif ( w !== undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\\r\\n\\t\\t\\treturn this.subVectors( v, w );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.x -= v.x;\\r\\n\\t\\tthis.y -= v.y;\\r\\n\\t\\tthis.z -= v.z;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsubScalar: function ( s ) {\\r\\n\\r\\n\\t\\tthis.x -= s;\\r\\n\\t\\tthis.y -= s;\\r\\n\\t\\tthis.z -= s;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsubVectors: function ( a, b ) {\\r\\n\\r\\n\\t\\tthis.x = a.x - b.x;\\r\\n\\t\\tthis.y = a.y - b.y;\\r\\n\\t\\tthis.z = a.z - b.z;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tmultiply: function ( v, w ) {\\r\\n\\r\\n\\t\\tif ( w !== undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\\r\\n\\t\\t\\treturn this.multiplyVectors( v, w );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.x *= v.x;\\r\\n\\t\\tthis.y *= v.y;\\r\\n\\t\\tthis.z *= v.z;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tmultiplyScalar: function ( scalar ) {\\r\\n\\r\\n\\t\\tthis.x *= scalar;\\r\\n\\t\\tthis.y *= scalar;\\r\\n\\t\\tthis.z *= scalar;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tmultiplyVectors: function ( a, b ) {\\r\\n\\r\\n\\t\\tthis.x = a.x * b.x;\\r\\n\\t\\tthis.y = a.y * b.y;\\r\\n\\t\\tthis.z = a.z * b.z;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tapplyEuler: function ( euler ) {\\r\\n\\r\\n\\t\\tif ( ! ( euler && euler.isEuler ) ) {\\r\\n\\r\\n\\t\\t\\tconsole.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this.applyQuaternion( _quaternion.setFromEuler( euler ) );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tapplyAxisAngle: function ( axis, angle ) {\\r\\n\\r\\n\\t\\treturn this.applyQuaternion( _quaternion.setFromAxisAngle( axis, angle ) );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tapplyMatrix3: function ( m ) {\\r\\n\\r\\n\\t\\tvar x = this.x, y = this.y, z = this.z;\\r\\n\\t\\tvar e = m.elements;\\r\\n\\r\\n\\t\\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\\r\\n\\t\\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\\r\\n\\t\\tthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tapplyNormalMatrix: function ( m ) {\\r\\n\\r\\n\\t\\treturn this.applyMatrix3( m ).normalize();\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tapplyMatrix4: function ( m ) {\\r\\n\\r\\n\\t\\tvar x = this.x, y = this.y, z = this.z;\\r\\n\\t\\tvar e = m.elements;\\r\\n\\r\\n\\t\\tvar w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );\\r\\n\\r\\n\\t\\tthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;\\r\\n\\t\\tthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;\\r\\n\\t\\tthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tapplyQuaternion: function ( q ) {\\r\\n\\r\\n\\t\\tvar x = this.x, y = this.y, z = this.z;\\r\\n\\t\\tvar qx = q.x, qy = q.y, qz = q.z, qw = q.w;\\r\\n\\r\\n\\t\\t// calculate quat * vector\\r\\n\\r\\n\\t\\tvar ix = qw * x + qy * z - qz * y;\\r\\n\\t\\tvar iy = qw * y + qz * x - qx * z;\\r\\n\\t\\tvar iz = qw * z + qx * y - qy * x;\\r\\n\\t\\tvar iw = - qx * x - qy * y - qz * z;\\r\\n\\r\\n\\t\\t// calculate result * inverse quat\\r\\n\\r\\n\\t\\tthis.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;\\r\\n\\t\\tthis.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;\\r\\n\\t\\tthis.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tproject: function ( camera ) {\\r\\n\\r\\n\\t\\treturn this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tunproject: function ( camera ) {\\r\\n\\r\\n\\t\\treturn this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttransformDirection: function ( m ) {\\r\\n\\r\\n\\t\\t// input: THREE.Matrix4 affine matrix\\r\\n\\t\\t// vector interpreted as a direction\\r\\n\\r\\n\\t\\tvar x = this.x, y = this.y, z = this.z;\\r\\n\\t\\tvar e = m.elements;\\r\\n\\r\\n\\t\\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;\\r\\n\\t\\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;\\r\\n\\t\\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\\r\\n\\r\\n\\t\\treturn this.normalize();\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tdivide: function ( v ) {\\r\\n\\r\\n\\t\\tthis.x /= v.x;\\r\\n\\t\\tthis.y /= v.y;\\r\\n\\t\\tthis.z /= v.z;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tdivideScalar: function ( scalar ) {\\r\\n\\r\\n\\t\\treturn this.multiplyScalar( 1 / scalar );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tmin: function ( v ) {\\r\\n\\r\\n\\t\\tthis.x = Math.min( this.x, v.x );\\r\\n\\t\\tthis.y = Math.min( this.y, v.y );\\r\\n\\t\\tthis.z = Math.min( this.z, v.z );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tmax: function ( v ) {\\r\\n\\r\\n\\t\\tthis.x = Math.max( this.x, v.x );\\r\\n\\t\\tthis.y = Math.max( this.y, v.y );\\r\\n\\t\\tthis.z = Math.max( this.z, v.z );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclamp: function ( min, max ) {\\r\\n\\r\\n\\t\\t// assumes min < max, componentwise\\r\\n\\r\\n\\t\\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\\r\\n\\t\\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\\r\\n\\t\\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclampScalar: function ( minVal, maxVal ) {\\r\\n\\r\\n\\t\\tthis.x = Math.max( minVal, Math.min( maxVal, this.x ) );\\r\\n\\t\\tthis.y = Math.max( minVal, Math.min( maxVal, this.y ) );\\r\\n\\t\\tthis.z = Math.max( minVal, Math.min( maxVal, this.z ) );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclampLength: function ( min, max ) {\\r\\n\\r\\n\\t\\tvar length = this.length();\\r\\n\\r\\n\\t\\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tfloor: function () {\\r\\n\\r\\n\\t\\tthis.x = Math.floor( this.x );\\r\\n\\t\\tthis.y = Math.floor( this.y );\\r\\n\\t\\tthis.z = Math.floor( this.z );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tceil: function () {\\r\\n\\r\\n\\t\\tthis.x = Math.ceil( this.x );\\r\\n\\t\\tthis.y = Math.ceil( this.y );\\r\\n\\t\\tthis.z = Math.ceil( this.z );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tround: function () {\\r\\n\\r\\n\\t\\tthis.x = Math.round( this.x );\\r\\n\\t\\tthis.y = Math.round( this.y );\\r\\n\\t\\tthis.z = Math.round( this.z );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\troundToZero: function () {\\r\\n\\r\\n\\t\\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\\r\\n\\t\\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\\r\\n\\t\\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tnegate: function () {\\r\\n\\r\\n\\t\\tthis.x = - this.x;\\r\\n\\t\\tthis.y = - this.y;\\r\\n\\t\\tthis.z = - this.z;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tdot: function ( v ) {\\r\\n\\r\\n\\t\\treturn this.x * v.x + this.y * v.y + this.z * v.z;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// TODO lengthSquared?\\r\\n\\r\\n\\tlengthSq: function () {\\r\\n\\r\\n\\t\\treturn this.x * this.x + this.y * this.y + this.z * this.z;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tlength: function () {\\r\\n\\r\\n\\t\\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tmanhattanLength: function () {\\r\\n\\r\\n\\t\\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tnormalize: function () {\\r\\n\\r\\n\\t\\treturn this.divideScalar( this.length() || 1 );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetLength: function ( length ) {\\r\\n\\r\\n\\t\\treturn this.normalize().multiplyScalar( length );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tlerp: function ( v, alpha ) {\\r\\n\\r\\n\\t\\tthis.x += ( v.x - this.x ) * alpha;\\r\\n\\t\\tthis.y += ( v.y - this.y ) * alpha;\\r\\n\\t\\tthis.z += ( v.z - this.z ) * alpha;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tlerpVectors: function ( v1, v2, alpha ) {\\r\\n\\r\\n\\t\\tthis.x = v1.x + ( v2.x - v1.x ) * alpha;\\r\\n\\t\\tthis.y = v1.y + ( v2.y - v1.y ) * alpha;\\r\\n\\t\\tthis.z = v1.z + ( v2.z - v1.z ) * alpha;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcross: function ( v, w ) {\\r\\n\\r\\n\\t\\tif ( w !== undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\\r\\n\\t\\t\\treturn this.crossVectors( v, w );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this.crossVectors( this, v );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcrossVectors: function ( a, b ) {\\r\\n\\r\\n\\t\\tvar ax = a.x, ay = a.y, az = a.z;\\r\\n\\t\\tvar bx = b.x, by = b.y, bz = b.z;\\r\\n\\r\\n\\t\\tthis.x = ay * bz - az * by;\\r\\n\\t\\tthis.y = az * bx - ax * bz;\\r\\n\\t\\tthis.z = ax * by - ay * bx;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tprojectOnVector: function ( v ) {\\r\\n\\r\\n\\t\\tvar denominator = v.lengthSq();\\r\\n\\r\\n\\t\\tif ( denominator === 0 ) return this.set( 0, 0, 0 );\\r\\n\\r\\n\\t\\tvar scalar = v.dot( this ) / denominator;\\r\\n\\r\\n\\t\\treturn this.copy( v ).multiplyScalar( scalar );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tprojectOnPlane: function ( planeNormal ) {\\r\\n\\r\\n\\t\\t_vector.copy( this ).projectOnVector( planeNormal );\\r\\n\\r\\n\\t\\treturn this.sub( _vector );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\treflect: function ( normal ) {\\r\\n\\r\\n\\t\\t// reflect incident vector off plane orthogonal to normal\\r\\n\\t\\t// normal is assumed to have unit length\\r\\n\\r\\n\\t\\treturn this.sub( _vector.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tangleTo: function ( v ) {\\r\\n\\r\\n\\t\\tvar denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );\\r\\n\\r\\n\\t\\tif ( denominator === 0 ) return Math.PI / 2;\\r\\n\\r\\n\\t\\tvar theta = this.dot( v ) / denominator;\\r\\n\\r\\n\\t\\t// clamp, to handle numerical problems\\r\\n\\r\\n\\t\\treturn Math.acos( MathUtils.clamp( theta, - 1, 1 ) );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tdistanceTo: function ( v ) {\\r\\n\\r\\n\\t\\treturn Math.sqrt( this.distanceToSquared( v ) );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tdistanceToSquared: function ( v ) {\\r\\n\\r\\n\\t\\tvar dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\\r\\n\\r\\n\\t\\treturn dx * dx + dy * dy + dz * dz;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tmanhattanDistanceTo: function ( v ) {\\r\\n\\r\\n\\t\\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetFromSpherical: function ( s ) {\\r\\n\\r\\n\\t\\treturn this.setFromSphericalCoords( s.radius, s.phi, s.theta );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetFromSphericalCoords: function ( radius, phi, theta ) {\\r\\n\\r\\n\\t\\tvar sinPhiRadius = Math.sin( phi ) * radius;\\r\\n\\r\\n\\t\\tthis.x = sinPhiRadius * Math.sin( theta );\\r\\n\\t\\tthis.y = Math.cos( phi ) * radius;\\r\\n\\t\\tthis.z = sinPhiRadius * Math.cos( theta );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetFromCylindrical: function ( c ) {\\r\\n\\r\\n\\t\\treturn this.setFromCylindricalCoords( c.radius, c.theta, c.y );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetFromCylindricalCoords: function ( radius, theta, y ) {\\r\\n\\r\\n\\t\\tthis.x = radius * Math.sin( theta );\\r\\n\\t\\tthis.y = y;\\r\\n\\t\\tthis.z = radius * Math.cos( theta );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetFromMatrixPosition: function ( m ) {\\r\\n\\r\\n\\t\\tvar e = m.elements;\\r\\n\\r\\n\\t\\tthis.x = e[ 12 ];\\r\\n\\t\\tthis.y = e[ 13 ];\\r\\n\\t\\tthis.z = e[ 14 ];\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetFromMatrixScale: function ( m ) {\\r\\n\\r\\n\\t\\tvar sx = this.setFromMatrixColumn( m, 0 ).length();\\r\\n\\t\\tvar sy = this.setFromMatrixColumn( m, 1 ).length();\\r\\n\\t\\tvar sz = this.setFromMatrixColumn( m, 2 ).length();\\r\\n\\r\\n\\t\\tthis.x = sx;\\r\\n\\t\\tthis.y = sy;\\r\\n\\t\\tthis.z = sz;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetFromMatrixColumn: function ( m, index ) {\\r\\n\\r\\n\\t\\treturn this.fromArray( m.elements, index * 4 );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetFromMatrix3Column: function ( m, index ) {\\r\\n\\r\\n\\t\\treturn this.fromArray( m.elements, index * 3 );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tequals: function ( v ) {\\r\\n\\r\\n\\t\\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tfromArray: function ( array, offset ) {\\r\\n\\r\\n\\t\\tif ( offset === undefined ) offset = 0;\\r\\n\\r\\n\\t\\tthis.x = array[ offset ];\\r\\n\\t\\tthis.y = array[ offset + 1 ];\\r\\n\\t\\tthis.z = array[ offset + 2 ];\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttoArray: function ( array, offset ) {\\r\\n\\r\\n\\t\\tif ( array === undefined ) array = [];\\r\\n\\t\\tif ( offset === undefined ) offset = 0;\\r\\n\\r\\n\\t\\tarray[ offset ] = this.x;\\r\\n\\t\\tarray[ offset + 1 ] = this.y;\\r\\n\\t\\tarray[ offset + 2 ] = this.z;\\r\\n\\r\\n\\t\\treturn array;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tfromBufferAttribute: function ( attribute, index, offset ) {\\r\\n\\r\\n\\t\\tif ( offset !== undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.x = attribute.getX( index );\\r\\n\\t\\tthis.y = attribute.getY( index );\\r\\n\\t\\tthis.z = attribute.getZ( index );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\trandom: function () {\\r\\n\\r\\n\\t\\tthis.x = Math.random();\\r\\n\\t\\tthis.y = Math.random();\\r\\n\\t\\tthis.z = Math.random();\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nvar _v1 = new Vector3();\\r\\nvar _m1 = new Matrix4();\\r\\nvar _zero = new Vector3( 0, 0, 0 );\\r\\nvar _one = new Vector3( 1, 1, 1 );\\r\\nvar _x = new Vector3();\\r\\nvar _y = new Vector3();\\r\\nvar _z = new Vector3();\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n * @author supereggbert / http://www.paulbrunt.co.uk/\\r\\n * @author philogb / http://blog.thejit.org/\\r\\n * @author jordi_ros / http://plattsoft.com\\r\\n * @author D1plo1d / http://github.com/D1plo1d\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n * @author mikael emtinger / http://gomo.se/\\r\\n * @author timknip / http://www.floorplanner.com/\\r\\n * @author bhouston / http://clara.io\\r\\n * @author WestLangley / http://github.com/WestLangley\\r\\n */\\r\\n\\r\\nfunction Matrix4() {\\r\\n\\r\\n\\tthis.elements = [\\r\\n\\r\\n\\t\\t1, 0, 0, 0,\\r\\n\\t\\t0, 1, 0, 0,\\r\\n\\t\\t0, 0, 1, 0,\\r\\n\\t\\t0, 0, 0, 1\\r\\n\\r\\n\\t];\\r\\n\\r\\n\\tif ( arguments.length > 0 ) {\\r\\n\\r\\n\\t\\tconsole.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );\\r\\n\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\\r\\nObject.assign( Matrix4.prototype, {\\r\\n\\r\\n\\tisMatrix4: true,\\r\\n\\r\\n\\tset: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\\r\\n\\r\\n\\t\\tvar te = this.elements;\\r\\n\\r\\n\\t\\tte[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\\r\\n\\t\\tte[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\\r\\n\\t\\tte[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\\r\\n\\t\\tte[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tidentity: function () {\\r\\n\\r\\n\\t\\tthis.set(\\r\\n\\r\\n\\t\\t\\t1, 0, 0, 0,\\r\\n\\t\\t\\t0, 1, 0, 0,\\r\\n\\t\\t\\t0, 0, 1, 0,\\r\\n\\t\\t\\t0, 0, 0, 1\\r\\n\\r\\n\\t\\t);\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclone: function () {\\r\\n\\r\\n\\t\\treturn new Matrix4().fromArray( this.elements );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcopy: function ( m ) {\\r\\n\\r\\n\\t\\tvar te = this.elements;\\r\\n\\t\\tvar me = m.elements;\\r\\n\\r\\n\\t\\tte[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];\\r\\n\\t\\tte[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];\\r\\n\\t\\tte[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];\\r\\n\\t\\tte[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcopyPosition: function ( m ) {\\r\\n\\r\\n\\t\\tvar te = this.elements, me = m.elements;\\r\\n\\r\\n\\t\\tte[ 12 ] = me[ 12 ];\\r\\n\\t\\tte[ 13 ] = me[ 13 ];\\r\\n\\t\\tte[ 14 ] = me[ 14 ];\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\textractBasis: function ( xAxis, yAxis, zAxis ) {\\r\\n\\r\\n\\t\\txAxis.setFromMatrixColumn( this, 0 );\\r\\n\\t\\tyAxis.setFromMatrixColumn( this, 1 );\\r\\n\\t\\tzAxis.setFromMatrixColumn( this, 2 );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tmakeBasis: function ( xAxis, yAxis, zAxis ) {\\r\\n\\r\\n\\t\\tthis.set(\\r\\n\\t\\t\\txAxis.x, yAxis.x, zAxis.x, 0,\\r\\n\\t\\t\\txAxis.y, yAxis.y, zAxis.y, 0,\\r\\n\\t\\t\\txAxis.z, yAxis.z, zAxis.z, 0,\\r\\n\\t\\t\\t0, 0, 0, 1\\r\\n\\t\\t);\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\textractRotation: function ( m ) {\\r\\n\\r\\n\\t\\t// this method does not support reflection matrices\\r\\n\\r\\n\\t\\tvar te = this.elements;\\r\\n\\t\\tvar me = m.elements;\\r\\n\\r\\n\\t\\tvar scaleX = 1 / _v1.setFromMatrixColumn( m, 0 ).length();\\r\\n\\t\\tvar scaleY = 1 / _v1.setFromMatrixColumn( m, 1 ).length();\\r\\n\\t\\tvar scaleZ = 1 / _v1.setFromMatrixColumn( m, 2 ).length();\\r\\n\\r\\n\\t\\tte[ 0 ] = me[ 0 ] * scaleX;\\r\\n\\t\\tte[ 1 ] = me[ 1 ] * scaleX;\\r\\n\\t\\tte[ 2 ] = me[ 2 ] * scaleX;\\r\\n\\t\\tte[ 3 ] = 0;\\r\\n\\r\\n\\t\\tte[ 4 ] = me[ 4 ] * scaleY;\\r\\n\\t\\tte[ 5 ] = me[ 5 ] * scaleY;\\r\\n\\t\\tte[ 6 ] = me[ 6 ] * scaleY;\\r\\n\\t\\tte[ 7 ] = 0;\\r\\n\\r\\n\\t\\tte[ 8 ] = me[ 8 ] * scaleZ;\\r\\n\\t\\tte[ 9 ] = me[ 9 ] * scaleZ;\\r\\n\\t\\tte[ 10 ] = me[ 10 ] * scaleZ;\\r\\n\\t\\tte[ 11 ] = 0;\\r\\n\\r\\n\\t\\tte[ 12 ] = 0;\\r\\n\\t\\tte[ 13 ] = 0;\\r\\n\\t\\tte[ 14 ] = 0;\\r\\n\\t\\tte[ 15 ] = 1;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tmakeRotationFromEuler: function ( euler ) {\\r\\n\\r\\n\\t\\tif ( ! ( euler && euler.isEuler ) ) {\\r\\n\\r\\n\\t\\t\\tconsole.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar te = this.elements;\\r\\n\\r\\n\\t\\tvar x = euler.x, y = euler.y, z = euler.z;\\r\\n\\t\\tvar a = Math.cos( x ), b = Math.sin( x );\\r\\n\\t\\tvar c = Math.cos( y ), d = Math.sin( y );\\r\\n\\t\\tvar e = Math.cos( z ), f = Math.sin( z );\\r\\n\\r\\n\\t\\tif ( euler.order === 'XYZ' ) {\\r\\n\\r\\n\\t\\t\\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\\r\\n\\r\\n\\t\\t\\tte[ 0 ] = c * e;\\r\\n\\t\\t\\tte[ 4 ] = - c * f;\\r\\n\\t\\t\\tte[ 8 ] = d;\\r\\n\\r\\n\\t\\t\\tte[ 1 ] = af + be * d;\\r\\n\\t\\t\\tte[ 5 ] = ae - bf * d;\\r\\n\\t\\t\\tte[ 9 ] = - b * c;\\r\\n\\r\\n\\t\\t\\tte[ 2 ] = bf - ae * d;\\r\\n\\t\\t\\tte[ 6 ] = be + af * d;\\r\\n\\t\\t\\tte[ 10 ] = a * c;\\r\\n\\r\\n\\t\\t} else if ( euler.order === 'YXZ' ) {\\r\\n\\r\\n\\t\\t\\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\\r\\n\\r\\n\\t\\t\\tte[ 0 ] = ce + df * b;\\r\\n\\t\\t\\tte[ 4 ] = de * b - cf;\\r\\n\\t\\t\\tte[ 8 ] = a * d;\\r\\n\\r\\n\\t\\t\\tte[ 1 ] = a * f;\\r\\n\\t\\t\\tte[ 5 ] = a * e;\\r\\n\\t\\t\\tte[ 9 ] = - b;\\r\\n\\r\\n\\t\\t\\tte[ 2 ] = cf * b - de;\\r\\n\\t\\t\\tte[ 6 ] = df + ce * b;\\r\\n\\t\\t\\tte[ 10 ] = a * c;\\r\\n\\r\\n\\t\\t} else if ( euler.order === 'ZXY' ) {\\r\\n\\r\\n\\t\\t\\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\\r\\n\\r\\n\\t\\t\\tte[ 0 ] = ce - df * b;\\r\\n\\t\\t\\tte[ 4 ] = - a * f;\\r\\n\\t\\t\\tte[ 8 ] = de + cf * b;\\r\\n\\r\\n\\t\\t\\tte[ 1 ] = cf + de * b;\\r\\n\\t\\t\\tte[ 5 ] = a * e;\\r\\n\\t\\t\\tte[ 9 ] = df - ce * b;\\r\\n\\r\\n\\t\\t\\tte[ 2 ] = - a * d;\\r\\n\\t\\t\\tte[ 6 ] = b;\\r\\n\\t\\t\\tte[ 10 ] = a * c;\\r\\n\\r\\n\\t\\t} else if ( euler.order === 'ZYX' ) {\\r\\n\\r\\n\\t\\t\\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\\r\\n\\r\\n\\t\\t\\tte[ 0 ] = c * e;\\r\\n\\t\\t\\tte[ 4 ] = be * d - af;\\r\\n\\t\\t\\tte[ 8 ] = ae * d + bf;\\r\\n\\r\\n\\t\\t\\tte[ 1 ] = c * f;\\r\\n\\t\\t\\tte[ 5 ] = bf * d + ae;\\r\\n\\t\\t\\tte[ 9 ] = af * d - be;\\r\\n\\r\\n\\t\\t\\tte[ 2 ] = - d;\\r\\n\\t\\t\\tte[ 6 ] = b * c;\\r\\n\\t\\t\\tte[ 10 ] = a * c;\\r\\n\\r\\n\\t\\t} else if ( euler.order === 'YZX' ) {\\r\\n\\r\\n\\t\\t\\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\\r\\n\\r\\n\\t\\t\\tte[ 0 ] = c * e;\\r\\n\\t\\t\\tte[ 4 ] = bd - ac * f;\\r\\n\\t\\t\\tte[ 8 ] = bc * f + ad;\\r\\n\\r\\n\\t\\t\\tte[ 1 ] = f;\\r\\n\\t\\t\\tte[ 5 ] = a * e;\\r\\n\\t\\t\\tte[ 9 ] = - b * e;\\r\\n\\r\\n\\t\\t\\tte[ 2 ] = - d * e;\\r\\n\\t\\t\\tte[ 6 ] = ad * f + bc;\\r\\n\\t\\t\\tte[ 10 ] = ac - bd * f;\\r\\n\\r\\n\\t\\t} else if ( euler.order === 'XZY' ) {\\r\\n\\r\\n\\t\\t\\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\\r\\n\\r\\n\\t\\t\\tte[ 0 ] = c * e;\\r\\n\\t\\t\\tte[ 4 ] = - f;\\r\\n\\t\\t\\tte[ 8 ] = d * e;\\r\\n\\r\\n\\t\\t\\tte[ 1 ] = ac * f + bd;\\r\\n\\t\\t\\tte[ 5 ] = a * e;\\r\\n\\t\\t\\tte[ 9 ] = ad * f - bc;\\r\\n\\r\\n\\t\\t\\tte[ 2 ] = bc * f - ad;\\r\\n\\t\\t\\tte[ 6 ] = b * e;\\r\\n\\t\\t\\tte[ 10 ] = bd * f + ac;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// bottom row\\r\\n\\t\\tte[ 3 ] = 0;\\r\\n\\t\\tte[ 7 ] = 0;\\r\\n\\t\\tte[ 11 ] = 0;\\r\\n\\r\\n\\t\\t// last column\\r\\n\\t\\tte[ 12 ] = 0;\\r\\n\\t\\tte[ 13 ] = 0;\\r\\n\\t\\tte[ 14 ] = 0;\\r\\n\\t\\tte[ 15 ] = 1;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tmakeRotationFromQuaternion: function ( q ) {\\r\\n\\r\\n\\t\\treturn this.compose( _zero, q, _one );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tlookAt: function ( eye, target, up ) {\\r\\n\\r\\n\\t\\tvar te = this.elements;\\r\\n\\r\\n\\t\\t_z.subVectors( eye, target );\\r\\n\\r\\n\\t\\tif ( _z.lengthSq() === 0 ) {\\r\\n\\r\\n\\t\\t\\t// eye and target are in the same position\\r\\n\\r\\n\\t\\t\\t_z.z = 1;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t_z.normalize();\\r\\n\\t\\t_x.crossVectors( up, _z );\\r\\n\\r\\n\\t\\tif ( _x.lengthSq() === 0 ) {\\r\\n\\r\\n\\t\\t\\t// up and z are parallel\\r\\n\\r\\n\\t\\t\\tif ( Math.abs( up.z ) === 1 ) {\\r\\n\\r\\n\\t\\t\\t\\t_z.x += 0.0001;\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t_z.z += 0.0001;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t_z.normalize();\\r\\n\\t\\t\\t_x.crossVectors( up, _z );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t_x.normalize();\\r\\n\\t\\t_y.crossVectors( _z, _x );\\r\\n\\r\\n\\t\\tte[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;\\r\\n\\t\\tte[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;\\r\\n\\t\\tte[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tmultiply: function ( m, n ) {\\r\\n\\r\\n\\t\\tif ( n !== undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\\r\\n\\t\\t\\treturn this.multiplyMatrices( m, n );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this.multiplyMatrices( this, m );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tpremultiply: function ( m ) {\\r\\n\\r\\n\\t\\treturn this.multiplyMatrices( m, this );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tmultiplyMatrices: function ( a, b ) {\\r\\n\\r\\n\\t\\tvar ae = a.elements;\\r\\n\\t\\tvar be = b.elements;\\r\\n\\t\\tvar te = this.elements;\\r\\n\\r\\n\\t\\tvar a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\\r\\n\\t\\tvar a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\\r\\n\\t\\tvar a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\\r\\n\\t\\tvar a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\\r\\n\\r\\n\\t\\tvar b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\\r\\n\\t\\tvar b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\\r\\n\\t\\tvar b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\\r\\n\\t\\tvar b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\\r\\n\\r\\n\\t\\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\\r\\n\\t\\tte[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\\r\\n\\t\\tte[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\\r\\n\\t\\tte[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\\r\\n\\r\\n\\t\\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\\r\\n\\t\\tte[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\\r\\n\\t\\tte[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\\r\\n\\t\\tte[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\\r\\n\\r\\n\\t\\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\\r\\n\\t\\tte[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\\r\\n\\t\\tte[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\\r\\n\\t\\tte[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\\r\\n\\r\\n\\t\\tte[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\\r\\n\\t\\tte[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\\r\\n\\t\\tte[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\\r\\n\\t\\tte[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tmultiplyScalar: function ( s ) {\\r\\n\\r\\n\\t\\tvar te = this.elements;\\r\\n\\r\\n\\t\\tte[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\\r\\n\\t\\tte[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\\r\\n\\t\\tte[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\\r\\n\\t\\tte[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tdeterminant: function () {\\r\\n\\r\\n\\t\\tvar te = this.elements;\\r\\n\\r\\n\\t\\tvar n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\\r\\n\\t\\tvar n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\\r\\n\\t\\tvar n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\\r\\n\\t\\tvar n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\\r\\n\\r\\n\\t\\t//TODO: make this more efficient\\r\\n\\t\\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\\r\\n\\r\\n\\t\\treturn (\\r\\n\\t\\t\\tn41 * (\\r\\n\\t\\t\\t\\t+ n14 * n23 * n32\\r\\n\\t\\t\\t\\t - n13 * n24 * n32\\r\\n\\t\\t\\t\\t - n14 * n22 * n33\\r\\n\\t\\t\\t\\t + n12 * n24 * n33\\r\\n\\t\\t\\t\\t + n13 * n22 * n34\\r\\n\\t\\t\\t\\t - n12 * n23 * n34\\r\\n\\t\\t\\t) +\\r\\n\\t\\t\\tn42 * (\\r\\n\\t\\t\\t\\t+ n11 * n23 * n34\\r\\n\\t\\t\\t\\t - n11 * n24 * n33\\r\\n\\t\\t\\t\\t + n14 * n21 * n33\\r\\n\\t\\t\\t\\t - n13 * n21 * n34\\r\\n\\t\\t\\t\\t + n13 * n24 * n31\\r\\n\\t\\t\\t\\t - n14 * n23 * n31\\r\\n\\t\\t\\t) +\\r\\n\\t\\t\\tn43 * (\\r\\n\\t\\t\\t\\t+ n11 * n24 * n32\\r\\n\\t\\t\\t\\t - n11 * n22 * n34\\r\\n\\t\\t\\t\\t - n14 * n21 * n32\\r\\n\\t\\t\\t\\t + n12 * n21 * n34\\r\\n\\t\\t\\t\\t + n14 * n22 * n31\\r\\n\\t\\t\\t\\t - n12 * n24 * n31\\r\\n\\t\\t\\t) +\\r\\n\\t\\t\\tn44 * (\\r\\n\\t\\t\\t\\t- n13 * n22 * n31\\r\\n\\t\\t\\t\\t - n11 * n23 * n32\\r\\n\\t\\t\\t\\t + n11 * n22 * n33\\r\\n\\t\\t\\t\\t + n13 * n21 * n32\\r\\n\\t\\t\\t\\t - n12 * n21 * n33\\r\\n\\t\\t\\t\\t + n12 * n23 * n31\\r\\n\\t\\t\\t)\\r\\n\\r\\n\\t\\t);\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttranspose: function () {\\r\\n\\r\\n\\t\\tvar te = this.elements;\\r\\n\\t\\tvar tmp;\\r\\n\\r\\n\\t\\ttmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\\r\\n\\t\\ttmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\\r\\n\\t\\ttmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\\r\\n\\r\\n\\t\\ttmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\\r\\n\\t\\ttmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\\r\\n\\t\\ttmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetPosition: function ( x, y, z ) {\\r\\n\\r\\n\\t\\tvar te = this.elements;\\r\\n\\r\\n\\t\\tif ( x.isVector3 ) {\\r\\n\\r\\n\\t\\t\\tte[ 12 ] = x.x;\\r\\n\\t\\t\\tte[ 13 ] = x.y;\\r\\n\\t\\t\\tte[ 14 ] = x.z;\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tte[ 12 ] = x;\\r\\n\\t\\t\\tte[ 13 ] = y;\\r\\n\\t\\t\\tte[ 14 ] = z;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetInverse: function ( m, throwOnDegenerate ) {\\r\\n\\r\\n\\t\\tif ( throwOnDegenerate !== undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( \\\"THREE.Matrix4: .getInverse() can no longer be configured to throw on degenerate.\\\" );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\\r\\n\\t\\tvar te = this.elements,\\r\\n\\t\\t\\tme = m.elements,\\r\\n\\r\\n\\t\\t\\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],\\r\\n\\t\\t\\tn12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],\\r\\n\\t\\t\\tn13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],\\r\\n\\t\\t\\tn14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],\\r\\n\\r\\n\\t\\t\\tt11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\\r\\n\\t\\t\\tt12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\\r\\n\\t\\t\\tt13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\\r\\n\\t\\t\\tt14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\\r\\n\\r\\n\\t\\tvar det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\\r\\n\\r\\n\\t\\tif ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );\\r\\n\\r\\n\\t\\tvar detInv = 1 / det;\\r\\n\\r\\n\\t\\tte[ 0 ] = t11 * detInv;\\r\\n\\t\\tte[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;\\r\\n\\t\\tte[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;\\r\\n\\t\\tte[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;\\r\\n\\r\\n\\t\\tte[ 4 ] = t12 * detInv;\\r\\n\\t\\tte[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;\\r\\n\\t\\tte[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;\\r\\n\\t\\tte[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;\\r\\n\\r\\n\\t\\tte[ 8 ] = t13 * detInv;\\r\\n\\t\\tte[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;\\r\\n\\t\\tte[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;\\r\\n\\t\\tte[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;\\r\\n\\r\\n\\t\\tte[ 12 ] = t14 * detInv;\\r\\n\\t\\tte[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;\\r\\n\\t\\tte[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;\\r\\n\\t\\tte[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tscale: function ( v ) {\\r\\n\\r\\n\\t\\tvar te = this.elements;\\r\\n\\t\\tvar x = v.x, y = v.y, z = v.z;\\r\\n\\r\\n\\t\\tte[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\\r\\n\\t\\tte[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\\r\\n\\t\\tte[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\\r\\n\\t\\tte[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetMaxScaleOnAxis: function () {\\r\\n\\r\\n\\t\\tvar te = this.elements;\\r\\n\\r\\n\\t\\tvar scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\\r\\n\\t\\tvar scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\\r\\n\\t\\tvar scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\\r\\n\\r\\n\\t\\treturn Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tmakeTranslation: function ( x, y, z ) {\\r\\n\\r\\n\\t\\tthis.set(\\r\\n\\r\\n\\t\\t\\t1, 0, 0, x,\\r\\n\\t\\t\\t0, 1, 0, y,\\r\\n\\t\\t\\t0, 0, 1, z,\\r\\n\\t\\t\\t0, 0, 0, 1\\r\\n\\r\\n\\t\\t);\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tmakeRotationX: function ( theta ) {\\r\\n\\r\\n\\t\\tvar c = Math.cos( theta ), s = Math.sin( theta );\\r\\n\\r\\n\\t\\tthis.set(\\r\\n\\r\\n\\t\\t\\t1, 0, 0, 0,\\r\\n\\t\\t\\t0, c, - s, 0,\\r\\n\\t\\t\\t0, s, c, 0,\\r\\n\\t\\t\\t0, 0, 0, 1\\r\\n\\r\\n\\t\\t);\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tmakeRotationY: function ( theta ) {\\r\\n\\r\\n\\t\\tvar c = Math.cos( theta ), s = Math.sin( theta );\\r\\n\\r\\n\\t\\tthis.set(\\r\\n\\r\\n\\t\\t\\t c, 0, s, 0,\\r\\n\\t\\t\\t 0, 1, 0, 0,\\r\\n\\t\\t\\t- s, 0, c, 0,\\r\\n\\t\\t\\t 0, 0, 0, 1\\r\\n\\r\\n\\t\\t);\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tmakeRotationZ: function ( theta ) {\\r\\n\\r\\n\\t\\tvar c = Math.cos( theta ), s = Math.sin( theta );\\r\\n\\r\\n\\t\\tthis.set(\\r\\n\\r\\n\\t\\t\\tc, - s, 0, 0,\\r\\n\\t\\t\\ts, c, 0, 0,\\r\\n\\t\\t\\t0, 0, 1, 0,\\r\\n\\t\\t\\t0, 0, 0, 1\\r\\n\\r\\n\\t\\t);\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tmakeRotationAxis: function ( axis, angle ) {\\r\\n\\r\\n\\t\\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\\r\\n\\r\\n\\t\\tvar c = Math.cos( angle );\\r\\n\\t\\tvar s = Math.sin( angle );\\r\\n\\t\\tvar t = 1 - c;\\r\\n\\t\\tvar x = axis.x, y = axis.y, z = axis.z;\\r\\n\\t\\tvar tx = t * x, ty = t * y;\\r\\n\\r\\n\\t\\tthis.set(\\r\\n\\r\\n\\t\\t\\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\\r\\n\\t\\t\\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\\r\\n\\t\\t\\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\\r\\n\\t\\t\\t0, 0, 0, 1\\r\\n\\r\\n\\t\\t);\\r\\n\\r\\n\\t\\t return this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tmakeScale: function ( x, y, z ) {\\r\\n\\r\\n\\t\\tthis.set(\\r\\n\\r\\n\\t\\t\\tx, 0, 0, 0,\\r\\n\\t\\t\\t0, y, 0, 0,\\r\\n\\t\\t\\t0, 0, z, 0,\\r\\n\\t\\t\\t0, 0, 0, 1\\r\\n\\r\\n\\t\\t);\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tmakeShear: function ( x, y, z ) {\\r\\n\\r\\n\\t\\tthis.set(\\r\\n\\r\\n\\t\\t\\t1, y, z, 0,\\r\\n\\t\\t\\tx, 1, z, 0,\\r\\n\\t\\t\\tx, y, 1, 0,\\r\\n\\t\\t\\t0, 0, 0, 1\\r\\n\\r\\n\\t\\t);\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcompose: function ( position, quaternion, scale ) {\\r\\n\\r\\n\\t\\tvar te = this.elements;\\r\\n\\r\\n\\t\\tvar x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;\\r\\n\\t\\tvar x2 = x + x,\\ty2 = y + y, z2 = z + z;\\r\\n\\t\\tvar xx = x * x2, xy = x * y2, xz = x * z2;\\r\\n\\t\\tvar yy = y * y2, yz = y * z2, zz = z * z2;\\r\\n\\t\\tvar wx = w * x2, wy = w * y2, wz = w * z2;\\r\\n\\r\\n\\t\\tvar sx = scale.x, sy = scale.y, sz = scale.z;\\r\\n\\r\\n\\t\\tte[ 0 ] = ( 1 - ( yy + zz ) ) * sx;\\r\\n\\t\\tte[ 1 ] = ( xy + wz ) * sx;\\r\\n\\t\\tte[ 2 ] = ( xz - wy ) * sx;\\r\\n\\t\\tte[ 3 ] = 0;\\r\\n\\r\\n\\t\\tte[ 4 ] = ( xy - wz ) * sy;\\r\\n\\t\\tte[ 5 ] = ( 1 - ( xx + zz ) ) * sy;\\r\\n\\t\\tte[ 6 ] = ( yz + wx ) * sy;\\r\\n\\t\\tte[ 7 ] = 0;\\r\\n\\r\\n\\t\\tte[ 8 ] = ( xz + wy ) * sz;\\r\\n\\t\\tte[ 9 ] = ( yz - wx ) * sz;\\r\\n\\t\\tte[ 10 ] = ( 1 - ( xx + yy ) ) * sz;\\r\\n\\t\\tte[ 11 ] = 0;\\r\\n\\r\\n\\t\\tte[ 12 ] = position.x;\\r\\n\\t\\tte[ 13 ] = position.y;\\r\\n\\t\\tte[ 14 ] = position.z;\\r\\n\\t\\tte[ 15 ] = 1;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tdecompose: function ( position, quaternion, scale ) {\\r\\n\\r\\n\\t\\tvar te = this.elements;\\r\\n\\r\\n\\t\\tvar sx = _v1.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\\r\\n\\t\\tvar sy = _v1.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\\r\\n\\t\\tvar sz = _v1.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\\r\\n\\r\\n\\t\\t// if determine is negative, we need to invert one scale\\r\\n\\t\\tvar det = this.determinant();\\r\\n\\t\\tif ( det < 0 ) sx = - sx;\\r\\n\\r\\n\\t\\tposition.x = te[ 12 ];\\r\\n\\t\\tposition.y = te[ 13 ];\\r\\n\\t\\tposition.z = te[ 14 ];\\r\\n\\r\\n\\t\\t// scale the rotation part\\r\\n\\t\\t_m1.copy( this );\\r\\n\\r\\n\\t\\tvar invSX = 1 / sx;\\r\\n\\t\\tvar invSY = 1 / sy;\\r\\n\\t\\tvar invSZ = 1 / sz;\\r\\n\\r\\n\\t\\t_m1.elements[ 0 ] *= invSX;\\r\\n\\t\\t_m1.elements[ 1 ] *= invSX;\\r\\n\\t\\t_m1.elements[ 2 ] *= invSX;\\r\\n\\r\\n\\t\\t_m1.elements[ 4 ] *= invSY;\\r\\n\\t\\t_m1.elements[ 5 ] *= invSY;\\r\\n\\t\\t_m1.elements[ 6 ] *= invSY;\\r\\n\\r\\n\\t\\t_m1.elements[ 8 ] *= invSZ;\\r\\n\\t\\t_m1.elements[ 9 ] *= invSZ;\\r\\n\\t\\t_m1.elements[ 10 ] *= invSZ;\\r\\n\\r\\n\\t\\tquaternion.setFromRotationMatrix( _m1 );\\r\\n\\r\\n\\t\\tscale.x = sx;\\r\\n\\t\\tscale.y = sy;\\r\\n\\t\\tscale.z = sz;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tmakePerspective: function ( left, right, top, bottom, near, far ) {\\r\\n\\r\\n\\t\\tif ( far === undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar te = this.elements;\\r\\n\\t\\tvar x = 2 * near / ( right - left );\\r\\n\\t\\tvar y = 2 * near / ( top - bottom );\\r\\n\\r\\n\\t\\tvar a = ( right + left ) / ( right - left );\\r\\n\\t\\tvar b = ( top + bottom ) / ( top - bottom );\\r\\n\\t\\tvar c = - ( far + near ) / ( far - near );\\r\\n\\t\\tvar d = - 2 * far * near / ( far - near );\\r\\n\\r\\n\\t\\tte[ 0 ] = x;\\tte[ 4 ] = 0;\\tte[ 8 ] = a;\\tte[ 12 ] = 0;\\r\\n\\t\\tte[ 1 ] = 0;\\tte[ 5 ] = y;\\tte[ 9 ] = b;\\tte[ 13 ] = 0;\\r\\n\\t\\tte[ 2 ] = 0;\\tte[ 6 ] = 0;\\tte[ 10 ] = c;\\tte[ 14 ] = d;\\r\\n\\t\\tte[ 3 ] = 0;\\tte[ 7 ] = 0;\\tte[ 11 ] = - 1;\\tte[ 15 ] = 0;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tmakeOrthographic: function ( left, right, top, bottom, near, far ) {\\r\\n\\r\\n\\t\\tvar te = this.elements;\\r\\n\\t\\tvar w = 1.0 / ( right - left );\\r\\n\\t\\tvar h = 1.0 / ( top - bottom );\\r\\n\\t\\tvar p = 1.0 / ( far - near );\\r\\n\\r\\n\\t\\tvar x = ( right + left ) * w;\\r\\n\\t\\tvar y = ( top + bottom ) * h;\\r\\n\\t\\tvar z = ( far + near ) * p;\\r\\n\\r\\n\\t\\tte[ 0 ] = 2 * w;\\tte[ 4 ] = 0;\\tte[ 8 ] = 0;\\tte[ 12 ] = - x;\\r\\n\\t\\tte[ 1 ] = 0;\\tte[ 5 ] = 2 * h;\\tte[ 9 ] = 0;\\tte[ 13 ] = - y;\\r\\n\\t\\tte[ 2 ] = 0;\\tte[ 6 ] = 0;\\tte[ 10 ] = - 2 * p;\\tte[ 14 ] = - z;\\r\\n\\t\\tte[ 3 ] = 0;\\tte[ 7 ] = 0;\\tte[ 11 ] = 0;\\tte[ 15 ] = 1;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tequals: function ( matrix ) {\\r\\n\\r\\n\\t\\tvar te = this.elements;\\r\\n\\t\\tvar me = matrix.elements;\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < 16; i ++ ) {\\r\\n\\r\\n\\t\\t\\tif ( te[ i ] !== me[ i ] ) return false;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn true;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tfromArray: function ( array, offset ) {\\r\\n\\r\\n\\t\\tif ( offset === undefined ) offset = 0;\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < 16; i ++ ) {\\r\\n\\r\\n\\t\\t\\tthis.elements[ i ] = array[ i + offset ];\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttoArray: function ( array, offset ) {\\r\\n\\r\\n\\t\\tif ( array === undefined ) array = [];\\r\\n\\t\\tif ( offset === undefined ) offset = 0;\\r\\n\\r\\n\\t\\tvar te = this.elements;\\r\\n\\r\\n\\t\\tarray[ offset ] = te[ 0 ];\\r\\n\\t\\tarray[ offset + 1 ] = te[ 1 ];\\r\\n\\t\\tarray[ offset + 2 ] = te[ 2 ];\\r\\n\\t\\tarray[ offset + 3 ] = te[ 3 ];\\r\\n\\r\\n\\t\\tarray[ offset + 4 ] = te[ 4 ];\\r\\n\\t\\tarray[ offset + 5 ] = te[ 5 ];\\r\\n\\t\\tarray[ offset + 6 ] = te[ 6 ];\\r\\n\\t\\tarray[ offset + 7 ] = te[ 7 ];\\r\\n\\r\\n\\t\\tarray[ offset + 8 ] = te[ 8 ];\\r\\n\\t\\tarray[ offset + 9 ] = te[ 9 ];\\r\\n\\t\\tarray[ offset + 10 ] = te[ 10 ];\\r\\n\\t\\tarray[ offset + 11 ] = te[ 11 ];\\r\\n\\r\\n\\t\\tarray[ offset + 12 ] = te[ 12 ];\\r\\n\\t\\tarray[ offset + 13 ] = te[ 13 ];\\r\\n\\t\\tarray[ offset + 14 ] = te[ 14 ];\\r\\n\\t\\tarray[ offset + 15 ] = te[ 15 ];\\r\\n\\r\\n\\t\\treturn array;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n * @author WestLangley / http://github.com/WestLangley\\r\\n * @author bhouston / http://clara.io\\r\\n */\\r\\n\\r\\nvar _matrix = new Matrix4();\\r\\nvar _quaternion$1 = new Quaternion();\\r\\n\\r\\nfunction Euler( x, y, z, order ) {\\r\\n\\r\\n\\tthis._x = x || 0;\\r\\n\\tthis._y = y || 0;\\r\\n\\tthis._z = z || 0;\\r\\n\\tthis._order = order || Euler.DefaultOrder;\\r\\n\\r\\n}\\r\\n\\r\\nEuler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];\\r\\n\\r\\nEuler.DefaultOrder = 'XYZ';\\r\\n\\r\\nObject.defineProperties( Euler.prototype, {\\r\\n\\r\\n\\tx: {\\r\\n\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\treturn this._x;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\tthis._x = value;\\r\\n\\t\\t\\tthis._onChangeCallback();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ty: {\\r\\n\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\treturn this._y;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\tthis._y = value;\\r\\n\\t\\t\\tthis._onChangeCallback();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tz: {\\r\\n\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\treturn this._z;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\tthis._z = value;\\r\\n\\t\\t\\tthis._onChangeCallback();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\torder: {\\r\\n\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\treturn this._order;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\tthis._order = value;\\r\\n\\t\\t\\tthis._onChangeCallback();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nObject.assign( Euler.prototype, {\\r\\n\\r\\n\\tisEuler: true,\\r\\n\\r\\n\\tset: function ( x, y, z, order ) {\\r\\n\\r\\n\\t\\tthis._x = x;\\r\\n\\t\\tthis._y = y;\\r\\n\\t\\tthis._z = z;\\r\\n\\t\\tthis._order = order || this._order;\\r\\n\\r\\n\\t\\tthis._onChangeCallback();\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclone: function () {\\r\\n\\r\\n\\t\\treturn new this.constructor( this._x, this._y, this._z, this._order );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcopy: function ( euler ) {\\r\\n\\r\\n\\t\\tthis._x = euler._x;\\r\\n\\t\\tthis._y = euler._y;\\r\\n\\t\\tthis._z = euler._z;\\r\\n\\t\\tthis._order = euler._order;\\r\\n\\r\\n\\t\\tthis._onChangeCallback();\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetFromRotationMatrix: function ( m, order, update ) {\\r\\n\\r\\n\\t\\tvar clamp = MathUtils.clamp;\\r\\n\\r\\n\\t\\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\\r\\n\\r\\n\\t\\tvar te = m.elements;\\r\\n\\t\\tvar m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\\r\\n\\t\\tvar m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\\r\\n\\t\\tvar m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\\r\\n\\r\\n\\t\\torder = order || this._order;\\r\\n\\r\\n\\t\\tswitch ( order ) {\\r\\n\\r\\n\\t\\t\\tcase 'XYZ':\\r\\n\\r\\n\\t\\t\\t\\tthis._y = Math.asin( clamp( m13, - 1, 1 ) );\\r\\n\\r\\n\\t\\t\\t\\tif ( Math.abs( m13 ) < 0.9999999 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis._x = Math.atan2( - m23, m33 );\\r\\n\\t\\t\\t\\t\\tthis._z = Math.atan2( - m12, m11 );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis._x = Math.atan2( m32, m22 );\\r\\n\\t\\t\\t\\t\\tthis._z = 0;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tcase 'YXZ':\\r\\n\\r\\n\\t\\t\\t\\tthis._x = Math.asin( - clamp( m23, - 1, 1 ) );\\r\\n\\r\\n\\t\\t\\t\\tif ( Math.abs( m23 ) < 0.9999999 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis._y = Math.atan2( m13, m33 );\\r\\n\\t\\t\\t\\t\\tthis._z = Math.atan2( m21, m22 );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis._y = Math.atan2( - m31, m11 );\\r\\n\\t\\t\\t\\t\\tthis._z = 0;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tcase 'ZXY':\\r\\n\\r\\n\\t\\t\\t\\tthis._x = Math.asin( clamp( m32, - 1, 1 ) );\\r\\n\\r\\n\\t\\t\\t\\tif ( Math.abs( m32 ) < 0.9999999 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis._y = Math.atan2( - m31, m33 );\\r\\n\\t\\t\\t\\t\\tthis._z = Math.atan2( - m12, m22 );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis._y = 0;\\r\\n\\t\\t\\t\\t\\tthis._z = Math.atan2( m21, m11 );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tcase 'ZYX':\\r\\n\\r\\n\\t\\t\\t\\tthis._y = Math.asin( - clamp( m31, - 1, 1 ) );\\r\\n\\r\\n\\t\\t\\t\\tif ( Math.abs( m31 ) < 0.9999999 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis._x = Math.atan2( m32, m33 );\\r\\n\\t\\t\\t\\t\\tthis._z = Math.atan2( m21, m11 );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis._x = 0;\\r\\n\\t\\t\\t\\t\\tthis._z = Math.atan2( - m12, m22 );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tcase 'YZX':\\r\\n\\r\\n\\t\\t\\t\\tthis._z = Math.asin( clamp( m21, - 1, 1 ) );\\r\\n\\r\\n\\t\\t\\t\\tif ( Math.abs( m21 ) < 0.9999999 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis._x = Math.atan2( - m23, m22 );\\r\\n\\t\\t\\t\\t\\tthis._y = Math.atan2( - m31, m11 );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis._x = 0;\\r\\n\\t\\t\\t\\t\\tthis._y = Math.atan2( m13, m33 );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tcase 'XZY':\\r\\n\\r\\n\\t\\t\\t\\tthis._z = Math.asin( - clamp( m12, - 1, 1 ) );\\r\\n\\r\\n\\t\\t\\t\\tif ( Math.abs( m12 ) < 0.9999999 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis._x = Math.atan2( m32, m22 );\\r\\n\\t\\t\\t\\t\\tthis._y = Math.atan2( m13, m11 );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis._x = Math.atan2( - m23, m33 );\\r\\n\\t\\t\\t\\t\\tthis._y = 0;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tdefault:\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis._order = order;\\r\\n\\r\\n\\t\\tif ( update !== false ) this._onChangeCallback();\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetFromQuaternion: function ( q, order, update ) {\\r\\n\\r\\n\\t\\t_matrix.makeRotationFromQuaternion( q );\\r\\n\\r\\n\\t\\treturn this.setFromRotationMatrix( _matrix, order, update );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetFromVector3: function ( v, order ) {\\r\\n\\r\\n\\t\\treturn this.set( v.x, v.y, v.z, order || this._order );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\treorder: function ( newOrder ) {\\r\\n\\r\\n\\t\\t// WARNING: this discards revolution information -bhouston\\r\\n\\r\\n\\t\\t_quaternion$1.setFromEuler( this );\\r\\n\\r\\n\\t\\treturn this.setFromQuaternion( _quaternion$1, newOrder );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tequals: function ( euler ) {\\r\\n\\r\\n\\t\\treturn ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tfromArray: function ( array ) {\\r\\n\\r\\n\\t\\tthis._x = array[ 0 ];\\r\\n\\t\\tthis._y = array[ 1 ];\\r\\n\\t\\tthis._z = array[ 2 ];\\r\\n\\t\\tif ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\\r\\n\\r\\n\\t\\tthis._onChangeCallback();\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttoArray: function ( array, offset ) {\\r\\n\\r\\n\\t\\tif ( array === undefined ) array = [];\\r\\n\\t\\tif ( offset === undefined ) offset = 0;\\r\\n\\r\\n\\t\\tarray[ offset ] = this._x;\\r\\n\\t\\tarray[ offset + 1 ] = this._y;\\r\\n\\t\\tarray[ offset + 2 ] = this._z;\\r\\n\\t\\tarray[ offset + 3 ] = this._order;\\r\\n\\r\\n\\t\\treturn array;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttoVector3: function ( optionalResult ) {\\r\\n\\r\\n\\t\\tif ( optionalResult ) {\\r\\n\\r\\n\\t\\t\\treturn optionalResult.set( this._x, this._y, this._z );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\treturn new Vector3( this._x, this._y, this._z );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t_onChange: function ( callback ) {\\r\\n\\r\\n\\t\\tthis._onChangeCallback = callback;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t_onChangeCallback: function () {}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nfunction Layers() {\\r\\n\\r\\n\\tthis.mask = 1 | 0;\\r\\n\\r\\n}\\r\\n\\r\\nObject.assign( Layers.prototype, {\\r\\n\\r\\n\\tset: function ( channel ) {\\r\\n\\r\\n\\t\\tthis.mask = 1 << channel | 0;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tenable: function ( channel ) {\\r\\n\\r\\n\\t\\tthis.mask |= 1 << channel | 0;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tenableAll: function () {\\r\\n\\r\\n\\t\\tthis.mask = 0xffffffff | 0;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttoggle: function ( channel ) {\\r\\n\\r\\n\\t\\tthis.mask ^= 1 << channel | 0;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tdisable: function ( channel ) {\\r\\n\\r\\n\\t\\tthis.mask &= ~ ( 1 << channel | 0 );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tdisableAll: function () {\\r\\n\\r\\n\\t\\tthis.mask = 0;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttest: function ( layers ) {\\r\\n\\r\\n\\t\\treturn ( this.mask & layers.mask ) !== 0;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nlet _object3DId = 0;\\r\\n\\r\\nconst _v1$1 = new Vector3();\\r\\nconst _q1 = new Quaternion();\\r\\nconst _m1$1 = new Matrix4();\\r\\nconst _target = new Vector3();\\r\\n\\r\\nconst _position = new Vector3();\\r\\nconst _scale = new Vector3();\\r\\nconst _quaternion$2 = new Quaternion();\\r\\n\\r\\nconst _xAxis = new Vector3( 1, 0, 0 );\\r\\nconst _yAxis = new Vector3( 0, 1, 0 );\\r\\nconst _zAxis = new Vector3( 0, 0, 1 );\\r\\n\\r\\nconst _addedEvent = { type: 'added' };\\r\\nconst _removedEvent = { type: 'removed' };\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n * @author mikael emtinger / http://gomo.se/\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n * @author WestLangley / http://github.com/WestLangley\\r\\n * @author elephantatwork / www.elephantatwork.ch\\r\\n */\\r\\n\\r\\nfunction Object3D() {\\r\\n\\r\\n\\tObject.defineProperty( this, 'id', { value: _object3DId ++ } );\\r\\n\\r\\n\\tthis.uuid = MathUtils.generateUUID();\\r\\n\\r\\n\\tthis.name = '';\\r\\n\\tthis.type = 'Object3D';\\r\\n\\r\\n\\tthis.parent = null;\\r\\n\\tthis.children = [];\\r\\n\\r\\n\\tthis.up = Object3D.DefaultUp.clone();\\r\\n\\r\\n\\tvar position = new Vector3();\\r\\n\\tvar rotation = new Euler();\\r\\n\\tvar quaternion = new Quaternion();\\r\\n\\tvar scale = new Vector3( 1, 1, 1 );\\r\\n\\r\\n\\tfunction onRotationChange() {\\r\\n\\r\\n\\t\\tquaternion.setFromEuler( rotation, false );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction onQuaternionChange() {\\r\\n\\r\\n\\t\\trotation.setFromQuaternion( quaternion, undefined, false );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\trotation._onChange( onRotationChange );\\r\\n\\tquaternion._onChange( onQuaternionChange );\\r\\n\\r\\n\\tObject.defineProperties( this, {\\r\\n\\t\\tposition: {\\r\\n\\t\\t\\tconfigurable: true,\\r\\n\\t\\t\\tenumerable: true,\\r\\n\\t\\t\\tvalue: position\\r\\n\\t\\t},\\r\\n\\t\\trotation: {\\r\\n\\t\\t\\tconfigurable: true,\\r\\n\\t\\t\\tenumerable: true,\\r\\n\\t\\t\\tvalue: rotation\\r\\n\\t\\t},\\r\\n\\t\\tquaternion: {\\r\\n\\t\\t\\tconfigurable: true,\\r\\n\\t\\t\\tenumerable: true,\\r\\n\\t\\t\\tvalue: quaternion\\r\\n\\t\\t},\\r\\n\\t\\tscale: {\\r\\n\\t\\t\\tconfigurable: true,\\r\\n\\t\\t\\tenumerable: true,\\r\\n\\t\\t\\tvalue: scale\\r\\n\\t\\t},\\r\\n\\t\\tmodelViewMatrix: {\\r\\n\\t\\t\\tvalue: new Matrix4()\\r\\n\\t\\t},\\r\\n\\t\\tnormalMatrix: {\\r\\n\\t\\t\\tvalue: new Matrix3()\\r\\n\\t\\t}\\r\\n\\t} );\\r\\n\\r\\n\\tthis.matrix = new Matrix4();\\r\\n\\tthis.matrixWorld = new Matrix4();\\r\\n\\r\\n\\tthis.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;\\r\\n\\tthis.matrixWorldNeedsUpdate = false;\\r\\n\\r\\n\\tthis.layers = new Layers();\\r\\n\\tthis.visible = true;\\r\\n\\r\\n\\tthis.castShadow = false;\\r\\n\\tthis.receiveShadow = false;\\r\\n\\r\\n\\tthis.frustumCulled = true;\\r\\n\\tthis.renderOrder = 0;\\r\\n\\r\\n\\tthis.userData = {};\\r\\n\\r\\n}\\r\\n\\r\\nObject3D.DefaultUp = new Vector3( 0, 1, 0 );\\r\\nObject3D.DefaultMatrixAutoUpdate = true;\\r\\n\\r\\nObject3D.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\\r\\n\\r\\n\\tconstructor: Object3D,\\r\\n\\r\\n\\tisObject3D: true,\\r\\n\\r\\n\\tonBeforeRender: function () {},\\r\\n\\tonAfterRender: function () {},\\r\\n\\r\\n\\tapplyMatrix4: function ( matrix ) {\\r\\n\\r\\n\\t\\tif ( this.matrixAutoUpdate ) this.updateMatrix();\\r\\n\\r\\n\\t\\tthis.matrix.premultiply( matrix );\\r\\n\\r\\n\\t\\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tapplyQuaternion: function ( q ) {\\r\\n\\r\\n\\t\\tthis.quaternion.premultiply( q );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetRotationFromAxisAngle: function ( axis, angle ) {\\r\\n\\r\\n\\t\\t// assumes axis is normalized\\r\\n\\r\\n\\t\\tthis.quaternion.setFromAxisAngle( axis, angle );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetRotationFromEuler: function ( euler ) {\\r\\n\\r\\n\\t\\tthis.quaternion.setFromEuler( euler, true );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetRotationFromMatrix: function ( m ) {\\r\\n\\r\\n\\t\\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\\r\\n\\r\\n\\t\\tthis.quaternion.setFromRotationMatrix( m );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetRotationFromQuaternion: function ( q ) {\\r\\n\\r\\n\\t\\t// assumes q is normalized\\r\\n\\r\\n\\t\\tthis.quaternion.copy( q );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\trotateOnAxis: function ( axis, angle ) {\\r\\n\\r\\n\\t\\t// rotate object on axis in object space\\r\\n\\t\\t// axis is assumed to be normalized\\r\\n\\r\\n\\t\\t_q1.setFromAxisAngle( axis, angle );\\r\\n\\r\\n\\t\\tthis.quaternion.multiply( _q1 );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\trotateOnWorldAxis: function ( axis, angle ) {\\r\\n\\r\\n\\t\\t// rotate object on axis in world space\\r\\n\\t\\t// axis is assumed to be normalized\\r\\n\\t\\t// method assumes no rotated parent\\r\\n\\r\\n\\t\\t_q1.setFromAxisAngle( axis, angle );\\r\\n\\r\\n\\t\\tthis.quaternion.premultiply( _q1 );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\trotateX: function ( angle ) {\\r\\n\\r\\n\\t\\treturn this.rotateOnAxis( _xAxis, angle );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\trotateY: function ( angle ) {\\r\\n\\r\\n\\t\\treturn this.rotateOnAxis( _yAxis, angle );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\trotateZ: function ( angle ) {\\r\\n\\r\\n\\t\\treturn this.rotateOnAxis( _zAxis, angle );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttranslateOnAxis: function ( axis, distance ) {\\r\\n\\r\\n\\t\\t// translate object by distance along axis in object space\\r\\n\\t\\t// axis is assumed to be normalized\\r\\n\\r\\n\\t\\t_v1$1.copy( axis ).applyQuaternion( this.quaternion );\\r\\n\\r\\n\\t\\tthis.position.add( _v1$1.multiplyScalar( distance ) );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttranslateX: function ( distance ) {\\r\\n\\r\\n\\t\\treturn this.translateOnAxis( _xAxis, distance );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttranslateY: function ( distance ) {\\r\\n\\r\\n\\t\\treturn this.translateOnAxis( _yAxis, distance );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttranslateZ: function ( distance ) {\\r\\n\\r\\n\\t\\treturn this.translateOnAxis( _zAxis, distance );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tlocalToWorld: function ( vector ) {\\r\\n\\r\\n\\t\\treturn vector.applyMatrix4( this.matrixWorld );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tworldToLocal: function ( vector ) {\\r\\n\\r\\n\\t\\treturn vector.applyMatrix4( _m1$1.getInverse( this.matrixWorld ) );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tlookAt: function ( x, y, z ) {\\r\\n\\r\\n\\t\\t// This method does not support objects having non-uniformly-scaled parent(s)\\r\\n\\r\\n\\t\\tif ( x.isVector3 ) {\\r\\n\\r\\n\\t\\t\\t_target.copy( x );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t_target.set( x, y, z );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar parent = this.parent;\\r\\n\\r\\n\\t\\tthis.updateWorldMatrix( true, false );\\r\\n\\r\\n\\t\\t_position.setFromMatrixPosition( this.matrixWorld );\\r\\n\\r\\n\\t\\tif ( this.isCamera || this.isLight ) {\\r\\n\\r\\n\\t\\t\\t_m1$1.lookAt( _position, _target, this.up );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t_m1$1.lookAt( _target, _position, this.up );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.quaternion.setFromRotationMatrix( _m1$1 );\\r\\n\\r\\n\\t\\tif ( parent ) {\\r\\n\\r\\n\\t\\t\\t_m1$1.extractRotation( parent.matrixWorld );\\r\\n\\t\\t\\t_q1.setFromRotationMatrix( _m1$1 );\\r\\n\\t\\t\\tthis.quaternion.premultiply( _q1.inverse() );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tadd: function ( object ) {\\r\\n\\r\\n\\t\\tif ( arguments.length > 1 ) {\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < arguments.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.add( arguments[ i ] );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( object === this ) {\\r\\n\\r\\n\\t\\t\\tconsole.error( \\\"THREE.Object3D.add: object can't be added as a child of itself.\\\", object );\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( ( object && object.isObject3D ) ) {\\r\\n\\r\\n\\t\\t\\tif ( object.parent !== null ) {\\r\\n\\r\\n\\t\\t\\t\\tobject.parent.remove( object );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tobject.parent = this;\\r\\n\\t\\t\\tthis.children.push( object );\\r\\n\\r\\n\\t\\t\\tobject.dispatchEvent( _addedEvent );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tconsole.error( \\\"THREE.Object3D.add: object not an instance of THREE.Object3D.\\\", object );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tremove: function ( object ) {\\r\\n\\r\\n\\t\\tif ( arguments.length > 1 ) {\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < arguments.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.remove( arguments[ i ] );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar index = this.children.indexOf( object );\\r\\n\\r\\n\\t\\tif ( index !== - 1 ) {\\r\\n\\r\\n\\t\\t\\tobject.parent = null;\\r\\n\\t\\t\\tthis.children.splice( index, 1 );\\r\\n\\r\\n\\t\\t\\tobject.dispatchEvent( _removedEvent );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tattach: function ( object ) {\\r\\n\\r\\n\\t\\t// adds object as a child of this, while maintaining the object's world transform\\r\\n\\r\\n\\t\\tthis.updateWorldMatrix( true, false );\\r\\n\\r\\n\\t\\t_m1$1.getInverse( this.matrixWorld );\\r\\n\\r\\n\\t\\tif ( object.parent !== null ) {\\r\\n\\r\\n\\t\\t\\tobject.parent.updateWorldMatrix( true, false );\\r\\n\\r\\n\\t\\t\\t_m1$1.multiply( object.parent.matrixWorld );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tobject.applyMatrix4( _m1$1 );\\r\\n\\r\\n\\t\\tobject.updateWorldMatrix( false, false );\\r\\n\\r\\n\\t\\tthis.add( object );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetObjectById: function ( id ) {\\r\\n\\r\\n\\t\\treturn this.getObjectByProperty( 'id', id );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetObjectByName: function ( name ) {\\r\\n\\r\\n\\t\\treturn this.getObjectByProperty( 'name', name );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetObjectByProperty: function ( name, value ) {\\r\\n\\r\\n\\t\\tif ( this[ name ] === value ) return this;\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar child = this.children[ i ];\\r\\n\\t\\t\\tvar object = child.getObjectByProperty( name, value );\\r\\n\\r\\n\\t\\t\\tif ( object !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\treturn object;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn undefined;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetWorldPosition: function ( target ) {\\r\\n\\r\\n\\t\\tif ( target === undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Object3D: .getWorldPosition() target is now required' );\\r\\n\\t\\t\\ttarget = new Vector3();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.updateMatrixWorld( true );\\r\\n\\r\\n\\t\\treturn target.setFromMatrixPosition( this.matrixWorld );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetWorldQuaternion: function ( target ) {\\r\\n\\r\\n\\t\\tif ( target === undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Object3D: .getWorldQuaternion() target is now required' );\\r\\n\\t\\t\\ttarget = new Quaternion();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.updateMatrixWorld( true );\\r\\n\\r\\n\\t\\tthis.matrixWorld.decompose( _position, target, _scale );\\r\\n\\r\\n\\t\\treturn target;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetWorldScale: function ( target ) {\\r\\n\\r\\n\\t\\tif ( target === undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Object3D: .getWorldScale() target is now required' );\\r\\n\\t\\t\\ttarget = new Vector3();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.updateMatrixWorld( true );\\r\\n\\r\\n\\t\\tthis.matrixWorld.decompose( _position, _quaternion$2, target );\\r\\n\\r\\n\\t\\treturn target;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetWorldDirection: function ( target ) {\\r\\n\\r\\n\\t\\tif ( target === undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Object3D: .getWorldDirection() target is now required' );\\r\\n\\t\\t\\ttarget = new Vector3();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.updateMatrixWorld( true );\\r\\n\\r\\n\\t\\tvar e = this.matrixWorld.elements;\\r\\n\\r\\n\\t\\treturn target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\traycast: function () {},\\r\\n\\r\\n\\ttraverse: function ( callback ) {\\r\\n\\r\\n\\t\\tcallback( this );\\r\\n\\r\\n\\t\\tvar children = this.children;\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\tchildren[ i ].traverse( callback );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttraverseVisible: function ( callback ) {\\r\\n\\r\\n\\t\\tif ( this.visible === false ) return;\\r\\n\\r\\n\\t\\tcallback( this );\\r\\n\\r\\n\\t\\tvar children = this.children;\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\tchildren[ i ].traverseVisible( callback );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttraverseAncestors: function ( callback ) {\\r\\n\\r\\n\\t\\tvar parent = this.parent;\\r\\n\\r\\n\\t\\tif ( parent !== null ) {\\r\\n\\r\\n\\t\\t\\tcallback( parent );\\r\\n\\r\\n\\t\\t\\tparent.traverseAncestors( callback );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tupdateMatrix: function () {\\r\\n\\r\\n\\t\\tthis.matrix.compose( this.position, this.quaternion, this.scale );\\r\\n\\r\\n\\t\\tthis.matrixWorldNeedsUpdate = true;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tupdateMatrixWorld: function ( force ) {\\r\\n\\r\\n\\t\\tif ( this.matrixAutoUpdate ) this.updateMatrix();\\r\\n\\r\\n\\t\\tif ( this.matrixWorldNeedsUpdate || force ) {\\r\\n\\r\\n\\t\\t\\tif ( this.parent === null ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.matrixWorld.copy( this.matrix );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.matrixWorldNeedsUpdate = false;\\r\\n\\r\\n\\t\\t\\tforce = true;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// update children\\r\\n\\r\\n\\t\\tvar children = this.children;\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\tchildren[ i ].updateMatrixWorld( force );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tupdateWorldMatrix: function ( updateParents, updateChildren ) {\\r\\n\\r\\n\\t\\tvar parent = this.parent;\\r\\n\\r\\n\\t\\tif ( updateParents === true && parent !== null ) {\\r\\n\\r\\n\\t\\t\\tparent.updateWorldMatrix( true, false );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( this.matrixAutoUpdate ) this.updateMatrix();\\r\\n\\r\\n\\t\\tif ( this.parent === null ) {\\r\\n\\r\\n\\t\\t\\tthis.matrixWorld.copy( this.matrix );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// update children\\r\\n\\r\\n\\t\\tif ( updateChildren === true ) {\\r\\n\\r\\n\\t\\t\\tvar children = this.children;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tchildren[ i ].updateWorldMatrix( false, true );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttoJSON: function ( meta ) {\\r\\n\\r\\n\\t\\t// meta is a string when called from JSON.stringify\\r\\n\\t\\tvar isRootObject = ( meta === undefined || typeof meta === 'string' );\\r\\n\\r\\n\\t\\tvar output = {};\\r\\n\\r\\n\\t\\t// meta is a hash used to collect geometries, materials.\\r\\n\\t\\t// not providing it implies that this is the root object\\r\\n\\t\\t// being serialized.\\r\\n\\t\\tif ( isRootObject ) {\\r\\n\\r\\n\\t\\t\\t// initialize meta obj\\r\\n\\t\\t\\tmeta = {\\r\\n\\t\\t\\t\\tgeometries: {},\\r\\n\\t\\t\\t\\tmaterials: {},\\r\\n\\t\\t\\t\\ttextures: {},\\r\\n\\t\\t\\t\\timages: {},\\r\\n\\t\\t\\t\\tshapes: {}\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\toutput.metadata = {\\r\\n\\t\\t\\t\\tversion: 4.5,\\r\\n\\t\\t\\t\\ttype: 'Object',\\r\\n\\t\\t\\t\\tgenerator: 'Object3D.toJSON'\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// standard Object3D serialization\\r\\n\\r\\n\\t\\tvar object = {};\\r\\n\\r\\n\\t\\tobject.uuid = this.uuid;\\r\\n\\t\\tobject.type = this.type;\\r\\n\\r\\n\\t\\tif ( this.name !== '' ) object.name = this.name;\\r\\n\\t\\tif ( this.castShadow === true ) object.castShadow = true;\\r\\n\\t\\tif ( this.receiveShadow === true ) object.receiveShadow = true;\\r\\n\\t\\tif ( this.visible === false ) object.visible = false;\\r\\n\\t\\tif ( this.frustumCulled === false ) object.frustumCulled = false;\\r\\n\\t\\tif ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;\\r\\n\\t\\tif ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;\\r\\n\\r\\n\\t\\tobject.layers = this.layers.mask;\\r\\n\\t\\tobject.matrix = this.matrix.toArray();\\r\\n\\r\\n\\t\\tif ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;\\r\\n\\r\\n\\t\\t// object specific properties\\r\\n\\r\\n\\t\\tif ( this.isInstancedMesh ) {\\r\\n\\r\\n\\t\\t\\tobject.type = 'InstancedMesh';\\r\\n\\t\\t\\tobject.count = this.count;\\r\\n\\t\\t\\tobject.instanceMatrix = this.instanceMatrix.toJSON();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\tfunction serialize( library, element ) {\\r\\n\\r\\n\\t\\t\\tif ( library[ element.uuid ] === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tlibrary[ element.uuid ] = element.toJSON( meta );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn element.uuid;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( this.isMesh || this.isLine || this.isPoints ) {\\r\\n\\r\\n\\t\\t\\tobject.geometry = serialize( meta.geometries, this.geometry );\\r\\n\\r\\n\\t\\t\\tvar parameters = this.geometry.parameters;\\r\\n\\r\\n\\t\\t\\tif ( parameters !== undefined && parameters.shapes !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tvar shapes = parameters.shapes;\\r\\n\\r\\n\\t\\t\\t\\tif ( Array.isArray( shapes ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar shape = shapes[ i ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tserialize( meta.shapes, shape );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tserialize( meta.shapes, shapes );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( this.material !== undefined ) {\\r\\n\\r\\n\\t\\t\\tif ( Array.isArray( this.material ) ) {\\r\\n\\r\\n\\t\\t\\t\\tvar uuids = [];\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, l = this.material.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tuuids.push( serialize( meta.materials, this.material[ i ] ) );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tobject.material = uuids;\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tobject.material = serialize( meta.materials, this.material );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\tif ( this.children.length > 0 ) {\\r\\n\\r\\n\\t\\t\\tobject.children = [];\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < this.children.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tobject.children.push( this.children[ i ].toJSON( meta ).object );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( isRootObject ) {\\r\\n\\r\\n\\t\\t\\tvar geometries = extractFromCache( meta.geometries );\\r\\n\\t\\t\\tvar materials = extractFromCache( meta.materials );\\r\\n\\t\\t\\tvar textures = extractFromCache( meta.textures );\\r\\n\\t\\t\\tvar images = extractFromCache( meta.images );\\r\\n\\t\\t\\tvar shapes = extractFromCache( meta.shapes );\\r\\n\\r\\n\\t\\t\\tif ( geometries.length > 0 ) output.geometries = geometries;\\r\\n\\t\\t\\tif ( materials.length > 0 ) output.materials = materials;\\r\\n\\t\\t\\tif ( textures.length > 0 ) output.textures = textures;\\r\\n\\t\\t\\tif ( images.length > 0 ) output.images = images;\\r\\n\\t\\t\\tif ( shapes.length > 0 ) output.shapes = shapes;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\toutput.object = object;\\r\\n\\r\\n\\t\\treturn output;\\r\\n\\r\\n\\t\\t// extract data from the cache hash\\r\\n\\t\\t// remove metadata on each item\\r\\n\\t\\t// and return as array\\r\\n\\t\\tfunction extractFromCache( cache ) {\\r\\n\\r\\n\\t\\t\\tvar values = [];\\r\\n\\t\\t\\tfor ( var key in cache ) {\\r\\n\\r\\n\\t\\t\\t\\tvar data = cache[ key ];\\r\\n\\t\\t\\t\\tdelete data.metadata;\\r\\n\\t\\t\\t\\tvalues.push( data );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn values;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclone: function ( recursive ) {\\r\\n\\r\\n\\t\\treturn new this.constructor().copy( this, recursive );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcopy: function ( source, recursive ) {\\r\\n\\r\\n\\t\\tif ( recursive === undefined ) recursive = true;\\r\\n\\r\\n\\t\\tthis.name = source.name;\\r\\n\\r\\n\\t\\tthis.up.copy( source.up );\\r\\n\\r\\n\\t\\tthis.position.copy( source.position );\\r\\n\\t\\tthis.quaternion.copy( source.quaternion );\\r\\n\\t\\tthis.scale.copy( source.scale );\\r\\n\\r\\n\\t\\tthis.matrix.copy( source.matrix );\\r\\n\\t\\tthis.matrixWorld.copy( source.matrixWorld );\\r\\n\\r\\n\\t\\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\\r\\n\\t\\tthis.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\\r\\n\\r\\n\\t\\tthis.layers.mask = source.layers.mask;\\r\\n\\t\\tthis.visible = source.visible;\\r\\n\\r\\n\\t\\tthis.castShadow = source.castShadow;\\r\\n\\t\\tthis.receiveShadow = source.receiveShadow;\\r\\n\\r\\n\\t\\tthis.frustumCulled = source.frustumCulled;\\r\\n\\t\\tthis.renderOrder = source.renderOrder;\\r\\n\\r\\n\\t\\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\\r\\n\\r\\n\\t\\tif ( recursive === true ) {\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < source.children.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar child = source.children[ i ];\\r\\n\\t\\t\\t\\tthis.add( child.clone() );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nfunction Scene() {\\r\\n\\r\\n\\tObject3D.call( this );\\r\\n\\r\\n\\tthis.type = 'Scene';\\r\\n\\r\\n\\tthis.background = null;\\r\\n\\tthis.environment = null;\\r\\n\\tthis.fog = null;\\r\\n\\r\\n\\tthis.overrideMaterial = null;\\r\\n\\r\\n\\tthis.autoUpdate = true; // checked by the renderer\\r\\n\\r\\n\\tif ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {\\r\\n\\r\\n\\t\\t__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) ); // eslint-disable-line no-undef\\r\\n\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\\r\\nScene.prototype = Object.assign( Object.create( Object3D.prototype ), {\\r\\n\\r\\n\\tconstructor: Scene,\\r\\n\\r\\n\\tisScene: true,\\r\\n\\r\\n\\tcopy: function ( source, recursive ) {\\r\\n\\r\\n\\t\\tObject3D.prototype.copy.call( this, source, recursive );\\r\\n\\r\\n\\t\\tif ( source.background !== null ) this.background = source.background.clone();\\r\\n\\t\\tif ( source.environment !== null ) this.environment = source.environment.clone();\\r\\n\\t\\tif ( source.fog !== null ) this.fog = source.fog.clone();\\r\\n\\r\\n\\t\\tif ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();\\r\\n\\r\\n\\t\\tthis.autoUpdate = source.autoUpdate;\\r\\n\\t\\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttoJSON: function ( meta ) {\\r\\n\\r\\n\\t\\tvar data = Object3D.prototype.toJSON.call( this, meta );\\r\\n\\r\\n\\t\\tif ( this.background !== null ) data.object.background = this.background.toJSON( meta );\\r\\n\\t\\tif ( this.environment !== null ) data.object.environment = this.environment.toJSON( meta );\\r\\n\\t\\tif ( this.fog !== null ) data.object.fog = this.fog.toJSON();\\r\\n\\r\\n\\t\\treturn data;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tdispose: function () {\\r\\n\\r\\n\\t\\tthis.dispatchEvent( { type: 'dispose' } );\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nvar _points = [\\r\\n\\tnew Vector3(),\\r\\n\\tnew Vector3(),\\r\\n\\tnew Vector3(),\\r\\n\\tnew Vector3(),\\r\\n\\tnew Vector3(),\\r\\n\\tnew Vector3(),\\r\\n\\tnew Vector3(),\\r\\n\\tnew Vector3()\\r\\n];\\r\\n\\r\\nvar _vector$1 = new Vector3();\\r\\n\\r\\nvar _box = new Box3();\\r\\n\\r\\n// triangle centered vertices\\r\\n\\r\\nvar _v0 = new Vector3();\\r\\nvar _v1$2 = new Vector3();\\r\\nvar _v2 = new Vector3();\\r\\n\\r\\n// triangle edge vectors\\r\\n\\r\\nvar _f0 = new Vector3();\\r\\nvar _f1 = new Vector3();\\r\\nvar _f2 = new Vector3();\\r\\n\\r\\nvar _center = new Vector3();\\r\\nvar _extents = new Vector3();\\r\\nvar _triangleNormal = new Vector3();\\r\\nvar _testAxis = new Vector3();\\r\\n\\r\\n/**\\r\\n * @author bhouston / http://clara.io\\r\\n * @author WestLangley / http://github.com/WestLangley\\r\\n */\\r\\n\\r\\nfunction Box3( min, max ) {\\r\\n\\r\\n\\tthis.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );\\r\\n\\tthis.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );\\r\\n\\r\\n}\\r\\n\\r\\n\\r\\nObject.assign( Box3.prototype, {\\r\\n\\r\\n\\tisBox3: true,\\r\\n\\r\\n\\tset: function ( min, max ) {\\r\\n\\r\\n\\t\\tthis.min.copy( min );\\r\\n\\t\\tthis.max.copy( max );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetFromArray: function ( array ) {\\r\\n\\r\\n\\t\\tvar minX = + Infinity;\\r\\n\\t\\tvar minY = + Infinity;\\r\\n\\t\\tvar minZ = + Infinity;\\r\\n\\r\\n\\t\\tvar maxX = - Infinity;\\r\\n\\t\\tvar maxY = - Infinity;\\r\\n\\t\\tvar maxZ = - Infinity;\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\\r\\n\\r\\n\\t\\t\\tvar x = array[ i ];\\r\\n\\t\\t\\tvar y = array[ i + 1 ];\\r\\n\\t\\t\\tvar z = array[ i + 2 ];\\r\\n\\r\\n\\t\\t\\tif ( x < minX ) minX = x;\\r\\n\\t\\t\\tif ( y < minY ) minY = y;\\r\\n\\t\\t\\tif ( z < minZ ) minZ = z;\\r\\n\\r\\n\\t\\t\\tif ( x > maxX ) maxX = x;\\r\\n\\t\\t\\tif ( y > maxY ) maxY = y;\\r\\n\\t\\t\\tif ( z > maxZ ) maxZ = z;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.min.set( minX, minY, minZ );\\r\\n\\t\\tthis.max.set( maxX, maxY, maxZ );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetFromBufferAttribute: function ( attribute ) {\\r\\n\\r\\n\\t\\tvar minX = + Infinity;\\r\\n\\t\\tvar minY = + Infinity;\\r\\n\\t\\tvar minZ = + Infinity;\\r\\n\\r\\n\\t\\tvar maxX = - Infinity;\\r\\n\\t\\tvar maxY = - Infinity;\\r\\n\\t\\tvar maxZ = - Infinity;\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = attribute.count; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar x = attribute.getX( i );\\r\\n\\t\\t\\tvar y = attribute.getY( i );\\r\\n\\t\\t\\tvar z = attribute.getZ( i );\\r\\n\\r\\n\\t\\t\\tif ( x < minX ) minX = x;\\r\\n\\t\\t\\tif ( y < minY ) minY = y;\\r\\n\\t\\t\\tif ( z < minZ ) minZ = z;\\r\\n\\r\\n\\t\\t\\tif ( x > maxX ) maxX = x;\\r\\n\\t\\t\\tif ( y > maxY ) maxY = y;\\r\\n\\t\\t\\tif ( z > maxZ ) maxZ = z;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.min.set( minX, minY, minZ );\\r\\n\\t\\tthis.max.set( maxX, maxY, maxZ );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetFromPoints: function ( points ) {\\r\\n\\r\\n\\t\\tthis.makeEmpty();\\r\\n\\r\\n\\t\\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\tthis.expandByPoint( points[ i ] );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetFromCenterAndSize: function ( center, size ) {\\r\\n\\r\\n\\t\\tvar halfSize = _vector$1.copy( size ).multiplyScalar( 0.5 );\\r\\n\\r\\n\\t\\tthis.min.copy( center ).sub( halfSize );\\r\\n\\t\\tthis.max.copy( center ).add( halfSize );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetFromObject: function ( object ) {\\r\\n\\r\\n\\t\\tthis.makeEmpty();\\r\\n\\r\\n\\t\\treturn this.expandByObject( object );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclone: function () {\\r\\n\\r\\n\\t\\treturn new this.constructor().copy( this );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcopy: function ( box ) {\\r\\n\\r\\n\\t\\tthis.min.copy( box.min );\\r\\n\\t\\tthis.max.copy( box.max );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tmakeEmpty: function () {\\r\\n\\r\\n\\t\\tthis.min.x = this.min.y = this.min.z = + Infinity;\\r\\n\\t\\tthis.max.x = this.max.y = this.max.z = - Infinity;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tisEmpty: function () {\\r\\n\\r\\n\\t\\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\\r\\n\\r\\n\\t\\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetCenter: function ( target ) {\\r\\n\\r\\n\\t\\tif ( target === undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Box3: .getCenter() target is now required' );\\r\\n\\t\\t\\ttarget = new Vector3();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetSize: function ( target ) {\\r\\n\\r\\n\\t\\tif ( target === undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Box3: .getSize() target is now required' );\\r\\n\\t\\t\\ttarget = new Vector3();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\texpandByPoint: function ( point ) {\\r\\n\\r\\n\\t\\tthis.min.min( point );\\r\\n\\t\\tthis.max.max( point );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\texpandByVector: function ( vector ) {\\r\\n\\r\\n\\t\\tthis.min.sub( vector );\\r\\n\\t\\tthis.max.add( vector );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\texpandByScalar: function ( scalar ) {\\r\\n\\r\\n\\t\\tthis.min.addScalar( - scalar );\\r\\n\\t\\tthis.max.addScalar( scalar );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\texpandByObject: function ( object ) {\\r\\n\\r\\n\\t\\t// Computes the world-axis-aligned bounding box of an object (including its children),\\r\\n\\t\\t// accounting for both the object's, and children's, world transforms\\r\\n\\r\\n\\t\\tobject.updateWorldMatrix( false, false );\\r\\n\\r\\n\\t\\tvar geometry = object.geometry;\\r\\n\\r\\n\\t\\tif ( geometry !== undefined ) {\\r\\n\\r\\n\\t\\t\\tif ( geometry.boundingBox === null ) {\\r\\n\\r\\n\\t\\t\\t\\tgeometry.computeBoundingBox();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t_box.copy( geometry.boundingBox );\\r\\n\\t\\t\\t_box.applyMatrix4( object.matrixWorld );\\r\\n\\r\\n\\t\\t\\tthis.union( _box );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar children = object.children;\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\tthis.expandByObject( children[ i ] );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcontainsPoint: function ( point ) {\\r\\n\\r\\n\\t\\treturn point.x < this.min.x || point.x > this.max.x ||\\r\\n\\t\\t\\tpoint.y < this.min.y || point.y > this.max.y ||\\r\\n\\t\\t\\tpoint.z < this.min.z || point.z > this.max.z ? false : true;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcontainsBox: function ( box ) {\\r\\n\\r\\n\\t\\treturn this.min.x <= box.min.x && box.max.x <= this.max.x &&\\r\\n\\t\\t\\tthis.min.y <= box.min.y && box.max.y <= this.max.y &&\\r\\n\\t\\t\\tthis.min.z <= box.min.z && box.max.z <= this.max.z;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetParameter: function ( point, target ) {\\r\\n\\r\\n\\t\\t// This can potentially have a divide by zero if the box\\r\\n\\t\\t// has a size dimension of 0.\\r\\n\\r\\n\\t\\tif ( target === undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Box3: .getParameter() target is now required' );\\r\\n\\t\\t\\ttarget = new Vector3();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn target.set(\\r\\n\\t\\t\\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\\r\\n\\t\\t\\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\\r\\n\\t\\t\\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\\r\\n\\t\\t);\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tintersectsBox: function ( box ) {\\r\\n\\r\\n\\t\\t// using 6 splitting planes to rule out intersections.\\r\\n\\t\\treturn box.max.x < this.min.x || box.min.x > this.max.x ||\\r\\n\\t\\t\\tbox.max.y < this.min.y || box.min.y > this.max.y ||\\r\\n\\t\\t\\tbox.max.z < this.min.z || box.min.z > this.max.z ? false : true;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tintersectsSphere: function ( sphere ) {\\r\\n\\r\\n\\t\\t// Find the point on the AABB closest to the sphere center.\\r\\n\\t\\tthis.clampPoint( sphere.center, _vector$1 );\\r\\n\\r\\n\\t\\t// If that point is inside the sphere, the AABB and sphere intersect.\\r\\n\\t\\treturn _vector$1.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tintersectsPlane: function ( plane ) {\\r\\n\\r\\n\\t\\t// We compute the minimum and maximum dot product values. If those values\\r\\n\\t\\t// are on the same side (back or front) of the plane, then there is no intersection.\\r\\n\\r\\n\\t\\tvar min, max;\\r\\n\\r\\n\\t\\tif ( plane.normal.x > 0 ) {\\r\\n\\r\\n\\t\\t\\tmin = plane.normal.x * this.min.x;\\r\\n\\t\\t\\tmax = plane.normal.x * this.max.x;\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tmin = plane.normal.x * this.max.x;\\r\\n\\t\\t\\tmax = plane.normal.x * this.min.x;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( plane.normal.y > 0 ) {\\r\\n\\r\\n\\t\\t\\tmin += plane.normal.y * this.min.y;\\r\\n\\t\\t\\tmax += plane.normal.y * this.max.y;\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tmin += plane.normal.y * this.max.y;\\r\\n\\t\\t\\tmax += plane.normal.y * this.min.y;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( plane.normal.z > 0 ) {\\r\\n\\r\\n\\t\\t\\tmin += plane.normal.z * this.min.z;\\r\\n\\t\\t\\tmax += plane.normal.z * this.max.z;\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tmin += plane.normal.z * this.max.z;\\r\\n\\t\\t\\tmax += plane.normal.z * this.min.z;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn ( min <= - plane.constant && max >= - plane.constant );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tintersectsTriangle: function ( triangle ) {\\r\\n\\r\\n\\t\\tif ( this.isEmpty() ) {\\r\\n\\r\\n\\t\\t\\treturn false;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// compute box center and extents\\r\\n\\t\\tthis.getCenter( _center );\\r\\n\\t\\t_extents.subVectors( this.max, _center );\\r\\n\\r\\n\\t\\t// translate triangle to aabb origin\\r\\n\\t\\t_v0.subVectors( triangle.a, _center );\\r\\n\\t\\t_v1$2.subVectors( triangle.b, _center );\\r\\n\\t\\t_v2.subVectors( triangle.c, _center );\\r\\n\\r\\n\\t\\t// compute edge vectors for triangle\\r\\n\\t\\t_f0.subVectors( _v1$2, _v0 );\\r\\n\\t\\t_f1.subVectors( _v2, _v1$2 );\\r\\n\\t\\t_f2.subVectors( _v0, _v2 );\\r\\n\\r\\n\\t\\t// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb\\r\\n\\t\\t// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation\\r\\n\\t\\t// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)\\r\\n\\t\\tvar axes = [\\r\\n\\t\\t\\t0, - _f0.z, _f0.y, 0, - _f1.z, _f1.y, 0, - _f2.z, _f2.y,\\r\\n\\t\\t\\t_f0.z, 0, - _f0.x, _f1.z, 0, - _f1.x, _f2.z, 0, - _f2.x,\\r\\n\\t\\t\\t- _f0.y, _f0.x, 0, - _f1.y, _f1.x, 0, - _f2.y, _f2.x, 0\\r\\n\\t\\t];\\r\\n\\t\\tif ( ! satForAxes( axes, _v0, _v1$2, _v2, _extents ) ) {\\r\\n\\r\\n\\t\\t\\treturn false;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// test 3 face normals from the aabb\\r\\n\\t\\taxes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];\\r\\n\\t\\tif ( ! satForAxes( axes, _v0, _v1$2, _v2, _extents ) ) {\\r\\n\\r\\n\\t\\t\\treturn false;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// finally testing the face normal of the triangle\\r\\n\\t\\t// use already existing triangle edge vectors here\\r\\n\\t\\t_triangleNormal.crossVectors( _f0, _f1 );\\r\\n\\t\\taxes = [ _triangleNormal.x, _triangleNormal.y, _triangleNormal.z ];\\r\\n\\r\\n\\t\\treturn satForAxes( axes, _v0, _v1$2, _v2, _extents );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclampPoint: function ( point, target ) {\\r\\n\\r\\n\\t\\tif ( target === undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Box3: .clampPoint() target is now required' );\\r\\n\\t\\t\\ttarget = new Vector3();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn target.copy( point ).clamp( this.min, this.max );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tdistanceToPoint: function ( point ) {\\r\\n\\r\\n\\t\\tvar clampedPoint = _vector$1.copy( point ).clamp( this.min, this.max );\\r\\n\\r\\n\\t\\treturn clampedPoint.sub( point ).length();\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetBoundingSphere: function ( target ) {\\r\\n\\r\\n\\t\\tif ( target === undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.error( 'THREE.Box3: .getBoundingSphere() target is now required' );\\r\\n\\t\\t\\t//target = new Sphere(); // removed to avoid cyclic dependency\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.getCenter( target.center );\\r\\n\\r\\n\\t\\ttarget.radius = this.getSize( _vector$1 ).length() * 0.5;\\r\\n\\r\\n\\t\\treturn target;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tintersect: function ( box ) {\\r\\n\\r\\n\\t\\tthis.min.max( box.min );\\r\\n\\t\\tthis.max.min( box.max );\\r\\n\\r\\n\\t\\t// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\\r\\n\\t\\tif ( this.isEmpty() ) this.makeEmpty();\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tunion: function ( box ) {\\r\\n\\r\\n\\t\\tthis.min.min( box.min );\\r\\n\\t\\tthis.max.max( box.max );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tapplyMatrix4: function ( matrix ) {\\r\\n\\r\\n\\t\\t// transform of empty box is an empty box.\\r\\n\\t\\tif ( this.isEmpty() ) return this;\\r\\n\\r\\n\\t\\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\\r\\n\\t\\t_points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\\r\\n\\t\\t_points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\\r\\n\\t\\t_points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\\r\\n\\t\\t_points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\\r\\n\\t\\t_points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\\r\\n\\t\\t_points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\\r\\n\\t\\t_points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\\r\\n\\t\\t_points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111\\r\\n\\r\\n\\t\\tthis.setFromPoints( _points );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttranslate: function ( offset ) {\\r\\n\\r\\n\\t\\tthis.min.add( offset );\\r\\n\\t\\tthis.max.add( offset );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tequals: function ( box ) {\\r\\n\\r\\n\\t\\treturn box.min.equals( this.min ) && box.max.equals( this.max );\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nfunction satForAxes( axes, v0, v1, v2, extents ) {\\r\\n\\r\\n\\tvar i, j;\\r\\n\\r\\n\\tfor ( i = 0, j = axes.length - 3; i <= j; i += 3 ) {\\r\\n\\r\\n\\t\\t_testAxis.fromArray( axes, i );\\r\\n\\t\\t// project the aabb onto the seperating axis\\r\\n\\t\\tvar r = extents.x * Math.abs( _testAxis.x ) + extents.y * Math.abs( _testAxis.y ) + extents.z * Math.abs( _testAxis.z );\\r\\n\\t\\t// project all 3 vertices of the triangle onto the seperating axis\\r\\n\\t\\tvar p0 = v0.dot( _testAxis );\\r\\n\\t\\tvar p1 = v1.dot( _testAxis );\\r\\n\\t\\tvar p2 = v2.dot( _testAxis );\\r\\n\\t\\t// actual test, basically see if either of the most extreme of the triangle points intersects r\\r\\n\\t\\tif ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {\\r\\n\\r\\n\\t\\t\\t// points of the projected triangle are outside the projected half-length of the aabb\\r\\n\\t\\t\\t// the axis is seperating and we can exit\\r\\n\\t\\t\\treturn false;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn true;\\r\\n\\r\\n}\\r\\n\\r\\nvar _box$1 = new Box3();\\r\\n\\r\\n/**\\r\\n * @author bhouston / http://clara.io\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nfunction Sphere( center, radius ) {\\r\\n\\r\\n\\tthis.center = ( center !== undefined ) ? center : new Vector3();\\r\\n\\tthis.radius = ( radius !== undefined ) ? radius : - 1;\\r\\n\\r\\n}\\r\\n\\r\\nObject.assign( Sphere.prototype, {\\r\\n\\r\\n\\tset: function ( center, radius ) {\\r\\n\\r\\n\\t\\tthis.center.copy( center );\\r\\n\\t\\tthis.radius = radius;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetFromPoints: function ( points, optionalCenter ) {\\r\\n\\r\\n\\t\\tvar center = this.center;\\r\\n\\r\\n\\t\\tif ( optionalCenter !== undefined ) {\\r\\n\\r\\n\\t\\t\\tcenter.copy( optionalCenter );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t_box$1.setFromPoints( points ).getCenter( center );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar maxRadiusSq = 0;\\r\\n\\r\\n\\t\\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.radius = Math.sqrt( maxRadiusSq );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclone: function () {\\r\\n\\r\\n\\t\\treturn new this.constructor().copy( this );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcopy: function ( sphere ) {\\r\\n\\r\\n\\t\\tthis.center.copy( sphere.center );\\r\\n\\t\\tthis.radius = sphere.radius;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tisEmpty: function () {\\r\\n\\r\\n\\t\\treturn ( this.radius < 0 );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tmakeEmpty: function () {\\r\\n\\r\\n\\t\\tthis.center.set( 0, 0, 0 );\\r\\n\\t\\tthis.radius = - 1;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcontainsPoint: function ( point ) {\\r\\n\\r\\n\\t\\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tdistanceToPoint: function ( point ) {\\r\\n\\r\\n\\t\\treturn ( point.distanceTo( this.center ) - this.radius );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tintersectsSphere: function ( sphere ) {\\r\\n\\r\\n\\t\\tvar radiusSum = this.radius + sphere.radius;\\r\\n\\r\\n\\t\\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tintersectsBox: function ( box ) {\\r\\n\\r\\n\\t\\treturn box.intersectsSphere( this );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tintersectsPlane: function ( plane ) {\\r\\n\\r\\n\\t\\treturn Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclampPoint: function ( point, target ) {\\r\\n\\r\\n\\t\\tvar deltaLengthSq = this.center.distanceToSquared( point );\\r\\n\\r\\n\\t\\tif ( target === undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Sphere: .clampPoint() target is now required' );\\r\\n\\t\\t\\ttarget = new Vector3();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\ttarget.copy( point );\\r\\n\\r\\n\\t\\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\\r\\n\\r\\n\\t\\t\\ttarget.sub( this.center ).normalize();\\r\\n\\t\\t\\ttarget.multiplyScalar( this.radius ).add( this.center );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn target;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetBoundingBox: function ( target ) {\\r\\n\\r\\n\\t\\tif ( target === undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Sphere: .getBoundingBox() target is now required' );\\r\\n\\t\\t\\ttarget = new Box3();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( this.isEmpty() ) {\\r\\n\\r\\n\\t\\t\\t// Empty sphere produces empty bounding box\\r\\n\\t\\t\\ttarget.makeEmpty();\\r\\n\\t\\t\\treturn target;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\ttarget.set( this.center, this.center );\\r\\n\\t\\ttarget.expandByScalar( this.radius );\\r\\n\\r\\n\\t\\treturn target;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tapplyMatrix4: function ( matrix ) {\\r\\n\\r\\n\\t\\tthis.center.applyMatrix4( matrix );\\r\\n\\t\\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttranslate: function ( offset ) {\\r\\n\\r\\n\\t\\tthis.center.add( offset );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tequals: function ( sphere ) {\\r\\n\\r\\n\\t\\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nvar _vector$2 = new Vector3();\\r\\nvar _segCenter = new Vector3();\\r\\nvar _segDir = new Vector3();\\r\\nvar _diff = new Vector3();\\r\\n\\r\\nvar _edge1 = new Vector3();\\r\\nvar _edge2 = new Vector3();\\r\\nvar _normal = new Vector3();\\r\\n\\r\\n/**\\r\\n * @author bhouston / http://clara.io\\r\\n */\\r\\n\\r\\nfunction Ray( origin, direction ) {\\r\\n\\r\\n\\tthis.origin = ( origin !== undefined ) ? origin : new Vector3();\\r\\n\\tthis.direction = ( direction !== undefined ) ? direction : new Vector3( 0, 0, - 1 );\\r\\n\\r\\n}\\r\\n\\r\\nObject.assign( Ray.prototype, {\\r\\n\\r\\n\\tset: function ( origin, direction ) {\\r\\n\\r\\n\\t\\tthis.origin.copy( origin );\\r\\n\\t\\tthis.direction.copy( direction );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclone: function () {\\r\\n\\r\\n\\t\\treturn new this.constructor().copy( this );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcopy: function ( ray ) {\\r\\n\\r\\n\\t\\tthis.origin.copy( ray.origin );\\r\\n\\t\\tthis.direction.copy( ray.direction );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tat: function ( t, target ) {\\r\\n\\r\\n\\t\\tif ( target === undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Ray: .at() target is now required' );\\r\\n\\t\\t\\ttarget = new Vector3();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn target.copy( this.direction ).multiplyScalar( t ).add( this.origin );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tlookAt: function ( v ) {\\r\\n\\r\\n\\t\\tthis.direction.copy( v ).sub( this.origin ).normalize();\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\trecast: function ( t ) {\\r\\n\\r\\n\\t\\tthis.origin.copy( this.at( t, _vector$2 ) );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclosestPointToPoint: function ( point, target ) {\\r\\n\\r\\n\\t\\tif ( target === undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Ray: .closestPointToPoint() target is now required' );\\r\\n\\t\\t\\ttarget = new Vector3();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\ttarget.subVectors( point, this.origin );\\r\\n\\r\\n\\t\\tvar directionDistance = target.dot( this.direction );\\r\\n\\r\\n\\t\\tif ( directionDistance < 0 ) {\\r\\n\\r\\n\\t\\t\\treturn target.copy( this.origin );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn target.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tdistanceToPoint: function ( point ) {\\r\\n\\r\\n\\t\\treturn Math.sqrt( this.distanceSqToPoint( point ) );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tdistanceSqToPoint: function ( point ) {\\r\\n\\r\\n\\t\\tvar directionDistance = _vector$2.subVectors( point, this.origin ).dot( this.direction );\\r\\n\\r\\n\\t\\t// point behind the ray\\r\\n\\r\\n\\t\\tif ( directionDistance < 0 ) {\\r\\n\\r\\n\\t\\t\\treturn this.origin.distanceToSquared( point );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t_vector$2.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\\r\\n\\r\\n\\t\\treturn _vector$2.distanceToSquared( point );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tdistanceSqToSegment: function ( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\\r\\n\\r\\n\\t\\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h\\r\\n\\t\\t// It returns the min distance between the ray and the segment\\r\\n\\t\\t// defined by v0 and v1\\r\\n\\t\\t// It can also set two optional targets :\\r\\n\\t\\t// - The closest point on the ray\\r\\n\\t\\t// - The closest point on the segment\\r\\n\\r\\n\\t\\t_segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\\r\\n\\t\\t_segDir.copy( v1 ).sub( v0 ).normalize();\\r\\n\\t\\t_diff.copy( this.origin ).sub( _segCenter );\\r\\n\\r\\n\\t\\tvar segExtent = v0.distanceTo( v1 ) * 0.5;\\r\\n\\t\\tvar a01 = - this.direction.dot( _segDir );\\r\\n\\t\\tvar b0 = _diff.dot( this.direction );\\r\\n\\t\\tvar b1 = - _diff.dot( _segDir );\\r\\n\\t\\tvar c = _diff.lengthSq();\\r\\n\\t\\tvar det = Math.abs( 1 - a01 * a01 );\\r\\n\\t\\tvar s0, s1, sqrDist, extDet;\\r\\n\\r\\n\\t\\tif ( det > 0 ) {\\r\\n\\r\\n\\t\\t\\t// The ray and segment are not parallel.\\r\\n\\r\\n\\t\\t\\ts0 = a01 * b1 - b0;\\r\\n\\t\\t\\ts1 = a01 * b0 - b1;\\r\\n\\t\\t\\textDet = segExtent * det;\\r\\n\\r\\n\\t\\t\\tif ( s0 >= 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( s1 >= - extDet ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( s1 <= extDet ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// region 0\\r\\n\\t\\t\\t\\t\\t\\t// Minimum at interior points of ray and segment.\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar invDet = 1 / det;\\r\\n\\t\\t\\t\\t\\t\\ts0 *= invDet;\\r\\n\\t\\t\\t\\t\\t\\ts1 *= invDet;\\r\\n\\t\\t\\t\\t\\t\\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// region 1\\r\\n\\r\\n\\t\\t\\t\\t\\t\\ts1 = segExtent;\\r\\n\\t\\t\\t\\t\\t\\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\\r\\n\\t\\t\\t\\t\\t\\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t// region 5\\r\\n\\r\\n\\t\\t\\t\\t\\ts1 = - segExtent;\\r\\n\\t\\t\\t\\t\\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\\r\\n\\t\\t\\t\\t\\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tif ( s1 <= - extDet ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// region 4\\r\\n\\r\\n\\t\\t\\t\\t\\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\\r\\n\\t\\t\\t\\t\\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\\r\\n\\t\\t\\t\\t\\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\\r\\n\\r\\n\\t\\t\\t\\t} else if ( s1 <= extDet ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// region 3\\r\\n\\r\\n\\t\\t\\t\\t\\ts0 = 0;\\r\\n\\t\\t\\t\\t\\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\\r\\n\\t\\t\\t\\t\\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t// region 2\\r\\n\\r\\n\\t\\t\\t\\t\\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\\r\\n\\t\\t\\t\\t\\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\\r\\n\\t\\t\\t\\t\\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t// Ray and segment are parallel.\\r\\n\\r\\n\\t\\t\\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\\r\\n\\t\\t\\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\\r\\n\\t\\t\\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( optionalPointOnRay ) {\\r\\n\\r\\n\\t\\t\\toptionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( optionalPointOnSegment ) {\\r\\n\\r\\n\\t\\t\\toptionalPointOnSegment.copy( _segDir ).multiplyScalar( s1 ).add( _segCenter );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn sqrDist;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tintersectSphere: function ( sphere, target ) {\\r\\n\\r\\n\\t\\t_vector$2.subVectors( sphere.center, this.origin );\\r\\n\\t\\tvar tca = _vector$2.dot( this.direction );\\r\\n\\t\\tvar d2 = _vector$2.dot( _vector$2 ) - tca * tca;\\r\\n\\t\\tvar radius2 = sphere.radius * sphere.radius;\\r\\n\\r\\n\\t\\tif ( d2 > radius2 ) return null;\\r\\n\\r\\n\\t\\tvar thc = Math.sqrt( radius2 - d2 );\\r\\n\\r\\n\\t\\t// t0 = first intersect point - entrance on front of sphere\\r\\n\\t\\tvar t0 = tca - thc;\\r\\n\\r\\n\\t\\t// t1 = second intersect point - exit point on back of sphere\\r\\n\\t\\tvar t1 = tca + thc;\\r\\n\\r\\n\\t\\t// test to see if both t0 and t1 are behind the ray - if so, return null\\r\\n\\t\\tif ( t0 < 0 && t1 < 0 ) return null;\\r\\n\\r\\n\\t\\t// test to see if t0 is behind the ray:\\r\\n\\t\\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\\r\\n\\t\\t// in order to always return an intersect point that is in front of the ray.\\r\\n\\t\\tif ( t0 < 0 ) return this.at( t1, target );\\r\\n\\r\\n\\t\\t// else t0 is in front of the ray, so return the first collision point scaled by t0\\r\\n\\t\\treturn this.at( t0, target );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tintersectsSphere: function ( sphere ) {\\r\\n\\r\\n\\t\\treturn this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tdistanceToPlane: function ( plane ) {\\r\\n\\r\\n\\t\\tvar denominator = plane.normal.dot( this.direction );\\r\\n\\r\\n\\t\\tif ( denominator === 0 ) {\\r\\n\\r\\n\\t\\t\\t// line is coplanar, return origin\\r\\n\\t\\t\\tif ( plane.distanceToPoint( this.origin ) === 0 ) {\\r\\n\\r\\n\\t\\t\\t\\treturn 0;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// Null is preferable to undefined since undefined means.... it is undefined\\r\\n\\r\\n\\t\\t\\treturn null;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\\r\\n\\r\\n\\t\\t// Return if the ray never intersects the plane\\r\\n\\r\\n\\t\\treturn t >= 0 ? t : null;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tintersectPlane: function ( plane, target ) {\\r\\n\\r\\n\\t\\tvar t = this.distanceToPlane( plane );\\r\\n\\r\\n\\t\\tif ( t === null ) {\\r\\n\\r\\n\\t\\t\\treturn null;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this.at( t, target );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tintersectsPlane: function ( plane ) {\\r\\n\\r\\n\\t\\t// check if the ray lies on the plane first\\r\\n\\r\\n\\t\\tvar distToPoint = plane.distanceToPoint( this.origin );\\r\\n\\r\\n\\t\\tif ( distToPoint === 0 ) {\\r\\n\\r\\n\\t\\t\\treturn true;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar denominator = plane.normal.dot( this.direction );\\r\\n\\r\\n\\t\\tif ( denominator * distToPoint < 0 ) {\\r\\n\\r\\n\\t\\t\\treturn true;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// ray origin is behind the plane (and is pointing behind it)\\r\\n\\r\\n\\t\\treturn false;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tintersectBox: function ( box, target ) {\\r\\n\\r\\n\\t\\tvar tmin, tmax, tymin, tymax, tzmin, tzmax;\\r\\n\\r\\n\\t\\tvar invdirx = 1 / this.direction.x,\\r\\n\\t\\t\\tinvdiry = 1 / this.direction.y,\\r\\n\\t\\t\\tinvdirz = 1 / this.direction.z;\\r\\n\\r\\n\\t\\tvar origin = this.origin;\\r\\n\\r\\n\\t\\tif ( invdirx >= 0 ) {\\r\\n\\r\\n\\t\\t\\ttmin = ( box.min.x - origin.x ) * invdirx;\\r\\n\\t\\t\\ttmax = ( box.max.x - origin.x ) * invdirx;\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\ttmin = ( box.max.x - origin.x ) * invdirx;\\r\\n\\t\\t\\ttmax = ( box.min.x - origin.x ) * invdirx;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( invdiry >= 0 ) {\\r\\n\\r\\n\\t\\t\\ttymin = ( box.min.y - origin.y ) * invdiry;\\r\\n\\t\\t\\ttymax = ( box.max.y - origin.y ) * invdiry;\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\ttymin = ( box.max.y - origin.y ) * invdiry;\\r\\n\\t\\t\\ttymax = ( box.min.y - origin.y ) * invdiry;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\\r\\n\\r\\n\\t\\t// These lines also handle the case where tmin or tmax is NaN\\r\\n\\t\\t// (result of 0 * Infinity). x !== x returns true if x is NaN\\r\\n\\r\\n\\t\\tif ( tymin > tmin || tmin !== tmin ) tmin = tymin;\\r\\n\\r\\n\\t\\tif ( tymax < tmax || tmax !== tmax ) tmax = tymax;\\r\\n\\r\\n\\t\\tif ( invdirz >= 0 ) {\\r\\n\\r\\n\\t\\t\\ttzmin = ( box.min.z - origin.z ) * invdirz;\\r\\n\\t\\t\\ttzmax = ( box.max.z - origin.z ) * invdirz;\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\ttzmin = ( box.max.z - origin.z ) * invdirz;\\r\\n\\t\\t\\ttzmax = ( box.min.z - origin.z ) * invdirz;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\\r\\n\\r\\n\\t\\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\\r\\n\\r\\n\\t\\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\\r\\n\\r\\n\\t\\t//return point closest to the ray (positive side)\\r\\n\\r\\n\\t\\tif ( tmax < 0 ) return null;\\r\\n\\r\\n\\t\\treturn this.at( tmin >= 0 ? tmin : tmax, target );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tintersectsBox: function ( box ) {\\r\\n\\r\\n\\t\\treturn this.intersectBox( box, _vector$2 ) !== null;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tintersectTriangle: function ( a, b, c, backfaceCulling, target ) {\\r\\n\\r\\n\\t\\t// Compute the offset origin, edges, and normal.\\r\\n\\r\\n\\t\\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\\r\\n\\r\\n\\t\\t_edge1.subVectors( b, a );\\r\\n\\t\\t_edge2.subVectors( c, a );\\r\\n\\t\\t_normal.crossVectors( _edge1, _edge2 );\\r\\n\\r\\n\\t\\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\\r\\n\\t\\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\\r\\n\\t\\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\\r\\n\\t\\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\\r\\n\\t\\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\\r\\n\\t\\tvar DdN = this.direction.dot( _normal );\\r\\n\\t\\tvar sign;\\r\\n\\r\\n\\t\\tif ( DdN > 0 ) {\\r\\n\\r\\n\\t\\t\\tif ( backfaceCulling ) return null;\\r\\n\\t\\t\\tsign = 1;\\r\\n\\r\\n\\t\\t} else if ( DdN < 0 ) {\\r\\n\\r\\n\\t\\t\\tsign = - 1;\\r\\n\\t\\t\\tDdN = - DdN;\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\treturn null;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t_diff.subVectors( this.origin, a );\\r\\n\\t\\tvar DdQxE2 = sign * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) );\\r\\n\\r\\n\\t\\t// b1 < 0, no intersection\\r\\n\\t\\tif ( DdQxE2 < 0 ) {\\r\\n\\r\\n\\t\\t\\treturn null;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar DdE1xQ = sign * this.direction.dot( _edge1.cross( _diff ) );\\r\\n\\r\\n\\t\\t// b2 < 0, no intersection\\r\\n\\t\\tif ( DdE1xQ < 0 ) {\\r\\n\\r\\n\\t\\t\\treturn null;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// b1+b2 > 1, no intersection\\r\\n\\t\\tif ( DdQxE2 + DdE1xQ > DdN ) {\\r\\n\\r\\n\\t\\t\\treturn null;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Line intersects triangle, check if ray does.\\r\\n\\t\\tvar QdN = - sign * _diff.dot( _normal );\\r\\n\\r\\n\\t\\t// t < 0, no intersection\\r\\n\\t\\tif ( QdN < 0 ) {\\r\\n\\r\\n\\t\\t\\treturn null;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Ray intersects triangle.\\r\\n\\t\\treturn this.at( QdN / DdN, target );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tapplyMatrix4: function ( matrix4 ) {\\r\\n\\r\\n\\t\\tthis.origin.applyMatrix4( matrix4 );\\r\\n\\t\\tthis.direction.transformDirection( matrix4 );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tequals: function ( ray ) {\\r\\n\\r\\n\\t\\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author bhouston / http://clara.io\\r\\n */\\r\\n\\r\\nvar _vector1 = new Vector3();\\r\\nvar _vector2 = new Vector3();\\r\\nvar _normalMatrix = new Matrix3();\\r\\n\\r\\nfunction Plane( normal, constant ) {\\r\\n\\r\\n\\t// normal is assumed to be normalized\\r\\n\\r\\n\\tthis.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );\\r\\n\\tthis.constant = ( constant !== undefined ) ? constant : 0;\\r\\n\\r\\n}\\r\\n\\r\\nObject.assign( Plane.prototype, {\\r\\n\\r\\n\\tisPlane: true,\\r\\n\\r\\n\\tset: function ( normal, constant ) {\\r\\n\\r\\n\\t\\tthis.normal.copy( normal );\\r\\n\\t\\tthis.constant = constant;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetComponents: function ( x, y, z, w ) {\\r\\n\\r\\n\\t\\tthis.normal.set( x, y, z );\\r\\n\\t\\tthis.constant = w;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetFromNormalAndCoplanarPoint: function ( normal, point ) {\\r\\n\\r\\n\\t\\tthis.normal.copy( normal );\\r\\n\\t\\tthis.constant = - point.dot( this.normal );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetFromCoplanarPoints: function ( a, b, c ) {\\r\\n\\r\\n\\t\\tvar normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize();\\r\\n\\r\\n\\t\\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\\r\\n\\r\\n\\t\\tthis.setFromNormalAndCoplanarPoint( normal, a );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclone: function () {\\r\\n\\r\\n\\t\\treturn new this.constructor().copy( this );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcopy: function ( plane ) {\\r\\n\\r\\n\\t\\tthis.normal.copy( plane.normal );\\r\\n\\t\\tthis.constant = plane.constant;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tnormalize: function () {\\r\\n\\r\\n\\t\\t// Note: will lead to a divide by zero if the plane is invalid.\\r\\n\\r\\n\\t\\tvar inverseNormalLength = 1.0 / this.normal.length();\\r\\n\\t\\tthis.normal.multiplyScalar( inverseNormalLength );\\r\\n\\t\\tthis.constant *= inverseNormalLength;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tnegate: function () {\\r\\n\\r\\n\\t\\tthis.constant *= - 1;\\r\\n\\t\\tthis.normal.negate();\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tdistanceToPoint: function ( point ) {\\r\\n\\r\\n\\t\\treturn this.normal.dot( point ) + this.constant;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tdistanceToSphere: function ( sphere ) {\\r\\n\\r\\n\\t\\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tprojectPoint: function ( point, target ) {\\r\\n\\r\\n\\t\\tif ( target === undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Plane: .projectPoint() target is now required' );\\r\\n\\t\\t\\ttarget = new Vector3();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tintersectLine: function ( line, target ) {\\r\\n\\r\\n\\t\\tif ( target === undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Plane: .intersectLine() target is now required' );\\r\\n\\t\\t\\ttarget = new Vector3();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar direction = line.delta( _vector1 );\\r\\n\\r\\n\\t\\tvar denominator = this.normal.dot( direction );\\r\\n\\r\\n\\t\\tif ( denominator === 0 ) {\\r\\n\\r\\n\\t\\t\\t// line is coplanar, return origin\\r\\n\\t\\t\\tif ( this.distanceToPoint( line.start ) === 0 ) {\\r\\n\\r\\n\\t\\t\\t\\treturn target.copy( line.start );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// Unsure if this is the correct method to handle this case.\\r\\n\\t\\t\\treturn undefined;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\\r\\n\\r\\n\\t\\tif ( t < 0 || t > 1 ) {\\r\\n\\r\\n\\t\\t\\treturn undefined;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn target.copy( direction ).multiplyScalar( t ).add( line.start );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tintersectsLine: function ( line ) {\\r\\n\\r\\n\\t\\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\\r\\n\\r\\n\\t\\tvar startSign = this.distanceToPoint( line.start );\\r\\n\\t\\tvar endSign = this.distanceToPoint( line.end );\\r\\n\\r\\n\\t\\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tintersectsBox: function ( box ) {\\r\\n\\r\\n\\t\\treturn box.intersectsPlane( this );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tintersectsSphere: function ( sphere ) {\\r\\n\\r\\n\\t\\treturn sphere.intersectsPlane( this );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcoplanarPoint: function ( target ) {\\r\\n\\r\\n\\t\\tif ( target === undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Plane: .coplanarPoint() target is now required' );\\r\\n\\t\\t\\ttarget = new Vector3();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn target.copy( this.normal ).multiplyScalar( - this.constant );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tapplyMatrix4: function ( matrix, optionalNormalMatrix ) {\\r\\n\\r\\n\\t\\tvar normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );\\r\\n\\r\\n\\t\\tvar referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );\\r\\n\\r\\n\\t\\tvar normal = this.normal.applyMatrix3( normalMatrix ).normalize();\\r\\n\\r\\n\\t\\tthis.constant = - referencePoint.dot( normal );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttranslate: function ( offset ) {\\r\\n\\r\\n\\t\\tthis.constant -= offset.dot( this.normal );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tequals: function ( plane ) {\\r\\n\\r\\n\\t\\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author bhouston / http://clara.io\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nvar _v0$1 = new Vector3();\\r\\nvar _v1$3 = new Vector3();\\r\\nvar _v2$1 = new Vector3();\\r\\nvar _v3 = new Vector3();\\r\\n\\r\\nvar _vab = new Vector3();\\r\\nvar _vac = new Vector3();\\r\\nvar _vbc = new Vector3();\\r\\nvar _vap = new Vector3();\\r\\nvar _vbp = new Vector3();\\r\\nvar _vcp = new Vector3();\\r\\n\\r\\nfunction Triangle( a, b, c ) {\\r\\n\\r\\n\\tthis.a = ( a !== undefined ) ? a : new Vector3();\\r\\n\\tthis.b = ( b !== undefined ) ? b : new Vector3();\\r\\n\\tthis.c = ( c !== undefined ) ? c : new Vector3();\\r\\n\\r\\n}\\r\\n\\r\\nObject.assign( Triangle, {\\r\\n\\r\\n\\tgetNormal: function ( a, b, c, target ) {\\r\\n\\r\\n\\t\\tif ( target === undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Triangle: .getNormal() target is now required' );\\r\\n\\t\\t\\ttarget = new Vector3();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\ttarget.subVectors( c, b );\\r\\n\\t\\t_v0$1.subVectors( a, b );\\r\\n\\t\\ttarget.cross( _v0$1 );\\r\\n\\r\\n\\t\\tvar targetLengthSq = target.lengthSq();\\r\\n\\t\\tif ( targetLengthSq > 0 ) {\\r\\n\\r\\n\\t\\t\\treturn target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn target.set( 0, 0, 0 );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// static/instance method to calculate barycentric coordinates\\r\\n\\t// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\\r\\n\\tgetBarycoord: function ( point, a, b, c, target ) {\\r\\n\\r\\n\\t\\t_v0$1.subVectors( c, a );\\r\\n\\t\\t_v1$3.subVectors( b, a );\\r\\n\\t\\t_v2$1.subVectors( point, a );\\r\\n\\r\\n\\t\\tvar dot00 = _v0$1.dot( _v0$1 );\\r\\n\\t\\tvar dot01 = _v0$1.dot( _v1$3 );\\r\\n\\t\\tvar dot02 = _v0$1.dot( _v2$1 );\\r\\n\\t\\tvar dot11 = _v1$3.dot( _v1$3 );\\r\\n\\t\\tvar dot12 = _v1$3.dot( _v2$1 );\\r\\n\\r\\n\\t\\tvar denom = ( dot00 * dot11 - dot01 * dot01 );\\r\\n\\r\\n\\t\\tif ( target === undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Triangle: .getBarycoord() target is now required' );\\r\\n\\t\\t\\ttarget = new Vector3();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// collinear or singular triangle\\r\\n\\t\\tif ( denom === 0 ) {\\r\\n\\r\\n\\t\\t\\t// arbitrary location outside of triangle?\\r\\n\\t\\t\\t// not sure if this is the best idea, maybe should be returning undefined\\r\\n\\t\\t\\treturn target.set( - 2, - 1, - 1 );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar invDenom = 1 / denom;\\r\\n\\t\\tvar u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\\r\\n\\t\\tvar v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\\r\\n\\r\\n\\t\\t// barycentric coordinates must always sum to 1\\r\\n\\t\\treturn target.set( 1 - u - v, v, u );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcontainsPoint: function ( point, a, b, c ) {\\r\\n\\r\\n\\t\\tTriangle.getBarycoord( point, a, b, c, _v3 );\\r\\n\\r\\n\\t\\treturn ( _v3.x >= 0 ) && ( _v3.y >= 0 ) && ( ( _v3.x + _v3.y ) <= 1 );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetUV: function ( point, p1, p2, p3, uv1, uv2, uv3, target ) {\\r\\n\\r\\n\\t\\tthis.getBarycoord( point, p1, p2, p3, _v3 );\\r\\n\\r\\n\\t\\ttarget.set( 0, 0 );\\r\\n\\t\\ttarget.addScaledVector( uv1, _v3.x );\\r\\n\\t\\ttarget.addScaledVector( uv2, _v3.y );\\r\\n\\t\\ttarget.addScaledVector( uv3, _v3.z );\\r\\n\\r\\n\\t\\treturn target;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tisFrontFacing: function ( a, b, c, direction ) {\\r\\n\\r\\n\\t\\t_v0$1.subVectors( c, b );\\r\\n\\t\\t_v1$3.subVectors( a, b );\\r\\n\\r\\n\\t\\t// strictly front facing\\r\\n\\t\\treturn ( _v0$1.cross( _v1$3 ).dot( direction ) < 0 ) ? true : false;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nObject.assign( Triangle.prototype, {\\r\\n\\r\\n\\tset: function ( a, b, c ) {\\r\\n\\r\\n\\t\\tthis.a.copy( a );\\r\\n\\t\\tthis.b.copy( b );\\r\\n\\t\\tthis.c.copy( c );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetFromPointsAndIndices: function ( points, i0, i1, i2 ) {\\r\\n\\r\\n\\t\\tthis.a.copy( points[ i0 ] );\\r\\n\\t\\tthis.b.copy( points[ i1 ] );\\r\\n\\t\\tthis.c.copy( points[ i2 ] );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclone: function () {\\r\\n\\r\\n\\t\\treturn new this.constructor().copy( this );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcopy: function ( triangle ) {\\r\\n\\r\\n\\t\\tthis.a.copy( triangle.a );\\r\\n\\t\\tthis.b.copy( triangle.b );\\r\\n\\t\\tthis.c.copy( triangle.c );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetArea: function () {\\r\\n\\r\\n\\t\\t_v0$1.subVectors( this.c, this.b );\\r\\n\\t\\t_v1$3.subVectors( this.a, this.b );\\r\\n\\r\\n\\t\\treturn _v0$1.cross( _v1$3 ).length() * 0.5;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetMidpoint: function ( target ) {\\r\\n\\r\\n\\t\\tif ( target === undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Triangle: .getMidpoint() target is now required' );\\r\\n\\t\\t\\ttarget = new Vector3();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetNormal: function ( target ) {\\r\\n\\r\\n\\t\\treturn Triangle.getNormal( this.a, this.b, this.c, target );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetPlane: function ( target ) {\\r\\n\\r\\n\\t\\tif ( target === undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Triangle: .getPlane() target is now required' );\\r\\n\\t\\t\\ttarget = new Plane();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn target.setFromCoplanarPoints( this.a, this.b, this.c );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetBarycoord: function ( point, target ) {\\r\\n\\r\\n\\t\\treturn Triangle.getBarycoord( point, this.a, this.b, this.c, target );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetUV: function ( point, uv1, uv2, uv3, target ) {\\r\\n\\r\\n\\t\\treturn Triangle.getUV( point, this.a, this.b, this.c, uv1, uv2, uv3, target );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcontainsPoint: function ( point ) {\\r\\n\\r\\n\\t\\treturn Triangle.containsPoint( point, this.a, this.b, this.c );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tisFrontFacing: function ( direction ) {\\r\\n\\r\\n\\t\\treturn Triangle.isFrontFacing( this.a, this.b, this.c, direction );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tintersectsBox: function ( box ) {\\r\\n\\r\\n\\t\\treturn box.intersectsTriangle( this );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclosestPointToPoint: function ( p, target ) {\\r\\n\\r\\n\\t\\tif ( target === undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Triangle: .closestPointToPoint() target is now required' );\\r\\n\\t\\t\\ttarget = new Vector3();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar a = this.a, b = this.b, c = this.c;\\r\\n\\t\\tvar v, w;\\r\\n\\r\\n\\t\\t// algorithm thanks to Real-Time Collision Detection by Christer Ericson,\\r\\n\\t\\t// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,\\r\\n\\t\\t// under the accompanying license; see chapter 5.1.5 for detailed explanation.\\r\\n\\t\\t// basically, we're distinguishing which of the voronoi regions of the triangle\\r\\n\\t\\t// the point lies in with the minimum amount of redundant computation.\\r\\n\\r\\n\\t\\t_vab.subVectors( b, a );\\r\\n\\t\\t_vac.subVectors( c, a );\\r\\n\\t\\t_vap.subVectors( p, a );\\r\\n\\t\\tvar d1 = _vab.dot( _vap );\\r\\n\\t\\tvar d2 = _vac.dot( _vap );\\r\\n\\t\\tif ( d1 <= 0 && d2 <= 0 ) {\\r\\n\\r\\n\\t\\t\\t// vertex region of A; barycentric coords (1, 0, 0)\\r\\n\\t\\t\\treturn target.copy( a );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t_vbp.subVectors( p, b );\\r\\n\\t\\tvar d3 = _vab.dot( _vbp );\\r\\n\\t\\tvar d4 = _vac.dot( _vbp );\\r\\n\\t\\tif ( d3 >= 0 && d4 <= d3 ) {\\r\\n\\r\\n\\t\\t\\t// vertex region of B; barycentric coords (0, 1, 0)\\r\\n\\t\\t\\treturn target.copy( b );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar vc = d1 * d4 - d3 * d2;\\r\\n\\t\\tif ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {\\r\\n\\r\\n\\t\\t\\tv = d1 / ( d1 - d3 );\\r\\n\\t\\t\\t// edge region of AB; barycentric coords (1-v, v, 0)\\r\\n\\t\\t\\treturn target.copy( a ).addScaledVector( _vab, v );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t_vcp.subVectors( p, c );\\r\\n\\t\\tvar d5 = _vab.dot( _vcp );\\r\\n\\t\\tvar d6 = _vac.dot( _vcp );\\r\\n\\t\\tif ( d6 >= 0 && d5 <= d6 ) {\\r\\n\\r\\n\\t\\t\\t// vertex region of C; barycentric coords (0, 0, 1)\\r\\n\\t\\t\\treturn target.copy( c );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar vb = d5 * d2 - d1 * d6;\\r\\n\\t\\tif ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {\\r\\n\\r\\n\\t\\t\\tw = d2 / ( d2 - d6 );\\r\\n\\t\\t\\t// edge region of AC; barycentric coords (1-w, 0, w)\\r\\n\\t\\t\\treturn target.copy( a ).addScaledVector( _vac, w );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar va = d3 * d6 - d5 * d4;\\r\\n\\t\\tif ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {\\r\\n\\r\\n\\t\\t\\t_vbc.subVectors( c, b );\\r\\n\\t\\t\\tw = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );\\r\\n\\t\\t\\t// edge region of BC; barycentric coords (0, 1-w, w)\\r\\n\\t\\t\\treturn target.copy( b ).addScaledVector( _vbc, w ); // edge region of BC\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// face region\\r\\n\\t\\tvar denom = 1 / ( va + vb + vc );\\r\\n\\t\\t// u = va * denom\\r\\n\\t\\tv = vb * denom;\\r\\n\\t\\tw = vc * denom;\\r\\n\\r\\n\\t\\treturn target.copy( a ).addScaledVector( _vab, v ).addScaledVector( _vac, w );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tequals: function ( triangle ) {\\r\\n\\r\\n\\t\\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nvar _colorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\\r\\n\\t'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\\r\\n\\t'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\\r\\n\\t'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\\r\\n\\t'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\\r\\n\\t'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\\r\\n\\t'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\\r\\n\\t'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\\r\\n\\t'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\\r\\n\\t'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\\r\\n\\t'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\\r\\n\\t'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\\r\\n\\t'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\\r\\n\\t'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\\r\\n\\t'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\\r\\n\\t'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\\r\\n\\t'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\\r\\n\\t'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\\r\\n\\t'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\\r\\n\\t'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\\r\\n\\t'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\\r\\n\\t'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\\r\\n\\t'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\\r\\n\\t'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\\r\\n\\r\\nvar _hslA = { h: 0, s: 0, l: 0 };\\r\\nvar _hslB = { h: 0, s: 0, l: 0 };\\r\\n\\r\\nfunction Color( r, g, b ) {\\r\\n\\r\\n\\tif ( g === undefined && b === undefined ) {\\r\\n\\r\\n\\t\\t// r is THREE.Color, hex or string\\r\\n\\t\\treturn this.set( r );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn this.setRGB( r, g, b );\\r\\n\\r\\n}\\r\\n\\r\\nfunction hue2rgb( p, q, t ) {\\r\\n\\r\\n\\tif ( t < 0 ) t += 1;\\r\\n\\tif ( t > 1 ) t -= 1;\\r\\n\\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\\r\\n\\tif ( t < 1 / 2 ) return q;\\r\\n\\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\\r\\n\\treturn p;\\r\\n\\r\\n}\\r\\n\\r\\nfunction SRGBToLinear( c ) {\\r\\n\\r\\n\\treturn ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );\\r\\n\\r\\n}\\r\\n\\r\\nfunction LinearToSRGB( c ) {\\r\\n\\r\\n\\treturn ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;\\r\\n\\r\\n}\\r\\n\\r\\nObject.assign( Color.prototype, {\\r\\n\\r\\n\\tisColor: true,\\r\\n\\r\\n\\tr: 1, g: 1, b: 1,\\r\\n\\r\\n\\tset: function ( value ) {\\r\\n\\r\\n\\t\\tif ( value && value.isColor ) {\\r\\n\\r\\n\\t\\t\\tthis.copy( value );\\r\\n\\r\\n\\t\\t} else if ( typeof value === 'number' ) {\\r\\n\\r\\n\\t\\t\\tthis.setHex( value );\\r\\n\\r\\n\\t\\t} else if ( typeof value === 'string' ) {\\r\\n\\r\\n\\t\\t\\tthis.setStyle( value );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetScalar: function ( scalar ) {\\r\\n\\r\\n\\t\\tthis.r = scalar;\\r\\n\\t\\tthis.g = scalar;\\r\\n\\t\\tthis.b = scalar;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetHex: function ( hex ) {\\r\\n\\r\\n\\t\\thex = Math.floor( hex );\\r\\n\\r\\n\\t\\tthis.r = ( hex >> 16 & 255 ) / 255;\\r\\n\\t\\tthis.g = ( hex >> 8 & 255 ) / 255;\\r\\n\\t\\tthis.b = ( hex & 255 ) / 255;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetRGB: function ( r, g, b ) {\\r\\n\\r\\n\\t\\tthis.r = r;\\r\\n\\t\\tthis.g = g;\\r\\n\\t\\tthis.b = b;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetHSL: function ( h, s, l ) {\\r\\n\\r\\n\\t\\t// h,s,l ranges are in 0.0 - 1.0\\r\\n\\t\\th = MathUtils.euclideanModulo( h, 1 );\\r\\n\\t\\ts = MathUtils.clamp( s, 0, 1 );\\r\\n\\t\\tl = MathUtils.clamp( l, 0, 1 );\\r\\n\\r\\n\\t\\tif ( s === 0 ) {\\r\\n\\r\\n\\t\\t\\tthis.r = this.g = this.b = l;\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tvar p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\\r\\n\\t\\t\\tvar q = ( 2 * l ) - p;\\r\\n\\r\\n\\t\\t\\tthis.r = hue2rgb( q, p, h + 1 / 3 );\\r\\n\\t\\t\\tthis.g = hue2rgb( q, p, h );\\r\\n\\t\\t\\tthis.b = hue2rgb( q, p, h - 1 / 3 );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetStyle: function ( style ) {\\r\\n\\r\\n\\t\\tfunction handleAlpha( string ) {\\r\\n\\r\\n\\t\\t\\tif ( string === undefined ) return;\\r\\n\\r\\n\\t\\t\\tif ( parseFloat( string ) < 1 ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\r\\n\\t\\tvar m;\\r\\n\\r\\n\\t\\tif ( m = /^((?:rgb|hsl)a?)\\\\(\\\\s*([^\\\\)]*)\\\\)/.exec( style ) ) {\\r\\n\\r\\n\\t\\t\\t// rgb / hsl\\r\\n\\r\\n\\t\\t\\tvar color;\\r\\n\\t\\t\\tvar name = m[ 1 ];\\r\\n\\t\\t\\tvar components = m[ 2 ];\\r\\n\\r\\n\\t\\t\\tswitch ( name ) {\\r\\n\\r\\n\\t\\t\\t\\tcase 'rgb':\\r\\n\\t\\t\\t\\tcase 'rgba':\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( color = /^(\\\\d+)\\\\s*,\\\\s*(\\\\d+)\\\\s*,\\\\s*(\\\\d+)\\\\s*(,\\\\s*([0-9]*\\\\.?[0-9]+)\\\\s*)?$/.exec( components ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// rgb(255,0,0) rgba(255,0,0,0.5)\\r\\n\\t\\t\\t\\t\\t\\tthis.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;\\r\\n\\t\\t\\t\\t\\t\\tthis.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;\\r\\n\\t\\t\\t\\t\\t\\tthis.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\thandleAlpha( color[ 5 ] );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( color = /^(\\\\d+)\\\\%\\\\s*,\\\\s*(\\\\d+)\\\\%\\\\s*,\\\\s*(\\\\d+)\\\\%\\\\s*(,\\\\s*([0-9]*\\\\.?[0-9]+)\\\\s*)?$/.exec( components ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\\r\\n\\t\\t\\t\\t\\t\\tthis.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;\\r\\n\\t\\t\\t\\t\\t\\tthis.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;\\r\\n\\t\\t\\t\\t\\t\\tthis.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\thandleAlpha( color[ 5 ] );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\tcase 'hsl':\\r\\n\\t\\t\\t\\tcase 'hsla':\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( color = /^([0-9]*\\\\.?[0-9]+)\\\\s*,\\\\s*(\\\\d+)\\\\%\\\\s*,\\\\s*(\\\\d+)\\\\%\\\\s*(,\\\\s*([0-9]*\\\\.?[0-9]+)\\\\s*)?$/.exec( components ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// hsl(120,50%,50%) hsla(120,50%,50%,0.5)\\r\\n\\t\\t\\t\\t\\t\\tvar h = parseFloat( color[ 1 ] ) / 360;\\r\\n\\t\\t\\t\\t\\t\\tvar s = parseInt( color[ 2 ], 10 ) / 100;\\r\\n\\t\\t\\t\\t\\t\\tvar l = parseInt( color[ 3 ], 10 ) / 100;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\thandleAlpha( color[ 5 ] );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\treturn this.setHSL( h, s, l );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t} else if ( m = /^\\\\#([A-Fa-f0-9]+)$/.exec( style ) ) {\\r\\n\\r\\n\\t\\t\\t// hex color\\r\\n\\r\\n\\t\\t\\tvar hex = m[ 1 ];\\r\\n\\t\\t\\tvar size = hex.length;\\r\\n\\r\\n\\t\\t\\tif ( size === 3 ) {\\r\\n\\r\\n\\t\\t\\t\\t// #ff0\\r\\n\\t\\t\\t\\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;\\r\\n\\t\\t\\t\\tthis.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;\\r\\n\\t\\t\\t\\tthis.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;\\r\\n\\r\\n\\t\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t\\t} else if ( size === 6 ) {\\r\\n\\r\\n\\t\\t\\t\\t// #ff0000\\r\\n\\t\\t\\t\\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;\\r\\n\\t\\t\\t\\tthis.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;\\r\\n\\t\\t\\t\\tthis.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;\\r\\n\\r\\n\\t\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( style && style.length > 0 ) {\\r\\n\\r\\n\\t\\t\\treturn this.setColorName( style );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetColorName: function ( style ) {\\r\\n\\r\\n\\t\\t// color keywords\\r\\n\\t\\tvar hex = _colorKeywords[ style ];\\r\\n\\r\\n\\t\\tif ( hex !== undefined ) {\\r\\n\\r\\n\\t\\t\\t// red\\r\\n\\t\\t\\tthis.setHex( hex );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t// unknown color\\r\\n\\t\\t\\tconsole.warn( 'THREE.Color: Unknown color ' + style );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclone: function () {\\r\\n\\r\\n\\t\\treturn new this.constructor( this.r, this.g, this.b );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcopy: function ( color ) {\\r\\n\\r\\n\\t\\tthis.r = color.r;\\r\\n\\t\\tthis.g = color.g;\\r\\n\\t\\tthis.b = color.b;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcopyGammaToLinear: function ( color, gammaFactor ) {\\r\\n\\r\\n\\t\\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\\r\\n\\r\\n\\t\\tthis.r = Math.pow( color.r, gammaFactor );\\r\\n\\t\\tthis.g = Math.pow( color.g, gammaFactor );\\r\\n\\t\\tthis.b = Math.pow( color.b, gammaFactor );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcopyLinearToGamma: function ( color, gammaFactor ) {\\r\\n\\r\\n\\t\\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\\r\\n\\r\\n\\t\\tvar safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;\\r\\n\\r\\n\\t\\tthis.r = Math.pow( color.r, safeInverse );\\r\\n\\t\\tthis.g = Math.pow( color.g, safeInverse );\\r\\n\\t\\tthis.b = Math.pow( color.b, safeInverse );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tconvertGammaToLinear: function ( gammaFactor ) {\\r\\n\\r\\n\\t\\tthis.copyGammaToLinear( this, gammaFactor );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tconvertLinearToGamma: function ( gammaFactor ) {\\r\\n\\r\\n\\t\\tthis.copyLinearToGamma( this, gammaFactor );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcopySRGBToLinear: function ( color ) {\\r\\n\\r\\n\\t\\tthis.r = SRGBToLinear( color.r );\\r\\n\\t\\tthis.g = SRGBToLinear( color.g );\\r\\n\\t\\tthis.b = SRGBToLinear( color.b );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcopyLinearToSRGB: function ( color ) {\\r\\n\\r\\n\\t\\tthis.r = LinearToSRGB( color.r );\\r\\n\\t\\tthis.g = LinearToSRGB( color.g );\\r\\n\\t\\tthis.b = LinearToSRGB( color.b );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tconvertSRGBToLinear: function () {\\r\\n\\r\\n\\t\\tthis.copySRGBToLinear( this );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tconvertLinearToSRGB: function () {\\r\\n\\r\\n\\t\\tthis.copyLinearToSRGB( this );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetHex: function () {\\r\\n\\r\\n\\t\\treturn ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetHexString: function () {\\r\\n\\r\\n\\t\\treturn ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetHSL: function ( target ) {\\r\\n\\r\\n\\t\\t// h,s,l ranges are in 0.0 - 1.0\\r\\n\\r\\n\\t\\tif ( target === undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Color: .getHSL() target is now required' );\\r\\n\\t\\t\\ttarget = { h: 0, s: 0, l: 0 };\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar r = this.r, g = this.g, b = this.b;\\r\\n\\r\\n\\t\\tvar max = Math.max( r, g, b );\\r\\n\\t\\tvar min = Math.min( r, g, b );\\r\\n\\r\\n\\t\\tvar hue, saturation;\\r\\n\\t\\tvar lightness = ( min + max ) / 2.0;\\r\\n\\r\\n\\t\\tif ( min === max ) {\\r\\n\\r\\n\\t\\t\\thue = 0;\\r\\n\\t\\t\\tsaturation = 0;\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tvar delta = max - min;\\r\\n\\r\\n\\t\\t\\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\\r\\n\\r\\n\\t\\t\\tswitch ( max ) {\\r\\n\\r\\n\\t\\t\\t\\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\\r\\n\\t\\t\\t\\tcase g: hue = ( b - r ) / delta + 2; break;\\r\\n\\t\\t\\t\\tcase b: hue = ( r - g ) / delta + 4; break;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\thue /= 6;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\ttarget.h = hue;\\r\\n\\t\\ttarget.s = saturation;\\r\\n\\t\\ttarget.l = lightness;\\r\\n\\r\\n\\t\\treturn target;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetStyle: function () {\\r\\n\\r\\n\\t\\treturn 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\toffsetHSL: function ( h, s, l ) {\\r\\n\\r\\n\\t\\tthis.getHSL( _hslA );\\r\\n\\r\\n\\t\\t_hslA.h += h; _hslA.s += s; _hslA.l += l;\\r\\n\\r\\n\\t\\tthis.setHSL( _hslA.h, _hslA.s, _hslA.l );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tadd: function ( color ) {\\r\\n\\r\\n\\t\\tthis.r += color.r;\\r\\n\\t\\tthis.g += color.g;\\r\\n\\t\\tthis.b += color.b;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\taddColors: function ( color1, color2 ) {\\r\\n\\r\\n\\t\\tthis.r = color1.r + color2.r;\\r\\n\\t\\tthis.g = color1.g + color2.g;\\r\\n\\t\\tthis.b = color1.b + color2.b;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\taddScalar: function ( s ) {\\r\\n\\r\\n\\t\\tthis.r += s;\\r\\n\\t\\tthis.g += s;\\r\\n\\t\\tthis.b += s;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsub: function ( color ) {\\r\\n\\r\\n\\t\\tthis.r = Math.max( 0, this.r - color.r );\\r\\n\\t\\tthis.g = Math.max( 0, this.g - color.g );\\r\\n\\t\\tthis.b = Math.max( 0, this.b - color.b );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tmultiply: function ( color ) {\\r\\n\\r\\n\\t\\tthis.r *= color.r;\\r\\n\\t\\tthis.g *= color.g;\\r\\n\\t\\tthis.b *= color.b;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tmultiplyScalar: function ( s ) {\\r\\n\\r\\n\\t\\tthis.r *= s;\\r\\n\\t\\tthis.g *= s;\\r\\n\\t\\tthis.b *= s;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tlerp: function ( color, alpha ) {\\r\\n\\r\\n\\t\\tthis.r += ( color.r - this.r ) * alpha;\\r\\n\\t\\tthis.g += ( color.g - this.g ) * alpha;\\r\\n\\t\\tthis.b += ( color.b - this.b ) * alpha;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tlerpHSL: function ( color, alpha ) {\\r\\n\\r\\n\\t\\tthis.getHSL( _hslA );\\r\\n\\t\\tcolor.getHSL( _hslB );\\r\\n\\r\\n\\t\\tvar h = MathUtils.lerp( _hslA.h, _hslB.h, alpha );\\r\\n\\t\\tvar s = MathUtils.lerp( _hslA.s, _hslB.s, alpha );\\r\\n\\t\\tvar l = MathUtils.lerp( _hslA.l, _hslB.l, alpha );\\r\\n\\r\\n\\t\\tthis.setHSL( h, s, l );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tequals: function ( c ) {\\r\\n\\r\\n\\t\\treturn ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tfromArray: function ( array, offset ) {\\r\\n\\r\\n\\t\\tif ( offset === undefined ) offset = 0;\\r\\n\\r\\n\\t\\tthis.r = array[ offset ];\\r\\n\\t\\tthis.g = array[ offset + 1 ];\\r\\n\\t\\tthis.b = array[ offset + 2 ];\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttoArray: function ( array, offset ) {\\r\\n\\r\\n\\t\\tif ( array === undefined ) array = [];\\r\\n\\t\\tif ( offset === undefined ) offset = 0;\\r\\n\\r\\n\\t\\tarray[ offset ] = this.r;\\r\\n\\t\\tarray[ offset + 1 ] = this.g;\\r\\n\\t\\tarray[ offset + 2 ] = this.b;\\r\\n\\r\\n\\t\\treturn array;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttoJSON: function () {\\r\\n\\r\\n\\t\\treturn this.getHex();\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nColor.NAMES = _colorKeywords;\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n */\\r\\n\\r\\nfunction Face3( a, b, c, normal, color, materialIndex ) {\\r\\n\\r\\n\\tthis.a = a;\\r\\n\\tthis.b = b;\\r\\n\\tthis.c = c;\\r\\n\\r\\n\\tthis.normal = ( normal && normal.isVector3 ) ? normal : new Vector3();\\r\\n\\tthis.vertexNormals = Array.isArray( normal ) ? normal : [];\\r\\n\\r\\n\\tthis.color = ( color && color.isColor ) ? color : new Color();\\r\\n\\tthis.vertexColors = Array.isArray( color ) ? color : [];\\r\\n\\r\\n\\tthis.materialIndex = materialIndex !== undefined ? materialIndex : 0;\\r\\n\\r\\n}\\r\\n\\r\\nObject.assign( Face3.prototype, {\\r\\n\\r\\n\\tclone: function () {\\r\\n\\r\\n\\t\\treturn new this.constructor().copy( this );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\tthis.a = source.a;\\r\\n\\t\\tthis.b = source.b;\\r\\n\\t\\tthis.c = source.c;\\r\\n\\r\\n\\t\\tthis.normal.copy( source.normal );\\r\\n\\t\\tthis.color.copy( source.color );\\r\\n\\r\\n\\t\\tthis.materialIndex = source.materialIndex;\\r\\n\\r\\n\\t\\tfor ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\tthis.vertexNormals[ i ] = source.vertexNormals[ i ].clone();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfor ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\tthis.vertexColors[ i ] = source.vertexColors[ i ].clone();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n */\\r\\n\\r\\nvar materialId = 0;\\r\\n\\r\\nfunction Material() {\\r\\n\\r\\n\\tObject.defineProperty( this, 'id', { value: materialId ++ } );\\r\\n\\r\\n\\tthis.uuid = MathUtils.generateUUID();\\r\\n\\r\\n\\tthis.name = '';\\r\\n\\tthis.type = 'Material';\\r\\n\\r\\n\\tthis.fog = true;\\r\\n\\r\\n\\tthis.blending = NormalBlending;\\r\\n\\tthis.side = FrontSide;\\r\\n\\tthis.flatShading = false;\\r\\n\\tthis.vertexColors = false;\\r\\n\\r\\n\\tthis.opacity = 1;\\r\\n\\tthis.transparent = false;\\r\\n\\r\\n\\tthis.blendSrc = SrcAlphaFactor;\\r\\n\\tthis.blendDst = OneMinusSrcAlphaFactor;\\r\\n\\tthis.blendEquation = AddEquation;\\r\\n\\tthis.blendSrcAlpha = null;\\r\\n\\tthis.blendDstAlpha = null;\\r\\n\\tthis.blendEquationAlpha = null;\\r\\n\\r\\n\\tthis.depthFunc = LessEqualDepth;\\r\\n\\tthis.depthTest = true;\\r\\n\\tthis.depthWrite = true;\\r\\n\\r\\n\\tthis.stencilWriteMask = 0xff;\\r\\n\\tthis.stencilFunc = AlwaysStencilFunc;\\r\\n\\tthis.stencilRef = 0;\\r\\n\\tthis.stencilFuncMask = 0xff;\\r\\n\\tthis.stencilFail = KeepStencilOp;\\r\\n\\tthis.stencilZFail = KeepStencilOp;\\r\\n\\tthis.stencilZPass = KeepStencilOp;\\r\\n\\tthis.stencilWrite = false;\\r\\n\\r\\n\\tthis.clippingPlanes = null;\\r\\n\\tthis.clipIntersection = false;\\r\\n\\tthis.clipShadows = false;\\r\\n\\r\\n\\tthis.shadowSide = null;\\r\\n\\r\\n\\tthis.colorWrite = true;\\r\\n\\r\\n\\tthis.precision = null; // override the renderer's default precision for this material\\r\\n\\r\\n\\tthis.polygonOffset = false;\\r\\n\\tthis.polygonOffsetFactor = 0;\\r\\n\\tthis.polygonOffsetUnits = 0;\\r\\n\\r\\n\\tthis.dithering = false;\\r\\n\\r\\n\\tthis.alphaTest = 0;\\r\\n\\tthis.premultipliedAlpha = false;\\r\\n\\r\\n\\tthis.visible = true;\\r\\n\\r\\n\\tthis.toneMapped = true;\\r\\n\\r\\n\\tthis.userData = {};\\r\\n\\r\\n\\tthis.version = 0;\\r\\n\\r\\n}\\r\\n\\r\\nMaterial.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\\r\\n\\r\\n\\tconstructor: Material,\\r\\n\\r\\n\\tisMaterial: true,\\r\\n\\r\\n\\tonBeforeCompile: function () {},\\r\\n\\r\\n\\tsetValues: function ( values ) {\\r\\n\\r\\n\\t\\tif ( values === undefined ) return;\\r\\n\\r\\n\\t\\tfor ( var key in values ) {\\r\\n\\r\\n\\t\\t\\tvar newValue = values[ key ];\\r\\n\\r\\n\\t\\t\\tif ( newValue === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( \\\"THREE.Material: '\\\" + key + \\\"' parameter is undefined.\\\" );\\r\\n\\t\\t\\t\\tcontinue;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// for backward compatability if shading is set in the constructor\\r\\n\\t\\t\\tif ( key === 'shading' ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );\\r\\n\\t\\t\\t\\tthis.flatShading = ( newValue === FlatShading ) ? true : false;\\r\\n\\t\\t\\t\\tcontinue;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar currentValue = this[ key ];\\r\\n\\r\\n\\t\\t\\tif ( currentValue === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( \\\"THREE.\\\" + this.type + \\\": '\\\" + key + \\\"' is not a property of this material.\\\" );\\r\\n\\t\\t\\t\\tcontinue;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( currentValue && currentValue.isColor ) {\\r\\n\\r\\n\\t\\t\\t\\tcurrentValue.set( newValue );\\r\\n\\r\\n\\t\\t\\t} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {\\r\\n\\r\\n\\t\\t\\t\\tcurrentValue.copy( newValue );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tthis[ key ] = newValue;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttoJSON: function ( meta ) {\\r\\n\\r\\n\\t\\tvar isRoot = ( meta === undefined || typeof meta === 'string' );\\r\\n\\r\\n\\t\\tif ( isRoot ) {\\r\\n\\r\\n\\t\\t\\tmeta = {\\r\\n\\t\\t\\t\\ttextures: {},\\r\\n\\t\\t\\t\\timages: {}\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar data = {\\r\\n\\t\\t\\tmetadata: {\\r\\n\\t\\t\\t\\tversion: 4.5,\\r\\n\\t\\t\\t\\ttype: 'Material',\\r\\n\\t\\t\\t\\tgenerator: 'Material.toJSON'\\r\\n\\t\\t\\t}\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\t// standard Material serialization\\r\\n\\t\\tdata.uuid = this.uuid;\\r\\n\\t\\tdata.type = this.type;\\r\\n\\r\\n\\t\\tif ( this.name !== '' ) data.name = this.name;\\r\\n\\r\\n\\t\\tif ( this.color && this.color.isColor ) data.color = this.color.getHex();\\r\\n\\r\\n\\t\\tif ( this.roughness !== undefined ) data.roughness = this.roughness;\\r\\n\\t\\tif ( this.metalness !== undefined ) data.metalness = this.metalness;\\r\\n\\r\\n\\t\\tif ( this.sheen && this.sheen.isColor ) data.sheen = this.sheen.getHex();\\r\\n\\t\\tif ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();\\r\\n\\t\\tif ( this.emissiveIntensity && this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;\\r\\n\\r\\n\\t\\tif ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();\\r\\n\\t\\tif ( this.shininess !== undefined ) data.shininess = this.shininess;\\r\\n\\t\\tif ( this.clearcoat !== undefined ) data.clearcoat = this.clearcoat;\\r\\n\\t\\tif ( this.clearcoatRoughness !== undefined ) data.clearcoatRoughness = this.clearcoatRoughness;\\r\\n\\r\\n\\t\\tif ( this.clearcoatMap && this.clearcoatMap.isTexture ) {\\r\\n\\r\\n\\t\\t\\tdata.clearcoatMap = this.clearcoatMap.toJSON( meta ).uuid;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture ) {\\r\\n\\r\\n\\t\\t\\tdata.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON( meta ).uuid;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture ) {\\r\\n\\r\\n\\t\\t\\tdata.clearcoatNormalMap = this.clearcoatNormalMap.toJSON( meta ).uuid;\\r\\n\\t\\t\\tdata.clearcoatNormalScale = this.clearcoatNormalScale.toArray();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;\\r\\n\\t\\tif ( this.matcap && this.matcap.isTexture ) data.matcap = this.matcap.toJSON( meta ).uuid;\\r\\n\\t\\tif ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;\\r\\n\\t\\tif ( this.lightMap && this.lightMap.isTexture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;\\r\\n\\r\\n\\t\\tif ( this.aoMap && this.aoMap.isTexture ) {\\r\\n\\r\\n\\t\\t\\tdata.aoMap = this.aoMap.toJSON( meta ).uuid;\\r\\n\\t\\t\\tdata.aoMapIntensity = this.aoMapIntensity;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( this.bumpMap && this.bumpMap.isTexture ) {\\r\\n\\r\\n\\t\\t\\tdata.bumpMap = this.bumpMap.toJSON( meta ).uuid;\\r\\n\\t\\t\\tdata.bumpScale = this.bumpScale;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( this.normalMap && this.normalMap.isTexture ) {\\r\\n\\r\\n\\t\\t\\tdata.normalMap = this.normalMap.toJSON( meta ).uuid;\\r\\n\\t\\t\\tdata.normalMapType = this.normalMapType;\\r\\n\\t\\t\\tdata.normalScale = this.normalScale.toArray();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( this.displacementMap && this.displacementMap.isTexture ) {\\r\\n\\r\\n\\t\\t\\tdata.displacementMap = this.displacementMap.toJSON( meta ).uuid;\\r\\n\\t\\t\\tdata.displacementScale = this.displacementScale;\\r\\n\\t\\t\\tdata.displacementBias = this.displacementBias;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;\\r\\n\\t\\tif ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;\\r\\n\\r\\n\\t\\tif ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;\\r\\n\\t\\tif ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;\\r\\n\\r\\n\\t\\tif ( this.envMap && this.envMap.isTexture ) {\\r\\n\\r\\n\\t\\t\\tdata.envMap = this.envMap.toJSON( meta ).uuid;\\r\\n\\t\\t\\tdata.reflectivity = this.reflectivity; // Scale behind envMap\\r\\n\\t\\t\\tdata.refractionRatio = this.refractionRatio;\\r\\n\\r\\n\\t\\t\\tif ( this.combine !== undefined ) data.combine = this.combine;\\r\\n\\t\\t\\tif ( this.envMapIntensity !== undefined ) data.envMapIntensity = this.envMapIntensity;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( this.gradientMap && this.gradientMap.isTexture ) {\\r\\n\\r\\n\\t\\t\\tdata.gradientMap = this.gradientMap.toJSON( meta ).uuid;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( this.size !== undefined ) data.size = this.size;\\r\\n\\t\\tif ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;\\r\\n\\r\\n\\t\\tif ( this.blending !== NormalBlending ) data.blending = this.blending;\\r\\n\\t\\tif ( this.flatShading === true ) data.flatShading = this.flatShading;\\r\\n\\t\\tif ( this.side !== FrontSide ) data.side = this.side;\\r\\n\\t\\tif ( this.vertexColors ) data.vertexColors = true;\\r\\n\\r\\n\\t\\tif ( this.opacity < 1 ) data.opacity = this.opacity;\\r\\n\\t\\tif ( this.transparent === true ) data.transparent = this.transparent;\\r\\n\\r\\n\\t\\tdata.depthFunc = this.depthFunc;\\r\\n\\t\\tdata.depthTest = this.depthTest;\\r\\n\\t\\tdata.depthWrite = this.depthWrite;\\r\\n\\r\\n\\t\\tdata.stencilWrite = this.stencilWrite;\\r\\n\\t\\tdata.stencilWriteMask = this.stencilWriteMask;\\r\\n\\t\\tdata.stencilFunc = this.stencilFunc;\\r\\n\\t\\tdata.stencilRef = this.stencilRef;\\r\\n\\t\\tdata.stencilFuncMask = this.stencilFuncMask;\\r\\n\\t\\tdata.stencilFail = this.stencilFail;\\r\\n\\t\\tdata.stencilZFail = this.stencilZFail;\\r\\n\\t\\tdata.stencilZPass = this.stencilZPass;\\r\\n\\r\\n\\t\\t// rotation (SpriteMaterial)\\r\\n\\t\\tif ( this.rotation && this.rotation !== 0 ) data.rotation = this.rotation;\\r\\n\\r\\n\\t\\tif ( this.polygonOffset === true ) data.polygonOffset = true;\\r\\n\\t\\tif ( this.polygonOffsetFactor !== 0 ) data.polygonOffsetFactor = this.polygonOffsetFactor;\\r\\n\\t\\tif ( this.polygonOffsetUnits !== 0 ) data.polygonOffsetUnits = this.polygonOffsetUnits;\\r\\n\\r\\n\\t\\tif ( this.linewidth && this.linewidth !== 1 ) data.linewidth = this.linewidth;\\r\\n\\t\\tif ( this.dashSize !== undefined ) data.dashSize = this.dashSize;\\r\\n\\t\\tif ( this.gapSize !== undefined ) data.gapSize = this.gapSize;\\r\\n\\t\\tif ( this.scale !== undefined ) data.scale = this.scale;\\r\\n\\r\\n\\t\\tif ( this.dithering === true ) data.dithering = true;\\r\\n\\r\\n\\t\\tif ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;\\r\\n\\t\\tif ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;\\r\\n\\r\\n\\t\\tif ( this.wireframe === true ) data.wireframe = this.wireframe;\\r\\n\\t\\tif ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;\\r\\n\\t\\tif ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;\\r\\n\\t\\tif ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;\\r\\n\\r\\n\\t\\tif ( this.morphTargets === true ) data.morphTargets = true;\\r\\n\\t\\tif ( this.morphNormals === true ) data.morphNormals = true;\\r\\n\\t\\tif ( this.skinning === true ) data.skinning = true;\\r\\n\\r\\n\\t\\tif ( this.visible === false ) data.visible = false;\\r\\n\\r\\n\\t\\tif ( this.toneMapped === false ) data.toneMapped = false;\\r\\n\\r\\n\\t\\tif ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData;\\r\\n\\r\\n\\t\\t// TODO: Copied from Object3D.toJSON\\r\\n\\r\\n\\t\\tfunction extractFromCache( cache ) {\\r\\n\\r\\n\\t\\t\\tvar values = [];\\r\\n\\r\\n\\t\\t\\tfor ( var key in cache ) {\\r\\n\\r\\n\\t\\t\\t\\tvar data = cache[ key ];\\r\\n\\t\\t\\t\\tdelete data.metadata;\\r\\n\\t\\t\\t\\tvalues.push( data );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn values;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( isRoot ) {\\r\\n\\r\\n\\t\\t\\tvar textures = extractFromCache( meta.textures );\\r\\n\\t\\t\\tvar images = extractFromCache( meta.images );\\r\\n\\r\\n\\t\\t\\tif ( textures.length > 0 ) data.textures = textures;\\r\\n\\t\\t\\tif ( images.length > 0 ) data.images = images;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn data;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclone: function () {\\r\\n\\r\\n\\t\\treturn new this.constructor().copy( this );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\tthis.name = source.name;\\r\\n\\r\\n\\t\\tthis.fog = source.fog;\\r\\n\\r\\n\\t\\tthis.blending = source.blending;\\r\\n\\t\\tthis.side = source.side;\\r\\n\\t\\tthis.flatShading = source.flatShading;\\r\\n\\t\\tthis.vertexColors = source.vertexColors;\\r\\n\\r\\n\\t\\tthis.opacity = source.opacity;\\r\\n\\t\\tthis.transparent = source.transparent;\\r\\n\\r\\n\\t\\tthis.blendSrc = source.blendSrc;\\r\\n\\t\\tthis.blendDst = source.blendDst;\\r\\n\\t\\tthis.blendEquation = source.blendEquation;\\r\\n\\t\\tthis.blendSrcAlpha = source.blendSrcAlpha;\\r\\n\\t\\tthis.blendDstAlpha = source.blendDstAlpha;\\r\\n\\t\\tthis.blendEquationAlpha = source.blendEquationAlpha;\\r\\n\\r\\n\\t\\tthis.depthFunc = source.depthFunc;\\r\\n\\t\\tthis.depthTest = source.depthTest;\\r\\n\\t\\tthis.depthWrite = source.depthWrite;\\r\\n\\r\\n\\t\\tthis.stencilWriteMask = source.stencilWriteMask;\\r\\n\\t\\tthis.stencilFunc = source.stencilFunc;\\r\\n\\t\\tthis.stencilRef = source.stencilRef;\\r\\n\\t\\tthis.stencilFuncMask = source.stencilFuncMask;\\r\\n\\t\\tthis.stencilFail = source.stencilFail;\\r\\n\\t\\tthis.stencilZFail = source.stencilZFail;\\r\\n\\t\\tthis.stencilZPass = source.stencilZPass;\\r\\n\\t\\tthis.stencilWrite = source.stencilWrite;\\r\\n\\r\\n\\t\\tvar srcPlanes = source.clippingPlanes,\\r\\n\\t\\t\\tdstPlanes = null;\\r\\n\\r\\n\\t\\tif ( srcPlanes !== null ) {\\r\\n\\r\\n\\t\\t\\tvar n = srcPlanes.length;\\r\\n\\t\\t\\tdstPlanes = new Array( n );\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i !== n; ++ i )\\r\\n\\t\\t\\t\\tdstPlanes[ i ] = srcPlanes[ i ].clone();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.clippingPlanes = dstPlanes;\\r\\n\\t\\tthis.clipIntersection = source.clipIntersection;\\r\\n\\t\\tthis.clipShadows = source.clipShadows;\\r\\n\\r\\n\\t\\tthis.shadowSide = source.shadowSide;\\r\\n\\r\\n\\t\\tthis.colorWrite = source.colorWrite;\\r\\n\\r\\n\\t\\tthis.precision = source.precision;\\r\\n\\r\\n\\t\\tthis.polygonOffset = source.polygonOffset;\\r\\n\\t\\tthis.polygonOffsetFactor = source.polygonOffsetFactor;\\r\\n\\t\\tthis.polygonOffsetUnits = source.polygonOffsetUnits;\\r\\n\\r\\n\\t\\tthis.dithering = source.dithering;\\r\\n\\r\\n\\t\\tthis.alphaTest = source.alphaTest;\\r\\n\\t\\tthis.premultipliedAlpha = source.premultipliedAlpha;\\r\\n\\r\\n\\t\\tthis.visible = source.visible;\\r\\n\\r\\n\\t\\tthis.toneMapped = source.toneMapped;\\r\\n\\r\\n\\t\\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tdispose: function () {\\r\\n\\r\\n\\t\\tthis.dispatchEvent( { type: 'dispose' } );\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nObject.defineProperty( Material.prototype, 'needsUpdate', {\\r\\n\\r\\n\\tset: function ( value ) {\\r\\n\\r\\n\\t\\tif ( value === true ) this.version ++;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n *\\r\\n * parameters = {\\r\\n *  color: <hex>,\\r\\n *  opacity: <float>,\\r\\n *  map: new THREE.Texture( <Image> ),\\r\\n *\\r\\n *  lightMap: new THREE.Texture( <Image> ),\\r\\n *  lightMapIntensity: <float>\\r\\n *\\r\\n *  aoMap: new THREE.Texture( <Image> ),\\r\\n *  aoMapIntensity: <float>\\r\\n *\\r\\n *  specularMap: new THREE.Texture( <Image> ),\\r\\n *\\r\\n *  alphaMap: new THREE.Texture( <Image> ),\\r\\n *\\r\\n *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\\r\\n *  combine: THREE.Multiply,\\r\\n *  reflectivity: <float>,\\r\\n *  refractionRatio: <float>,\\r\\n *\\r\\n *  depthTest: <bool>,\\r\\n *  depthWrite: <bool>,\\r\\n *\\r\\n *  wireframe: <boolean>,\\r\\n *  wireframeLinewidth: <float>,\\r\\n *\\r\\n *  skinning: <bool>,\\r\\n *  morphTargets: <bool>\\r\\n * }\\r\\n */\\r\\n\\r\\nfunction MeshBasicMaterial( parameters ) {\\r\\n\\r\\n\\tMaterial.call( this );\\r\\n\\r\\n\\tthis.type = 'MeshBasicMaterial';\\r\\n\\r\\n\\tthis.color = new Color( 0xffffff ); // emissive\\r\\n\\r\\n\\tthis.map = null;\\r\\n\\r\\n\\tthis.lightMap = null;\\r\\n\\tthis.lightMapIntensity = 1.0;\\r\\n\\r\\n\\tthis.aoMap = null;\\r\\n\\tthis.aoMapIntensity = 1.0;\\r\\n\\r\\n\\tthis.specularMap = null;\\r\\n\\r\\n\\tthis.alphaMap = null;\\r\\n\\r\\n\\tthis.envMap = null;\\r\\n\\tthis.combine = MultiplyOperation;\\r\\n\\tthis.reflectivity = 1;\\r\\n\\tthis.refractionRatio = 0.98;\\r\\n\\r\\n\\tthis.wireframe = false;\\r\\n\\tthis.wireframeLinewidth = 1;\\r\\n\\tthis.wireframeLinecap = 'round';\\r\\n\\tthis.wireframeLinejoin = 'round';\\r\\n\\r\\n\\tthis.skinning = false;\\r\\n\\tthis.morphTargets = false;\\r\\n\\r\\n\\tthis.setValues( parameters );\\r\\n\\r\\n}\\r\\n\\r\\nMeshBasicMaterial.prototype = Object.create( Material.prototype );\\r\\nMeshBasicMaterial.prototype.constructor = MeshBasicMaterial;\\r\\n\\r\\nMeshBasicMaterial.prototype.isMeshBasicMaterial = true;\\r\\n\\r\\nMeshBasicMaterial.prototype.copy = function ( source ) {\\r\\n\\r\\n\\tMaterial.prototype.copy.call( this, source );\\r\\n\\r\\n\\tthis.color.copy( source.color );\\r\\n\\r\\n\\tthis.map = source.map;\\r\\n\\r\\n\\tthis.lightMap = source.lightMap;\\r\\n\\tthis.lightMapIntensity = source.lightMapIntensity;\\r\\n\\r\\n\\tthis.aoMap = source.aoMap;\\r\\n\\tthis.aoMapIntensity = source.aoMapIntensity;\\r\\n\\r\\n\\tthis.specularMap = source.specularMap;\\r\\n\\r\\n\\tthis.alphaMap = source.alphaMap;\\r\\n\\r\\n\\tthis.envMap = source.envMap;\\r\\n\\tthis.combine = source.combine;\\r\\n\\tthis.reflectivity = source.reflectivity;\\r\\n\\tthis.refractionRatio = source.refractionRatio;\\r\\n\\r\\n\\tthis.wireframe = source.wireframe;\\r\\n\\tthis.wireframeLinewidth = source.wireframeLinewidth;\\r\\n\\tthis.wireframeLinecap = source.wireframeLinecap;\\r\\n\\tthis.wireframeLinejoin = source.wireframeLinejoin;\\r\\n\\r\\n\\tthis.skinning = source.skinning;\\r\\n\\tthis.morphTargets = source.morphTargets;\\r\\n\\r\\n\\treturn this;\\r\\n\\r\\n};\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nvar _vector$3 = new Vector3();\\r\\n\\r\\nfunction BufferAttribute( array, itemSize, normalized ) {\\r\\n\\r\\n\\tif ( Array.isArray( array ) ) {\\r\\n\\r\\n\\t\\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tthis.name = '';\\r\\n\\r\\n\\tthis.array = array;\\r\\n\\tthis.itemSize = itemSize;\\r\\n\\tthis.count = array !== undefined ? array.length / itemSize : 0;\\r\\n\\tthis.normalized = normalized === true;\\r\\n\\r\\n\\tthis.usage = StaticDrawUsage;\\r\\n\\tthis.updateRange = { offset: 0, count: - 1 };\\r\\n\\r\\n\\tthis.version = 0;\\r\\n\\r\\n}\\r\\n\\r\\nObject.defineProperty( BufferAttribute.prototype, 'needsUpdate', {\\r\\n\\r\\n\\tset: function ( value ) {\\r\\n\\r\\n\\t\\tif ( value === true ) this.version ++;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nObject.assign( BufferAttribute.prototype, {\\r\\n\\r\\n\\tisBufferAttribute: true,\\r\\n\\r\\n\\tonUploadCallback: function () {},\\r\\n\\r\\n\\tsetUsage: function ( value ) {\\r\\n\\r\\n\\t\\tthis.usage = value;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\tthis.name = source.name;\\r\\n\\t\\tthis.array = new source.array.constructor( source.array );\\r\\n\\t\\tthis.itemSize = source.itemSize;\\r\\n\\t\\tthis.count = source.count;\\r\\n\\t\\tthis.normalized = source.normalized;\\r\\n\\r\\n\\t\\tthis.usage = source.usage;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcopyAt: function ( index1, attribute, index2 ) {\\r\\n\\r\\n\\t\\tindex1 *= this.itemSize;\\r\\n\\t\\tindex2 *= attribute.itemSize;\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = this.itemSize; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcopyArray: function ( array ) {\\r\\n\\r\\n\\t\\tthis.array.set( array );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcopyColorsArray: function ( colors ) {\\r\\n\\r\\n\\t\\tvar array = this.array, offset = 0;\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = colors.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar color = colors[ i ];\\r\\n\\r\\n\\t\\t\\tif ( color === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );\\r\\n\\t\\t\\t\\tcolor = new Color();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tarray[ offset ++ ] = color.r;\\r\\n\\t\\t\\tarray[ offset ++ ] = color.g;\\r\\n\\t\\t\\tarray[ offset ++ ] = color.b;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcopyVector2sArray: function ( vectors ) {\\r\\n\\r\\n\\t\\tvar array = this.array, offset = 0;\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar vector = vectors[ i ];\\r\\n\\r\\n\\t\\t\\tif ( vector === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );\\r\\n\\t\\t\\t\\tvector = new Vector2();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tarray[ offset ++ ] = vector.x;\\r\\n\\t\\t\\tarray[ offset ++ ] = vector.y;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcopyVector3sArray: function ( vectors ) {\\r\\n\\r\\n\\t\\tvar array = this.array, offset = 0;\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar vector = vectors[ i ];\\r\\n\\r\\n\\t\\t\\tif ( vector === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );\\r\\n\\t\\t\\t\\tvector = new Vector3();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tarray[ offset ++ ] = vector.x;\\r\\n\\t\\t\\tarray[ offset ++ ] = vector.y;\\r\\n\\t\\t\\tarray[ offset ++ ] = vector.z;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcopyVector4sArray: function ( vectors ) {\\r\\n\\r\\n\\t\\tvar array = this.array, offset = 0;\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar vector = vectors[ i ];\\r\\n\\r\\n\\t\\t\\tif ( vector === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );\\r\\n\\t\\t\\t\\tvector = new Vector4();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tarray[ offset ++ ] = vector.x;\\r\\n\\t\\t\\tarray[ offset ++ ] = vector.y;\\r\\n\\t\\t\\tarray[ offset ++ ] = vector.z;\\r\\n\\t\\t\\tarray[ offset ++ ] = vector.w;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tapplyMatrix3: function ( m ) {\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = this.count; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t_vector$3.x = this.getX( i );\\r\\n\\t\\t\\t_vector$3.y = this.getY( i );\\r\\n\\t\\t\\t_vector$3.z = this.getZ( i );\\r\\n\\r\\n\\t\\t\\t_vector$3.applyMatrix3( m );\\r\\n\\r\\n\\t\\t\\tthis.setXYZ( i, _vector$3.x, _vector$3.y, _vector$3.z );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tapplyMatrix4: function ( m ) {\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = this.count; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t_vector$3.x = this.getX( i );\\r\\n\\t\\t\\t_vector$3.y = this.getY( i );\\r\\n\\t\\t\\t_vector$3.z = this.getZ( i );\\r\\n\\r\\n\\t\\t\\t_vector$3.applyMatrix4( m );\\r\\n\\r\\n\\t\\t\\tthis.setXYZ( i, _vector$3.x, _vector$3.y, _vector$3.z );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tapplyNormalMatrix: function ( m ) {\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = this.count; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t_vector$3.x = this.getX( i );\\r\\n\\t\\t\\t_vector$3.y = this.getY( i );\\r\\n\\t\\t\\t_vector$3.z = this.getZ( i );\\r\\n\\r\\n\\t\\t\\t_vector$3.applyNormalMatrix( m );\\r\\n\\r\\n\\t\\t\\tthis.setXYZ( i, _vector$3.x, _vector$3.y, _vector$3.z );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttransformDirection: function ( m ) {\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = this.count; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t_vector$3.x = this.getX( i );\\r\\n\\t\\t\\t_vector$3.y = this.getY( i );\\r\\n\\t\\t\\t_vector$3.z = this.getZ( i );\\r\\n\\r\\n\\t\\t\\t_vector$3.transformDirection( m );\\r\\n\\r\\n\\t\\t\\tthis.setXYZ( i, _vector$3.x, _vector$3.y, _vector$3.z );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tset: function ( value, offset ) {\\r\\n\\r\\n\\t\\tif ( offset === undefined ) offset = 0;\\r\\n\\r\\n\\t\\tthis.array.set( value, offset );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetX: function ( index ) {\\r\\n\\r\\n\\t\\treturn this.array[ index * this.itemSize ];\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetX: function ( index, x ) {\\r\\n\\r\\n\\t\\tthis.array[ index * this.itemSize ] = x;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetY: function ( index ) {\\r\\n\\r\\n\\t\\treturn this.array[ index * this.itemSize + 1 ];\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetY: function ( index, y ) {\\r\\n\\r\\n\\t\\tthis.array[ index * this.itemSize + 1 ] = y;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetZ: function ( index ) {\\r\\n\\r\\n\\t\\treturn this.array[ index * this.itemSize + 2 ];\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetZ: function ( index, z ) {\\r\\n\\r\\n\\t\\tthis.array[ index * this.itemSize + 2 ] = z;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetW: function ( index ) {\\r\\n\\r\\n\\t\\treturn this.array[ index * this.itemSize + 3 ];\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetW: function ( index, w ) {\\r\\n\\r\\n\\t\\tthis.array[ index * this.itemSize + 3 ] = w;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetXY: function ( index, x, y ) {\\r\\n\\r\\n\\t\\tindex *= this.itemSize;\\r\\n\\r\\n\\t\\tthis.array[ index + 0 ] = x;\\r\\n\\t\\tthis.array[ index + 1 ] = y;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetXYZ: function ( index, x, y, z ) {\\r\\n\\r\\n\\t\\tindex *= this.itemSize;\\r\\n\\r\\n\\t\\tthis.array[ index + 0 ] = x;\\r\\n\\t\\tthis.array[ index + 1 ] = y;\\r\\n\\t\\tthis.array[ index + 2 ] = z;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetXYZW: function ( index, x, y, z, w ) {\\r\\n\\r\\n\\t\\tindex *= this.itemSize;\\r\\n\\r\\n\\t\\tthis.array[ index + 0 ] = x;\\r\\n\\t\\tthis.array[ index + 1 ] = y;\\r\\n\\t\\tthis.array[ index + 2 ] = z;\\r\\n\\t\\tthis.array[ index + 3 ] = w;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tonUpload: function ( callback ) {\\r\\n\\r\\n\\t\\tthis.onUploadCallback = callback;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclone: function () {\\r\\n\\r\\n\\t\\treturn new this.constructor( this.array, this.itemSize ).copy( this );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttoJSON: function () {\\r\\n\\r\\n\\t\\treturn {\\r\\n\\t\\t\\titemSize: this.itemSize,\\r\\n\\t\\t\\ttype: this.array.constructor.name,\\r\\n\\t\\t\\tarray: Array.prototype.slice.call( this.array ),\\r\\n\\t\\t\\tnormalized: this.normalized\\r\\n\\t\\t};\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n//\\r\\n\\r\\nfunction Int8BufferAttribute( array, itemSize, normalized ) {\\r\\n\\r\\n\\tBufferAttribute.call( this, new Int8Array( array ), itemSize, normalized );\\r\\n\\r\\n}\\r\\n\\r\\nInt8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\\r\\nInt8BufferAttribute.prototype.constructor = Int8BufferAttribute;\\r\\n\\r\\n\\r\\nfunction Uint8BufferAttribute( array, itemSize, normalized ) {\\r\\n\\r\\n\\tBufferAttribute.call( this, new Uint8Array( array ), itemSize, normalized );\\r\\n\\r\\n}\\r\\n\\r\\nUint8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\\r\\nUint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;\\r\\n\\r\\n\\r\\nfunction Uint8ClampedBufferAttribute( array, itemSize, normalized ) {\\r\\n\\r\\n\\tBufferAttribute.call( this, new Uint8ClampedArray( array ), itemSize, normalized );\\r\\n\\r\\n}\\r\\n\\r\\nUint8ClampedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );\\r\\nUint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;\\r\\n\\r\\n\\r\\nfunction Int16BufferAttribute( array, itemSize, normalized ) {\\r\\n\\r\\n\\tBufferAttribute.call( this, new Int16Array( array ), itemSize, normalized );\\r\\n\\r\\n}\\r\\n\\r\\nInt16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\\r\\nInt16BufferAttribute.prototype.constructor = Int16BufferAttribute;\\r\\n\\r\\n\\r\\nfunction Uint16BufferAttribute( array, itemSize, normalized ) {\\r\\n\\r\\n\\tBufferAttribute.call( this, new Uint16Array( array ), itemSize, normalized );\\r\\n\\r\\n}\\r\\n\\r\\nUint16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\\r\\nUint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;\\r\\n\\r\\n\\r\\nfunction Int32BufferAttribute( array, itemSize, normalized ) {\\r\\n\\r\\n\\tBufferAttribute.call( this, new Int32Array( array ), itemSize, normalized );\\r\\n\\r\\n}\\r\\n\\r\\nInt32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\\r\\nInt32BufferAttribute.prototype.constructor = Int32BufferAttribute;\\r\\n\\r\\n\\r\\nfunction Uint32BufferAttribute( array, itemSize, normalized ) {\\r\\n\\r\\n\\tBufferAttribute.call( this, new Uint32Array( array ), itemSize, normalized );\\r\\n\\r\\n}\\r\\n\\r\\nUint32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\\r\\nUint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;\\r\\n\\r\\n\\r\\nfunction Float32BufferAttribute( array, itemSize, normalized ) {\\r\\n\\r\\n\\tBufferAttribute.call( this, new Float32Array( array ), itemSize, normalized );\\r\\n\\r\\n}\\r\\n\\r\\nFloat32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\\r\\nFloat32BufferAttribute.prototype.constructor = Float32BufferAttribute;\\r\\n\\r\\n\\r\\nfunction Float64BufferAttribute( array, itemSize, normalized ) {\\r\\n\\r\\n\\tBufferAttribute.call( this, new Float64Array( array ), itemSize, normalized );\\r\\n\\r\\n}\\r\\n\\r\\nFloat64BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\\r\\nFloat64BufferAttribute.prototype.constructor = Float64BufferAttribute;\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nfunction DirectGeometry() {\\r\\n\\r\\n\\tthis.vertices = [];\\r\\n\\tthis.normals = [];\\r\\n\\tthis.colors = [];\\r\\n\\tthis.uvs = [];\\r\\n\\tthis.uvs2 = [];\\r\\n\\r\\n\\tthis.groups = [];\\r\\n\\r\\n\\tthis.morphTargets = {};\\r\\n\\r\\n\\tthis.skinWeights = [];\\r\\n\\tthis.skinIndices = [];\\r\\n\\r\\n\\t// this.lineDistances = [];\\r\\n\\r\\n\\tthis.boundingBox = null;\\r\\n\\tthis.boundingSphere = null;\\r\\n\\r\\n\\t// update flags\\r\\n\\r\\n\\tthis.verticesNeedUpdate = false;\\r\\n\\tthis.normalsNeedUpdate = false;\\r\\n\\tthis.colorsNeedUpdate = false;\\r\\n\\tthis.uvsNeedUpdate = false;\\r\\n\\tthis.groupsNeedUpdate = false;\\r\\n\\r\\n}\\r\\n\\r\\nObject.assign( DirectGeometry.prototype, {\\r\\n\\r\\n\\tcomputeGroups: function ( geometry ) {\\r\\n\\r\\n\\t\\tvar group;\\r\\n\\t\\tvar groups = [];\\r\\n\\t\\tvar materialIndex = undefined;\\r\\n\\r\\n\\t\\tvar faces = geometry.faces;\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < faces.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar face = faces[ i ];\\r\\n\\r\\n\\t\\t\\t// materials\\r\\n\\r\\n\\t\\t\\tif ( face.materialIndex !== materialIndex ) {\\r\\n\\r\\n\\t\\t\\t\\tmaterialIndex = face.materialIndex;\\r\\n\\r\\n\\t\\t\\t\\tif ( group !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tgroup.count = ( i * 3 ) - group.start;\\r\\n\\t\\t\\t\\t\\tgroups.push( group );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tgroup = {\\r\\n\\t\\t\\t\\t\\tstart: i * 3,\\r\\n\\t\\t\\t\\t\\tmaterialIndex: materialIndex\\r\\n\\t\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( group !== undefined ) {\\r\\n\\r\\n\\t\\t\\tgroup.count = ( i * 3 ) - group.start;\\r\\n\\t\\t\\tgroups.push( group );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.groups = groups;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tfromGeometry: function ( geometry ) {\\r\\n\\r\\n\\t\\tvar faces = geometry.faces;\\r\\n\\t\\tvar vertices = geometry.vertices;\\r\\n\\t\\tvar faceVertexUvs = geometry.faceVertexUvs;\\r\\n\\r\\n\\t\\tvar hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;\\r\\n\\t\\tvar hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;\\r\\n\\r\\n\\t\\t// morphs\\r\\n\\r\\n\\t\\tvar morphTargets = geometry.morphTargets;\\r\\n\\t\\tvar morphTargetsLength = morphTargets.length;\\r\\n\\r\\n\\t\\tvar morphTargetsPosition;\\r\\n\\r\\n\\t\\tif ( morphTargetsLength > 0 ) {\\r\\n\\r\\n\\t\\t\\tmorphTargetsPosition = [];\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < morphTargetsLength; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tmorphTargetsPosition[ i ] = {\\r\\n\\t\\t\\t\\t\\tname: morphTargets[ i ].name,\\r\\n\\t\\t\\t\\t \\tdata: []\\r\\n\\t\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.morphTargets.position = morphTargetsPosition;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar morphNormals = geometry.morphNormals;\\r\\n\\t\\tvar morphNormalsLength = morphNormals.length;\\r\\n\\r\\n\\t\\tvar morphTargetsNormal;\\r\\n\\r\\n\\t\\tif ( morphNormalsLength > 0 ) {\\r\\n\\r\\n\\t\\t\\tmorphTargetsNormal = [];\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < morphNormalsLength; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tmorphTargetsNormal[ i ] = {\\r\\n\\t\\t\\t\\t\\tname: morphNormals[ i ].name,\\r\\n\\t\\t\\t\\t \\tdata: []\\r\\n\\t\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.morphTargets.normal = morphTargetsNormal;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// skins\\r\\n\\r\\n\\t\\tvar skinIndices = geometry.skinIndices;\\r\\n\\t\\tvar skinWeights = geometry.skinWeights;\\r\\n\\r\\n\\t\\tvar hasSkinIndices = skinIndices.length === vertices.length;\\r\\n\\t\\tvar hasSkinWeights = skinWeights.length === vertices.length;\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\tif ( vertices.length > 0 && faces.length === 0 ) {\\r\\n\\r\\n\\t\\t\\tconsole.error( 'THREE.DirectGeometry: Faceless geometries are not supported.' );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < faces.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar face = faces[ i ];\\r\\n\\r\\n\\t\\t\\tthis.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );\\r\\n\\r\\n\\t\\t\\tvar vertexNormals = face.vertexNormals;\\r\\n\\r\\n\\t\\t\\tif ( vertexNormals.length === 3 ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tvar normal = face.normal;\\r\\n\\r\\n\\t\\t\\t\\tthis.normals.push( normal, normal, normal );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar vertexColors = face.vertexColors;\\r\\n\\r\\n\\t\\t\\tif ( vertexColors.length === 3 ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tvar color = face.color;\\r\\n\\r\\n\\t\\t\\t\\tthis.colors.push( color, color, color );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( hasFaceVertexUv === true ) {\\r\\n\\r\\n\\t\\t\\t\\tvar vertexUvs = faceVertexUvs[ 0 ][ i ];\\r\\n\\r\\n\\t\\t\\t\\tif ( vertexUvs !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.uvs.push( new Vector2(), new Vector2(), new Vector2() );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( hasFaceVertexUv2 === true ) {\\r\\n\\r\\n\\t\\t\\t\\tvar vertexUvs = faceVertexUvs[ 1 ][ i ];\\r\\n\\r\\n\\t\\t\\t\\tif ( vertexUvs !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.uvs2.push( new Vector2(), new Vector2(), new Vector2() );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// morphs\\r\\n\\r\\n\\t\\t\\tfor ( var j = 0; j < morphTargetsLength; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar morphTarget = morphTargets[ j ].vertices;\\r\\n\\r\\n\\t\\t\\t\\tmorphTargetsPosition[ j ].data.push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tfor ( var j = 0; j < morphNormalsLength; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar morphNormal = morphNormals[ j ].vertexNormals[ i ];\\r\\n\\r\\n\\t\\t\\t\\tmorphTargetsNormal[ j ].data.push( morphNormal.a, morphNormal.b, morphNormal.c );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// skins\\r\\n\\r\\n\\t\\t\\tif ( hasSkinIndices ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( hasSkinWeights ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.computeGroups( geometry );\\r\\n\\r\\n\\t\\tthis.verticesNeedUpdate = geometry.verticesNeedUpdate;\\r\\n\\t\\tthis.normalsNeedUpdate = geometry.normalsNeedUpdate;\\r\\n\\t\\tthis.colorsNeedUpdate = geometry.colorsNeedUpdate;\\r\\n\\t\\tthis.uvsNeedUpdate = geometry.uvsNeedUpdate;\\r\\n\\t\\tthis.groupsNeedUpdate = geometry.groupsNeedUpdate;\\r\\n\\r\\n\\t\\tif ( geometry.boundingSphere !== null ) {\\r\\n\\r\\n\\t\\t\\tthis.boundingSphere = geometry.boundingSphere.clone();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( geometry.boundingBox !== null ) {\\r\\n\\r\\n\\t\\t\\tthis.boundingBox = geometry.boundingBox.clone();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nfunction arrayMax( array ) {\\r\\n\\r\\n\\tif ( array.length === 0 ) return - Infinity;\\r\\n\\r\\n\\tlet max = array[ 0 ];\\r\\n\\r\\n\\tfor ( let i = 1, l = array.length; i < l; ++ i ) {\\r\\n\\r\\n\\t\\tif ( array[ i ] > max ) max = array[ i ];\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn max;\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nvar _bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id\\r\\n\\r\\nvar _m1$2 = new Matrix4();\\r\\nvar _obj = new Object3D();\\r\\nvar _offset = new Vector3();\\r\\nvar _box$2 = new Box3();\\r\\nvar _boxMorphTargets = new Box3();\\r\\nvar _vector$4 = new Vector3();\\r\\n\\r\\nfunction BufferGeometry() {\\r\\n\\r\\n\\tObject.defineProperty( this, 'id', { value: _bufferGeometryId += 2 } );\\r\\n\\r\\n\\tthis.uuid = MathUtils.generateUUID();\\r\\n\\r\\n\\tthis.name = '';\\r\\n\\tthis.type = 'BufferGeometry';\\r\\n\\r\\n\\tthis.index = null;\\r\\n\\tthis.attributes = {};\\r\\n\\r\\n\\tthis.morphAttributes = {};\\r\\n\\tthis.morphTargetsRelative = false;\\r\\n\\r\\n\\tthis.groups = [];\\r\\n\\r\\n\\tthis.boundingBox = null;\\r\\n\\tthis.boundingSphere = null;\\r\\n\\r\\n\\tthis.drawRange = { start: 0, count: Infinity };\\r\\n\\r\\n\\tthis.userData = {};\\r\\n\\r\\n}\\r\\n\\r\\nBufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\\r\\n\\r\\n\\tconstructor: BufferGeometry,\\r\\n\\r\\n\\tisBufferGeometry: true,\\r\\n\\r\\n\\tgetIndex: function () {\\r\\n\\r\\n\\t\\treturn this.index;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetIndex: function ( index ) {\\r\\n\\r\\n\\t\\tif ( Array.isArray( index ) ) {\\r\\n\\r\\n\\t\\t\\tthis.index = new ( arrayMax( index ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tthis.index = index;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetAttribute: function ( name ) {\\r\\n\\r\\n\\t\\treturn this.attributes[ name ];\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetAttribute: function ( name, attribute ) {\\r\\n\\r\\n\\t\\tthis.attributes[ name ] = attribute;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tdeleteAttribute: function ( name ) {\\r\\n\\r\\n\\t\\tdelete this.attributes[ name ];\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\taddGroup: function ( start, count, materialIndex ) {\\r\\n\\r\\n\\t\\tthis.groups.push( {\\r\\n\\r\\n\\t\\t\\tstart: start,\\r\\n\\t\\t\\tcount: count,\\r\\n\\t\\t\\tmaterialIndex: materialIndex !== undefined ? materialIndex : 0\\r\\n\\r\\n\\t\\t} );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclearGroups: function () {\\r\\n\\r\\n\\t\\tthis.groups = [];\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetDrawRange: function ( start, count ) {\\r\\n\\r\\n\\t\\tthis.drawRange.start = start;\\r\\n\\t\\tthis.drawRange.count = count;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tapplyMatrix4: function ( matrix ) {\\r\\n\\r\\n\\t\\tvar position = this.attributes.position;\\r\\n\\r\\n\\t\\tif ( position !== undefined ) {\\r\\n\\r\\n\\t\\t\\tposition.applyMatrix4( matrix );\\r\\n\\r\\n\\t\\t\\tposition.needsUpdate = true;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar normal = this.attributes.normal;\\r\\n\\r\\n\\t\\tif ( normal !== undefined ) {\\r\\n\\r\\n\\t\\t\\tvar normalMatrix = new Matrix3().getNormalMatrix( matrix );\\r\\n\\r\\n\\t\\t\\tnormal.applyNormalMatrix( normalMatrix );\\r\\n\\r\\n\\t\\t\\tnormal.needsUpdate = true;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar tangent = this.attributes.tangent;\\r\\n\\r\\n\\t\\tif ( tangent !== undefined ) {\\r\\n\\r\\n\\t\\t\\ttangent.transformDirection( matrix );\\r\\n\\r\\n\\t\\t\\ttangent.needsUpdate = true;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( this.boundingBox !== null ) {\\r\\n\\r\\n\\t\\t\\tthis.computeBoundingBox();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( this.boundingSphere !== null ) {\\r\\n\\r\\n\\t\\t\\tthis.computeBoundingSphere();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\trotateX: function ( angle ) {\\r\\n\\r\\n\\t\\t// rotate geometry around world x-axis\\r\\n\\r\\n\\t\\t_m1$2.makeRotationX( angle );\\r\\n\\r\\n\\t\\tthis.applyMatrix4( _m1$2 );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\trotateY: function ( angle ) {\\r\\n\\r\\n\\t\\t// rotate geometry around world y-axis\\r\\n\\r\\n\\t\\t_m1$2.makeRotationY( angle );\\r\\n\\r\\n\\t\\tthis.applyMatrix4( _m1$2 );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\trotateZ: function ( angle ) {\\r\\n\\r\\n\\t\\t// rotate geometry around world z-axis\\r\\n\\r\\n\\t\\t_m1$2.makeRotationZ( angle );\\r\\n\\r\\n\\t\\tthis.applyMatrix4( _m1$2 );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttranslate: function ( x, y, z ) {\\r\\n\\r\\n\\t\\t// translate geometry\\r\\n\\r\\n\\t\\t_m1$2.makeTranslation( x, y, z );\\r\\n\\r\\n\\t\\tthis.applyMatrix4( _m1$2 );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tscale: function ( x, y, z ) {\\r\\n\\r\\n\\t\\t// scale geometry\\r\\n\\r\\n\\t\\t_m1$2.makeScale( x, y, z );\\r\\n\\r\\n\\t\\tthis.applyMatrix4( _m1$2 );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tlookAt: function ( vector ) {\\r\\n\\r\\n\\t\\t_obj.lookAt( vector );\\r\\n\\r\\n\\t\\t_obj.updateMatrix();\\r\\n\\r\\n\\t\\tthis.applyMatrix4( _obj.matrix );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcenter: function () {\\r\\n\\r\\n\\t\\tthis.computeBoundingBox();\\r\\n\\r\\n\\t\\tthis.boundingBox.getCenter( _offset ).negate();\\r\\n\\r\\n\\t\\tthis.translate( _offset.x, _offset.y, _offset.z );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetFromObject: function ( object ) {\\r\\n\\r\\n\\t\\t// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );\\r\\n\\r\\n\\t\\tvar geometry = object.geometry;\\r\\n\\r\\n\\t\\tif ( object.isPoints || object.isLine ) {\\r\\n\\r\\n\\t\\t\\tvar positions = new Float32BufferAttribute( geometry.vertices.length * 3, 3 );\\r\\n\\t\\t\\tvar colors = new Float32BufferAttribute( geometry.colors.length * 3, 3 );\\r\\n\\r\\n\\t\\t\\tthis.setAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );\\r\\n\\t\\t\\tthis.setAttribute( 'color', colors.copyColorsArray( geometry.colors ) );\\r\\n\\r\\n\\t\\t\\tif ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {\\r\\n\\r\\n\\t\\t\\t\\tvar lineDistances = new Float32BufferAttribute( geometry.lineDistances.length, 1 );\\r\\n\\r\\n\\t\\t\\t\\tthis.setAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( geometry.boundingSphere !== null ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.boundingSphere = geometry.boundingSphere.clone();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( geometry.boundingBox !== null ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.boundingBox = geometry.boundingBox.clone();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t} else if ( object.isMesh ) {\\r\\n\\r\\n\\t\\t\\tif ( geometry && geometry.isGeometry ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.fromGeometry( geometry );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetFromPoints: function ( points ) {\\r\\n\\r\\n\\t\\tvar position = [];\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar point = points[ i ];\\r\\n\\t\\t\\tposition.push( point.x, point.y, point.z || 0 );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tupdateFromObject: function ( object ) {\\r\\n\\r\\n\\t\\tvar geometry = object.geometry;\\r\\n\\r\\n\\t\\tif ( object.isMesh ) {\\r\\n\\r\\n\\t\\t\\tvar direct = geometry.__directGeometry;\\r\\n\\r\\n\\t\\t\\tif ( geometry.elementsNeedUpdate === true ) {\\r\\n\\r\\n\\t\\t\\t\\tdirect = undefined;\\r\\n\\t\\t\\t\\tgeometry.elementsNeedUpdate = false;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( direct === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\treturn this.fromGeometry( geometry );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tdirect.verticesNeedUpdate = geometry.verticesNeedUpdate;\\r\\n\\t\\t\\tdirect.normalsNeedUpdate = geometry.normalsNeedUpdate;\\r\\n\\t\\t\\tdirect.colorsNeedUpdate = geometry.colorsNeedUpdate;\\r\\n\\t\\t\\tdirect.uvsNeedUpdate = geometry.uvsNeedUpdate;\\r\\n\\t\\t\\tdirect.groupsNeedUpdate = geometry.groupsNeedUpdate;\\r\\n\\r\\n\\t\\t\\tgeometry.verticesNeedUpdate = false;\\r\\n\\t\\t\\tgeometry.normalsNeedUpdate = false;\\r\\n\\t\\t\\tgeometry.colorsNeedUpdate = false;\\r\\n\\t\\t\\tgeometry.uvsNeedUpdate = false;\\r\\n\\t\\t\\tgeometry.groupsNeedUpdate = false;\\r\\n\\r\\n\\t\\t\\tgeometry = direct;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar attribute;\\r\\n\\r\\n\\t\\tif ( geometry.verticesNeedUpdate === true ) {\\r\\n\\r\\n\\t\\t\\tattribute = this.attributes.position;\\r\\n\\r\\n\\t\\t\\tif ( attribute !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tattribute.copyVector3sArray( geometry.vertices );\\r\\n\\t\\t\\t\\tattribute.needsUpdate = true;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tgeometry.verticesNeedUpdate = false;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( geometry.normalsNeedUpdate === true ) {\\r\\n\\r\\n\\t\\t\\tattribute = this.attributes.normal;\\r\\n\\r\\n\\t\\t\\tif ( attribute !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tattribute.copyVector3sArray( geometry.normals );\\r\\n\\t\\t\\t\\tattribute.needsUpdate = true;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tgeometry.normalsNeedUpdate = false;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( geometry.colorsNeedUpdate === true ) {\\r\\n\\r\\n\\t\\t\\tattribute = this.attributes.color;\\r\\n\\r\\n\\t\\t\\tif ( attribute !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tattribute.copyColorsArray( geometry.colors );\\r\\n\\t\\t\\t\\tattribute.needsUpdate = true;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tgeometry.colorsNeedUpdate = false;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( geometry.uvsNeedUpdate ) {\\r\\n\\r\\n\\t\\t\\tattribute = this.attributes.uv;\\r\\n\\r\\n\\t\\t\\tif ( attribute !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tattribute.copyVector2sArray( geometry.uvs );\\r\\n\\t\\t\\t\\tattribute.needsUpdate = true;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tgeometry.uvsNeedUpdate = false;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( geometry.lineDistancesNeedUpdate ) {\\r\\n\\r\\n\\t\\t\\tattribute = this.attributes.lineDistance;\\r\\n\\r\\n\\t\\t\\tif ( attribute !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tattribute.copyArray( geometry.lineDistances );\\r\\n\\t\\t\\t\\tattribute.needsUpdate = true;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tgeometry.lineDistancesNeedUpdate = false;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( geometry.groupsNeedUpdate ) {\\r\\n\\r\\n\\t\\t\\tgeometry.computeGroups( object.geometry );\\r\\n\\t\\t\\tthis.groups = geometry.groups;\\r\\n\\r\\n\\t\\t\\tgeometry.groupsNeedUpdate = false;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tfromGeometry: function ( geometry ) {\\r\\n\\r\\n\\t\\tgeometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );\\r\\n\\r\\n\\t\\treturn this.fromDirectGeometry( geometry.__directGeometry );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tfromDirectGeometry: function ( geometry ) {\\r\\n\\r\\n\\t\\tvar positions = new Float32Array( geometry.vertices.length * 3 );\\r\\n\\t\\tthis.setAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );\\r\\n\\r\\n\\t\\tif ( geometry.normals.length > 0 ) {\\r\\n\\r\\n\\t\\t\\tvar normals = new Float32Array( geometry.normals.length * 3 );\\r\\n\\t\\t\\tthis.setAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( geometry.colors.length > 0 ) {\\r\\n\\r\\n\\t\\t\\tvar colors = new Float32Array( geometry.colors.length * 3 );\\r\\n\\t\\t\\tthis.setAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( geometry.uvs.length > 0 ) {\\r\\n\\r\\n\\t\\t\\tvar uvs = new Float32Array( geometry.uvs.length * 2 );\\r\\n\\t\\t\\tthis.setAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( geometry.uvs2.length > 0 ) {\\r\\n\\r\\n\\t\\t\\tvar uvs2 = new Float32Array( geometry.uvs2.length * 2 );\\r\\n\\t\\t\\tthis.setAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// groups\\r\\n\\r\\n\\t\\tthis.groups = geometry.groups;\\r\\n\\r\\n\\t\\t// morphs\\r\\n\\r\\n\\t\\tfor ( var name in geometry.morphTargets ) {\\r\\n\\r\\n\\t\\t\\tvar array = [];\\r\\n\\t\\t\\tvar morphTargets = geometry.morphTargets[ name ];\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = morphTargets.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar morphTarget = morphTargets[ i ];\\r\\n\\r\\n\\t\\t\\t\\tvar attribute = new Float32BufferAttribute( morphTarget.data.length * 3, 3 );\\r\\n\\t\\t\\t\\tattribute.name = morphTarget.name;\\r\\n\\r\\n\\t\\t\\t\\tarray.push( attribute.copyVector3sArray( morphTarget.data ) );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.morphAttributes[ name ] = array;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// skinning\\r\\n\\r\\n\\t\\tif ( geometry.skinIndices.length > 0 ) {\\r\\n\\r\\n\\t\\t\\tvar skinIndices = new Float32BufferAttribute( geometry.skinIndices.length * 4, 4 );\\r\\n\\t\\t\\tthis.setAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( geometry.skinWeights.length > 0 ) {\\r\\n\\r\\n\\t\\t\\tvar skinWeights = new Float32BufferAttribute( geometry.skinWeights.length * 4, 4 );\\r\\n\\t\\t\\tthis.setAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\tif ( geometry.boundingSphere !== null ) {\\r\\n\\r\\n\\t\\t\\tthis.boundingSphere = geometry.boundingSphere.clone();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( geometry.boundingBox !== null ) {\\r\\n\\r\\n\\t\\t\\tthis.boundingBox = geometry.boundingBox.clone();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcomputeBoundingBox: function () {\\r\\n\\r\\n\\t\\tif ( this.boundingBox === null ) {\\r\\n\\r\\n\\t\\t\\tthis.boundingBox = new Box3();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar position = this.attributes.position;\\r\\n\\t\\tvar morphAttributesPosition = this.morphAttributes.position;\\r\\n\\r\\n\\t\\tif ( position !== undefined ) {\\r\\n\\r\\n\\t\\t\\tthis.boundingBox.setFromBufferAttribute( position );\\r\\n\\r\\n\\t\\t\\t// process morph attributes if present\\r\\n\\r\\n\\t\\t\\tif ( morphAttributesPosition ) {\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar morphAttribute = morphAttributesPosition[ i ];\\r\\n\\t\\t\\t\\t\\t_box$2.setFromBufferAttribute( morphAttribute );\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( this.morphTargetsRelative ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t_vector$4.addVectors( this.boundingBox.min, _box$2.min );\\r\\n\\t\\t\\t\\t\\t\\tthis.boundingBox.expandByPoint( _vector$4 );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t_vector$4.addVectors( this.boundingBox.max, _box$2.max );\\r\\n\\t\\t\\t\\t\\t\\tthis.boundingBox.expandByPoint( _vector$4 );\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tthis.boundingBox.expandByPoint( _box$2.min );\\r\\n\\t\\t\\t\\t\\t\\tthis.boundingBox.expandByPoint( _box$2.max );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tthis.boundingBox.makeEmpty();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\\r\\n\\r\\n\\t\\t\\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \\\"position\\\" attribute is likely to have NaN values.', this );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcomputeBoundingSphere: function () {\\r\\n\\r\\n\\t\\tif ( this.boundingSphere === null ) {\\r\\n\\r\\n\\t\\t\\tthis.boundingSphere = new Sphere();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar position = this.attributes.position;\\r\\n\\t\\tvar morphAttributesPosition = this.morphAttributes.position;\\r\\n\\r\\n\\t\\tif ( position ) {\\r\\n\\r\\n\\t\\t\\t// first, find the center of the bounding sphere\\r\\n\\r\\n\\t\\t\\tvar center = this.boundingSphere.center;\\r\\n\\r\\n\\t\\t\\t_box$2.setFromBufferAttribute( position );\\r\\n\\r\\n\\t\\t\\t// process morph attributes if present\\r\\n\\r\\n\\t\\t\\tif ( morphAttributesPosition ) {\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar morphAttribute = morphAttributesPosition[ i ];\\r\\n\\t\\t\\t\\t\\t_boxMorphTargets.setFromBufferAttribute( morphAttribute );\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( this.morphTargetsRelative ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t_vector$4.addVectors( _box$2.min, _boxMorphTargets.min );\\r\\n\\t\\t\\t\\t\\t\\t_box$2.expandByPoint( _vector$4 );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t_vector$4.addVectors( _box$2.max, _boxMorphTargets.max );\\r\\n\\t\\t\\t\\t\\t\\t_box$2.expandByPoint( _vector$4 );\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t_box$2.expandByPoint( _boxMorphTargets.min );\\r\\n\\t\\t\\t\\t\\t\\t_box$2.expandByPoint( _boxMorphTargets.max );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t_box$2.getCenter( center );\\r\\n\\r\\n\\t\\t\\t// second, try to find a boundingSphere with a radius smaller than the\\r\\n\\t\\t\\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\\r\\n\\r\\n\\t\\t\\tvar maxRadiusSq = 0;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, il = position.count; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t_vector$4.fromBufferAttribute( position, i );\\r\\n\\r\\n\\t\\t\\t\\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$4 ) );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// process morph attributes if present\\r\\n\\r\\n\\t\\t\\tif ( morphAttributesPosition ) {\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar morphAttribute = morphAttributesPosition[ i ];\\r\\n\\t\\t\\t\\t\\tvar morphTargetsRelative = this.morphTargetsRelative;\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var j = 0, jl = morphAttribute.count; j < jl; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t_vector$4.fromBufferAttribute( morphAttribute, j );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( morphTargetsRelative ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t_offset.fromBufferAttribute( position, j );\\r\\n\\t\\t\\t\\t\\t\\t\\t_vector$4.add( _offset );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$4 ) );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\\r\\n\\r\\n\\t\\t\\tif ( isNaN( this.boundingSphere.radius ) ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \\\"position\\\" attribute is likely to have NaN values.', this );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcomputeFaceNormals: function () {\\r\\n\\r\\n\\t\\t// backwards compatibility\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcomputeVertexNormals: function () {\\r\\n\\r\\n\\t\\tvar index = this.index;\\r\\n\\t\\tvar attributes = this.attributes;\\r\\n\\r\\n\\t\\tif ( attributes.position ) {\\r\\n\\r\\n\\t\\t\\tvar positions = attributes.position.array;\\r\\n\\r\\n\\t\\t\\tif ( attributes.normal === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.setAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t// reset existing normals to zero\\r\\n\\r\\n\\t\\t\\t\\tvar array = attributes.normal.array;\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tarray[ i ] = 0;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar normals = attributes.normal.array;\\r\\n\\r\\n\\t\\t\\tvar vA, vB, vC;\\r\\n\\t\\t\\tvar pA = new Vector3(), pB = new Vector3(), pC = new Vector3();\\r\\n\\t\\t\\tvar cb = new Vector3(), ab = new Vector3();\\r\\n\\r\\n\\t\\t\\t// indexed elements\\r\\n\\r\\n\\t\\t\\tif ( index ) {\\r\\n\\r\\n\\t\\t\\t\\tvar indices = index.array;\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, il = index.count; i < il; i += 3 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvA = indices[ i + 0 ] * 3;\\r\\n\\t\\t\\t\\t\\tvB = indices[ i + 1 ] * 3;\\r\\n\\t\\t\\t\\t\\tvC = indices[ i + 2 ] * 3;\\r\\n\\r\\n\\t\\t\\t\\t\\tpA.fromArray( positions, vA );\\r\\n\\t\\t\\t\\t\\tpB.fromArray( positions, vB );\\r\\n\\t\\t\\t\\t\\tpC.fromArray( positions, vC );\\r\\n\\r\\n\\t\\t\\t\\t\\tcb.subVectors( pC, pB );\\r\\n\\t\\t\\t\\t\\tab.subVectors( pA, pB );\\r\\n\\t\\t\\t\\t\\tcb.cross( ab );\\r\\n\\r\\n\\t\\t\\t\\t\\tnormals[ vA ] += cb.x;\\r\\n\\t\\t\\t\\t\\tnormals[ vA + 1 ] += cb.y;\\r\\n\\t\\t\\t\\t\\tnormals[ vA + 2 ] += cb.z;\\r\\n\\r\\n\\t\\t\\t\\t\\tnormals[ vB ] += cb.x;\\r\\n\\t\\t\\t\\t\\tnormals[ vB + 1 ] += cb.y;\\r\\n\\t\\t\\t\\t\\tnormals[ vB + 2 ] += cb.z;\\r\\n\\r\\n\\t\\t\\t\\t\\tnormals[ vC ] += cb.x;\\r\\n\\t\\t\\t\\t\\tnormals[ vC + 1 ] += cb.y;\\r\\n\\t\\t\\t\\t\\tnormals[ vC + 2 ] += cb.z;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t// non-indexed elements (unconnected triangle soup)\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, il = positions.length; i < il; i += 9 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tpA.fromArray( positions, i );\\r\\n\\t\\t\\t\\t\\tpB.fromArray( positions, i + 3 );\\r\\n\\t\\t\\t\\t\\tpC.fromArray( positions, i + 6 );\\r\\n\\r\\n\\t\\t\\t\\t\\tcb.subVectors( pC, pB );\\r\\n\\t\\t\\t\\t\\tab.subVectors( pA, pB );\\r\\n\\t\\t\\t\\t\\tcb.cross( ab );\\r\\n\\r\\n\\t\\t\\t\\t\\tnormals[ i ] = cb.x;\\r\\n\\t\\t\\t\\t\\tnormals[ i + 1 ] = cb.y;\\r\\n\\t\\t\\t\\t\\tnormals[ i + 2 ] = cb.z;\\r\\n\\r\\n\\t\\t\\t\\t\\tnormals[ i + 3 ] = cb.x;\\r\\n\\t\\t\\t\\t\\tnormals[ i + 4 ] = cb.y;\\r\\n\\t\\t\\t\\t\\tnormals[ i + 5 ] = cb.z;\\r\\n\\r\\n\\t\\t\\t\\t\\tnormals[ i + 6 ] = cb.x;\\r\\n\\t\\t\\t\\t\\tnormals[ i + 7 ] = cb.y;\\r\\n\\t\\t\\t\\t\\tnormals[ i + 8 ] = cb.z;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.normalizeNormals();\\r\\n\\r\\n\\t\\t\\tattributes.normal.needsUpdate = true;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tmerge: function ( geometry, offset ) {\\r\\n\\r\\n\\t\\tif ( ! ( geometry && geometry.isBufferGeometry ) ) {\\r\\n\\r\\n\\t\\t\\tconsole.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );\\r\\n\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( offset === undefined ) {\\r\\n\\r\\n\\t\\t\\toffset = 0;\\r\\n\\r\\n\\t\\t\\tconsole.warn(\\r\\n\\t\\t\\t\\t'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '\\r\\n\\t\\t\\t\\t+ 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'\\r\\n\\t\\t\\t);\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar attributes = this.attributes;\\r\\n\\r\\n\\t\\tfor ( var key in attributes ) {\\r\\n\\r\\n\\t\\t\\tif ( geometry.attributes[ key ] === undefined ) continue;\\r\\n\\r\\n\\t\\t\\tvar attribute1 = attributes[ key ];\\r\\n\\t\\t\\tvar attributeArray1 = attribute1.array;\\r\\n\\r\\n\\t\\t\\tvar attribute2 = geometry.attributes[ key ];\\r\\n\\t\\t\\tvar attributeArray2 = attribute2.array;\\r\\n\\r\\n\\t\\t\\tvar attributeOffset = attribute2.itemSize * offset;\\r\\n\\t\\t\\tvar length = Math.min( attributeArray2.length, attributeArray1.length - attributeOffset );\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, j = attributeOffset; i < length; i ++, j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tattributeArray1[ j ] = attributeArray2[ i ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tnormalizeNormals: function () {\\r\\n\\r\\n\\t\\tvar normals = this.attributes.normal;\\r\\n\\r\\n\\t\\tfor ( var i = 0, il = normals.count; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t_vector$4.x = normals.getX( i );\\r\\n\\t\\t\\t_vector$4.y = normals.getY( i );\\r\\n\\t\\t\\t_vector$4.z = normals.getZ( i );\\r\\n\\r\\n\\t\\t\\t_vector$4.normalize();\\r\\n\\r\\n\\t\\t\\tnormals.setXYZ( i, _vector$4.x, _vector$4.y, _vector$4.z );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttoNonIndexed: function () {\\r\\n\\r\\n\\t\\tfunction convertBufferAttribute( attribute, indices ) {\\r\\n\\r\\n\\t\\t\\tvar array = attribute.array;\\r\\n\\t\\t\\tvar itemSize = attribute.itemSize;\\r\\n\\t\\t\\tvar normalized = attribute.normalized;\\r\\n\\r\\n\\t\\t\\tvar array2 = new array.constructor( indices.length * itemSize );\\r\\n\\r\\n\\t\\t\\tvar index = 0, index2 = 0;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tindex = indices[ i ] * itemSize;\\r\\n\\r\\n\\t\\t\\t\\tfor ( var j = 0; j < itemSize; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tarray2[ index2 ++ ] = array[ index ++ ];\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn new BufferAttribute( array2, itemSize, normalized );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\tif ( this.index === null ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar geometry2 = new BufferGeometry();\\r\\n\\r\\n\\t\\tvar indices = this.index.array;\\r\\n\\t\\tvar attributes = this.attributes;\\r\\n\\r\\n\\t\\t// attributes\\r\\n\\r\\n\\t\\tfor ( var name in attributes ) {\\r\\n\\r\\n\\t\\t\\tvar attribute = attributes[ name ];\\r\\n\\r\\n\\t\\t\\tvar newAttribute = convertBufferAttribute( attribute, indices );\\r\\n\\r\\n\\t\\t\\tgeometry2.setAttribute( name, newAttribute );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// morph attributes\\r\\n\\r\\n\\t\\tvar morphAttributes = this.morphAttributes;\\r\\n\\r\\n\\t\\tfor ( name in morphAttributes ) {\\r\\n\\r\\n\\t\\t\\tvar morphArray = [];\\r\\n\\t\\t\\tvar morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, il = morphAttribute.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar attribute = morphAttribute[ i ];\\r\\n\\r\\n\\t\\t\\t\\tvar newAttribute = convertBufferAttribute( attribute, indices );\\r\\n\\r\\n\\t\\t\\t\\tmorphArray.push( newAttribute );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tgeometry2.morphAttributes[ name ] = morphArray;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tgeometry2.morphTargetsRelative = this.morphTargetsRelative;\\r\\n\\r\\n\\t\\t// groups\\r\\n\\r\\n\\t\\tvar groups = this.groups;\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar group = groups[ i ];\\r\\n\\t\\t\\tgeometry2.addGroup( group.start, group.count, group.materialIndex );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn geometry2;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttoJSON: function () {\\r\\n\\r\\n\\t\\tvar data = {\\r\\n\\t\\t\\tmetadata: {\\r\\n\\t\\t\\t\\tversion: 4.5,\\r\\n\\t\\t\\t\\ttype: 'BufferGeometry',\\r\\n\\t\\t\\t\\tgenerator: 'BufferGeometry.toJSON'\\r\\n\\t\\t\\t}\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\t// standard BufferGeometry serialization\\r\\n\\r\\n\\t\\tdata.uuid = this.uuid;\\r\\n\\t\\tdata.type = this.type;\\r\\n\\t\\tif ( this.name !== '' ) data.name = this.name;\\r\\n\\t\\tif ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;\\r\\n\\r\\n\\t\\tif ( this.parameters !== undefined ) {\\r\\n\\r\\n\\t\\t\\tvar parameters = this.parameters;\\r\\n\\r\\n\\t\\t\\tfor ( var key in parameters ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn data;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tdata.data = { attributes: {} };\\r\\n\\r\\n\\t\\tvar index = this.index;\\r\\n\\r\\n\\t\\tif ( index !== null ) {\\r\\n\\r\\n\\t\\t\\tdata.data.index = {\\r\\n\\t\\t\\t\\ttype: index.array.constructor.name,\\r\\n\\t\\t\\t\\tarray: Array.prototype.slice.call( index.array )\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar attributes = this.attributes;\\r\\n\\r\\n\\t\\tfor ( var key in attributes ) {\\r\\n\\r\\n\\t\\t\\tvar attribute = attributes[ key ];\\r\\n\\r\\n\\t\\t\\tvar attributeData = attribute.toJSON();\\r\\n\\r\\n\\t\\t\\tif ( attribute.name !== '' ) attributeData.name = attribute.name;\\r\\n\\r\\n\\t\\t\\tdata.data.attributes[ key ] = attributeData;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar morphAttributes = {};\\r\\n\\t\\tvar hasMorphAttributes = false;\\r\\n\\r\\n\\t\\tfor ( var key in this.morphAttributes ) {\\r\\n\\r\\n\\t\\t\\tvar attributeArray = this.morphAttributes[ key ];\\r\\n\\r\\n\\t\\t\\tvar array = [];\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, il = attributeArray.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar attribute = attributeArray[ i ];\\r\\n\\r\\n\\t\\t\\t\\tvar attributeData = attribute.toJSON();\\r\\n\\r\\n\\t\\t\\t\\tif ( attribute.name !== '' ) attributeData.name = attribute.name;\\r\\n\\r\\n\\t\\t\\t\\tarray.push( attributeData );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( array.length > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tmorphAttributes[ key ] = array;\\r\\n\\r\\n\\t\\t\\t\\thasMorphAttributes = true;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( hasMorphAttributes ) {\\r\\n\\r\\n\\t\\t\\tdata.data.morphAttributes = morphAttributes;\\r\\n\\t\\t\\tdata.data.morphTargetsRelative = this.morphTargetsRelative;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar groups = this.groups;\\r\\n\\r\\n\\t\\tif ( groups.length > 0 ) {\\r\\n\\r\\n\\t\\t\\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar boundingSphere = this.boundingSphere;\\r\\n\\r\\n\\t\\tif ( boundingSphere !== null ) {\\r\\n\\r\\n\\t\\t\\tdata.data.boundingSphere = {\\r\\n\\t\\t\\t\\tcenter: boundingSphere.center.toArray(),\\r\\n\\t\\t\\t\\tradius: boundingSphere.radius\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn data;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclone: function () {\\r\\n\\r\\n\\t\\t/*\\r\\n\\t\\t // Handle primitives\\r\\n\\r\\n\\t\\t var parameters = this.parameters;\\r\\n\\r\\n\\t\\t if ( parameters !== undefined ) {\\r\\n\\r\\n\\t\\t var values = [];\\r\\n\\r\\n\\t\\t for ( var key in parameters ) {\\r\\n\\r\\n\\t\\t values.push( parameters[ key ] );\\r\\n\\r\\n\\t\\t }\\r\\n\\r\\n\\t\\t var geometry = Object.create( this.constructor.prototype );\\r\\n\\t\\t this.constructor.apply( geometry, values );\\r\\n\\t\\t return geometry;\\r\\n\\r\\n\\t\\t }\\r\\n\\r\\n\\t\\t return new this.constructor().copy( this );\\r\\n\\t\\t */\\r\\n\\r\\n\\t\\treturn new BufferGeometry().copy( this );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\tvar name, i, l;\\r\\n\\r\\n\\t\\t// reset\\r\\n\\r\\n\\t\\tthis.index = null;\\r\\n\\t\\tthis.attributes = {};\\r\\n\\t\\tthis.morphAttributes = {};\\r\\n\\t\\tthis.groups = [];\\r\\n\\t\\tthis.boundingBox = null;\\r\\n\\t\\tthis.boundingSphere = null;\\r\\n\\r\\n\\t\\t// name\\r\\n\\r\\n\\t\\tthis.name = source.name;\\r\\n\\r\\n\\t\\t// index\\r\\n\\r\\n\\t\\tvar index = source.index;\\r\\n\\r\\n\\t\\tif ( index !== null ) {\\r\\n\\r\\n\\t\\t\\tthis.setIndex( index.clone() );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// attributes\\r\\n\\r\\n\\t\\tvar attributes = source.attributes;\\r\\n\\r\\n\\t\\tfor ( name in attributes ) {\\r\\n\\r\\n\\t\\t\\tvar attribute = attributes[ name ];\\r\\n\\t\\t\\tthis.setAttribute( name, attribute.clone() );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// morph attributes\\r\\n\\r\\n\\t\\tvar morphAttributes = source.morphAttributes;\\r\\n\\r\\n\\t\\tfor ( name in morphAttributes ) {\\r\\n\\r\\n\\t\\t\\tvar array = [];\\r\\n\\t\\t\\tvar morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\\r\\n\\r\\n\\t\\t\\tfor ( i = 0, l = morphAttribute.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tarray.push( morphAttribute[ i ].clone() );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.morphAttributes[ name ] = array;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.morphTargetsRelative = source.morphTargetsRelative;\\r\\n\\r\\n\\t\\t// groups\\r\\n\\r\\n\\t\\tvar groups = source.groups;\\r\\n\\r\\n\\t\\tfor ( i = 0, l = groups.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar group = groups[ i ];\\r\\n\\t\\t\\tthis.addGroup( group.start, group.count, group.materialIndex );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// bounding box\\r\\n\\r\\n\\t\\tvar boundingBox = source.boundingBox;\\r\\n\\r\\n\\t\\tif ( boundingBox !== null ) {\\r\\n\\r\\n\\t\\t\\tthis.boundingBox = boundingBox.clone();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// bounding sphere\\r\\n\\r\\n\\t\\tvar boundingSphere = source.boundingSphere;\\r\\n\\r\\n\\t\\tif ( boundingSphere !== null ) {\\r\\n\\r\\n\\t\\t\\tthis.boundingSphere = boundingSphere.clone();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// draw range\\r\\n\\r\\n\\t\\tthis.drawRange.start = source.drawRange.start;\\r\\n\\t\\tthis.drawRange.count = source.drawRange.count;\\r\\n\\r\\n\\t\\t// user data\\r\\n\\r\\n\\t\\tthis.userData = source.userData;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tdispose: function () {\\r\\n\\r\\n\\t\\tthis.dispatchEvent( { type: 'dispose' } );\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n * @author mikael emtinger / http://gomo.se/\\r\\n * @author jonobr1 / http://jonobr1.com/\\r\\n */\\r\\n\\r\\nvar _inverseMatrix = new Matrix4();\\r\\nvar _ray = new Ray();\\r\\nvar _sphere = new Sphere();\\r\\n\\r\\nvar _vA = new Vector3();\\r\\nvar _vB = new Vector3();\\r\\nvar _vC = new Vector3();\\r\\n\\r\\nvar _tempA = new Vector3();\\r\\nvar _tempB = new Vector3();\\r\\nvar _tempC = new Vector3();\\r\\n\\r\\nvar _morphA = new Vector3();\\r\\nvar _morphB = new Vector3();\\r\\nvar _morphC = new Vector3();\\r\\n\\r\\nvar _uvA = new Vector2();\\r\\nvar _uvB = new Vector2();\\r\\nvar _uvC = new Vector2();\\r\\n\\r\\nvar _intersectionPoint = new Vector3();\\r\\nvar _intersectionPointWorld = new Vector3();\\r\\n\\r\\nfunction Mesh( geometry, material ) {\\r\\n\\r\\n\\tObject3D.call( this );\\r\\n\\r\\n\\tthis.type = 'Mesh';\\r\\n\\r\\n\\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\\r\\n\\tthis.material = material !== undefined ? material : new MeshBasicMaterial();\\r\\n\\r\\n\\tthis.updateMorphTargets();\\r\\n\\r\\n}\\r\\n\\r\\nMesh.prototype = Object.assign( Object.create( Object3D.prototype ), {\\r\\n\\r\\n\\tconstructor: Mesh,\\r\\n\\r\\n\\tisMesh: true,\\r\\n\\r\\n\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\tObject3D.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\tif ( source.morphTargetInfluences !== undefined ) {\\r\\n\\r\\n\\t\\t\\tthis.morphTargetInfluences = source.morphTargetInfluences.slice();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( source.morphTargetDictionary !== undefined ) {\\r\\n\\r\\n\\t\\t\\tthis.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tupdateMorphTargets: function () {\\r\\n\\r\\n\\t\\tvar geometry = this.geometry;\\r\\n\\t\\tvar m, ml, name;\\r\\n\\r\\n\\t\\tif ( geometry.isBufferGeometry ) {\\r\\n\\r\\n\\t\\t\\tvar morphAttributes = geometry.morphAttributes;\\r\\n\\t\\t\\tvar keys = Object.keys( morphAttributes );\\r\\n\\r\\n\\t\\t\\tif ( keys.length > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tvar morphAttribute = morphAttributes[ keys[ 0 ] ];\\r\\n\\r\\n\\t\\t\\t\\tif ( morphAttribute !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.morphTargetInfluences = [];\\r\\n\\t\\t\\t\\t\\tthis.morphTargetDictionary = {};\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( m = 0, ml = morphAttribute.length; m < ml; m ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tname = morphAttribute[ m ].name || String( m );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tthis.morphTargetInfluences.push( 0 );\\r\\n\\t\\t\\t\\t\\t\\tthis.morphTargetDictionary[ name ] = m;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tvar morphTargets = geometry.morphTargets;\\r\\n\\r\\n\\t\\t\\tif ( morphTargets !== undefined && morphTargets.length > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.error( 'THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\traycast: function ( raycaster, intersects ) {\\r\\n\\r\\n\\t\\tvar geometry = this.geometry;\\r\\n\\t\\tvar material = this.material;\\r\\n\\t\\tvar matrixWorld = this.matrixWorld;\\r\\n\\r\\n\\t\\tif ( material === undefined ) return;\\r\\n\\r\\n\\t\\t// Checking boundingSphere distance to ray\\r\\n\\r\\n\\t\\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\\r\\n\\r\\n\\t\\t_sphere.copy( geometry.boundingSphere );\\r\\n\\t\\t_sphere.applyMatrix4( matrixWorld );\\r\\n\\r\\n\\t\\tif ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\t_inverseMatrix.getInverse( matrixWorld );\\r\\n\\t\\t_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );\\r\\n\\r\\n\\t\\t// Check boundingBox before continuing\\r\\n\\r\\n\\t\\tif ( geometry.boundingBox !== null ) {\\r\\n\\r\\n\\t\\t\\tif ( _ray.intersectsBox( geometry.boundingBox ) === false ) return;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar intersection;\\r\\n\\r\\n\\t\\tif ( geometry.isBufferGeometry ) {\\r\\n\\r\\n\\t\\t\\tvar a, b, c;\\r\\n\\t\\t\\tvar index = geometry.index;\\r\\n\\t\\t\\tvar position = geometry.attributes.position;\\r\\n\\t\\t\\tvar morphPosition = geometry.morphAttributes.position;\\r\\n\\t\\t\\tvar morphTargetsRelative = geometry.morphTargetsRelative;\\r\\n\\t\\t\\tvar uv = geometry.attributes.uv;\\r\\n\\t\\t\\tvar uv2 = geometry.attributes.uv2;\\r\\n\\t\\t\\tvar groups = geometry.groups;\\r\\n\\t\\t\\tvar drawRange = geometry.drawRange;\\r\\n\\t\\t\\tvar i, j, il, jl;\\r\\n\\t\\t\\tvar group, groupMaterial;\\r\\n\\t\\t\\tvar start, end;\\r\\n\\r\\n\\t\\t\\tif ( index !== null ) {\\r\\n\\r\\n\\t\\t\\t\\t// indexed buffer geometry\\r\\n\\r\\n\\t\\t\\t\\tif ( Array.isArray( material ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tgroup = groups[ i ];\\r\\n\\t\\t\\t\\t\\t\\tgroupMaterial = material[ group.materialIndex ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tstart = Math.max( group.start, drawRange.start );\\r\\n\\t\\t\\t\\t\\t\\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tfor ( j = start, jl = end; j < jl; j += 3 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\ta = index.getX( j );\\r\\n\\t\\t\\t\\t\\t\\t\\tb = index.getX( j + 1 );\\r\\n\\t\\t\\t\\t\\t\\t\\tc = index.getX( j + 2 );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tintersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( intersection ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tintersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tintersection.face.materialIndex = group.materialIndex;\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tintersects.push( intersection );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tstart = Math.max( 0, drawRange.start );\\r\\n\\t\\t\\t\\t\\tend = Math.min( index.count, ( drawRange.start + drawRange.count ) );\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( i = start, il = end; i < il; i += 3 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\ta = index.getX( i );\\r\\n\\t\\t\\t\\t\\t\\tb = index.getX( i + 1 );\\r\\n\\t\\t\\t\\t\\t\\tc = index.getX( i + 2 );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tintersection = checkBufferGeometryIntersection( this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( intersection ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics\\r\\n\\t\\t\\t\\t\\t\\t\\tintersects.push( intersection );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} else if ( position !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t// non-indexed buffer geometry\\r\\n\\r\\n\\t\\t\\t\\tif ( Array.isArray( material ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tgroup = groups[ i ];\\r\\n\\t\\t\\t\\t\\t\\tgroupMaterial = material[ group.materialIndex ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tstart = Math.max( group.start, drawRange.start );\\r\\n\\t\\t\\t\\t\\t\\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tfor ( j = start, jl = end; j < jl; j += 3 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\ta = j;\\r\\n\\t\\t\\t\\t\\t\\t\\tb = j + 1;\\r\\n\\t\\t\\t\\t\\t\\t\\tc = j + 2;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tintersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( intersection ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tintersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tintersection.face.materialIndex = group.materialIndex;\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tintersects.push( intersection );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tstart = Math.max( 0, drawRange.start );\\r\\n\\t\\t\\t\\t\\tend = Math.min( position.count, ( drawRange.start + drawRange.count ) );\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( i = start, il = end; i < il; i += 3 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\ta = i;\\r\\n\\t\\t\\t\\t\\t\\tb = i + 1;\\r\\n\\t\\t\\t\\t\\t\\tc = i + 2;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tintersection = checkBufferGeometryIntersection( this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( intersection ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics\\r\\n\\t\\t\\t\\t\\t\\t\\tintersects.push( intersection );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t} else if ( geometry.isGeometry ) {\\r\\n\\r\\n\\t\\t\\tvar fvA, fvB, fvC;\\r\\n\\t\\t\\tvar isMultiMaterial = Array.isArray( material );\\r\\n\\r\\n\\t\\t\\tvar vertices = geometry.vertices;\\r\\n\\t\\t\\tvar faces = geometry.faces;\\r\\n\\t\\t\\tvar uvs;\\r\\n\\r\\n\\t\\t\\tvar faceVertexUvs = geometry.faceVertexUvs[ 0 ];\\r\\n\\t\\t\\tif ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;\\r\\n\\r\\n\\t\\t\\tfor ( var f = 0, fl = faces.length; f < fl; f ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar face = faces[ f ];\\r\\n\\t\\t\\t\\tvar faceMaterial = isMultiMaterial ? material[ face.materialIndex ] : material;\\r\\n\\r\\n\\t\\t\\t\\tif ( faceMaterial === undefined ) continue;\\r\\n\\r\\n\\t\\t\\t\\tfvA = vertices[ face.a ];\\r\\n\\t\\t\\t\\tfvB = vertices[ face.b ];\\r\\n\\t\\t\\t\\tfvC = vertices[ face.c ];\\r\\n\\r\\n\\t\\t\\t\\tintersection = checkIntersection( this, faceMaterial, raycaster, _ray, fvA, fvB, fvC, _intersectionPoint );\\r\\n\\r\\n\\t\\t\\t\\tif ( intersection ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( uvs && uvs[ f ] ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar uvs_f = uvs[ f ];\\r\\n\\t\\t\\t\\t\\t\\t_uvA.copy( uvs_f[ 0 ] );\\r\\n\\t\\t\\t\\t\\t\\t_uvB.copy( uvs_f[ 1 ] );\\r\\n\\t\\t\\t\\t\\t\\t_uvC.copy( uvs_f[ 2 ] );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tintersection.uv = Triangle.getUV( _intersectionPoint, fvA, fvB, fvC, _uvA, _uvB, _uvC, new Vector2() );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tintersection.face = face;\\r\\n\\t\\t\\t\\t\\tintersection.faceIndex = f;\\r\\n\\t\\t\\t\\t\\tintersects.push( intersection );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclone: function () {\\r\\n\\r\\n\\t\\treturn new this.constructor( this.geometry, this.material ).copy( this );\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nfunction checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {\\r\\n\\r\\n\\tvar intersect;\\r\\n\\r\\n\\tif ( material.side === BackSide ) {\\r\\n\\r\\n\\t\\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\\r\\n\\r\\n\\t} else {\\r\\n\\r\\n\\t\\tintersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tif ( intersect === null ) return null;\\r\\n\\r\\n\\t_intersectionPointWorld.copy( point );\\r\\n\\t_intersectionPointWorld.applyMatrix4( object.matrixWorld );\\r\\n\\r\\n\\tvar distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );\\r\\n\\r\\n\\tif ( distance < raycaster.near || distance > raycaster.far ) return null;\\r\\n\\r\\n\\treturn {\\r\\n\\t\\tdistance: distance,\\r\\n\\t\\tpoint: _intersectionPointWorld.clone(),\\r\\n\\t\\tobject: object\\r\\n\\t};\\r\\n\\r\\n}\\r\\n\\r\\nfunction checkBufferGeometryIntersection( object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c ) {\\r\\n\\r\\n\\t_vA.fromBufferAttribute( position, a );\\r\\n\\t_vB.fromBufferAttribute( position, b );\\r\\n\\t_vC.fromBufferAttribute( position, c );\\r\\n\\r\\n\\tvar morphInfluences = object.morphTargetInfluences;\\r\\n\\r\\n\\tif ( material.morphTargets && morphPosition && morphInfluences ) {\\r\\n\\r\\n\\t\\t_morphA.set( 0, 0, 0 );\\r\\n\\t\\t_morphB.set( 0, 0, 0 );\\r\\n\\t\\t_morphC.set( 0, 0, 0 );\\r\\n\\r\\n\\t\\tfor ( var i = 0, il = morphPosition.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar influence = morphInfluences[ i ];\\r\\n\\t\\t\\tvar morphAttribute = morphPosition[ i ];\\r\\n\\r\\n\\t\\t\\tif ( influence === 0 ) continue;\\r\\n\\r\\n\\t\\t\\t_tempA.fromBufferAttribute( morphAttribute, a );\\r\\n\\t\\t\\t_tempB.fromBufferAttribute( morphAttribute, b );\\r\\n\\t\\t\\t_tempC.fromBufferAttribute( morphAttribute, c );\\r\\n\\r\\n\\t\\t\\tif ( morphTargetsRelative ) {\\r\\n\\r\\n\\t\\t\\t\\t_morphA.addScaledVector( _tempA, influence );\\r\\n\\t\\t\\t\\t_morphB.addScaledVector( _tempB, influence );\\r\\n\\t\\t\\t\\t_morphC.addScaledVector( _tempC, influence );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t_morphA.addScaledVector( _tempA.sub( _vA ), influence );\\r\\n\\t\\t\\t\\t_morphB.addScaledVector( _tempB.sub( _vB ), influence );\\r\\n\\t\\t\\t\\t_morphC.addScaledVector( _tempC.sub( _vC ), influence );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t_vA.add( _morphA );\\r\\n\\t\\t_vB.add( _morphB );\\r\\n\\t\\t_vC.add( _morphC );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tif ( object.isSkinnedMesh ) {\\r\\n\\r\\n\\t\\tobject.boneTransform( a, _vA );\\r\\n\\t\\tobject.boneTransform( b, _vB );\\r\\n\\t\\tobject.boneTransform( c, _vC );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tvar intersection = checkIntersection( object, material, raycaster, ray, _vA, _vB, _vC, _intersectionPoint );\\r\\n\\r\\n\\tif ( intersection ) {\\r\\n\\r\\n\\t\\tif ( uv ) {\\r\\n\\r\\n\\t\\t\\t_uvA.fromBufferAttribute( uv, a );\\r\\n\\t\\t\\t_uvB.fromBufferAttribute( uv, b );\\r\\n\\t\\t\\t_uvC.fromBufferAttribute( uv, c );\\r\\n\\r\\n\\t\\t\\tintersection.uv = Triangle.getUV( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( uv2 ) {\\r\\n\\r\\n\\t\\t\\t_uvA.fromBufferAttribute( uv2, a );\\r\\n\\t\\t\\t_uvB.fromBufferAttribute( uv2, b );\\r\\n\\t\\t\\t_uvC.fromBufferAttribute( uv2, c );\\r\\n\\r\\n\\t\\t\\tintersection.uv2 = Triangle.getUV( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar face = new Face3( a, b, c );\\r\\n\\t\\tTriangle.getNormal( _vA, _vB, _vC, face.normal );\\r\\n\\r\\n\\t\\tintersection.face = face;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn intersection;\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n * @author kile / http://kile.stravaganza.org/\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n * @author mikael emtinger / http://gomo.se/\\r\\n * @author zz85 / http://www.lab4games.net/zz85/blog\\r\\n * @author bhouston / http://clara.io\\r\\n */\\r\\n\\r\\nvar _geometryId = 0; // Geometry uses even numbers as Id\\r\\nvar _m1$3 = new Matrix4();\\r\\nvar _obj$1 = new Object3D();\\r\\nvar _offset$1 = new Vector3();\\r\\n\\r\\nfunction Geometry() {\\r\\n\\r\\n\\tObject.defineProperty( this, 'id', { value: _geometryId += 2 } );\\r\\n\\r\\n\\tthis.uuid = MathUtils.generateUUID();\\r\\n\\r\\n\\tthis.name = '';\\r\\n\\tthis.type = 'Geometry';\\r\\n\\r\\n\\tthis.vertices = [];\\r\\n\\tthis.colors = [];\\r\\n\\tthis.faces = [];\\r\\n\\tthis.faceVertexUvs = [[]];\\r\\n\\r\\n\\tthis.morphTargets = [];\\r\\n\\tthis.morphNormals = [];\\r\\n\\r\\n\\tthis.skinWeights = [];\\r\\n\\tthis.skinIndices = [];\\r\\n\\r\\n\\tthis.lineDistances = [];\\r\\n\\r\\n\\tthis.boundingBox = null;\\r\\n\\tthis.boundingSphere = null;\\r\\n\\r\\n\\t// update flags\\r\\n\\r\\n\\tthis.elementsNeedUpdate = false;\\r\\n\\tthis.verticesNeedUpdate = false;\\r\\n\\tthis.uvsNeedUpdate = false;\\r\\n\\tthis.normalsNeedUpdate = false;\\r\\n\\tthis.colorsNeedUpdate = false;\\r\\n\\tthis.lineDistancesNeedUpdate = false;\\r\\n\\tthis.groupsNeedUpdate = false;\\r\\n\\r\\n}\\r\\n\\r\\nGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\\r\\n\\r\\n\\tconstructor: Geometry,\\r\\n\\r\\n\\tisGeometry: true,\\r\\n\\r\\n\\tapplyMatrix4: function ( matrix ) {\\r\\n\\r\\n\\t\\tvar normalMatrix = new Matrix3().getNormalMatrix( matrix );\\r\\n\\r\\n\\t\\tfor ( var i = 0, il = this.vertices.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar vertex = this.vertices[ i ];\\r\\n\\t\\t\\tvertex.applyMatrix4( matrix );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfor ( var i = 0, il = this.faces.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar face = this.faces[ i ];\\r\\n\\t\\t\\tface.normal.applyMatrix3( normalMatrix ).normalize();\\r\\n\\r\\n\\t\\t\\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tface.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( this.boundingBox !== null ) {\\r\\n\\r\\n\\t\\t\\tthis.computeBoundingBox();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( this.boundingSphere !== null ) {\\r\\n\\r\\n\\t\\t\\tthis.computeBoundingSphere();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.verticesNeedUpdate = true;\\r\\n\\t\\tthis.normalsNeedUpdate = true;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\trotateX: function ( angle ) {\\r\\n\\r\\n\\t\\t// rotate geometry around world x-axis\\r\\n\\r\\n\\t\\t_m1$3.makeRotationX( angle );\\r\\n\\r\\n\\t\\tthis.applyMatrix4( _m1$3 );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\trotateY: function ( angle ) {\\r\\n\\r\\n\\t\\t// rotate geometry around world y-axis\\r\\n\\r\\n\\t\\t_m1$3.makeRotationY( angle );\\r\\n\\r\\n\\t\\tthis.applyMatrix4( _m1$3 );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\trotateZ: function ( angle ) {\\r\\n\\r\\n\\t\\t// rotate geometry around world z-axis\\r\\n\\r\\n\\t\\t_m1$3.makeRotationZ( angle );\\r\\n\\r\\n\\t\\tthis.applyMatrix4( _m1$3 );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttranslate: function ( x, y, z ) {\\r\\n\\r\\n\\t\\t// translate geometry\\r\\n\\r\\n\\t\\t_m1$3.makeTranslation( x, y, z );\\r\\n\\r\\n\\t\\tthis.applyMatrix4( _m1$3 );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tscale: function ( x, y, z ) {\\r\\n\\r\\n\\t\\t// scale geometry\\r\\n\\r\\n\\t\\t_m1$3.makeScale( x, y, z );\\r\\n\\r\\n\\t\\tthis.applyMatrix4( _m1$3 );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tlookAt: function ( vector ) {\\r\\n\\r\\n\\t\\t_obj$1.lookAt( vector );\\r\\n\\r\\n\\t\\t_obj$1.updateMatrix();\\r\\n\\r\\n\\t\\tthis.applyMatrix4( _obj$1.matrix );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tfromBufferGeometry: function ( geometry ) {\\r\\n\\r\\n\\t\\tvar scope = this;\\r\\n\\r\\n\\t\\tvar indices = geometry.index !== null ? geometry.index.array : undefined;\\r\\n\\t\\tvar attributes = geometry.attributes;\\r\\n\\r\\n\\t\\tif ( attributes.position === undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.error( 'THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.' );\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar positions = attributes.position.array;\\r\\n\\t\\tvar normals = attributes.normal !== undefined ? attributes.normal.array : undefined;\\r\\n\\t\\tvar colors = attributes.color !== undefined ? attributes.color.array : undefined;\\r\\n\\t\\tvar uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;\\r\\n\\t\\tvar uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;\\r\\n\\r\\n\\t\\tif ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < positions.length; i += 3 ) {\\r\\n\\r\\n\\t\\t\\tscope.vertices.push( new Vector3().fromArray( positions, i ) );\\r\\n\\r\\n\\t\\t\\tif ( colors !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tscope.colors.push( new Color().fromArray( colors, i ) );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction addFace( a, b, c, materialIndex ) {\\r\\n\\r\\n\\t\\t\\tvar vertexColors = ( colors === undefined ) ? [] : [\\r\\n\\t\\t\\t\\tscope.colors[ a ].clone(),\\r\\n\\t\\t\\t\\tscope.colors[ b ].clone(),\\r\\n\\t\\t\\t\\tscope.colors[ c ].clone() ];\\r\\n\\r\\n\\t\\t\\tvar vertexNormals = ( normals === undefined ) ? [] : [\\r\\n\\t\\t\\t\\tnew Vector3().fromArray( normals, a * 3 ),\\r\\n\\t\\t\\t\\tnew Vector3().fromArray( normals, b * 3 ),\\r\\n\\t\\t\\t\\tnew Vector3().fromArray( normals, c * 3 )\\r\\n\\t\\t\\t];\\r\\n\\r\\n\\t\\t\\tvar face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );\\r\\n\\r\\n\\t\\t\\tscope.faces.push( face );\\r\\n\\r\\n\\t\\t\\tif ( uvs !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tscope.faceVertexUvs[ 0 ].push( [\\r\\n\\t\\t\\t\\t\\tnew Vector2().fromArray( uvs, a * 2 ),\\r\\n\\t\\t\\t\\t\\tnew Vector2().fromArray( uvs, b * 2 ),\\r\\n\\t\\t\\t\\t\\tnew Vector2().fromArray( uvs, c * 2 )\\r\\n\\t\\t\\t\\t] );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( uvs2 !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tscope.faceVertexUvs[ 1 ].push( [\\r\\n\\t\\t\\t\\t\\tnew Vector2().fromArray( uvs2, a * 2 ),\\r\\n\\t\\t\\t\\t\\tnew Vector2().fromArray( uvs2, b * 2 ),\\r\\n\\t\\t\\t\\t\\tnew Vector2().fromArray( uvs2, c * 2 )\\r\\n\\t\\t\\t\\t] );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar groups = geometry.groups;\\r\\n\\r\\n\\t\\tif ( groups.length > 0 ) {\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < groups.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar group = groups[ i ];\\r\\n\\r\\n\\t\\t\\t\\tvar start = group.start;\\r\\n\\t\\t\\t\\tvar count = group.count;\\r\\n\\r\\n\\t\\t\\t\\tfor ( var j = start, jl = start + count; j < jl; j += 3 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( indices !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\taddFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex );\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\taddFace( j, j + 1, j + 2, group.materialIndex );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tif ( indices !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0; i < indices.length; i += 3 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\taddFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0; i < positions.length / 3; i += 3 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\taddFace( i, i + 1, i + 2 );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.computeFaceNormals();\\r\\n\\r\\n\\t\\tif ( geometry.boundingBox !== null ) {\\r\\n\\r\\n\\t\\t\\tthis.boundingBox = geometry.boundingBox.clone();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( geometry.boundingSphere !== null ) {\\r\\n\\r\\n\\t\\t\\tthis.boundingSphere = geometry.boundingSphere.clone();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcenter: function () {\\r\\n\\r\\n\\t\\tthis.computeBoundingBox();\\r\\n\\r\\n\\t\\tthis.boundingBox.getCenter( _offset$1 ).negate();\\r\\n\\r\\n\\t\\tthis.translate( _offset$1.x, _offset$1.y, _offset$1.z );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tnormalize: function () {\\r\\n\\r\\n\\t\\tthis.computeBoundingSphere();\\r\\n\\r\\n\\t\\tvar center = this.boundingSphere.center;\\r\\n\\t\\tvar radius = this.boundingSphere.radius;\\r\\n\\r\\n\\t\\tvar s = radius === 0 ? 1 : 1.0 / radius;\\r\\n\\r\\n\\t\\tvar matrix = new Matrix4();\\r\\n\\t\\tmatrix.set(\\r\\n\\t\\t\\ts, 0, 0, - s * center.x,\\r\\n\\t\\t\\t0, s, 0, - s * center.y,\\r\\n\\t\\t\\t0, 0, s, - s * center.z,\\r\\n\\t\\t\\t0, 0, 0, 1\\r\\n\\t\\t);\\r\\n\\r\\n\\t\\tthis.applyMatrix4( matrix );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcomputeFaceNormals: function () {\\r\\n\\r\\n\\t\\tvar cb = new Vector3(), ab = new Vector3();\\r\\n\\r\\n\\t\\tfor ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {\\r\\n\\r\\n\\t\\t\\tvar face = this.faces[ f ];\\r\\n\\r\\n\\t\\t\\tvar vA = this.vertices[ face.a ];\\r\\n\\t\\t\\tvar vB = this.vertices[ face.b ];\\r\\n\\t\\t\\tvar vC = this.vertices[ face.c ];\\r\\n\\r\\n\\t\\t\\tcb.subVectors( vC, vB );\\r\\n\\t\\t\\tab.subVectors( vA, vB );\\r\\n\\t\\t\\tcb.cross( ab );\\r\\n\\r\\n\\t\\t\\tcb.normalize();\\r\\n\\r\\n\\t\\t\\tface.normal.copy( cb );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcomputeVertexNormals: function ( areaWeighted ) {\\r\\n\\r\\n\\t\\tif ( areaWeighted === undefined ) areaWeighted = true;\\r\\n\\r\\n\\t\\tvar v, vl, f, fl, face, vertices;\\r\\n\\r\\n\\t\\tvertices = new Array( this.vertices.length );\\r\\n\\r\\n\\t\\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\\r\\n\\r\\n\\t\\t\\tvertices[ v ] = new Vector3();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( areaWeighted ) {\\r\\n\\r\\n\\t\\t\\t// vertex normals weighted by triangle areas\\r\\n\\t\\t\\t// http://www.iquilezles.org/www/articles/normals/normals.htm\\r\\n\\r\\n\\t\\t\\tvar vA, vB, vC;\\r\\n\\t\\t\\tvar cb = new Vector3(), ab = new Vector3();\\r\\n\\r\\n\\t\\t\\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tface = this.faces[ f ];\\r\\n\\r\\n\\t\\t\\t\\tvA = this.vertices[ face.a ];\\r\\n\\t\\t\\t\\tvB = this.vertices[ face.b ];\\r\\n\\t\\t\\t\\tvC = this.vertices[ face.c ];\\r\\n\\r\\n\\t\\t\\t\\tcb.subVectors( vC, vB );\\r\\n\\t\\t\\t\\tab.subVectors( vA, vB );\\r\\n\\t\\t\\t\\tcb.cross( ab );\\r\\n\\r\\n\\t\\t\\t\\tvertices[ face.a ].add( cb );\\r\\n\\t\\t\\t\\tvertices[ face.b ].add( cb );\\r\\n\\t\\t\\t\\tvertices[ face.c ].add( cb );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tthis.computeFaceNormals();\\r\\n\\r\\n\\t\\t\\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tface = this.faces[ f ];\\r\\n\\r\\n\\t\\t\\t\\tvertices[ face.a ].add( face.normal );\\r\\n\\t\\t\\t\\tvertices[ face.b ].add( face.normal );\\r\\n\\t\\t\\t\\tvertices[ face.c ].add( face.normal );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\\r\\n\\r\\n\\t\\t\\tvertices[ v ].normalize();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\\r\\n\\r\\n\\t\\t\\tface = this.faces[ f ];\\r\\n\\r\\n\\t\\t\\tvar vertexNormals = face.vertexNormals;\\r\\n\\r\\n\\t\\t\\tif ( vertexNormals.length === 3 ) {\\r\\n\\r\\n\\t\\t\\t\\tvertexNormals[ 0 ].copy( vertices[ face.a ] );\\r\\n\\t\\t\\t\\tvertexNormals[ 1 ].copy( vertices[ face.b ] );\\r\\n\\t\\t\\t\\tvertexNormals[ 2 ].copy( vertices[ face.c ] );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tvertexNormals[ 0 ] = vertices[ face.a ].clone();\\r\\n\\t\\t\\t\\tvertexNormals[ 1 ] = vertices[ face.b ].clone();\\r\\n\\t\\t\\t\\tvertexNormals[ 2 ] = vertices[ face.c ].clone();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( this.faces.length > 0 ) {\\r\\n\\r\\n\\t\\t\\tthis.normalsNeedUpdate = true;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcomputeFlatVertexNormals: function () {\\r\\n\\r\\n\\t\\tvar f, fl, face;\\r\\n\\r\\n\\t\\tthis.computeFaceNormals();\\r\\n\\r\\n\\t\\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\\r\\n\\r\\n\\t\\t\\tface = this.faces[ f ];\\r\\n\\r\\n\\t\\t\\tvar vertexNormals = face.vertexNormals;\\r\\n\\r\\n\\t\\t\\tif ( vertexNormals.length === 3 ) {\\r\\n\\r\\n\\t\\t\\t\\tvertexNormals[ 0 ].copy( face.normal );\\r\\n\\t\\t\\t\\tvertexNormals[ 1 ].copy( face.normal );\\r\\n\\t\\t\\t\\tvertexNormals[ 2 ].copy( face.normal );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tvertexNormals[ 0 ] = face.normal.clone();\\r\\n\\t\\t\\t\\tvertexNormals[ 1 ] = face.normal.clone();\\r\\n\\t\\t\\t\\tvertexNormals[ 2 ] = face.normal.clone();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( this.faces.length > 0 ) {\\r\\n\\r\\n\\t\\t\\tthis.normalsNeedUpdate = true;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcomputeMorphNormals: function () {\\r\\n\\r\\n\\t\\tvar i, il, f, fl, face;\\r\\n\\r\\n\\t\\t// save original normals\\r\\n\\t\\t// - create temp variables on first access\\r\\n\\t\\t//   otherwise just copy (for faster repeated calls)\\r\\n\\r\\n\\t\\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\\r\\n\\r\\n\\t\\t\\tface = this.faces[ f ];\\r\\n\\r\\n\\t\\t\\tif ( ! face.__originalFaceNormal ) {\\r\\n\\r\\n\\t\\t\\t\\tface.__originalFaceNormal = face.normal.clone();\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tface.__originalFaceNormal.copy( face.normal );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\\r\\n\\r\\n\\t\\t\\tfor ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( ! face.__originalVertexNormals[ i ] ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tface.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tface.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// use temp geometry to compute face and vertex normals for each morph\\r\\n\\r\\n\\t\\tvar tmpGeo = new Geometry();\\r\\n\\t\\ttmpGeo.faces = this.faces;\\r\\n\\r\\n\\t\\tfor ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t// create on first access\\r\\n\\r\\n\\t\\t\\tif ( ! this.morphNormals[ i ] ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.morphNormals[ i ] = {};\\r\\n\\t\\t\\t\\tthis.morphNormals[ i ].faceNormals = [];\\r\\n\\t\\t\\t\\tthis.morphNormals[ i ].vertexNormals = [];\\r\\n\\r\\n\\t\\t\\t\\tvar dstNormalsFace = this.morphNormals[ i ].faceNormals;\\r\\n\\t\\t\\t\\tvar dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\\r\\n\\r\\n\\t\\t\\t\\tvar faceNormal, vertexNormals;\\r\\n\\r\\n\\t\\t\\t\\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tfaceNormal = new Vector3();\\r\\n\\t\\t\\t\\t\\tvertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };\\r\\n\\r\\n\\t\\t\\t\\t\\tdstNormalsFace.push( faceNormal );\\r\\n\\t\\t\\t\\t\\tdstNormalsVertex.push( vertexNormals );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar morphNormals = this.morphNormals[ i ];\\r\\n\\r\\n\\t\\t\\t// set vertices to morph target\\r\\n\\r\\n\\t\\t\\ttmpGeo.vertices = this.morphTargets[ i ].vertices;\\r\\n\\r\\n\\t\\t\\t// compute morph normals\\r\\n\\r\\n\\t\\t\\ttmpGeo.computeFaceNormals();\\r\\n\\t\\t\\ttmpGeo.computeVertexNormals();\\r\\n\\r\\n\\t\\t\\t// store morph normals\\r\\n\\r\\n\\t\\t\\tvar faceNormal, vertexNormals;\\r\\n\\r\\n\\t\\t\\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tface = this.faces[ f ];\\r\\n\\r\\n\\t\\t\\t\\tfaceNormal = morphNormals.faceNormals[ f ];\\r\\n\\t\\t\\t\\tvertexNormals = morphNormals.vertexNormals[ f ];\\r\\n\\r\\n\\t\\t\\t\\tfaceNormal.copy( face.normal );\\r\\n\\r\\n\\t\\t\\t\\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\\r\\n\\t\\t\\t\\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\\r\\n\\t\\t\\t\\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// restore original normals\\r\\n\\r\\n\\t\\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\\r\\n\\r\\n\\t\\t\\tface = this.faces[ f ];\\r\\n\\r\\n\\t\\t\\tface.normal = face.__originalFaceNormal;\\r\\n\\t\\t\\tface.vertexNormals = face.__originalVertexNormals;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcomputeBoundingBox: function () {\\r\\n\\r\\n\\t\\tif ( this.boundingBox === null ) {\\r\\n\\r\\n\\t\\t\\tthis.boundingBox = new Box3();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.boundingBox.setFromPoints( this.vertices );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcomputeBoundingSphere: function () {\\r\\n\\r\\n\\t\\tif ( this.boundingSphere === null ) {\\r\\n\\r\\n\\t\\t\\tthis.boundingSphere = new Sphere();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.boundingSphere.setFromPoints( this.vertices );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tmerge: function ( geometry, matrix, materialIndexOffset ) {\\r\\n\\r\\n\\t\\tif ( ! ( geometry && geometry.isGeometry ) ) {\\r\\n\\r\\n\\t\\t\\tconsole.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );\\r\\n\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar normalMatrix,\\r\\n\\t\\t\\tvertexOffset = this.vertices.length,\\r\\n\\t\\t\\tvertices1 = this.vertices,\\r\\n\\t\\t\\tvertices2 = geometry.vertices,\\r\\n\\t\\t\\tfaces1 = this.faces,\\r\\n\\t\\t\\tfaces2 = geometry.faces,\\r\\n\\t\\t\\tcolors1 = this.colors,\\r\\n\\t\\t\\tcolors2 = geometry.colors;\\r\\n\\r\\n\\t\\tif ( materialIndexOffset === undefined ) materialIndexOffset = 0;\\r\\n\\r\\n\\t\\tif ( matrix !== undefined ) {\\r\\n\\r\\n\\t\\t\\tnormalMatrix = new Matrix3().getNormalMatrix( matrix );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// vertices\\r\\n\\r\\n\\t\\tfor ( var i = 0, il = vertices2.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar vertex = vertices2[ i ];\\r\\n\\r\\n\\t\\t\\tvar vertexCopy = vertex.clone();\\r\\n\\r\\n\\t\\t\\tif ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );\\r\\n\\r\\n\\t\\t\\tvertices1.push( vertexCopy );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// colors\\r\\n\\r\\n\\t\\tfor ( var i = 0, il = colors2.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\tcolors1.push( colors2[ i ].clone() );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// faces\\r\\n\\r\\n\\t\\tfor ( i = 0, il = faces2.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar face = faces2[ i ], faceCopy, normal, color,\\r\\n\\t\\t\\t\\tfaceVertexNormals = face.vertexNormals,\\r\\n\\t\\t\\t\\tfaceVertexColors = face.vertexColors;\\r\\n\\r\\n\\t\\t\\tfaceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\\r\\n\\t\\t\\tfaceCopy.normal.copy( face.normal );\\r\\n\\r\\n\\t\\t\\tif ( normalMatrix !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tfaceCopy.normal.applyMatrix3( normalMatrix ).normalize();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tfor ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tnormal = faceVertexNormals[ j ].clone();\\r\\n\\r\\n\\t\\t\\t\\tif ( normalMatrix !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tnormal.applyMatrix3( normalMatrix ).normalize();\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tfaceCopy.vertexNormals.push( normal );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tfaceCopy.color.copy( face.color );\\r\\n\\r\\n\\t\\t\\tfor ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tcolor = faceVertexColors[ j ];\\r\\n\\t\\t\\t\\tfaceCopy.vertexColors.push( color.clone() );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tfaceCopy.materialIndex = face.materialIndex + materialIndexOffset;\\r\\n\\r\\n\\t\\t\\tfaces1.push( faceCopy );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// uvs\\r\\n\\r\\n\\t\\tfor ( var i = 0, il = geometry.faceVertexUvs.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar faceVertexUvs2 = geometry.faceVertexUvs[ i ];\\r\\n\\r\\n\\t\\t\\tif ( this.faceVertexUvs[ i ] === undefined ) this.faceVertexUvs[ i ] = [];\\r\\n\\r\\n\\t\\t\\tfor ( var j = 0, jl = faceVertexUvs2.length; j < jl; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar uvs2 = faceVertexUvs2[ j ], uvsCopy = [];\\r\\n\\r\\n\\t\\t\\t\\tfor ( var k = 0, kl = uvs2.length; k < kl; k ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tuvsCopy.push( uvs2[ k ].clone() );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tthis.faceVertexUvs[ i ].push( uvsCopy );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tmergeMesh: function ( mesh ) {\\r\\n\\r\\n\\t\\tif ( ! ( mesh && mesh.isMesh ) ) {\\r\\n\\r\\n\\t\\t\\tconsole.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );\\r\\n\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( mesh.matrixAutoUpdate ) mesh.updateMatrix();\\r\\n\\r\\n\\t\\tthis.merge( mesh.geometry, mesh.matrix );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t/*\\r\\n\\t * Checks for duplicate vertices with hashmap.\\r\\n\\t * Duplicated vertices are removed\\r\\n\\t * and faces' vertices are updated.\\r\\n\\t */\\r\\n\\r\\n\\tmergeVertices: function () {\\r\\n\\r\\n\\t\\tvar verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\\r\\n\\t\\tvar unique = [], changes = [];\\r\\n\\r\\n\\t\\tvar v, key;\\r\\n\\t\\tvar precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\\r\\n\\t\\tvar precision = Math.pow( 10, precisionPoints );\\r\\n\\t\\tvar i, il, face;\\r\\n\\t\\tvar indices, j, jl;\\r\\n\\r\\n\\t\\tfor ( i = 0, il = this.vertices.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\tv = this.vertices[ i ];\\r\\n\\t\\t\\tkey = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\\r\\n\\r\\n\\t\\t\\tif ( verticesMap[ key ] === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tverticesMap[ key ] = i;\\r\\n\\t\\t\\t\\tunique.push( this.vertices[ i ] );\\r\\n\\t\\t\\t\\tchanges[ i ] = unique.length - 1;\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\\r\\n\\t\\t\\t\\tchanges[ i ] = changes[ verticesMap[ key ] ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\r\\n\\t\\t// if faces are completely degenerate after merging vertices, we\\r\\n\\t\\t// have to remove them from the geometry.\\r\\n\\t\\tvar faceIndicesToRemove = [];\\r\\n\\r\\n\\t\\tfor ( i = 0, il = this.faces.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\tface = this.faces[ i ];\\r\\n\\r\\n\\t\\t\\tface.a = changes[ face.a ];\\r\\n\\t\\t\\tface.b = changes[ face.b ];\\r\\n\\t\\t\\tface.c = changes[ face.c ];\\r\\n\\r\\n\\t\\t\\tindices = [ face.a, face.b, face.c ];\\r\\n\\r\\n\\t\\t\\t// if any duplicate vertices are found in a Face3\\r\\n\\t\\t\\t// we have to remove the face as nothing can be saved\\r\\n\\t\\t\\tfor ( var n = 0; n < 3; n ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tfaceIndicesToRemove.push( i );\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfor ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\\r\\n\\r\\n\\t\\t\\tvar idx = faceIndicesToRemove[ i ];\\r\\n\\r\\n\\t\\t\\tthis.faces.splice( idx, 1 );\\r\\n\\r\\n\\t\\t\\tfor ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.faceVertexUvs[ j ].splice( idx, 1 );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Use unique set of vertices\\r\\n\\r\\n\\t\\tvar diff = this.vertices.length - unique.length;\\r\\n\\t\\tthis.vertices = unique;\\r\\n\\t\\treturn diff;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetFromPoints: function ( points ) {\\r\\n\\r\\n\\t\\tthis.vertices = [];\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar point = points[ i ];\\r\\n\\t\\t\\tthis.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsortFacesByMaterialIndex: function () {\\r\\n\\r\\n\\t\\tvar faces = this.faces;\\r\\n\\t\\tvar length = faces.length;\\r\\n\\r\\n\\t\\t// tag faces\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < length; i ++ ) {\\r\\n\\r\\n\\t\\t\\tfaces[ i ]._id = i;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// sort faces\\r\\n\\r\\n\\t\\tfunction materialIndexSort( a, b ) {\\r\\n\\r\\n\\t\\t\\treturn a.materialIndex - b.materialIndex;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfaces.sort( materialIndexSort );\\r\\n\\r\\n\\t\\t// sort uvs\\r\\n\\r\\n\\t\\tvar uvs1 = this.faceVertexUvs[ 0 ];\\r\\n\\t\\tvar uvs2 = this.faceVertexUvs[ 1 ];\\r\\n\\r\\n\\t\\tvar newUvs1, newUvs2;\\r\\n\\r\\n\\t\\tif ( uvs1 && uvs1.length === length ) newUvs1 = [];\\r\\n\\t\\tif ( uvs2 && uvs2.length === length ) newUvs2 = [];\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < length; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar id = faces[ i ]._id;\\r\\n\\r\\n\\t\\t\\tif ( newUvs1 ) newUvs1.push( uvs1[ id ] );\\r\\n\\t\\t\\tif ( newUvs2 ) newUvs2.push( uvs2[ id ] );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;\\r\\n\\t\\tif ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttoJSON: function () {\\r\\n\\r\\n\\t\\tvar data = {\\r\\n\\t\\t\\tmetadata: {\\r\\n\\t\\t\\t\\tversion: 4.5,\\r\\n\\t\\t\\t\\ttype: 'Geometry',\\r\\n\\t\\t\\t\\tgenerator: 'Geometry.toJSON'\\r\\n\\t\\t\\t}\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\t// standard Geometry serialization\\r\\n\\r\\n\\t\\tdata.uuid = this.uuid;\\r\\n\\t\\tdata.type = this.type;\\r\\n\\t\\tif ( this.name !== '' ) data.name = this.name;\\r\\n\\r\\n\\t\\tif ( this.parameters !== undefined ) {\\r\\n\\r\\n\\t\\t\\tvar parameters = this.parameters;\\r\\n\\r\\n\\t\\t\\tfor ( var key in parameters ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn data;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar vertices = [];\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < this.vertices.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar vertex = this.vertices[ i ];\\r\\n\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar faces = [];\\r\\n\\t\\tvar normals = [];\\r\\n\\t\\tvar normalsHash = {};\\r\\n\\t\\tvar colors = [];\\r\\n\\t\\tvar colorsHash = {};\\r\\n\\t\\tvar uvs = [];\\r\\n\\t\\tvar uvsHash = {};\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < this.faces.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar face = this.faces[ i ];\\r\\n\\r\\n\\t\\t\\tvar hasMaterial = true;\\r\\n\\t\\t\\tvar hasFaceUv = false; // deprecated\\r\\n\\t\\t\\tvar hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;\\r\\n\\t\\t\\tvar hasFaceNormal = face.normal.length() > 0;\\r\\n\\t\\t\\tvar hasFaceVertexNormal = face.vertexNormals.length > 0;\\r\\n\\t\\t\\tvar hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\\r\\n\\t\\t\\tvar hasFaceVertexColor = face.vertexColors.length > 0;\\r\\n\\r\\n\\t\\t\\tvar faceType = 0;\\r\\n\\r\\n\\t\\t\\tfaceType = setBit( faceType, 0, 0 ); // isQuad\\r\\n\\t\\t\\tfaceType = setBit( faceType, 1, hasMaterial );\\r\\n\\t\\t\\tfaceType = setBit( faceType, 2, hasFaceUv );\\r\\n\\t\\t\\tfaceType = setBit( faceType, 3, hasFaceVertexUv );\\r\\n\\t\\t\\tfaceType = setBit( faceType, 4, hasFaceNormal );\\r\\n\\t\\t\\tfaceType = setBit( faceType, 5, hasFaceVertexNormal );\\r\\n\\t\\t\\tfaceType = setBit( faceType, 6, hasFaceColor );\\r\\n\\t\\t\\tfaceType = setBit( faceType, 7, hasFaceVertexColor );\\r\\n\\r\\n\\t\\t\\tfaces.push( faceType );\\r\\n\\t\\t\\tfaces.push( face.a, face.b, face.c );\\r\\n\\t\\t\\tfaces.push( face.materialIndex );\\r\\n\\r\\n\\t\\t\\tif ( hasFaceVertexUv ) {\\r\\n\\r\\n\\t\\t\\t\\tvar faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];\\r\\n\\r\\n\\t\\t\\t\\tfaces.push(\\r\\n\\t\\t\\t\\t\\tgetUvIndex( faceVertexUvs[ 0 ] ),\\r\\n\\t\\t\\t\\t\\tgetUvIndex( faceVertexUvs[ 1 ] ),\\r\\n\\t\\t\\t\\t\\tgetUvIndex( faceVertexUvs[ 2 ] )\\r\\n\\t\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( hasFaceNormal ) {\\r\\n\\r\\n\\t\\t\\t\\tfaces.push( getNormalIndex( face.normal ) );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( hasFaceVertexNormal ) {\\r\\n\\r\\n\\t\\t\\t\\tvar vertexNormals = face.vertexNormals;\\r\\n\\r\\n\\t\\t\\t\\tfaces.push(\\r\\n\\t\\t\\t\\t\\tgetNormalIndex( vertexNormals[ 0 ] ),\\r\\n\\t\\t\\t\\t\\tgetNormalIndex( vertexNormals[ 1 ] ),\\r\\n\\t\\t\\t\\t\\tgetNormalIndex( vertexNormals[ 2 ] )\\r\\n\\t\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( hasFaceColor ) {\\r\\n\\r\\n\\t\\t\\t\\tfaces.push( getColorIndex( face.color ) );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( hasFaceVertexColor ) {\\r\\n\\r\\n\\t\\t\\t\\tvar vertexColors = face.vertexColors;\\r\\n\\r\\n\\t\\t\\t\\tfaces.push(\\r\\n\\t\\t\\t\\t\\tgetColorIndex( vertexColors[ 0 ] ),\\r\\n\\t\\t\\t\\t\\tgetColorIndex( vertexColors[ 1 ] ),\\r\\n\\t\\t\\t\\t\\tgetColorIndex( vertexColors[ 2 ] )\\r\\n\\t\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction setBit( value, position, enabled ) {\\r\\n\\r\\n\\t\\t\\treturn enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction getNormalIndex( normal ) {\\r\\n\\r\\n\\t\\t\\tvar hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\\r\\n\\r\\n\\t\\t\\tif ( normalsHash[ hash ] !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\treturn normalsHash[ hash ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tnormalsHash[ hash ] = normals.length / 3;\\r\\n\\t\\t\\tnormals.push( normal.x, normal.y, normal.z );\\r\\n\\r\\n\\t\\t\\treturn normalsHash[ hash ];\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction getColorIndex( color ) {\\r\\n\\r\\n\\t\\t\\tvar hash = color.r.toString() + color.g.toString() + color.b.toString();\\r\\n\\r\\n\\t\\t\\tif ( colorsHash[ hash ] !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\treturn colorsHash[ hash ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tcolorsHash[ hash ] = colors.length;\\r\\n\\t\\t\\tcolors.push( color.getHex() );\\r\\n\\r\\n\\t\\t\\treturn colorsHash[ hash ];\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction getUvIndex( uv ) {\\r\\n\\r\\n\\t\\t\\tvar hash = uv.x.toString() + uv.y.toString();\\r\\n\\r\\n\\t\\t\\tif ( uvsHash[ hash ] !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\treturn uvsHash[ hash ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tuvsHash[ hash ] = uvs.length / 2;\\r\\n\\t\\t\\tuvs.push( uv.x, uv.y );\\r\\n\\r\\n\\t\\t\\treturn uvsHash[ hash ];\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tdata.data = {};\\r\\n\\r\\n\\t\\tdata.data.vertices = vertices;\\r\\n\\t\\tdata.data.normals = normals;\\r\\n\\t\\tif ( colors.length > 0 ) data.data.colors = colors;\\r\\n\\t\\tif ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility\\r\\n\\t\\tdata.data.faces = faces;\\r\\n\\r\\n\\t\\treturn data;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclone: function () {\\r\\n\\r\\n\\t\\t/*\\r\\n\\t\\t // Handle primitives\\r\\n\\r\\n\\t\\t var parameters = this.parameters;\\r\\n\\r\\n\\t\\t if ( parameters !== undefined ) {\\r\\n\\r\\n\\t\\t var values = [];\\r\\n\\r\\n\\t\\t for ( var key in parameters ) {\\r\\n\\r\\n\\t\\t values.push( parameters[ key ] );\\r\\n\\r\\n\\t\\t }\\r\\n\\r\\n\\t\\t var geometry = Object.create( this.constructor.prototype );\\r\\n\\t\\t this.constructor.apply( geometry, values );\\r\\n\\t\\t return geometry;\\r\\n\\r\\n\\t\\t }\\r\\n\\r\\n\\t\\t return new this.constructor().copy( this );\\r\\n\\t\\t */\\r\\n\\r\\n\\t\\treturn new Geometry().copy( this );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\tvar i, il, j, jl, k, kl;\\r\\n\\r\\n\\t\\t// reset\\r\\n\\r\\n\\t\\tthis.vertices = [];\\r\\n\\t\\tthis.colors = [];\\r\\n\\t\\tthis.faces = [];\\r\\n\\t\\tthis.faceVertexUvs = [[]];\\r\\n\\t\\tthis.morphTargets = [];\\r\\n\\t\\tthis.morphNormals = [];\\r\\n\\t\\tthis.skinWeights = [];\\r\\n\\t\\tthis.skinIndices = [];\\r\\n\\t\\tthis.lineDistances = [];\\r\\n\\t\\tthis.boundingBox = null;\\r\\n\\t\\tthis.boundingSphere = null;\\r\\n\\r\\n\\t\\t// name\\r\\n\\r\\n\\t\\tthis.name = source.name;\\r\\n\\r\\n\\t\\t// vertices\\r\\n\\r\\n\\t\\tvar vertices = source.vertices;\\r\\n\\r\\n\\t\\tfor ( i = 0, il = vertices.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\tthis.vertices.push( vertices[ i ].clone() );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// colors\\r\\n\\r\\n\\t\\tvar colors = source.colors;\\r\\n\\r\\n\\t\\tfor ( i = 0, il = colors.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\tthis.colors.push( colors[ i ].clone() );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// faces\\r\\n\\r\\n\\t\\tvar faces = source.faces;\\r\\n\\r\\n\\t\\tfor ( i = 0, il = faces.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\tthis.faces.push( faces[ i ].clone() );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// face vertex uvs\\r\\n\\r\\n\\t\\tfor ( i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar faceVertexUvs = source.faceVertexUvs[ i ];\\r\\n\\r\\n\\t\\t\\tif ( this.faceVertexUvs[ i ] === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.faceVertexUvs[ i ] = [];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tfor ( j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar uvs = faceVertexUvs[ j ], uvsCopy = [];\\r\\n\\r\\n\\t\\t\\t\\tfor ( k = 0, kl = uvs.length; k < kl; k ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar uv = uvs[ k ];\\r\\n\\r\\n\\t\\t\\t\\t\\tuvsCopy.push( uv.clone() );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tthis.faceVertexUvs[ i ].push( uvsCopy );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// morph targets\\r\\n\\r\\n\\t\\tvar morphTargets = source.morphTargets;\\r\\n\\r\\n\\t\\tfor ( i = 0, il = morphTargets.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar morphTarget = {};\\r\\n\\t\\t\\tmorphTarget.name = morphTargets[ i ].name;\\r\\n\\r\\n\\t\\t\\t// vertices\\r\\n\\r\\n\\t\\t\\tif ( morphTargets[ i ].vertices !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tmorphTarget.vertices = [];\\r\\n\\r\\n\\t\\t\\t\\tfor ( j = 0, jl = morphTargets[ i ].vertices.length; j < jl; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tmorphTarget.vertices.push( morphTargets[ i ].vertices[ j ].clone() );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// normals\\r\\n\\r\\n\\t\\t\\tif ( morphTargets[ i ].normals !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tmorphTarget.normals = [];\\r\\n\\r\\n\\t\\t\\t\\tfor ( j = 0, jl = morphTargets[ i ].normals.length; j < jl; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tmorphTarget.normals.push( morphTargets[ i ].normals[ j ].clone() );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.morphTargets.push( morphTarget );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// morph normals\\r\\n\\r\\n\\t\\tvar morphNormals = source.morphNormals;\\r\\n\\r\\n\\t\\tfor ( i = 0, il = morphNormals.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar morphNormal = {};\\r\\n\\r\\n\\t\\t\\t// vertex normals\\r\\n\\r\\n\\t\\t\\tif ( morphNormals[ i ].vertexNormals !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tmorphNormal.vertexNormals = [];\\r\\n\\r\\n\\t\\t\\t\\tfor ( j = 0, jl = morphNormals[ i ].vertexNormals.length; j < jl; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar srcVertexNormal = morphNormals[ i ].vertexNormals[ j ];\\r\\n\\t\\t\\t\\t\\tvar destVertexNormal = {};\\r\\n\\r\\n\\t\\t\\t\\t\\tdestVertexNormal.a = srcVertexNormal.a.clone();\\r\\n\\t\\t\\t\\t\\tdestVertexNormal.b = srcVertexNormal.b.clone();\\r\\n\\t\\t\\t\\t\\tdestVertexNormal.c = srcVertexNormal.c.clone();\\r\\n\\r\\n\\t\\t\\t\\t\\tmorphNormal.vertexNormals.push( destVertexNormal );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// face normals\\r\\n\\r\\n\\t\\t\\tif ( morphNormals[ i ].faceNormals !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tmorphNormal.faceNormals = [];\\r\\n\\r\\n\\t\\t\\t\\tfor ( j = 0, jl = morphNormals[ i ].faceNormals.length; j < jl; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tmorphNormal.faceNormals.push( morphNormals[ i ].faceNormals[ j ].clone() );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.morphNormals.push( morphNormal );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// skin weights\\r\\n\\r\\n\\t\\tvar skinWeights = source.skinWeights;\\r\\n\\r\\n\\t\\tfor ( i = 0, il = skinWeights.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\tthis.skinWeights.push( skinWeights[ i ].clone() );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// skin indices\\r\\n\\r\\n\\t\\tvar skinIndices = source.skinIndices;\\r\\n\\r\\n\\t\\tfor ( i = 0, il = skinIndices.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\tthis.skinIndices.push( skinIndices[ i ].clone() );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// line distances\\r\\n\\r\\n\\t\\tvar lineDistances = source.lineDistances;\\r\\n\\r\\n\\t\\tfor ( i = 0, il = lineDistances.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\tthis.lineDistances.push( lineDistances[ i ] );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// bounding box\\r\\n\\r\\n\\t\\tvar boundingBox = source.boundingBox;\\r\\n\\r\\n\\t\\tif ( boundingBox !== null ) {\\r\\n\\r\\n\\t\\t\\tthis.boundingBox = boundingBox.clone();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// bounding sphere\\r\\n\\r\\n\\t\\tvar boundingSphere = source.boundingSphere;\\r\\n\\r\\n\\t\\tif ( boundingSphere !== null ) {\\r\\n\\r\\n\\t\\t\\tthis.boundingSphere = boundingSphere.clone();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// update flags\\r\\n\\r\\n\\t\\tthis.elementsNeedUpdate = source.elementsNeedUpdate;\\r\\n\\t\\tthis.verticesNeedUpdate = source.verticesNeedUpdate;\\r\\n\\t\\tthis.uvsNeedUpdate = source.uvsNeedUpdate;\\r\\n\\t\\tthis.normalsNeedUpdate = source.normalsNeedUpdate;\\r\\n\\t\\tthis.colorsNeedUpdate = source.colorsNeedUpdate;\\r\\n\\t\\tthis.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;\\r\\n\\t\\tthis.groupsNeedUpdate = source.groupsNeedUpdate;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tdispose: function () {\\r\\n\\r\\n\\t\\tthis.dispatchEvent( { type: 'dispose' } );\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n * @author Mugen87 / https://github.com/Mugen87\\r\\n */\\r\\n\\r\\n// BoxGeometry\\r\\n\\r\\nclass BoxGeometry extends Geometry {\\r\\n\\r\\n\\tconstructor( width, height, depth, widthSegments, heightSegments, depthSegments ) {\\r\\n\\r\\n\\t\\tsuper();\\r\\n\\r\\n\\t\\tthis.type = 'BoxGeometry';\\r\\n\\r\\n\\t\\tthis.parameters = {\\r\\n\\t\\t\\twidth: width,\\r\\n\\t\\t\\theight: height,\\r\\n\\t\\t\\tdepth: depth,\\r\\n\\t\\t\\twidthSegments: widthSegments,\\r\\n\\t\\t\\theightSegments: heightSegments,\\r\\n\\t\\t\\tdepthSegments: depthSegments\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );\\r\\n\\t\\tthis.mergeVertices();\\r\\n\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\\r\\n// BoxBufferGeometry\\r\\n\\r\\nclass BoxBufferGeometry extends BufferGeometry {\\r\\n\\r\\n\\tconstructor( width, height, depth, widthSegments, heightSegments, depthSegments ) {\\r\\n\\r\\n\\t\\tsuper();\\r\\n\\r\\n\\t\\tthis.type = 'BoxBufferGeometry';\\r\\n\\r\\n\\t\\tthis.parameters = {\\r\\n\\t\\t\\twidth: width,\\r\\n\\t\\t\\theight: height,\\r\\n\\t\\t\\tdepth: depth,\\r\\n\\t\\t\\twidthSegments: widthSegments,\\r\\n\\t\\t\\theightSegments: heightSegments,\\r\\n\\t\\t\\tdepthSegments: depthSegments\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tconst scope = this;\\r\\n\\r\\n\\t\\twidth = width || 1;\\r\\n\\t\\theight = height || 1;\\r\\n\\t\\tdepth = depth || 1;\\r\\n\\r\\n\\t\\t// segments\\r\\n\\r\\n\\t\\twidthSegments = Math.floor( widthSegments ) || 1;\\r\\n\\t\\theightSegments = Math.floor( heightSegments ) || 1;\\r\\n\\t\\tdepthSegments = Math.floor( depthSegments ) || 1;\\r\\n\\r\\n\\t\\t// buffers\\r\\n\\r\\n\\t\\tconst indices = [];\\r\\n\\t\\tconst vertices = [];\\r\\n\\t\\tconst normals = [];\\r\\n\\t\\tconst uvs = [];\\r\\n\\r\\n\\t\\t// helper variables\\r\\n\\r\\n\\t\\tlet numberOfVertices = 0;\\r\\n\\t\\tlet groupStart = 0;\\r\\n\\r\\n\\t\\t// build each side of the box geometry\\r\\n\\r\\n\\t\\tbuildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px\\r\\n\\t\\tbuildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx\\r\\n\\t\\tbuildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py\\r\\n\\t\\tbuildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny\\r\\n\\t\\tbuildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz\\r\\n\\t\\tbuildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz\\r\\n\\r\\n\\t\\t// build geometry\\r\\n\\r\\n\\t\\tthis.setIndex( indices );\\r\\n\\t\\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\r\\n\\t\\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\r\\n\\t\\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\r\\n\\r\\n\\t\\tfunction buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {\\r\\n\\r\\n\\t\\t\\tconst segmentWidth = width / gridX;\\r\\n\\t\\t\\tconst segmentHeight = height / gridY;\\r\\n\\r\\n\\t\\t\\tconst widthHalf = width / 2;\\r\\n\\t\\t\\tconst heightHalf = height / 2;\\r\\n\\t\\t\\tconst depthHalf = depth / 2;\\r\\n\\r\\n\\t\\t\\tconst gridX1 = gridX + 1;\\r\\n\\t\\t\\tconst gridY1 = gridY + 1;\\r\\n\\r\\n\\t\\t\\tlet vertexCounter = 0;\\r\\n\\t\\t\\tlet groupCount = 0;\\r\\n\\r\\n\\t\\t\\tconst vector = new Vector3();\\r\\n\\r\\n\\t\\t\\t// generate vertices, normals and uvs\\r\\n\\r\\n\\t\\t\\tfor ( let iy = 0; iy < gridY1; iy ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tconst y = iy * segmentHeight - heightHalf;\\r\\n\\r\\n\\t\\t\\t\\tfor ( let ix = 0; ix < gridX1; ix ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tconst x = ix * segmentWidth - widthHalf;\\r\\n\\r\\n\\t\\t\\t\\t\\t// set values to correct vector component\\r\\n\\r\\n\\t\\t\\t\\t\\tvector[ u ] = x * udir;\\r\\n\\t\\t\\t\\t\\tvector[ v ] = y * vdir;\\r\\n\\t\\t\\t\\t\\tvector[ w ] = depthHalf;\\r\\n\\r\\n\\t\\t\\t\\t\\t// now apply vector to vertex buffer\\r\\n\\r\\n\\t\\t\\t\\t\\tvertices.push( vector.x, vector.y, vector.z );\\r\\n\\r\\n\\t\\t\\t\\t\\t// set values to correct vector component\\r\\n\\r\\n\\t\\t\\t\\t\\tvector[ u ] = 0;\\r\\n\\t\\t\\t\\t\\tvector[ v ] = 0;\\r\\n\\t\\t\\t\\t\\tvector[ w ] = depth > 0 ? 1 : - 1;\\r\\n\\r\\n\\t\\t\\t\\t\\t// now apply vector to normal buffer\\r\\n\\r\\n\\t\\t\\t\\t\\tnormals.push( vector.x, vector.y, vector.z );\\r\\n\\r\\n\\t\\t\\t\\t\\t// uvs\\r\\n\\r\\n\\t\\t\\t\\t\\tuvs.push( ix / gridX );\\r\\n\\t\\t\\t\\t\\tuvs.push( 1 - ( iy / gridY ) );\\r\\n\\r\\n\\t\\t\\t\\t\\t// counters\\r\\n\\r\\n\\t\\t\\t\\t\\tvertexCounter += 1;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// indices\\r\\n\\r\\n\\t\\t\\t// 1. you need three indices to draw a single face\\r\\n\\t\\t\\t// 2. a single segment consists of two faces\\r\\n\\t\\t\\t// 3. so we need to generate six (2*3) indices per segment\\r\\n\\r\\n\\t\\t\\tfor ( let iy = 0; iy < gridY; iy ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tfor ( let ix = 0; ix < gridX; ix ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tconst a = numberOfVertices + ix + gridX1 * iy;\\r\\n\\t\\t\\t\\t\\tconst b = numberOfVertices + ix + gridX1 * ( iy + 1 );\\r\\n\\t\\t\\t\\t\\tconst c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );\\r\\n\\t\\t\\t\\t\\tconst d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;\\r\\n\\r\\n\\t\\t\\t\\t\\t// faces\\r\\n\\r\\n\\t\\t\\t\\t\\tindices.push( a, b, d );\\r\\n\\t\\t\\t\\t\\tindices.push( b, c, d );\\r\\n\\r\\n\\t\\t\\t\\t\\t// increase counter\\r\\n\\r\\n\\t\\t\\t\\t\\tgroupCount += 6;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// add a group to the geometry. this will ensure multi material support\\r\\n\\r\\n\\t\\t\\tscope.addGroup( groupStart, groupCount, materialIndex );\\r\\n\\r\\n\\t\\t\\t// calculate new start value for groups\\r\\n\\r\\n\\t\\t\\tgroupStart += groupCount;\\r\\n\\r\\n\\t\\t\\t// update total number of vertices\\r\\n\\r\\n\\t\\t\\tnumberOfVertices += vertexCounter;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * Uniform Utilities\\r\\n */\\r\\n\\r\\nfunction cloneUniforms( src ) {\\r\\n\\r\\n\\tvar dst = {};\\r\\n\\r\\n\\tfor ( var u in src ) {\\r\\n\\r\\n\\t\\tdst[ u ] = {};\\r\\n\\r\\n\\t\\tfor ( var p in src[ u ] ) {\\r\\n\\r\\n\\t\\t\\tvar property = src[ u ][ p ];\\r\\n\\r\\n\\t\\t\\tif ( property && ( property.isColor ||\\r\\n\\t\\t\\t\\tproperty.isMatrix3 || property.isMatrix4 ||\\r\\n\\t\\t\\t\\tproperty.isVector2 || property.isVector3 || property.isVector4 ||\\r\\n\\t\\t\\t\\tproperty.isTexture ) ) {\\r\\n\\r\\n\\t\\t\\t\\tdst[ u ][ p ] = property.clone();\\r\\n\\r\\n\\t\\t\\t} else if ( Array.isArray( property ) ) {\\r\\n\\r\\n\\t\\t\\t\\tdst[ u ][ p ] = property.slice();\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tdst[ u ][ p ] = property;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn dst;\\r\\n\\r\\n}\\r\\n\\r\\nfunction mergeUniforms( uniforms ) {\\r\\n\\r\\n\\tvar merged = {};\\r\\n\\r\\n\\tfor ( var u = 0; u < uniforms.length; u ++ ) {\\r\\n\\r\\n\\t\\tvar tmp = cloneUniforms( uniforms[ u ] );\\r\\n\\r\\n\\t\\tfor ( var p in tmp ) {\\r\\n\\r\\n\\t\\t\\tmerged[ p ] = tmp[ p ];\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn merged;\\r\\n\\r\\n}\\r\\n\\r\\n// Legacy\\r\\n\\r\\nvar UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };\\r\\n\\r\\nvar default_vertex = \\\"void main() {\\\\n\\\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\\n}\\\";\\r\\n\\r\\nvar default_fragment = \\\"void main() {\\\\n\\\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\\\n}\\\";\\r\\n\\r\\n/**\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n *\\r\\n * parameters = {\\r\\n *  defines: { \\\"label\\\" : \\\"value\\\" },\\r\\n *  uniforms: { \\\"parameter1\\\": { value: 1.0 }, \\\"parameter2\\\": { value2: 2 } },\\r\\n *\\r\\n *  fragmentShader: <string>,\\r\\n *  vertexShader: <string>,\\r\\n *\\r\\n *  wireframe: <boolean>,\\r\\n *  wireframeLinewidth: <float>,\\r\\n *\\r\\n *  lights: <bool>,\\r\\n *\\r\\n *  skinning: <bool>,\\r\\n *  morphTargets: <bool>,\\r\\n *  morphNormals: <bool>\\r\\n * }\\r\\n */\\r\\n\\r\\nfunction ShaderMaterial( parameters ) {\\r\\n\\r\\n\\tMaterial.call( this );\\r\\n\\r\\n\\tthis.type = 'ShaderMaterial';\\r\\n\\r\\n\\tthis.defines = {};\\r\\n\\tthis.uniforms = {};\\r\\n\\r\\n\\tthis.vertexShader = default_vertex;\\r\\n\\tthis.fragmentShader = default_fragment;\\r\\n\\r\\n\\tthis.linewidth = 1;\\r\\n\\r\\n\\tthis.wireframe = false;\\r\\n\\tthis.wireframeLinewidth = 1;\\r\\n\\r\\n\\tthis.fog = false; // set to use scene fog\\r\\n\\tthis.lights = false; // set to use scene lights\\r\\n\\tthis.clipping = false; // set to use user-defined clipping planes\\r\\n\\r\\n\\tthis.skinning = false; // set to use skinning attribute streams\\r\\n\\tthis.morphTargets = false; // set to use morph targets\\r\\n\\tthis.morphNormals = false; // set to use morph normals\\r\\n\\r\\n\\tthis.extensions = {\\r\\n\\t\\tderivatives: false, // set to use derivatives\\r\\n\\t\\tfragDepth: false, // set to use fragment depth values\\r\\n\\t\\tdrawBuffers: false, // set to use draw buffers\\r\\n\\t\\tshaderTextureLOD: false // set to use shader texture LOD\\r\\n\\t};\\r\\n\\r\\n\\t// When rendered geometry doesn't include these attributes but the material does,\\r\\n\\t// use these default values in WebGL. This avoids errors when buffer data is missing.\\r\\n\\tthis.defaultAttributeValues = {\\r\\n\\t\\t'color': [ 1, 1, 1 ],\\r\\n\\t\\t'uv': [ 0, 0 ],\\r\\n\\t\\t'uv2': [ 0, 0 ]\\r\\n\\t};\\r\\n\\r\\n\\tthis.index0AttributeName = undefined;\\r\\n\\tthis.uniformsNeedUpdate = false;\\r\\n\\r\\n\\tif ( parameters !== undefined ) {\\r\\n\\r\\n\\t\\tif ( parameters.attributes !== undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.setValues( parameters );\\r\\n\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\\r\\nShaderMaterial.prototype = Object.create( Material.prototype );\\r\\nShaderMaterial.prototype.constructor = ShaderMaterial;\\r\\n\\r\\nShaderMaterial.prototype.isShaderMaterial = true;\\r\\n\\r\\nShaderMaterial.prototype.copy = function ( source ) {\\r\\n\\r\\n\\tMaterial.prototype.copy.call( this, source );\\r\\n\\r\\n\\tthis.fragmentShader = source.fragmentShader;\\r\\n\\tthis.vertexShader = source.vertexShader;\\r\\n\\r\\n\\tthis.uniforms = cloneUniforms( source.uniforms );\\r\\n\\r\\n\\tthis.defines = Object.assign( {}, source.defines );\\r\\n\\r\\n\\tthis.wireframe = source.wireframe;\\r\\n\\tthis.wireframeLinewidth = source.wireframeLinewidth;\\r\\n\\r\\n\\tthis.lights = source.lights;\\r\\n\\tthis.clipping = source.clipping;\\r\\n\\r\\n\\tthis.skinning = source.skinning;\\r\\n\\r\\n\\tthis.morphTargets = source.morphTargets;\\r\\n\\tthis.morphNormals = source.morphNormals;\\r\\n\\r\\n\\tthis.extensions = Object.assign( {}, source.extensions );\\r\\n\\r\\n\\treturn this;\\r\\n\\r\\n};\\r\\n\\r\\nShaderMaterial.prototype.toJSON = function ( meta ) {\\r\\n\\r\\n\\tvar data = Material.prototype.toJSON.call( this, meta );\\r\\n\\r\\n\\tdata.uniforms = {};\\r\\n\\r\\n\\tfor ( var name in this.uniforms ) {\\r\\n\\r\\n\\t\\tvar uniform = this.uniforms[ name ];\\r\\n\\t\\tvar value = uniform.value;\\r\\n\\r\\n\\t\\tif ( value && value.isTexture ) {\\r\\n\\r\\n\\t\\t\\tdata.uniforms[ name ] = {\\r\\n\\t\\t\\t\\ttype: 't',\\r\\n\\t\\t\\t\\tvalue: value.toJSON( meta ).uuid\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t} else if ( value && value.isColor ) {\\r\\n\\r\\n\\t\\t\\tdata.uniforms[ name ] = {\\r\\n\\t\\t\\t\\ttype: 'c',\\r\\n\\t\\t\\t\\tvalue: value.getHex()\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t} else if ( value && value.isVector2 ) {\\r\\n\\r\\n\\t\\t\\tdata.uniforms[ name ] = {\\r\\n\\t\\t\\t\\ttype: 'v2',\\r\\n\\t\\t\\t\\tvalue: value.toArray()\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t} else if ( value && value.isVector3 ) {\\r\\n\\r\\n\\t\\t\\tdata.uniforms[ name ] = {\\r\\n\\t\\t\\t\\ttype: 'v3',\\r\\n\\t\\t\\t\\tvalue: value.toArray()\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t} else if ( value && value.isVector4 ) {\\r\\n\\r\\n\\t\\t\\tdata.uniforms[ name ] = {\\r\\n\\t\\t\\t\\ttype: 'v4',\\r\\n\\t\\t\\t\\tvalue: value.toArray()\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t} else if ( value && value.isMatrix3 ) {\\r\\n\\r\\n\\t\\t\\tdata.uniforms[ name ] = {\\r\\n\\t\\t\\t\\ttype: 'm3',\\r\\n\\t\\t\\t\\tvalue: value.toArray()\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t} else if ( value && value.isMatrix4 ) {\\r\\n\\r\\n\\t\\t\\tdata.uniforms[ name ] = {\\r\\n\\t\\t\\t\\ttype: 'm4',\\r\\n\\t\\t\\t\\tvalue: value.toArray()\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tdata.uniforms[ name ] = {\\r\\n\\t\\t\\t\\tvalue: value\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\t// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tif ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;\\r\\n\\r\\n\\tdata.vertexShader = this.vertexShader;\\r\\n\\tdata.fragmentShader = this.fragmentShader;\\r\\n\\r\\n\\tvar extensions = {};\\r\\n\\r\\n\\tfor ( var key in this.extensions ) {\\r\\n\\r\\n\\t\\tif ( this.extensions[ key ] === true ) extensions[ key ] = true;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tif ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;\\r\\n\\r\\n\\treturn data;\\r\\n\\r\\n};\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n * @author mikael emtinger / http://gomo.se/\\r\\n * @author WestLangley / http://github.com/WestLangley\\r\\n*/\\r\\n\\r\\nfunction Camera() {\\r\\n\\r\\n\\tObject3D.call( this );\\r\\n\\r\\n\\tthis.type = 'Camera';\\r\\n\\r\\n\\tthis.matrixWorldInverse = new Matrix4();\\r\\n\\r\\n\\tthis.projectionMatrix = new Matrix4();\\r\\n\\tthis.projectionMatrixInverse = new Matrix4();\\r\\n\\r\\n}\\r\\n\\r\\nCamera.prototype = Object.assign( Object.create( Object3D.prototype ), {\\r\\n\\r\\n\\tconstructor: Camera,\\r\\n\\r\\n\\tisCamera: true,\\r\\n\\r\\n\\tcopy: function ( source, recursive ) {\\r\\n\\r\\n\\t\\tObject3D.prototype.copy.call( this, source, recursive );\\r\\n\\r\\n\\t\\tthis.matrixWorldInverse.copy( source.matrixWorldInverse );\\r\\n\\r\\n\\t\\tthis.projectionMatrix.copy( source.projectionMatrix );\\r\\n\\t\\tthis.projectionMatrixInverse.copy( source.projectionMatrixInverse );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetWorldDirection: function ( target ) {\\r\\n\\r\\n\\t\\tif ( target === undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Camera: .getWorldDirection() target is now required' );\\r\\n\\t\\t\\ttarget = new Vector3();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.updateMatrixWorld( true );\\r\\n\\r\\n\\t\\tvar e = this.matrixWorld.elements;\\r\\n\\r\\n\\t\\treturn target.set( - e[ 8 ], - e[ 9 ], - e[ 10 ] ).normalize();\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tupdateMatrixWorld: function ( force ) {\\r\\n\\r\\n\\t\\tObject3D.prototype.updateMatrixWorld.call( this, force );\\r\\n\\r\\n\\t\\tthis.matrixWorldInverse.getInverse( this.matrixWorld );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tupdateWorldMatrix: function ( updateParents, updateChildren ) {\\r\\n\\r\\n\\t\\tObject3D.prototype.updateWorldMatrix.call( this, updateParents, updateChildren );\\r\\n\\r\\n\\t\\tthis.matrixWorldInverse.getInverse( this.matrixWorld );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclone: function () {\\r\\n\\r\\n\\t\\treturn new this.constructor().copy( this );\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n * @author greggman / http://games.greggman.com/\\r\\n * @author zz85 / http://www.lab4games.net/zz85/blog\\r\\n * @author tschw\\r\\n */\\r\\n\\r\\nfunction PerspectiveCamera( fov, aspect, near, far ) {\\r\\n\\r\\n\\tCamera.call( this );\\r\\n\\r\\n\\tthis.type = 'PerspectiveCamera';\\r\\n\\r\\n\\tthis.fov = fov !== undefined ? fov : 50;\\r\\n\\tthis.zoom = 1;\\r\\n\\r\\n\\tthis.near = near !== undefined ? near : 0.1;\\r\\n\\tthis.far = far !== undefined ? far : 2000;\\r\\n\\tthis.focus = 10;\\r\\n\\r\\n\\tthis.aspect = aspect !== undefined ? aspect : 1;\\r\\n\\tthis.view = null;\\r\\n\\r\\n\\tthis.filmGauge = 35;\\t// width of the film (default in millimeters)\\r\\n\\tthis.filmOffset = 0;\\t// horizontal film offset (same unit as gauge)\\r\\n\\r\\n\\tthis.updateProjectionMatrix();\\r\\n\\r\\n}\\r\\n\\r\\nPerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {\\r\\n\\r\\n\\tconstructor: PerspectiveCamera,\\r\\n\\r\\n\\tisPerspectiveCamera: true,\\r\\n\\r\\n\\tcopy: function ( source, recursive ) {\\r\\n\\r\\n\\t\\tCamera.prototype.copy.call( this, source, recursive );\\r\\n\\r\\n\\t\\tthis.fov = source.fov;\\r\\n\\t\\tthis.zoom = source.zoom;\\r\\n\\r\\n\\t\\tthis.near = source.near;\\r\\n\\t\\tthis.far = source.far;\\r\\n\\t\\tthis.focus = source.focus;\\r\\n\\r\\n\\t\\tthis.aspect = source.aspect;\\r\\n\\t\\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\\r\\n\\r\\n\\t\\tthis.filmGauge = source.filmGauge;\\r\\n\\t\\tthis.filmOffset = source.filmOffset;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t/**\\r\\n\\t * Sets the FOV by focal length in respect to the current .filmGauge.\\r\\n\\t *\\r\\n\\t * The default film gauge is 35, so that the focal length can be specified for\\r\\n\\t * a 35mm (full frame) camera.\\r\\n\\t *\\r\\n\\t * Values for focal length and film gauge must have the same unit.\\r\\n\\t */\\r\\n\\tsetFocalLength: function ( focalLength ) {\\r\\n\\r\\n\\t\\t// see http://www.bobatkins.com/photography/technical/field_of_view.html\\r\\n\\t\\tvar vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\\r\\n\\r\\n\\t\\tthis.fov = MathUtils.RAD2DEG * 2 * Math.atan( vExtentSlope );\\r\\n\\t\\tthis.updateProjectionMatrix();\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t/**\\r\\n\\t * Calculates the focal length from the current .fov and .filmGauge.\\r\\n\\t */\\r\\n\\tgetFocalLength: function () {\\r\\n\\r\\n\\t\\tvar vExtentSlope = Math.tan( MathUtils.DEG2RAD * 0.5 * this.fov );\\r\\n\\r\\n\\t\\treturn 0.5 * this.getFilmHeight() / vExtentSlope;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetEffectiveFOV: function () {\\r\\n\\r\\n\\t\\treturn MathUtils.RAD2DEG * 2 * Math.atan(\\r\\n\\t\\t\\tMath.tan( MathUtils.DEG2RAD * 0.5 * this.fov ) / this.zoom );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetFilmWidth: function () {\\r\\n\\r\\n\\t\\t// film not completely covered in portrait format (aspect < 1)\\r\\n\\t\\treturn this.filmGauge * Math.min( this.aspect, 1 );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetFilmHeight: function () {\\r\\n\\r\\n\\t\\t// film not completely covered in landscape format (aspect > 1)\\r\\n\\t\\treturn this.filmGauge / Math.max( this.aspect, 1 );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t/**\\r\\n\\t * Sets an offset in a larger frustum. This is useful for multi-window or\\r\\n\\t * multi-monitor/multi-machine setups.\\r\\n\\t *\\r\\n\\t * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\\r\\n\\t * the monitors are in grid like this\\r\\n\\t *\\r\\n\\t *   +---+---+---+\\r\\n\\t *   | A | B | C |\\r\\n\\t *   +---+---+---+\\r\\n\\t *   | D | E | F |\\r\\n\\t *   +---+---+---+\\r\\n\\t *\\r\\n\\t * then for each monitor you would call it like this\\r\\n\\t *\\r\\n\\t *   var w = 1920;\\r\\n\\t *   var h = 1080;\\r\\n\\t *   var fullWidth = w * 3;\\r\\n\\t *   var fullHeight = h * 2;\\r\\n\\t *\\r\\n\\t *   --A--\\r\\n\\t *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\\r\\n\\t *   --B--\\r\\n\\t *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\\r\\n\\t *   --C--\\r\\n\\t *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\\r\\n\\t *   --D--\\r\\n\\t *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\\r\\n\\t *   --E--\\r\\n\\t *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\\r\\n\\t *   --F--\\r\\n\\t *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\\r\\n\\t *\\r\\n\\t *   Note there is no reason monitors have to be the same size or in a grid.\\r\\n\\t */\\r\\n\\tsetViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {\\r\\n\\r\\n\\t\\tthis.aspect = fullWidth / fullHeight;\\r\\n\\r\\n\\t\\tif ( this.view === null ) {\\r\\n\\r\\n\\t\\t\\tthis.view = {\\r\\n\\t\\t\\t\\tenabled: true,\\r\\n\\t\\t\\t\\tfullWidth: 1,\\r\\n\\t\\t\\t\\tfullHeight: 1,\\r\\n\\t\\t\\t\\toffsetX: 0,\\r\\n\\t\\t\\t\\toffsetY: 0,\\r\\n\\t\\t\\t\\twidth: 1,\\r\\n\\t\\t\\t\\theight: 1\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.view.enabled = true;\\r\\n\\t\\tthis.view.fullWidth = fullWidth;\\r\\n\\t\\tthis.view.fullHeight = fullHeight;\\r\\n\\t\\tthis.view.offsetX = x;\\r\\n\\t\\tthis.view.offsetY = y;\\r\\n\\t\\tthis.view.width = width;\\r\\n\\t\\tthis.view.height = height;\\r\\n\\r\\n\\t\\tthis.updateProjectionMatrix();\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclearViewOffset: function () {\\r\\n\\r\\n\\t\\tif ( this.view !== null ) {\\r\\n\\r\\n\\t\\t\\tthis.view.enabled = false;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.updateProjectionMatrix();\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tupdateProjectionMatrix: function () {\\r\\n\\r\\n\\t\\tvar near = this.near,\\r\\n\\t\\t\\ttop = near * Math.tan( MathUtils.DEG2RAD * 0.5 * this.fov ) / this.zoom,\\r\\n\\t\\t\\theight = 2 * top,\\r\\n\\t\\t\\twidth = this.aspect * height,\\r\\n\\t\\t\\tleft = - 0.5 * width,\\r\\n\\t\\t\\tview = this.view;\\r\\n\\r\\n\\t\\tif ( this.view !== null && this.view.enabled ) {\\r\\n\\r\\n\\t\\t\\tvar fullWidth = view.fullWidth,\\r\\n\\t\\t\\t\\tfullHeight = view.fullHeight;\\r\\n\\r\\n\\t\\t\\tleft += view.offsetX * width / fullWidth;\\r\\n\\t\\t\\ttop -= view.offsetY * height / fullHeight;\\r\\n\\t\\t\\twidth *= view.width / fullWidth;\\r\\n\\t\\t\\theight *= view.height / fullHeight;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar skew = this.filmOffset;\\r\\n\\t\\tif ( skew !== 0 ) left += near * skew / this.getFilmWidth();\\r\\n\\r\\n\\t\\tthis.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );\\r\\n\\r\\n\\t\\tthis.projectionMatrixInverse.getInverse( this.projectionMatrix );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttoJSON: function ( meta ) {\\r\\n\\r\\n\\t\\tvar data = Object3D.prototype.toJSON.call( this, meta );\\r\\n\\r\\n\\t\\tdata.object.fov = this.fov;\\r\\n\\t\\tdata.object.zoom = this.zoom;\\r\\n\\r\\n\\t\\tdata.object.near = this.near;\\r\\n\\t\\tdata.object.far = this.far;\\r\\n\\t\\tdata.object.focus = this.focus;\\r\\n\\r\\n\\t\\tdata.object.aspect = this.aspect;\\r\\n\\r\\n\\t\\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\\r\\n\\r\\n\\t\\tdata.object.filmGauge = this.filmGauge;\\r\\n\\t\\tdata.object.filmOffset = this.filmOffset;\\r\\n\\r\\n\\t\\treturn data;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * Camera for rendering cube maps\\r\\n *\\t- renders scene into axis-aligned cube\\r\\n *\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n */\\r\\n\\r\\nvar fov = 90, aspect = 1;\\r\\n\\r\\nfunction CubeCamera( near, far, renderTarget ) {\\r\\n\\r\\n\\tObject3D.call( this );\\r\\n\\r\\n\\tthis.type = 'CubeCamera';\\r\\n\\r\\n\\tif ( renderTarget.isWebGLCubeRenderTarget !== true ) {\\r\\n\\r\\n\\t\\tconsole.error( 'THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.' );\\r\\n\\t\\treturn;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tthis.renderTarget = renderTarget;\\r\\n\\r\\n\\tvar cameraPX = new PerspectiveCamera( fov, aspect, near, far );\\r\\n\\tcameraPX.layers = this.layers;\\r\\n\\tcameraPX.up.set( 0, - 1, 0 );\\r\\n\\tcameraPX.lookAt( new Vector3( 1, 0, 0 ) );\\r\\n\\tthis.add( cameraPX );\\r\\n\\r\\n\\tvar cameraNX = new PerspectiveCamera( fov, aspect, near, far );\\r\\n\\tcameraNX.layers = this.layers;\\r\\n\\tcameraNX.up.set( 0, - 1, 0 );\\r\\n\\tcameraNX.lookAt( new Vector3( - 1, 0, 0 ) );\\r\\n\\tthis.add( cameraNX );\\r\\n\\r\\n\\tvar cameraPY = new PerspectiveCamera( fov, aspect, near, far );\\r\\n\\tcameraPY.layers = this.layers;\\r\\n\\tcameraPY.up.set( 0, 0, 1 );\\r\\n\\tcameraPY.lookAt( new Vector3( 0, 1, 0 ) );\\r\\n\\tthis.add( cameraPY );\\r\\n\\r\\n\\tvar cameraNY = new PerspectiveCamera( fov, aspect, near, far );\\r\\n\\tcameraNY.layers = this.layers;\\r\\n\\tcameraNY.up.set( 0, 0, - 1 );\\r\\n\\tcameraNY.lookAt( new Vector3( 0, - 1, 0 ) );\\r\\n\\tthis.add( cameraNY );\\r\\n\\r\\n\\tvar cameraPZ = new PerspectiveCamera( fov, aspect, near, far );\\r\\n\\tcameraPZ.layers = this.layers;\\r\\n\\tcameraPZ.up.set( 0, - 1, 0 );\\r\\n\\tcameraPZ.lookAt( new Vector3( 0, 0, 1 ) );\\r\\n\\tthis.add( cameraPZ );\\r\\n\\r\\n\\tvar cameraNZ = new PerspectiveCamera( fov, aspect, near, far );\\r\\n\\tcameraNZ.layers = this.layers;\\r\\n\\tcameraNZ.up.set( 0, - 1, 0 );\\r\\n\\tcameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );\\r\\n\\tthis.add( cameraNZ );\\r\\n\\r\\n\\tthis.update = function ( renderer, scene ) {\\r\\n\\r\\n\\t\\tif ( this.parent === null ) this.updateMatrixWorld();\\r\\n\\r\\n\\t\\tvar currentXrEnabled = renderer.xr.enabled;\\r\\n\\t\\tvar currentRenderTarget = renderer.getRenderTarget();\\r\\n\\r\\n\\t\\trenderer.xr.enabled = false;\\r\\n\\r\\n\\t\\tvar generateMipmaps = renderTarget.texture.generateMipmaps;\\r\\n\\r\\n\\t\\trenderTarget.texture.generateMipmaps = false;\\r\\n\\r\\n\\t\\trenderer.setRenderTarget( renderTarget, 0 );\\r\\n\\t\\trenderer.render( scene, cameraPX );\\r\\n\\r\\n\\t\\trenderer.setRenderTarget( renderTarget, 1 );\\r\\n\\t\\trenderer.render( scene, cameraNX );\\r\\n\\r\\n\\t\\trenderer.setRenderTarget( renderTarget, 2 );\\r\\n\\t\\trenderer.render( scene, cameraPY );\\r\\n\\r\\n\\t\\trenderer.setRenderTarget( renderTarget, 3 );\\r\\n\\t\\trenderer.render( scene, cameraNY );\\r\\n\\r\\n\\t\\trenderer.setRenderTarget( renderTarget, 4 );\\r\\n\\t\\trenderer.render( scene, cameraPZ );\\r\\n\\r\\n\\t\\trenderTarget.texture.generateMipmaps = generateMipmaps;\\r\\n\\r\\n\\t\\trenderer.setRenderTarget( renderTarget, 5 );\\r\\n\\t\\trenderer.render( scene, cameraNZ );\\r\\n\\r\\n\\t\\trenderer.setRenderTarget( currentRenderTarget );\\r\\n\\r\\n\\t\\trenderer.xr.enabled = currentXrEnabled;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.clear = function ( renderer, color, depth, stencil ) {\\r\\n\\r\\n\\t\\tvar currentRenderTarget = renderer.getRenderTarget();\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\r\\n\\r\\n\\t\\t\\trenderer.setRenderTarget( renderTarget, i );\\r\\n\\r\\n\\t\\t\\trenderer.clear( color, depth, stencil );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\trenderer.setRenderTarget( currentRenderTarget );\\r\\n\\r\\n\\t};\\r\\n\\r\\n}\\r\\n\\r\\nCubeCamera.prototype = Object.create( Object3D.prototype );\\r\\nCubeCamera.prototype.constructor = CubeCamera;\\r\\n\\r\\n/**\\r\\n * @author alteredq / http://alteredqualia.com\\r\\n * @author WestLangley / http://github.com/WestLangley\\r\\n */\\r\\n\\r\\nfunction WebGLCubeRenderTarget( size, options, dummy ) {\\r\\n\\r\\n\\tif ( Number.isInteger( options ) ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )' );\\r\\n\\r\\n\\t\\toptions = dummy;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tWebGLRenderTarget.call( this, size, size, options );\\r\\n\\r\\n}\\r\\n\\r\\nWebGLCubeRenderTarget.prototype = Object.create( WebGLRenderTarget.prototype );\\r\\nWebGLCubeRenderTarget.prototype.constructor = WebGLCubeRenderTarget;\\r\\n\\r\\nWebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;\\r\\n\\r\\nWebGLCubeRenderTarget.prototype.fromEquirectangularTexture = function ( renderer, texture ) {\\r\\n\\r\\n\\tthis.texture.type = texture.type;\\r\\n\\tthis.texture.format = texture.format;\\r\\n\\tthis.texture.encoding = texture.encoding;\\r\\n\\r\\n\\tvar scene = new Scene();\\r\\n\\r\\n\\tvar shader = {\\r\\n\\r\\n\\t\\tuniforms: {\\r\\n\\t\\t\\ttEquirect: { value: null },\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tvertexShader: [\\r\\n\\r\\n\\t\\t\\t\\\"varying vec3 vWorldDirection;\\\",\\r\\n\\r\\n\\t\\t\\t\\\"vec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\\",\\r\\n\\r\\n\\t\\t\\t\\\"\\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\\",\\r\\n\\r\\n\\t\\t\\t\\\"}\\\",\\r\\n\\r\\n\\t\\t\\t\\\"void main() {\\\",\\r\\n\\r\\n\\t\\t\\t\\\"\\tvWorldDirection = transformDirection( position, modelMatrix );\\\",\\r\\n\\r\\n\\t\\t\\t\\\"\\t#include <begin_vertex>\\\",\\r\\n\\t\\t\\t\\\"\\t#include <project_vertex>\\\",\\r\\n\\r\\n\\t\\t\\t\\\"}\\\"\\r\\n\\r\\n\\t\\t].join( '\\\\n' ),\\r\\n\\r\\n\\t\\tfragmentShader: [\\r\\n\\r\\n\\t\\t\\t\\\"uniform sampler2D tEquirect;\\\",\\r\\n\\r\\n\\t\\t\\t\\\"varying vec3 vWorldDirection;\\\",\\r\\n\\r\\n\\t\\t\\t\\\"#include <common>\\\",\\r\\n\\r\\n\\t\\t\\t\\\"void main() {\\\",\\r\\n\\r\\n\\t\\t\\t\\\"\\tvec3 direction = normalize( vWorldDirection );\\\",\\r\\n\\r\\n\\t\\t\\t\\\"\\tvec2 sampleUV = equirectUv( direction );\\\",\\r\\n\\r\\n\\t\\t\\t\\\"\\tgl_FragColor = texture2D( tEquirect, sampleUV );\\\",\\r\\n\\r\\n\\t\\t\\t\\\"}\\\"\\r\\n\\r\\n\\t\\t].join( '\\\\n' ),\\r\\n\\t};\\r\\n\\r\\n\\tvar material = new ShaderMaterial( {\\r\\n\\r\\n\\t\\ttype: 'CubemapFromEquirect',\\r\\n\\r\\n\\t\\tuniforms: cloneUniforms( shader.uniforms ),\\r\\n\\t\\tvertexShader: shader.vertexShader,\\r\\n\\t\\tfragmentShader: shader.fragmentShader,\\r\\n\\t\\tside: BackSide,\\r\\n\\t\\tblending: NoBlending\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\tmaterial.uniforms.tEquirect.value = texture;\\r\\n\\r\\n\\tvar mesh = new Mesh( new BoxBufferGeometry( 5, 5, 5 ), material );\\r\\n\\r\\n\\tscene.add( mesh );\\r\\n\\r\\n\\tvar camera = new CubeCamera( 1, 10, this );\\r\\n\\tcamera.update( renderer, scene );\\r\\n\\r\\n\\tmesh.geometry.dispose();\\r\\n\\tmesh.material.dispose();\\r\\n\\r\\n\\treturn this;\\r\\n\\r\\n};\\r\\n\\r\\n/**\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n */\\r\\n\\r\\nfunction DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\\r\\n\\r\\n\\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\\r\\n\\r\\n\\tthis.image = { data: data || null, width: width || 1, height: height || 1 };\\r\\n\\r\\n\\tthis.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\\r\\n\\tthis.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\\r\\n\\r\\n\\tthis.generateMipmaps = false;\\r\\n\\tthis.flipY = false;\\r\\n\\tthis.unpackAlignment = 1;\\r\\n\\r\\n\\tthis.needsUpdate = true;\\r\\n\\r\\n}\\r\\n\\r\\nDataTexture.prototype = Object.create( Texture.prototype );\\r\\nDataTexture.prototype.constructor = DataTexture;\\r\\n\\r\\nDataTexture.prototype.isDataTexture = true;\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n * @author bhouston / http://clara.io\\r\\n */\\r\\n\\r\\nvar _sphere$1 = new Sphere();\\r\\nvar _vector$5 = new Vector3();\\r\\n\\r\\nfunction Frustum( p0, p1, p2, p3, p4, p5 ) {\\r\\n\\r\\n\\tthis.planes = [\\r\\n\\r\\n\\t\\t( p0 !== undefined ) ? p0 : new Plane(),\\r\\n\\t\\t( p1 !== undefined ) ? p1 : new Plane(),\\r\\n\\t\\t( p2 !== undefined ) ? p2 : new Plane(),\\r\\n\\t\\t( p3 !== undefined ) ? p3 : new Plane(),\\r\\n\\t\\t( p4 !== undefined ) ? p4 : new Plane(),\\r\\n\\t\\t( p5 !== undefined ) ? p5 : new Plane()\\r\\n\\r\\n\\t];\\r\\n\\r\\n}\\r\\n\\r\\nObject.assign( Frustum.prototype, {\\r\\n\\r\\n\\tset: function ( p0, p1, p2, p3, p4, p5 ) {\\r\\n\\r\\n\\t\\tvar planes = this.planes;\\r\\n\\r\\n\\t\\tplanes[ 0 ].copy( p0 );\\r\\n\\t\\tplanes[ 1 ].copy( p1 );\\r\\n\\t\\tplanes[ 2 ].copy( p2 );\\r\\n\\t\\tplanes[ 3 ].copy( p3 );\\r\\n\\t\\tplanes[ 4 ].copy( p4 );\\r\\n\\t\\tplanes[ 5 ].copy( p5 );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclone: function () {\\r\\n\\r\\n\\t\\treturn new this.constructor().copy( this );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcopy: function ( frustum ) {\\r\\n\\r\\n\\t\\tvar planes = this.planes;\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\r\\n\\r\\n\\t\\t\\tplanes[ i ].copy( frustum.planes[ i ] );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetFromProjectionMatrix: function ( m ) {\\r\\n\\r\\n\\t\\tvar planes = this.planes;\\r\\n\\t\\tvar me = m.elements;\\r\\n\\t\\tvar me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];\\r\\n\\t\\tvar me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];\\r\\n\\t\\tvar me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];\\r\\n\\t\\tvar me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];\\r\\n\\r\\n\\t\\tplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\\r\\n\\t\\tplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\\r\\n\\t\\tplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\\r\\n\\t\\tplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\\r\\n\\t\\tplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\\r\\n\\t\\tplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tintersectsObject: function ( object ) {\\r\\n\\r\\n\\t\\tvar geometry = object.geometry;\\r\\n\\r\\n\\t\\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\\r\\n\\r\\n\\t\\t_sphere$1.copy( geometry.boundingSphere ).applyMatrix4( object.matrixWorld );\\r\\n\\r\\n\\t\\treturn this.intersectsSphere( _sphere$1 );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tintersectsSprite: function ( sprite ) {\\r\\n\\r\\n\\t\\t_sphere$1.center.set( 0, 0, 0 );\\r\\n\\t\\t_sphere$1.radius = 0.7071067811865476;\\r\\n\\t\\t_sphere$1.applyMatrix4( sprite.matrixWorld );\\r\\n\\r\\n\\t\\treturn this.intersectsSphere( _sphere$1 );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tintersectsSphere: function ( sphere ) {\\r\\n\\r\\n\\t\\tvar planes = this.planes;\\r\\n\\t\\tvar center = sphere.center;\\r\\n\\t\\tvar negRadius = - sphere.radius;\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar distance = planes[ i ].distanceToPoint( center );\\r\\n\\r\\n\\t\\t\\tif ( distance < negRadius ) {\\r\\n\\r\\n\\t\\t\\t\\treturn false;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn true;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tintersectsBox: function ( box ) {\\r\\n\\r\\n\\t\\tvar planes = this.planes;\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar plane = planes[ i ];\\r\\n\\r\\n\\t\\t\\t// corner at max distance\\r\\n\\r\\n\\t\\t\\t_vector$5.x = plane.normal.x > 0 ? box.max.x : box.min.x;\\r\\n\\t\\t\\t_vector$5.y = plane.normal.y > 0 ? box.max.y : box.min.y;\\r\\n\\t\\t\\t_vector$5.z = plane.normal.z > 0 ? box.max.z : box.min.z;\\r\\n\\r\\n\\t\\t\\tif ( plane.distanceToPoint( _vector$5 ) < 0 ) {\\r\\n\\r\\n\\t\\t\\t\\treturn false;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn true;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcontainsPoint: function ( point ) {\\r\\n\\r\\n\\t\\tvar planes = this.planes;\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\r\\n\\r\\n\\t\\t\\tif ( planes[ i ].distanceToPoint( point ) < 0 ) {\\r\\n\\r\\n\\t\\t\\t\\treturn false;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn true;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * Uniforms library for shared webgl shaders\\r\\n */\\r\\n\\r\\nvar UniformsLib = {\\r\\n\\r\\n\\tcommon: {\\r\\n\\r\\n\\t\\tdiffuse: { value: new Color( 0xeeeeee ) },\\r\\n\\t\\topacity: { value: 1.0 },\\r\\n\\r\\n\\t\\tmap: { value: null },\\r\\n\\t\\tuvTransform: { value: new Matrix3() },\\r\\n\\t\\tuv2Transform: { value: new Matrix3() },\\r\\n\\r\\n\\t\\talphaMap: { value: null },\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tspecularmap: {\\r\\n\\r\\n\\t\\tspecularMap: { value: null },\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tenvmap: {\\r\\n\\r\\n\\t\\tenvMap: { value: null },\\r\\n\\t\\tflipEnvMap: { value: - 1 },\\r\\n\\t\\treflectivity: { value: 1.0 },\\r\\n\\t\\trefractionRatio: { value: 0.98 },\\r\\n\\t\\tmaxMipLevel: { value: 0 }\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\taomap: {\\r\\n\\r\\n\\t\\taoMap: { value: null },\\r\\n\\t\\taoMapIntensity: { value: 1 }\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tlightmap: {\\r\\n\\r\\n\\t\\tlightMap: { value: null },\\r\\n\\t\\tlightMapIntensity: { value: 1 }\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\temissivemap: {\\r\\n\\r\\n\\t\\temissiveMap: { value: null }\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tbumpmap: {\\r\\n\\r\\n\\t\\tbumpMap: { value: null },\\r\\n\\t\\tbumpScale: { value: 1 }\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tnormalmap: {\\r\\n\\r\\n\\t\\tnormalMap: { value: null },\\r\\n\\t\\tnormalScale: { value: new Vector2( 1, 1 ) }\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tdisplacementmap: {\\r\\n\\r\\n\\t\\tdisplacementMap: { value: null },\\r\\n\\t\\tdisplacementScale: { value: 1 },\\r\\n\\t\\tdisplacementBias: { value: 0 }\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\troughnessmap: {\\r\\n\\r\\n\\t\\troughnessMap: { value: null }\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tmetalnessmap: {\\r\\n\\r\\n\\t\\tmetalnessMap: { value: null }\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgradientmap: {\\r\\n\\r\\n\\t\\tgradientMap: { value: null }\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tfog: {\\r\\n\\r\\n\\t\\tfogDensity: { value: 0.00025 },\\r\\n\\t\\tfogNear: { value: 1 },\\r\\n\\t\\tfogFar: { value: 2000 },\\r\\n\\t\\tfogColor: { value: new Color( 0xffffff ) }\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tlights: {\\r\\n\\r\\n\\t\\tambientLightColor: { value: [] },\\r\\n\\r\\n\\t\\tlightProbe: { value: [] },\\r\\n\\r\\n\\t\\tdirectionalLights: { value: [], properties: {\\r\\n\\t\\t\\tdirection: {},\\r\\n\\t\\t\\tcolor: {}\\r\\n\\t\\t} },\\r\\n\\r\\n\\t\\tdirectionalLightShadows: { value: [], properties: {\\r\\n\\t\\t\\tshadowBias: {},\\r\\n\\t\\t\\tshadowRadius: {},\\r\\n\\t\\t\\tshadowMapSize: {}\\r\\n\\t\\t} },\\r\\n\\r\\n\\t\\tdirectionalShadowMap: { value: [] },\\r\\n\\t\\tdirectionalShadowMatrix: { value: [] },\\r\\n\\r\\n\\t\\tspotLights: { value: [], properties: {\\r\\n\\t\\t\\tcolor: {},\\r\\n\\t\\t\\tposition: {},\\r\\n\\t\\t\\tdirection: {},\\r\\n\\t\\t\\tdistance: {},\\r\\n\\t\\t\\tconeCos: {},\\r\\n\\t\\t\\tpenumbraCos: {},\\r\\n\\t\\t\\tdecay: {}\\r\\n\\t\\t} },\\r\\n\\r\\n\\t\\tspotLightShadows: { value: [], properties: {\\r\\n\\t\\t\\tshadowBias: {},\\r\\n\\t\\t\\tshadowRadius: {},\\r\\n\\t\\t\\tshadowMapSize: {}\\r\\n\\t\\t} },\\r\\n\\r\\n\\t\\tspotShadowMap: { value: [] },\\r\\n\\t\\tspotShadowMatrix: { value: [] },\\r\\n\\r\\n\\t\\tpointLights: { value: [], properties: {\\r\\n\\t\\t\\tcolor: {},\\r\\n\\t\\t\\tposition: {},\\r\\n\\t\\t\\tdecay: {},\\r\\n\\t\\t\\tdistance: {}\\r\\n\\t\\t} },\\r\\n\\r\\n\\t\\tpointLightShadows: { value: [], properties: {\\r\\n\\t\\t\\tshadowBias: {},\\r\\n\\t\\t\\tshadowRadius: {},\\r\\n\\t\\t\\tshadowMapSize: {},\\r\\n\\t\\t\\tshadowCameraNear: {},\\r\\n\\t\\t\\tshadowCameraFar: {}\\r\\n\\t\\t} },\\r\\n\\r\\n\\t\\tpointShadowMap: { value: [] },\\r\\n\\t\\tpointShadowMatrix: { value: [] },\\r\\n\\r\\n\\t\\themisphereLights: { value: [], properties: {\\r\\n\\t\\t\\tdirection: {},\\r\\n\\t\\t\\tskyColor: {},\\r\\n\\t\\t\\tgroundColor: {}\\r\\n\\t\\t} },\\r\\n\\r\\n\\t\\t// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src\\r\\n\\t\\trectAreaLights: { value: [], properties: {\\r\\n\\t\\t\\tcolor: {},\\r\\n\\t\\t\\tposition: {},\\r\\n\\t\\t\\twidth: {},\\r\\n\\t\\t\\theight: {}\\r\\n\\t\\t} }\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tpoints: {\\r\\n\\r\\n\\t\\tdiffuse: { value: new Color( 0xeeeeee ) },\\r\\n\\t\\topacity: { value: 1.0 },\\r\\n\\t\\tsize: { value: 1.0 },\\r\\n\\t\\tscale: { value: 1.0 },\\r\\n\\t\\tmap: { value: null },\\r\\n\\t\\talphaMap: { value: null },\\r\\n\\t\\tuvTransform: { value: new Matrix3() }\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsprite: {\\r\\n\\r\\n\\t\\tdiffuse: { value: new Color( 0xeeeeee ) },\\r\\n\\t\\topacity: { value: 1.0 },\\r\\n\\t\\tcenter: { value: new Vector2( 0.5, 0.5 ) },\\r\\n\\t\\trotation: { value: 0.0 },\\r\\n\\t\\tmap: { value: null },\\r\\n\\t\\talphaMap: { value: null },\\r\\n\\t\\tuvTransform: { value: new Matrix3() }\\r\\n\\r\\n\\t}\\r\\n\\r\\n};\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nfunction WebGLAnimation() {\\r\\n\\r\\n\\tvar context = null;\\r\\n\\tvar isAnimating = false;\\r\\n\\tvar animationLoop = null;\\r\\n\\r\\n\\tfunction onAnimationFrame( time, frame ) {\\r\\n\\r\\n\\t\\tif ( isAnimating === false ) return;\\r\\n\\r\\n\\t\\tanimationLoop( time, frame );\\r\\n\\r\\n\\t\\tcontext.requestAnimationFrame( onAnimationFrame );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn {\\r\\n\\r\\n\\t\\tstart: function () {\\r\\n\\r\\n\\t\\t\\tif ( isAnimating === true ) return;\\r\\n\\t\\t\\tif ( animationLoop === null ) return;\\r\\n\\r\\n\\t\\t\\tcontext.requestAnimationFrame( onAnimationFrame );\\r\\n\\r\\n\\t\\t\\tisAnimating = true;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tstop: function () {\\r\\n\\r\\n\\t\\t\\tisAnimating = false;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetAnimationLoop: function ( callback ) {\\r\\n\\r\\n\\t\\t\\tanimationLoop = callback;\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tsetContext: function ( value ) {\\r\\n\\r\\n\\t\\t\\tcontext = value;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t};\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nfunction WebGLAttributes( gl, capabilities ) {\\r\\n\\r\\n\\tvar isWebGL2 = capabilities.isWebGL2;\\r\\n\\r\\n\\tvar buffers = new WeakMap();\\r\\n\\r\\n\\tfunction createBuffer( attribute, bufferType ) {\\r\\n\\r\\n\\t\\tvar array = attribute.array;\\r\\n\\t\\tvar usage = attribute.usage;\\r\\n\\r\\n\\t\\tvar buffer = gl.createBuffer();\\r\\n\\r\\n\\t\\tgl.bindBuffer( bufferType, buffer );\\r\\n\\t\\tgl.bufferData( bufferType, array, usage );\\r\\n\\r\\n\\t\\tattribute.onUploadCallback();\\r\\n\\r\\n\\t\\tvar type = 5126;\\r\\n\\r\\n\\t\\tif ( array instanceof Float32Array ) {\\r\\n\\r\\n\\t\\t\\ttype = 5126;\\r\\n\\r\\n\\t\\t} else if ( array instanceof Float64Array ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.' );\\r\\n\\r\\n\\t\\t} else if ( array instanceof Uint16Array ) {\\r\\n\\r\\n\\t\\t\\ttype = 5123;\\r\\n\\r\\n\\t\\t} else if ( array instanceof Int16Array ) {\\r\\n\\r\\n\\t\\t\\ttype = 5122;\\r\\n\\r\\n\\t\\t} else if ( array instanceof Uint32Array ) {\\r\\n\\r\\n\\t\\t\\ttype = 5125;\\r\\n\\r\\n\\t\\t} else if ( array instanceof Int32Array ) {\\r\\n\\r\\n\\t\\t\\ttype = 5124;\\r\\n\\r\\n\\t\\t} else if ( array instanceof Int8Array ) {\\r\\n\\r\\n\\t\\t\\ttype = 5120;\\r\\n\\r\\n\\t\\t} else if ( array instanceof Uint8Array ) {\\r\\n\\r\\n\\t\\t\\ttype = 5121;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn {\\r\\n\\t\\t\\tbuffer: buffer,\\r\\n\\t\\t\\ttype: type,\\r\\n\\t\\t\\tbytesPerElement: array.BYTES_PER_ELEMENT,\\r\\n\\t\\t\\tversion: attribute.version\\r\\n\\t\\t};\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction updateBuffer( buffer, attribute, bufferType ) {\\r\\n\\r\\n\\t\\tvar array = attribute.array;\\r\\n\\t\\tvar updateRange = attribute.updateRange;\\r\\n\\r\\n\\t\\tgl.bindBuffer( bufferType, buffer );\\r\\n\\r\\n\\t\\tif ( updateRange.count === - 1 ) {\\r\\n\\r\\n\\t\\t\\t// Not using update ranges\\r\\n\\r\\n\\t\\t\\tgl.bufferSubData( bufferType, 0, array );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tif ( isWebGL2 ) {\\r\\n\\r\\n\\t\\t\\t\\tgl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,\\r\\n\\t\\t\\t\\t\\tarray, updateRange.offset, updateRange.count );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tgl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,\\r\\n\\t\\t\\t\\t\\tarray.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tupdateRange.count = - 1; // reset range\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tfunction get( attribute ) {\\r\\n\\r\\n\\t\\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\\r\\n\\r\\n\\t\\treturn buffers.get( attribute );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction remove( attribute ) {\\r\\n\\r\\n\\t\\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\\r\\n\\r\\n\\t\\tvar data = buffers.get( attribute );\\r\\n\\r\\n\\t\\tif ( data ) {\\r\\n\\r\\n\\t\\t\\tgl.deleteBuffer( data.buffer );\\r\\n\\r\\n\\t\\t\\tbuffers.delete( attribute );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction update( attribute, bufferType ) {\\r\\n\\r\\n\\t\\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\\r\\n\\r\\n\\t\\tvar data = buffers.get( attribute );\\r\\n\\r\\n\\t\\tif ( data === undefined ) {\\r\\n\\r\\n\\t\\t\\tbuffers.set( attribute, createBuffer( attribute, bufferType ) );\\r\\n\\r\\n\\t\\t} else if ( data.version < attribute.version ) {\\r\\n\\r\\n\\t\\t\\tupdateBuffer( data.buffer, attribute, bufferType );\\r\\n\\r\\n\\t\\t\\tdata.version = attribute.version;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn {\\r\\n\\r\\n\\t\\tget: get,\\r\\n\\t\\tremove: remove,\\r\\n\\t\\tupdate: update\\r\\n\\r\\n\\t};\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n * @author Mugen87 / https://github.com/Mugen87\\r\\n */\\r\\n\\r\\n// PlaneGeometry\\r\\n\\r\\nfunction PlaneGeometry( width, height, widthSegments, heightSegments ) {\\r\\n\\r\\n\\tGeometry.call( this );\\r\\n\\r\\n\\tthis.type = 'PlaneGeometry';\\r\\n\\r\\n\\tthis.parameters = {\\r\\n\\t\\twidth: width,\\r\\n\\t\\theight: height,\\r\\n\\t\\twidthSegments: widthSegments,\\r\\n\\t\\theightSegments: heightSegments\\r\\n\\t};\\r\\n\\r\\n\\tthis.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );\\r\\n\\tthis.mergeVertices();\\r\\n\\r\\n}\\r\\n\\r\\nPlaneGeometry.prototype = Object.create( Geometry.prototype );\\r\\nPlaneGeometry.prototype.constructor = PlaneGeometry;\\r\\n\\r\\n// PlaneBufferGeometry\\r\\n\\r\\nfunction PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {\\r\\n\\r\\n\\tBufferGeometry.call( this );\\r\\n\\r\\n\\tthis.type = 'PlaneBufferGeometry';\\r\\n\\r\\n\\tthis.parameters = {\\r\\n\\t\\twidth: width,\\r\\n\\t\\theight: height,\\r\\n\\t\\twidthSegments: widthSegments,\\r\\n\\t\\theightSegments: heightSegments\\r\\n\\t};\\r\\n\\r\\n\\twidth = width || 1;\\r\\n\\theight = height || 1;\\r\\n\\r\\n\\tvar width_half = width / 2;\\r\\n\\tvar height_half = height / 2;\\r\\n\\r\\n\\tvar gridX = Math.floor( widthSegments ) || 1;\\r\\n\\tvar gridY = Math.floor( heightSegments ) || 1;\\r\\n\\r\\n\\tvar gridX1 = gridX + 1;\\r\\n\\tvar gridY1 = gridY + 1;\\r\\n\\r\\n\\tvar segment_width = width / gridX;\\r\\n\\tvar segment_height = height / gridY;\\r\\n\\r\\n\\tvar ix, iy;\\r\\n\\r\\n\\t// buffers\\r\\n\\r\\n\\tvar indices = [];\\r\\n\\tvar vertices = [];\\r\\n\\tvar normals = [];\\r\\n\\tvar uvs = [];\\r\\n\\r\\n\\t// generate vertices, normals and uvs\\r\\n\\r\\n\\tfor ( iy = 0; iy < gridY1; iy ++ ) {\\r\\n\\r\\n\\t\\tvar y = iy * segment_height - height_half;\\r\\n\\r\\n\\t\\tfor ( ix = 0; ix < gridX1; ix ++ ) {\\r\\n\\r\\n\\t\\t\\tvar x = ix * segment_width - width_half;\\r\\n\\r\\n\\t\\t\\tvertices.push( x, - y, 0 );\\r\\n\\r\\n\\t\\t\\tnormals.push( 0, 0, 1 );\\r\\n\\r\\n\\t\\t\\tuvs.push( ix / gridX );\\r\\n\\t\\t\\tuvs.push( 1 - ( iy / gridY ) );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// indices\\r\\n\\r\\n\\tfor ( iy = 0; iy < gridY; iy ++ ) {\\r\\n\\r\\n\\t\\tfor ( ix = 0; ix < gridX; ix ++ ) {\\r\\n\\r\\n\\t\\t\\tvar a = ix + gridX1 * iy;\\r\\n\\t\\t\\tvar b = ix + gridX1 * ( iy + 1 );\\r\\n\\t\\t\\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\\r\\n\\t\\t\\tvar d = ( ix + 1 ) + gridX1 * iy;\\r\\n\\r\\n\\t\\t\\t// faces\\r\\n\\r\\n\\t\\t\\tindices.push( a, b, d );\\r\\n\\t\\t\\tindices.push( b, c, d );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// build geometry\\r\\n\\r\\n\\tthis.setIndex( indices );\\r\\n\\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\r\\n\\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\r\\n\\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\r\\n\\r\\n}\\r\\n\\r\\nPlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\r\\nPlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;\\r\\n\\r\\nvar alphamap_fragment = \\\"#ifdef USE_ALPHAMAP\\\\n\\\\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\\\n#endif\\\";\\r\\n\\r\\nvar alphamap_pars_fragment = \\\"#ifdef USE_ALPHAMAP\\\\n\\\\tuniform sampler2D alphaMap;\\\\n#endif\\\";\\r\\n\\r\\nvar alphatest_fragment = \\\"#ifdef ALPHATEST\\\\n\\\\tif ( diffuseColor.a < ALPHATEST ) discard;\\\\n#endif\\\";\\r\\n\\r\\nvar aomap_fragment = \\\"#ifdef USE_AOMAP\\\\n\\\\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\\\n\\\\treflectedLight.indirectDiffuse *= ambientOcclusion;\\\\n\\\\t#if defined( USE_ENVMAP ) && defined( STANDARD )\\\\n\\\\t\\\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\\\n\\\\t\\\\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\\\\n\\\\t#endif\\\\n#endif\\\";\\r\\n\\r\\nvar aomap_pars_fragment = \\\"#ifdef USE_AOMAP\\\\n\\\\tuniform sampler2D aoMap;\\\\n\\\\tuniform float aoMapIntensity;\\\\n#endif\\\";\\r\\n\\r\\nvar begin_vertex = \\\"vec3 transformed = vec3( position );\\\";\\r\\n\\r\\nvar beginnormal_vertex = \\\"vec3 objectNormal = vec3( normal );\\\\n#ifdef USE_TANGENT\\\\n\\\\tvec3 objectTangent = vec3( tangent.xyz );\\\\n#endif\\\";\\r\\n\\r\\nvar bsdfs = \\\"vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\\\\n\\\\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\\\n\\\\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\\\n\\\\tvec4 r = roughness * c0 + c1;\\\\n\\\\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\\\n\\\\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\\\\n}\\\\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\\\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\\\\n\\\\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\\\n\\\\tif( cutoffDistance > 0.0 ) {\\\\n\\\\t\\\\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\\\n\\\\t}\\\\n\\\\treturn distanceFalloff;\\\\n#else\\\\n\\\\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\\\\n\\\\t\\\\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\\\n\\\\t}\\\\n\\\\treturn 1.0;\\\\n#endif\\\\n}\\\\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\\\\n\\\\treturn RECIPROCAL_PI * diffuseColor;\\\\n}\\\\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\\\\n\\\\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\\\\n\\\\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\\\\n}\\\\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\\\\n\\\\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\\\\n\\\\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\\\\n\\\\treturn Fr * fresnel + F0;\\\\n}\\\\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\\\\n\\\\tfloat a2 = pow2( alpha );\\\\n\\\\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\\\n\\\\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\\\n\\\\treturn 1.0 / ( gl * gv );\\\\n}\\\\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\\\n\\\\tfloat a2 = pow2( alpha );\\\\n\\\\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\\\n\\\\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\\\n\\\\treturn 0.5 / max( gv + gl, EPSILON );\\\\n}\\\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\\\n\\\\tfloat a2 = pow2( alpha );\\\\n\\\\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\\\n\\\\treturn RECIPROCAL_PI * a2 / pow2( denom );\\\\n}\\\\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\\\\n\\\\tfloat alpha = pow2( roughness );\\\\n\\\\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\\\\n\\\\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\\\\n\\\\tfloat dotNV = saturate( dot( normal, viewDir ) );\\\\n\\\\tfloat dotNH = saturate( dot( normal, halfDir ) );\\\\n\\\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\\\n\\\\tvec3 F = F_Schlick( specularColor, dotLH );\\\\n\\\\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\\\n\\\\tfloat D = D_GGX( alpha, dotNH );\\\\n\\\\treturn F * ( G * D );\\\\n}\\\\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\\\\n\\\\tconst float LUT_SIZE  = 64.0;\\\\n\\\\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\\\\n\\\\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\\\\n\\\\tfloat dotNV = saturate( dot( N, V ) );\\\\n\\\\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\\\\n\\\\tuv = uv * LUT_SCALE + LUT_BIAS;\\\\n\\\\treturn uv;\\\\n}\\\\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\\\\n\\\\tfloat l = length( f );\\\\n\\\\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\\\\n}\\\\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\\\\n\\\\tfloat x = dot( v1, v2 );\\\\n\\\\tfloat y = abs( x );\\\\n\\\\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\\\\n\\\\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\\\\n\\\\tfloat v = a / b;\\\\n\\\\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\\\\n\\\\treturn cross( v1, v2 ) * theta_sintheta;\\\\n}\\\\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\\\\n\\\\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\\\\n\\\\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\\\\n\\\\tvec3 lightNormal = cross( v1, v2 );\\\\n\\\\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\\\\n\\\\tvec3 T1, T2;\\\\n\\\\tT1 = normalize( V - N * dot( V, N ) );\\\\n\\\\tT2 = - cross( N, T1 );\\\\n\\\\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\\\\n\\\\tvec3 coords[ 4 ];\\\\n\\\\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\\\\n\\\\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\\\\n\\\\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\\\\n\\\\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\\\\n\\\\tcoords[ 0 ] = normalize( coords[ 0 ] );\\\\n\\\\tcoords[ 1 ] = normalize( coords[ 1 ] );\\\\n\\\\tcoords[ 2 ] = normalize( coords[ 2 ] );\\\\n\\\\tcoords[ 3 ] = normalize( coords[ 3 ] );\\\\n\\\\tvec3 vectorFormFactor = vec3( 0.0 );\\\\n\\\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\\\\n\\\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\\\\n\\\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\\\\n\\\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\\\\n\\\\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\\\\n\\\\treturn vec3( result );\\\\n}\\\\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\\\\n\\\\tfloat dotNV = saturate( dot( normal, viewDir ) );\\\\n\\\\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\\\\n\\\\treturn specularColor * brdf.x + brdf.y;\\\\n}\\\\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\\\\n\\\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\\\n\\\\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\\\\n\\\\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\\\\n\\\\tvec3 FssEss = F * brdf.x + brdf.y;\\\\n\\\\tfloat Ess = brdf.x + brdf.y;\\\\n\\\\tfloat Ems = 1.0 - Ess;\\\\n\\\\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\\\\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\\\\n\\\\tsingleScatter += FssEss;\\\\n\\\\tmultiScatter += Fms * Ems;\\\\n}\\\\nfloat G_BlinnPhong_Implicit( ) {\\\\n\\\\treturn 0.25;\\\\n}\\\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\\\n\\\\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\\\n}\\\\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\\\\n\\\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\\\n\\\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\\\n\\\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\\\n\\\\tvec3 F = F_Schlick( specularColor, dotLH );\\\\n\\\\tfloat G = G_BlinnPhong_Implicit( );\\\\n\\\\tfloat D = D_BlinnPhong( shininess, dotNH );\\\\n\\\\treturn F * ( G * D );\\\\n}\\\\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\\\n\\\\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\\\\n}\\\\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\\\\n\\\\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\\\\n}\\\\n#if defined( USE_SHEEN )\\\\nfloat D_Charlie(float roughness, float NoH) {\\\\n\\\\tfloat invAlpha  = 1.0 / roughness;\\\\n\\\\tfloat cos2h = NoH * NoH;\\\\n\\\\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\\\\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\\\\n}\\\\nfloat V_Neubelt(float NoV, float NoL) {\\\\n\\\\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\\\\n}\\\\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\\\\n\\\\tvec3 N = geometry.normal;\\\\n\\\\tvec3 V = geometry.viewDir;\\\\n\\\\tvec3 H = normalize( V + L );\\\\n\\\\tfloat dotNH = saturate( dot( N, H ) );\\\\n\\\\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\\\\n}\\\\n#endif\\\";\\r\\n\\r\\nvar bumpmap_pars_fragment = \\\"#ifdef USE_BUMPMAP\\\\n\\\\tuniform sampler2D bumpMap;\\\\n\\\\tuniform float bumpScale;\\\\n\\\\tvec2 dHdxy_fwd() {\\\\n\\\\t\\\\tvec2 dSTdx = dFdx( vUv );\\\\n\\\\t\\\\tvec2 dSTdy = dFdy( vUv );\\\\n\\\\t\\\\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\\\n\\\\t\\\\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\\\n\\\\t\\\\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\\\n\\\\t\\\\treturn vec2( dBx, dBy );\\\\n\\\\t}\\\\n\\\\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\\\n\\\\t\\\\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\\\\n\\\\t\\\\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\\\\n\\\\t\\\\tvec3 vN = surf_norm;\\\\n\\\\t\\\\tvec3 R1 = cross( vSigmaY, vN );\\\\n\\\\t\\\\tvec3 R2 = cross( vN, vSigmaX );\\\\n\\\\t\\\\tfloat fDet = dot( vSigmaX, R1 );\\\\n\\\\t\\\\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\\\n\\\\t\\\\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\\\n\\\\t\\\\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\\\n\\\\t}\\\\n#endif\\\";\\r\\n\\r\\nvar clipping_planes_fragment = \\\"#if NUM_CLIPPING_PLANES > 0\\\\n\\\\tvec4 plane;\\\\n\\\\t#pragma unroll_loop_start\\\\n\\\\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\\\\n\\\\t\\\\tplane = clippingPlanes[ i ];\\\\n\\\\t\\\\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\\\\n\\\\t}\\\\n\\\\t#pragma unroll_loop_end\\\\n\\\\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\\\\n\\\\t\\\\tbool clipped = true;\\\\n\\\\t\\\\t#pragma unroll_loop_start\\\\n\\\\t\\\\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\\\\n\\\\t\\\\t\\\\tplane = clippingPlanes[ i ];\\\\n\\\\t\\\\t\\\\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\\\\n\\\\t\\\\t}\\\\n\\\\t\\\\t#pragma unroll_loop_end\\\\n\\\\t\\\\tif ( clipped ) discard;\\\\n\\\\t#endif\\\\n#endif\\\";\\r\\n\\r\\nvar clipping_planes_pars_fragment = \\\"#if NUM_CLIPPING_PLANES > 0\\\\n\\\\tvarying vec3 vClipPosition;\\\\n\\\\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\\\n#endif\\\";\\r\\n\\r\\nvar clipping_planes_pars_vertex = \\\"#if NUM_CLIPPING_PLANES > 0\\\\n\\\\tvarying vec3 vClipPosition;\\\\n#endif\\\";\\r\\n\\r\\nvar clipping_planes_vertex = \\\"#if NUM_CLIPPING_PLANES > 0\\\\n\\\\tvClipPosition = - mvPosition.xyz;\\\\n#endif\\\";\\r\\n\\r\\nvar color_fragment = \\\"#ifdef USE_COLOR\\\\n\\\\tdiffuseColor.rgb *= vColor;\\\\n#endif\\\";\\r\\n\\r\\nvar color_pars_fragment = \\\"#ifdef USE_COLOR\\\\n\\\\tvarying vec3 vColor;\\\\n#endif\\\";\\r\\n\\r\\nvar color_pars_vertex = \\\"#ifdef USE_COLOR\\\\n\\\\tvarying vec3 vColor;\\\\n#endif\\\";\\r\\n\\r\\nvar color_vertex = \\\"#ifdef USE_COLOR\\\\n\\\\tvColor.xyz = color.xyz;\\\\n#endif\\\";\\r\\n\\r\\nvar common = \\\"#define PI 3.14159265359\\\\n#define PI2 6.28318530718\\\\n#define PI_HALF 1.5707963267949\\\\n#define RECIPROCAL_PI 0.31830988618\\\\n#define RECIPROCAL_PI2 0.15915494\\\\n#define LOG2 1.442695\\\\n#define EPSILON 1e-6\\\\n#ifndef saturate\\\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\\\n#endif\\\\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\\\\nfloat pow2( const in float x ) { return x*x; }\\\\nfloat pow3( const in float x ) { return x*x*x; }\\\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\\\nhighp float rand( const in vec2 uv ) {\\\\n\\\\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\\\n\\\\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\\\n\\\\treturn fract(sin(sn) * c);\\\\n}\\\\n#ifdef HIGH_PRECISION\\\\n\\\\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\\\\n#else\\\\n\\\\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\\\\n\\\\tfloat precisionSafeLength( vec3 v ) {\\\\n\\\\t\\\\tfloat maxComponent = max3( abs( v ) );\\\\n\\\\t\\\\treturn length( v / maxComponent ) * maxComponent;\\\\n\\\\t}\\\\n#endif\\\\nstruct IncidentLight {\\\\n\\\\tvec3 color;\\\\n\\\\tvec3 direction;\\\\n\\\\tbool visible;\\\\n};\\\\nstruct ReflectedLight {\\\\n\\\\tvec3 directDiffuse;\\\\n\\\\tvec3 directSpecular;\\\\n\\\\tvec3 indirectDiffuse;\\\\n\\\\tvec3 indirectSpecular;\\\\n};\\\\nstruct GeometricContext {\\\\n\\\\tvec3 position;\\\\n\\\\tvec3 normal;\\\\n\\\\tvec3 viewDir;\\\\n#ifdef CLEARCOAT\\\\n\\\\tvec3 clearcoatNormal;\\\\n#endif\\\\n};\\\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\\\n\\\\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\\\n}\\\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\\\n\\\\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\\\n}\\\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\\\n\\\\tfloat distance = dot( planeNormal, point - pointOnPlane );\\\\n\\\\treturn - distance * planeNormal + point;\\\\n}\\\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\\\n\\\\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\\\n}\\\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\\\n\\\\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\\\\n}\\\\nmat3 transposeMat3( const in mat3 m ) {\\\\n\\\\tmat3 tmp;\\\\n\\\\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\\\\n\\\\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\\\\n\\\\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\\\\n\\\\treturn tmp;\\\\n}\\\\nfloat linearToRelativeLuminance( const in vec3 color ) {\\\\n\\\\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\\\\n\\\\treturn dot( weights, color.rgb );\\\\n}\\\\nbool isPerspectiveMatrix( mat4 m ) {\\\\n  return m[ 2 ][ 3 ] == - 1.0;\\\\n}\\\\nvec2 equirectUv( in vec3 dir ) {\\\\n\\\\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\\\\n\\\\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\\\n\\\\treturn vec2( u, v );\\\\n}\\\";\\r\\n\\r\\nvar cube_uv_reflection_fragment = \\\"#ifdef ENVMAP_TYPE_CUBE_UV\\\\n#define cubeUV_maxMipLevel 8.0\\\\n#define cubeUV_minMipLevel 4.0\\\\n#define cubeUV_maxTileSize 256.0\\\\n#define cubeUV_minTileSize 16.0\\\\nfloat getFace(vec3 direction) {\\\\n    vec3 absDirection = abs(direction);\\\\n    float face = -1.0;\\\\n    if (absDirection.x > absDirection.z) {\\\\n      if (absDirection.x > absDirection.y)\\\\n        face = direction.x > 0.0 ? 0.0 : 3.0;\\\\n      else\\\\n        face = direction.y > 0.0 ? 1.0 : 4.0;\\\\n    } else {\\\\n      if (absDirection.z > absDirection.y)\\\\n        face = direction.z > 0.0 ? 2.0 : 5.0;\\\\n      else\\\\n        face = direction.y > 0.0 ? 1.0 : 4.0;\\\\n    }\\\\n    return face;\\\\n}\\\\nvec2 getUV(vec3 direction, float face) {\\\\n    vec2 uv;\\\\n    if (face == 0.0) {\\\\n      uv = vec2(direction.z, direction.y) / abs(direction.x);    } else if (face == 1.0) {\\\\n      uv = vec2(-direction.x, -direction.z) / abs(direction.y);    } else if (face == 2.0) {\\\\n      uv = vec2(-direction.x, direction.y) / abs(direction.z);    } else if (face == 3.0) {\\\\n      uv = vec2(-direction.z, direction.y) / abs(direction.x);    } else if (face == 4.0) {\\\\n      uv = vec2(-direction.x, direction.z) / abs(direction.y);    } else {\\\\n      uv = vec2(direction.x, direction.y) / abs(direction.z);    }\\\\n    return 0.5 * (uv + 1.0);\\\\n}\\\\nvec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\\\\n  float face = getFace(direction);\\\\n  float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\\\\n  mipInt = max(mipInt, cubeUV_minMipLevel);\\\\n  float faceSize = exp2(mipInt);\\\\n  float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\\\\n  vec2 uv = getUV(direction, face) * (faceSize - 1.0);\\\\n  vec2 f = fract(uv);\\\\n  uv += 0.5 - f;\\\\n  if (face > 2.0) {\\\\n    uv.y += faceSize;\\\\n    face -= 3.0;\\\\n  }\\\\n  uv.x += face * faceSize;\\\\n  if(mipInt < cubeUV_maxMipLevel){\\\\n    uv.y += 2.0 * cubeUV_maxTileSize;\\\\n  }\\\\n  uv.y += filterInt * 2.0 * cubeUV_minTileSize;\\\\n  uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\\\\n  uv *= texelSize;\\\\n  vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\\\\n  uv.x += texelSize;\\\\n  vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\\\\n  uv.y += texelSize;\\\\n  vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\\\\n  uv.x -= texelSize;\\\\n  vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\\\\n  vec3 tm = mix(tl, tr, f.x);\\\\n  vec3 bm = mix(bl, br, f.x);\\\\n  return mix(tm, bm, f.y);\\\\n}\\\\n#define r0 1.0\\\\n#define v0 0.339\\\\n#define m0 -2.0\\\\n#define r1 0.8\\\\n#define v1 0.276\\\\n#define m1 -1.0\\\\n#define r4 0.4\\\\n#define v4 0.046\\\\n#define m4 2.0\\\\n#define r5 0.305\\\\n#define v5 0.016\\\\n#define m5 3.0\\\\n#define r6 0.21\\\\n#define v6 0.0038\\\\n#define m6 4.0\\\\nfloat roughnessToMip(float roughness) {\\\\n  float mip = 0.0;\\\\n  if (roughness >= r1) {\\\\n    mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\\\\n  } else if (roughness >= r4) {\\\\n    mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\\\\n  } else if (roughness >= r5) {\\\\n    mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\\\\n  } else if (roughness >= r6) {\\\\n    mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\\\\n  } else {\\\\n    mip = -2.0 * log2(1.16 * roughness);  }\\\\n  return mip;\\\\n}\\\\nvec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {\\\\n  float mip = clamp(roughnessToMip(roughness), m0, cubeUV_maxMipLevel);\\\\n  float mipF = fract(mip);\\\\n  float mipInt = floor(mip);\\\\n  vec3 color0 = bilinearCubeUV(envMap, sampleDir, mipInt);\\\\n  if (mipF == 0.0) {\\\\n    return vec4(color0, 1.0);\\\\n  } else {\\\\n    vec3 color1 = bilinearCubeUV(envMap, sampleDir, mipInt + 1.0);\\\\n    return vec4(mix(color0, color1, mipF), 1.0);\\\\n  }\\\\n}\\\\n#endif\\\";\\r\\n\\r\\nvar defaultnormal_vertex = \\\"vec3 transformedNormal = objectNormal;\\\\n#ifdef USE_INSTANCING\\\\n\\\\tmat3 m = mat3( instanceMatrix );\\\\n\\\\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\\\\n\\\\ttransformedNormal = m * transformedNormal;\\\\n#endif\\\\ntransformedNormal = normalMatrix * transformedNormal;\\\\n#ifdef FLIP_SIDED\\\\n\\\\ttransformedNormal = - transformedNormal;\\\\n#endif\\\\n#ifdef USE_TANGENT\\\\n\\\\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\\\\n\\\\t#ifdef FLIP_SIDED\\\\n\\\\t\\\\ttransformedTangent = - transformedTangent;\\\\n\\\\t#endif\\\\n#endif\\\";\\r\\n\\r\\nvar displacementmap_pars_vertex = \\\"#ifdef USE_DISPLACEMENTMAP\\\\n\\\\tuniform sampler2D displacementMap;\\\\n\\\\tuniform float displacementScale;\\\\n\\\\tuniform float displacementBias;\\\\n#endif\\\";\\r\\n\\r\\nvar displacementmap_vertex = \\\"#ifdef USE_DISPLACEMENTMAP\\\\n\\\\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\\\\n#endif\\\";\\r\\n\\r\\nvar emissivemap_fragment = \\\"#ifdef USE_EMISSIVEMAP\\\\n\\\\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\\\n\\\\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\\\\n\\\\ttotalEmissiveRadiance *= emissiveColor.rgb;\\\\n#endif\\\";\\r\\n\\r\\nvar emissivemap_pars_fragment = \\\"#ifdef USE_EMISSIVEMAP\\\\n\\\\tuniform sampler2D emissiveMap;\\\\n#endif\\\";\\r\\n\\r\\nvar encodings_fragment = \\\"gl_FragColor = linearToOutputTexel( gl_FragColor );\\\";\\r\\n\\r\\nvar encodings_pars_fragment = \\\"\\\\nvec4 LinearToLinear( in vec4 value ) {\\\\n\\\\treturn value;\\\\n}\\\\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\\\\n\\\\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\\\\n}\\\\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\\\\n\\\\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\\\\n}\\\\nvec4 sRGBToLinear( in vec4 value ) {\\\\n\\\\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\\\\n}\\\\nvec4 LinearTosRGB( in vec4 value ) {\\\\n\\\\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\\\\n}\\\\nvec4 RGBEToLinear( in vec4 value ) {\\\\n\\\\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\\\\n}\\\\nvec4 LinearToRGBE( in vec4 value ) {\\\\n\\\\tfloat maxComponent = max( max( value.r, value.g ), value.b );\\\\n\\\\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\\\\n\\\\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\\\\n}\\\\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\\\\n\\\\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\\\\n}\\\\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\\\\n\\\\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\\\\n\\\\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\\\\n\\\\tM = ceil( M * 255.0 ) / 255.0;\\\\n\\\\treturn vec4( value.rgb / ( M * maxRange ), M );\\\\n}\\\\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\\\\n\\\\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\\\\n}\\\\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\\\\n\\\\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\\\\n\\\\tfloat D = max( maxRange / maxRGB, 1.0 );\\\\n\\\\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\\\\n\\\\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\\\\n}\\\\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\\\\nvec4 LinearToLogLuv( in vec4 value )  {\\\\n\\\\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\\\\n\\\\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\\\\n\\\\tvec4 vResult;\\\\n\\\\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\\\\n\\\\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\\\\n\\\\tvResult.w = fract( Le );\\\\n\\\\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\\\\n\\\\treturn vResult;\\\\n}\\\\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\\\\nvec4 LogLuvToLinear( in vec4 value ) {\\\\n\\\\tfloat Le = value.z * 255.0 + value.w;\\\\n\\\\tvec3 Xp_Y_XYZp;\\\\n\\\\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\\\\n\\\\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\\\\n\\\\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\\\\n\\\\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\\\\n\\\\treturn vec4( max( vRGB, 0.0 ), 1.0 );\\\\n}\\\";\\r\\n\\r\\nvar envmap_fragment = \\\"#ifdef USE_ENVMAP\\\\n\\\\t#ifdef ENV_WORLDPOS\\\\n\\\\t\\\\tvec3 cameraToFrag;\\\\n\\\\t\\\\t\\\\n\\\\t\\\\tif ( isOrthographic ) {\\\\n\\\\t\\\\t\\\\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\\\\n\\\\t\\\\t}  else {\\\\n\\\\t\\\\t\\\\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\\\\n\\\\t\\\\t}\\\\n\\\\t\\\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\\\n\\\\t\\\\t#ifdef ENVMAP_MODE_REFLECTION\\\\n\\\\t\\\\t\\\\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\\\\n\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\\\\n\\\\t\\\\t#endif\\\\n\\\\t#else\\\\n\\\\t\\\\tvec3 reflectVec = vReflect;\\\\n\\\\t#endif\\\\n\\\\t#ifdef ENVMAP_TYPE_CUBE\\\\n\\\\t\\\\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\\\n\\\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\\\n\\\\t\\\\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\\\\n\\\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\\\n\\\\t\\\\treflectVec = normalize( reflectVec );\\\\n\\\\t\\\\tvec2 sampleUV = equirectUv( reflectVec );\\\\n\\\\t\\\\tvec4 envColor = texture2D( envMap, sampleUV );\\\\n\\\\t#elif defined( ENVMAP_TYPE_SPHERE )\\\\n\\\\t\\\\treflectVec = normalize( reflectVec );\\\\n\\\\t\\\\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\\\\n\\\\t\\\\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\\\\n\\\\t#else\\\\n\\\\t\\\\tvec4 envColor = vec4( 0.0 );\\\\n\\\\t#endif\\\\n\\\\t#ifndef ENVMAP_TYPE_CUBE_UV\\\\n\\\\t\\\\tenvColor = envMapTexelToLinear( envColor );\\\\n\\\\t#endif\\\\n\\\\t#ifdef ENVMAP_BLENDING_MULTIPLY\\\\n\\\\t\\\\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\\\n\\\\t#elif defined( ENVMAP_BLENDING_MIX )\\\\n\\\\t\\\\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\\\n\\\\t#elif defined( ENVMAP_BLENDING_ADD )\\\\n\\\\t\\\\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\\\n\\\\t#endif\\\\n#endif\\\";\\r\\n\\r\\nvar envmap_common_pars_fragment = \\\"#ifdef USE_ENVMAP\\\\n\\\\tuniform float envMapIntensity;\\\\n\\\\tuniform float flipEnvMap;\\\\n\\\\tuniform int maxMipLevel;\\\\n\\\\t#ifdef ENVMAP_TYPE_CUBE\\\\n\\\\t\\\\tuniform samplerCube envMap;\\\\n\\\\t#else\\\\n\\\\t\\\\tuniform sampler2D envMap;\\\\n\\\\t#endif\\\\n\\\\t\\\\n#endif\\\";\\r\\n\\r\\nvar envmap_pars_fragment = \\\"#ifdef USE_ENVMAP\\\\n\\\\tuniform float reflectivity;\\\\n\\\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\\\n\\\\t\\\\t#define ENV_WORLDPOS\\\\n\\\\t#endif\\\\n\\\\t#ifdef ENV_WORLDPOS\\\\n\\\\t\\\\tvarying vec3 vWorldPosition;\\\\n\\\\t\\\\tuniform float refractionRatio;\\\\n\\\\t#else\\\\n\\\\t\\\\tvarying vec3 vReflect;\\\\n\\\\t#endif\\\\n#endif\\\";\\r\\n\\r\\nvar envmap_pars_vertex = \\\"#ifdef USE_ENVMAP\\\\n\\\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\\\\n\\\\t\\\\t#define ENV_WORLDPOS\\\\n\\\\t#endif\\\\n\\\\t#ifdef ENV_WORLDPOS\\\\n\\\\t\\\\t\\\\n\\\\t\\\\tvarying vec3 vWorldPosition;\\\\n\\\\t#else\\\\n\\\\t\\\\tvarying vec3 vReflect;\\\\n\\\\t\\\\tuniform float refractionRatio;\\\\n\\\\t#endif\\\\n#endif\\\";\\r\\n\\r\\nvar envmap_vertex = \\\"#ifdef USE_ENVMAP\\\\n\\\\t#ifdef ENV_WORLDPOS\\\\n\\\\t\\\\tvWorldPosition = worldPosition.xyz;\\\\n\\\\t#else\\\\n\\\\t\\\\tvec3 cameraToVertex;\\\\n\\\\t\\\\tif ( isOrthographic ) { \\\\n\\\\t\\\\t\\\\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\\\\n\\\\t\\\\t} else {\\\\n\\\\t\\\\t\\\\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\\\n\\\\t\\\\t}\\\\n\\\\t\\\\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\\\n\\\\t\\\\t#ifdef ENVMAP_MODE_REFLECTION\\\\n\\\\t\\\\t\\\\tvReflect = reflect( cameraToVertex, worldNormal );\\\\n\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\\\n\\\\t\\\\t#endif\\\\n\\\\t#endif\\\\n#endif\\\";\\r\\n\\r\\nvar fog_vertex = \\\"#ifdef USE_FOG\\\\n\\\\tfogDepth = -mvPosition.z;\\\\n#endif\\\";\\r\\n\\r\\nvar fog_pars_vertex = \\\"#ifdef USE_FOG\\\\n\\\\tvarying float fogDepth;\\\\n#endif\\\";\\r\\n\\r\\nvar fog_fragment = \\\"#ifdef USE_FOG\\\\n\\\\t#ifdef FOG_EXP2\\\\n\\\\t\\\\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\\\\n\\\\t#else\\\\n\\\\t\\\\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\\\\n\\\\t#endif\\\\n\\\\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\\\n#endif\\\";\\r\\n\\r\\nvar fog_pars_fragment = \\\"#ifdef USE_FOG\\\\n\\\\tuniform vec3 fogColor;\\\\n\\\\tvarying float fogDepth;\\\\n\\\\t#ifdef FOG_EXP2\\\\n\\\\t\\\\tuniform float fogDensity;\\\\n\\\\t#else\\\\n\\\\t\\\\tuniform float fogNear;\\\\n\\\\t\\\\tuniform float fogFar;\\\\n\\\\t#endif\\\\n#endif\\\";\\r\\n\\r\\nvar gradientmap_pars_fragment = \\\"#ifdef USE_GRADIENTMAP\\\\n\\\\tuniform sampler2D gradientMap;\\\\n#endif\\\\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\\\\n\\\\tfloat dotNL = dot( normal, lightDirection );\\\\n\\\\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\\\\n\\\\t#ifdef USE_GRADIENTMAP\\\\n\\\\t\\\\treturn texture2D( gradientMap, coord ).rgb;\\\\n\\\\t#else\\\\n\\\\t\\\\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\\\\n\\\\t#endif\\\\n}\\\";\\r\\n\\r\\nvar lightmap_fragment = \\\"#ifdef USE_LIGHTMAP\\\\n\\\\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\\\\n\\\\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\\\\n#endif\\\";\\r\\n\\r\\nvar lightmap_pars_fragment = \\\"#ifdef USE_LIGHTMAP\\\\n\\\\tuniform sampler2D lightMap;\\\\n\\\\tuniform float lightMapIntensity;\\\\n#endif\\\";\\r\\n\\r\\nvar lights_lambert_vertex = \\\"vec3 diffuse = vec3( 1.0 );\\\\nGeometricContext geometry;\\\\ngeometry.position = mvPosition.xyz;\\\\ngeometry.normal = normalize( transformedNormal );\\\\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\\\\nGeometricContext backGeometry;\\\\nbackGeometry.position = geometry.position;\\\\nbackGeometry.normal = -geometry.normal;\\\\nbackGeometry.viewDir = geometry.viewDir;\\\\nvLightFront = vec3( 0.0 );\\\\nvIndirectFront = vec3( 0.0 );\\\\n#ifdef DOUBLE_SIDED\\\\n\\\\tvLightBack = vec3( 0.0 );\\\\n\\\\tvIndirectBack = vec3( 0.0 );\\\\n#endif\\\\nIncidentLight directLight;\\\\nfloat dotNL;\\\\nvec3 directLightColor_Diffuse;\\\\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\\\\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\\\\n#ifdef DOUBLE_SIDED\\\\n\\\\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\\\\n\\\\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\\\\n#endif\\\\n#if NUM_POINT_LIGHTS > 0\\\\n\\\\t#pragma unroll_loop_start\\\\n\\\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\\\\n\\\\t\\\\tdotNL = dot( geometry.normal, directLight.direction );\\\\n\\\\t\\\\tdirectLightColor_Diffuse = PI * directLight.color;\\\\n\\\\t\\\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\\\n\\\\t\\\\t#ifdef DOUBLE_SIDED\\\\n\\\\t\\\\t\\\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\\\n\\\\t\\\\t#endif\\\\n\\\\t}\\\\n\\\\t#pragma unroll_loop_end\\\\n#endif\\\\n#if NUM_SPOT_LIGHTS > 0\\\\n\\\\t#pragma unroll_loop_start\\\\n\\\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\\\\n\\\\t\\\\tdotNL = dot( geometry.normal, directLight.direction );\\\\n\\\\t\\\\tdirectLightColor_Diffuse = PI * directLight.color;\\\\n\\\\t\\\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\\\n\\\\t\\\\t#ifdef DOUBLE_SIDED\\\\n\\\\t\\\\t\\\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\\\n\\\\t\\\\t#endif\\\\n\\\\t}\\\\n\\\\t#pragma unroll_loop_end\\\\n#endif\\\\n#if NUM_DIR_LIGHTS > 0\\\\n\\\\t#pragma unroll_loop_start\\\\n\\\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\\\\n\\\\t\\\\tdotNL = dot( geometry.normal, directLight.direction );\\\\n\\\\t\\\\tdirectLightColor_Diffuse = PI * directLight.color;\\\\n\\\\t\\\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\\\n\\\\t\\\\t#ifdef DOUBLE_SIDED\\\\n\\\\t\\\\t\\\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\\\n\\\\t\\\\t#endif\\\\n\\\\t}\\\\n\\\\t#pragma unroll_loop_end\\\\n#endif\\\\n#if NUM_HEMI_LIGHTS > 0\\\\n\\\\t#pragma unroll_loop_start\\\\n\\\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\\\n\\\\t\\\\t#ifdef DOUBLE_SIDED\\\\n\\\\t\\\\t\\\\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\\\\n\\\\t\\\\t#endif\\\\n\\\\t}\\\\n\\\\t#pragma unroll_loop_end\\\\n#endif\\\";\\r\\n\\r\\nvar lights_pars_begin = \\\"uniform bool receiveShadow;\\\\nuniform vec3 ambientLightColor;\\\\nuniform vec3 lightProbe[ 9 ];\\\\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\\\\n\\\\tfloat x = normal.x, y = normal.y, z = normal.z;\\\\n\\\\tvec3 result = shCoefficients[ 0 ] * 0.886227;\\\\n\\\\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\\\\n\\\\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\\\\n\\\\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\\\\n\\\\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\\\\n\\\\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\\\\n\\\\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\\\\n\\\\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\\\\n\\\\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\\\\n\\\\treturn result;\\\\n}\\\\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\\\\n\\\\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\\\n\\\\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\\\\n\\\\treturn irradiance;\\\\n}\\\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\\\n\\\\tvec3 irradiance = ambientLightColor;\\\\n\\\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\\\n\\\\t\\\\tirradiance *= PI;\\\\n\\\\t#endif\\\\n\\\\treturn irradiance;\\\\n}\\\\n#if NUM_DIR_LIGHTS > 0\\\\n\\\\tstruct DirectionalLight {\\\\n\\\\t\\\\tvec3 direction;\\\\n\\\\t\\\\tvec3 color;\\\\n\\\\t};\\\\n\\\\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\\\n\\\\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\\\\n\\\\t\\\\tstruct DirectionalLightShadow {\\\\n\\\\t\\\\t\\\\tfloat shadowBias;\\\\n\\\\t\\\\t\\\\tfloat shadowRadius;\\\\n\\\\t\\\\t\\\\tvec2 shadowMapSize;\\\\n\\\\t\\\\t};\\\\n\\\\t\\\\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\\\\n\\\\t#endif\\\\n\\\\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\\\n\\\\t\\\\tdirectLight.color = directionalLight.color;\\\\n\\\\t\\\\tdirectLight.direction = directionalLight.direction;\\\\n\\\\t\\\\tdirectLight.visible = true;\\\\n\\\\t}\\\\n#endif\\\\n#if NUM_POINT_LIGHTS > 0\\\\n\\\\tstruct PointLight {\\\\n\\\\t\\\\tvec3 position;\\\\n\\\\t\\\\tvec3 color;\\\\n\\\\t\\\\tfloat distance;\\\\n\\\\t\\\\tfloat decay;\\\\n\\\\t};\\\\n\\\\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\\\n\\\\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\\\\n\\\\t\\\\tstruct PointLightShadow {\\\\n\\\\t\\\\t\\\\tfloat shadowBias;\\\\n\\\\t\\\\t\\\\tfloat shadowRadius;\\\\n\\\\t\\\\t\\\\tvec2 shadowMapSize;\\\\n\\\\t\\\\t\\\\tfloat shadowCameraNear;\\\\n\\\\t\\\\t\\\\tfloat shadowCameraFar;\\\\n\\\\t\\\\t};\\\\n\\\\t\\\\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\\\\n\\\\t#endif\\\\n\\\\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\\\n\\\\t\\\\tvec3 lVector = pointLight.position - geometry.position;\\\\n\\\\t\\\\tdirectLight.direction = normalize( lVector );\\\\n\\\\t\\\\tfloat lightDistance = length( lVector );\\\\n\\\\t\\\\tdirectLight.color = pointLight.color;\\\\n\\\\t\\\\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\\\\n\\\\t\\\\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\\\\n\\\\t}\\\\n#endif\\\\n#if NUM_SPOT_LIGHTS > 0\\\\n\\\\tstruct SpotLight {\\\\n\\\\t\\\\tvec3 position;\\\\n\\\\t\\\\tvec3 direction;\\\\n\\\\t\\\\tvec3 color;\\\\n\\\\t\\\\tfloat distance;\\\\n\\\\t\\\\tfloat decay;\\\\n\\\\t\\\\tfloat coneCos;\\\\n\\\\t\\\\tfloat penumbraCos;\\\\n\\\\t};\\\\n\\\\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\\\n\\\\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\\\\n\\\\t\\\\tstruct SpotLightShadow {\\\\n\\\\t\\\\t\\\\tfloat shadowBias;\\\\n\\\\t\\\\t\\\\tfloat shadowRadius;\\\\n\\\\t\\\\t\\\\tvec2 shadowMapSize;\\\\n\\\\t\\\\t};\\\\n\\\\t\\\\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\\\\n\\\\t#endif\\\\n\\\\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\\\\n\\\\t\\\\tvec3 lVector = spotLight.position - geometry.position;\\\\n\\\\t\\\\tdirectLight.direction = normalize( lVector );\\\\n\\\\t\\\\tfloat lightDistance = length( lVector );\\\\n\\\\t\\\\tfloat angleCos = dot( directLight.direction, spotLight.direction );\\\\n\\\\t\\\\tif ( angleCos > spotLight.coneCos ) {\\\\n\\\\t\\\\t\\\\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\\\n\\\\t\\\\t\\\\tdirectLight.color = spotLight.color;\\\\n\\\\t\\\\t\\\\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\\\\n\\\\t\\\\t\\\\tdirectLight.visible = true;\\\\n\\\\t\\\\t} else {\\\\n\\\\t\\\\t\\\\tdirectLight.color = vec3( 0.0 );\\\\n\\\\t\\\\t\\\\tdirectLight.visible = false;\\\\n\\\\t\\\\t}\\\\n\\\\t}\\\\n#endif\\\\n#if NUM_RECT_AREA_LIGHTS > 0\\\\n\\\\tstruct RectAreaLight {\\\\n\\\\t\\\\tvec3 color;\\\\n\\\\t\\\\tvec3 position;\\\\n\\\\t\\\\tvec3 halfWidth;\\\\n\\\\t\\\\tvec3 halfHeight;\\\\n\\\\t};\\\\n\\\\tuniform sampler2D ltc_1;\\\\tuniform sampler2D ltc_2;\\\\n\\\\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\\\\n#endif\\\\n#if NUM_HEMI_LIGHTS > 0\\\\n\\\\tstruct HemisphereLight {\\\\n\\\\t\\\\tvec3 direction;\\\\n\\\\t\\\\tvec3 skyColor;\\\\n\\\\t\\\\tvec3 groundColor;\\\\n\\\\t};\\\\n\\\\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\\\n\\\\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\\\\n\\\\t\\\\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\\\\n\\\\t\\\\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\\\n\\\\t\\\\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\\\n\\\\t\\\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\\\n\\\\t\\\\t\\\\tirradiance *= PI;\\\\n\\\\t\\\\t#endif\\\\n\\\\t\\\\treturn irradiance;\\\\n\\\\t}\\\\n#endif\\\";\\r\\n\\r\\nvar envmap_physical_pars_fragment = \\\"#if defined( USE_ENVMAP )\\\\n\\\\t#ifdef ENVMAP_MODE_REFRACTION\\\\n\\\\t\\\\tuniform float refractionRatio;\\\\n\\\\t#endif\\\\n\\\\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\\\\n\\\\t\\\\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\\\n\\\\t\\\\t#ifdef ENVMAP_TYPE_CUBE\\\\n\\\\t\\\\t\\\\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\\\n\\\\t\\\\t\\\\t#ifdef TEXTURE_LOD_EXT\\\\n\\\\t\\\\t\\\\t\\\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\\\\n\\\\t\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\t\\\\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\\\\n\\\\t\\\\t\\\\t#endif\\\\n\\\\t\\\\t\\\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\\\n\\\\t\\\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\\\n\\\\t\\\\t\\\\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\\\\n\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\tvec4 envMapColor = vec4( 0.0 );\\\\n\\\\t\\\\t#endif\\\\n\\\\t\\\\treturn PI * envMapColor.rgb * envMapIntensity;\\\\n\\\\t}\\\\n\\\\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\\\\n\\\\t\\\\tfloat maxMIPLevelScalar = float( maxMIPLevel );\\\\n\\\\t\\\\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\\\\n\\\\t\\\\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\\\\n\\\\t\\\\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\\\\n\\\\t}\\\\n\\\\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\\\\n\\\\t\\\\t#ifdef ENVMAP_MODE_REFLECTION\\\\n\\\\t\\\\t  vec3 reflectVec = reflect( -viewDir, normal );\\\\n\\\\t\\\\t  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\\\\n\\\\t\\\\t#else\\\\n\\\\t\\\\t  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\\\\n\\\\t\\\\t#endif\\\\n\\\\t\\\\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\\\n\\\\t\\\\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\\\\n\\\\t\\\\t#ifdef ENVMAP_TYPE_CUBE\\\\n\\\\t\\\\t\\\\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\\\n\\\\t\\\\t\\\\t#ifdef TEXTURE_LOD_EXT\\\\n\\\\t\\\\t\\\\t\\\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\\\\n\\\\t\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\t\\\\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\\\\n\\\\t\\\\t\\\\t#endif\\\\n\\\\t\\\\t\\\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\\\n\\\\t\\\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\\\n\\\\t\\\\t\\\\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\\\\n\\\\t\\\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\\\n\\\\t\\\\t\\\\tvec2 sampleUV = equirectUv( reflectVec );\\\\n\\\\t\\\\t\\\\t#ifdef TEXTURE_LOD_EXT\\\\n\\\\t\\\\t\\\\t\\\\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\\\\n\\\\t\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\t\\\\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\\\\n\\\\t\\\\t\\\\t#endif\\\\n\\\\t\\\\t\\\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\\\n\\\\t\\\\t#elif defined( ENVMAP_TYPE_SPHERE )\\\\n\\\\t\\\\t\\\\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\\\\n\\\\t\\\\t\\\\t#ifdef TEXTURE_LOD_EXT\\\\n\\\\t\\\\t\\\\t\\\\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\\\n\\\\t\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\t\\\\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\\\n\\\\t\\\\t\\\\t#endif\\\\n\\\\t\\\\t\\\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\\\n\\\\t\\\\t#endif\\\\n\\\\t\\\\treturn envMapColor.rgb * envMapIntensity;\\\\n\\\\t}\\\\n#endif\\\";\\r\\n\\r\\nvar lights_toon_fragment = \\\"ToonMaterial material;\\\\nmaterial.diffuseColor = diffuseColor.rgb;\\\\nmaterial.specularColor = specular;\\\\nmaterial.specularShininess = shininess;\\\\nmaterial.specularStrength = specularStrength;\\\";\\r\\n\\r\\nvar lights_toon_pars_fragment = \\\"varying vec3 vViewPosition;\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvarying vec3 vNormal;\\\\n#endif\\\\nstruct ToonMaterial {\\\\n\\\\tvec3\\\\tdiffuseColor;\\\\n\\\\tvec3\\\\tspecularColor;\\\\n\\\\tfloat\\\\tspecularShininess;\\\\n\\\\tfloat\\\\tspecularStrength;\\\\n};\\\\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\\\\n\\\\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\\\\n\\\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\\\n\\\\t\\\\tirradiance *= PI;\\\\n\\\\t#endif\\\\n\\\\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\\\n\\\\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\\\\n}\\\\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\\\\n\\\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\\\n}\\\\n#define RE_Direct\\\\t\\\\t\\\\t\\\\tRE_Direct_Toon\\\\n#define RE_IndirectDiffuse\\\\t\\\\tRE_IndirectDiffuse_Toon\\\\n#define Material_LightProbeLOD( material )\\\\t(0)\\\";\\r\\n\\r\\nvar lights_phong_fragment = \\\"BlinnPhongMaterial material;\\\\nmaterial.diffuseColor = diffuseColor.rgb;\\\\nmaterial.specularColor = specular;\\\\nmaterial.specularShininess = shininess;\\\\nmaterial.specularStrength = specularStrength;\\\";\\r\\n\\r\\nvar lights_phong_pars_fragment = \\\"varying vec3 vViewPosition;\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvarying vec3 vNormal;\\\\n#endif\\\\nstruct BlinnPhongMaterial {\\\\n\\\\tvec3\\\\tdiffuseColor;\\\\n\\\\tvec3\\\\tspecularColor;\\\\n\\\\tfloat\\\\tspecularShininess;\\\\n\\\\tfloat\\\\tspecularStrength;\\\\n};\\\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\\\n\\\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\\\n\\\\tvec3 irradiance = dotNL * directLight.color;\\\\n\\\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\\\n\\\\t\\\\tirradiance *= PI;\\\\n\\\\t#endif\\\\n\\\\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\\\n\\\\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\\\\n}\\\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\\\n\\\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\\\n}\\\\n#define RE_Direct\\\\t\\\\t\\\\t\\\\tRE_Direct_BlinnPhong\\\\n#define RE_IndirectDiffuse\\\\t\\\\tRE_IndirectDiffuse_BlinnPhong\\\\n#define Material_LightProbeLOD( material )\\\\t(0)\\\";\\r\\n\\r\\nvar lights_physical_fragment = \\\"PhysicalMaterial material;\\\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\\\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\\\\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\\\\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\\\\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\\\\n#ifdef REFLECTIVITY\\\\n\\\\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\\\\n#else\\\\n\\\\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\\\\n#endif\\\\n#ifdef CLEARCOAT\\\\n\\\\tmaterial.clearcoat = clearcoat;\\\\n\\\\tmaterial.clearcoatRoughness = clearcoatRoughness;\\\\n\\\\t#ifdef USE_CLEARCOATMAP\\\\n\\\\t\\\\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\\\\n\\\\t#endif\\\\n\\\\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\\\\n\\\\t\\\\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\\\\n\\\\t#endif\\\\n\\\\tmaterial.clearcoat = saturate( material.clearcoat );\\\\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\\\\n\\\\tmaterial.clearcoatRoughness += geometryRoughness;\\\\n\\\\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\\\\n#endif\\\\n#ifdef USE_SHEEN\\\\n\\\\tmaterial.sheenColor = sheen;\\\\n#endif\\\";\\r\\n\\r\\nvar lights_physical_pars_fragment = \\\"struct PhysicalMaterial {\\\\n\\\\tvec3\\\\tdiffuseColor;\\\\n\\\\tfloat\\\\tspecularRoughness;\\\\n\\\\tvec3\\\\tspecularColor;\\\\n#ifdef CLEARCOAT\\\\n\\\\tfloat clearcoat;\\\\n\\\\tfloat clearcoatRoughness;\\\\n#endif\\\\n#ifdef USE_SHEEN\\\\n\\\\tvec3 sheenColor;\\\\n#endif\\\\n};\\\\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\\\\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\\\\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\\\\n\\\\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\\\\n}\\\\n#if NUM_RECT_AREA_LIGHTS > 0\\\\n\\\\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\\\n\\\\t\\\\tvec3 normal = geometry.normal;\\\\n\\\\t\\\\tvec3 viewDir = geometry.viewDir;\\\\n\\\\t\\\\tvec3 position = geometry.position;\\\\n\\\\t\\\\tvec3 lightPos = rectAreaLight.position;\\\\n\\\\t\\\\tvec3 halfWidth = rectAreaLight.halfWidth;\\\\n\\\\t\\\\tvec3 halfHeight = rectAreaLight.halfHeight;\\\\n\\\\t\\\\tvec3 lightColor = rectAreaLight.color;\\\\n\\\\t\\\\tfloat roughness = material.specularRoughness;\\\\n\\\\t\\\\tvec3 rectCoords[ 4 ];\\\\n\\\\t\\\\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\\\\t\\\\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\\\\n\\\\t\\\\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\\\\n\\\\t\\\\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\\\\n\\\\t\\\\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\\\\n\\\\t\\\\tvec4 t1 = texture2D( ltc_1, uv );\\\\n\\\\t\\\\tvec4 t2 = texture2D( ltc_2, uv );\\\\n\\\\t\\\\tmat3 mInv = mat3(\\\\n\\\\t\\\\t\\\\tvec3( t1.x, 0, t1.y ),\\\\n\\\\t\\\\t\\\\tvec3(    0, 1,    0 ),\\\\n\\\\t\\\\t\\\\tvec3( t1.z, 0, t1.w )\\\\n\\\\t\\\\t);\\\\n\\\\t\\\\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\\\\n\\\\t\\\\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\\\\n\\\\t\\\\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\\\\n\\\\t}\\\\n#endif\\\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\\\n\\\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\\\n\\\\tvec3 irradiance = dotNL * directLight.color;\\\\n\\\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\\\n\\\\t\\\\tirradiance *= PI;\\\\n\\\\t#endif\\\\n\\\\t#ifdef CLEARCOAT\\\\n\\\\t\\\\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\\\\n\\\\t\\\\tvec3 ccIrradiance = ccDotNL * directLight.color;\\\\n\\\\t\\\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\\\n\\\\t\\\\t\\\\tccIrradiance *= PI;\\\\n\\\\t\\\\t#endif\\\\n\\\\t\\\\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\\\\n\\\\t\\\\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\\\\n\\\\t#else\\\\n\\\\t\\\\tfloat clearcoatDHR = 0.0;\\\\n\\\\t#endif\\\\n\\\\t#ifdef USE_SHEEN\\\\n\\\\t\\\\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\\\\n\\\\t\\\\t\\\\tmaterial.specularRoughness,\\\\n\\\\t\\\\t\\\\tdirectLight.direction,\\\\n\\\\t\\\\t\\\\tgeometry,\\\\n\\\\t\\\\t\\\\tmaterial.sheenColor\\\\n\\\\t\\\\t);\\\\n\\\\t#else\\\\n\\\\t\\\\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\\\\n\\\\t#endif\\\\n\\\\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\\\n}\\\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\\\n\\\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\\\n}\\\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\\\\n\\\\t#ifdef CLEARCOAT\\\\n\\\\t\\\\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\\\\n\\\\t\\\\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\\\\n\\\\t\\\\tfloat ccDotNL = ccDotNV;\\\\n\\\\t\\\\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\\\\n\\\\t#else\\\\n\\\\t\\\\tfloat clearcoatDHR = 0.0;\\\\n\\\\t#endif\\\\n\\\\tfloat clearcoatInv = 1.0 - clearcoatDHR;\\\\n\\\\tvec3 singleScattering = vec3( 0.0 );\\\\n\\\\tvec3 multiScattering = vec3( 0.0 );\\\\n\\\\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\\\\n\\\\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\\\\n\\\\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\\\\n\\\\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\\\\n\\\\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\\\\n\\\\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\\\\n}\\\\n#define RE_Direct\\\\t\\\\t\\\\t\\\\tRE_Direct_Physical\\\\n#define RE_Direct_RectArea\\\\t\\\\tRE_Direct_RectArea_Physical\\\\n#define RE_IndirectDiffuse\\\\t\\\\tRE_IndirectDiffuse_Physical\\\\n#define RE_IndirectSpecular\\\\t\\\\tRE_IndirectSpecular_Physical\\\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\\\n\\\\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\\\n}\\\";\\r\\n\\r\\nvar lights_fragment_begin = \\\"\\\\nGeometricContext geometry;\\\\ngeometry.position = - vViewPosition;\\\\ngeometry.normal = normal;\\\\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\\\\n#ifdef CLEARCOAT\\\\n\\\\tgeometry.clearcoatNormal = clearcoatNormal;\\\\n#endif\\\\nIncidentLight directLight;\\\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\\\n\\\\tPointLight pointLight;\\\\n\\\\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\\\\n\\\\tPointLightShadow pointLightShadow;\\\\n\\\\t#endif\\\\n\\\\t#pragma unroll_loop_start\\\\n\\\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tpointLight = pointLights[ i ];\\\\n\\\\t\\\\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\\\\n\\\\t\\\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\\\\n\\\\t\\\\tpointLightShadow = pointLightShadows[ i ];\\\\n\\\\t\\\\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\\\\n\\\\t\\\\t#endif\\\\n\\\\t\\\\tRE_Direct( directLight, geometry, material, reflectedLight );\\\\n\\\\t}\\\\n\\\\t#pragma unroll_loop_end\\\\n#endif\\\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\\\n\\\\tSpotLight spotLight;\\\\n\\\\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\\\\n\\\\tSpotLightShadow spotLightShadow;\\\\n\\\\t#endif\\\\n\\\\t#pragma unroll_loop_start\\\\n\\\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tspotLight = spotLights[ i ];\\\\n\\\\t\\\\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\\\\n\\\\t\\\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\\\\n\\\\t\\\\tspotLightShadow = spotLightShadows[ i ];\\\\n\\\\t\\\\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\\\n\\\\t\\\\t#endif\\\\n\\\\t\\\\tRE_Direct( directLight, geometry, material, reflectedLight );\\\\n\\\\t}\\\\n\\\\t#pragma unroll_loop_end\\\\n#endif\\\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\\\n\\\\tDirectionalLight directionalLight;\\\\n\\\\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\\\\n\\\\tDirectionalLightShadow directionalLightShadow;\\\\n\\\\t#endif\\\\n\\\\t#pragma unroll_loop_start\\\\n\\\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tdirectionalLight = directionalLights[ i ];\\\\n\\\\t\\\\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\\\n\\\\t\\\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\\\\n\\\\t\\\\tdirectionalLightShadow = directionalLightShadows[ i ];\\\\n\\\\t\\\\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\\\n\\\\t\\\\t#endif\\\\n\\\\t\\\\tRE_Direct( directLight, geometry, material, reflectedLight );\\\\n\\\\t}\\\\n\\\\t#pragma unroll_loop_end\\\\n#endif\\\\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\\\\n\\\\tRectAreaLight rectAreaLight;\\\\n\\\\t#pragma unroll_loop_start\\\\n\\\\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\\\\n\\\\t\\\\trectAreaLight = rectAreaLights[ i ];\\\\n\\\\t\\\\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\\\\n\\\\t}\\\\n\\\\t#pragma unroll_loop_end\\\\n#endif\\\\n#if defined( RE_IndirectDiffuse )\\\\n\\\\tvec3 iblIrradiance = vec3( 0.0 );\\\\n\\\\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\\\n\\\\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\\\\n\\\\t#if ( NUM_HEMI_LIGHTS > 0 )\\\\n\\\\t\\\\t#pragma unroll_loop_start\\\\n\\\\t\\\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\\\n\\\\t\\\\t\\\\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\\\n\\\\t\\\\t}\\\\n\\\\t\\\\t#pragma unroll_loop_end\\\\n\\\\t#endif\\\\n#endif\\\\n#if defined( RE_IndirectSpecular )\\\\n\\\\tvec3 radiance = vec3( 0.0 );\\\\n\\\\tvec3 clearcoatRadiance = vec3( 0.0 );\\\\n#endif\\\";\\r\\n\\r\\nvar lights_fragment_maps = \\\"#if defined( RE_IndirectDiffuse )\\\\n\\\\t#ifdef USE_LIGHTMAP\\\\n\\\\t\\\\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\\\\n\\\\t\\\\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\\\\n\\\\t\\\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\\\n\\\\t\\\\t\\\\tlightMapIrradiance *= PI;\\\\n\\\\t\\\\t#endif\\\\n\\\\t\\\\tirradiance += lightMapIrradiance;\\\\n\\\\t#endif\\\\n\\\\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\\\\n\\\\t\\\\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\\\\n\\\\t#endif\\\\n#endif\\\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\\\n\\\\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\\\\n\\\\t#ifdef CLEARCOAT\\\\n\\\\t\\\\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\\\\n\\\\t#endif\\\\n#endif\\\";\\r\\n\\r\\nvar lights_fragment_end = \\\"#if defined( RE_IndirectDiffuse )\\\\n\\\\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\\\n#endif\\\\n#if defined( RE_IndirectSpecular )\\\\n\\\\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\\\\n#endif\\\";\\r\\n\\r\\nvar logdepthbuf_fragment = \\\"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\\\\n\\\\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\\\\n#endif\\\";\\r\\n\\r\\nvar logdepthbuf_pars_fragment = \\\"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\\\\n\\\\tuniform float logDepthBufFC;\\\\n\\\\tvarying float vFragDepth;\\\\n\\\\tvarying float vIsPerspective;\\\\n#endif\\\";\\r\\n\\r\\nvar logdepthbuf_pars_vertex = \\\"#ifdef USE_LOGDEPTHBUF\\\\n\\\\t#ifdef USE_LOGDEPTHBUF_EXT\\\\n\\\\t\\\\tvarying float vFragDepth;\\\\n\\\\t\\\\tvarying float vIsPerspective;\\\\n\\\\t#else\\\\n\\\\t\\\\tuniform float logDepthBufFC;\\\\n\\\\t#endif\\\\n#endif\\\";\\r\\n\\r\\nvar logdepthbuf_vertex = \\\"#ifdef USE_LOGDEPTHBUF\\\\n\\\\t#ifdef USE_LOGDEPTHBUF_EXT\\\\n\\\\t\\\\tvFragDepth = 1.0 + gl_Position.w;\\\\n\\\\t\\\\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\\\\n\\\\t#else\\\\n\\\\t\\\\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\\\\n\\\\t\\\\t\\\\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\\\\n\\\\t\\\\t\\\\tgl_Position.z *= gl_Position.w;\\\\n\\\\t\\\\t}\\\\n\\\\t#endif\\\\n#endif\\\";\\r\\n\\r\\nvar map_fragment = \\\"#ifdef USE_MAP\\\\n\\\\tvec4 texelColor = texture2D( map, vUv );\\\\n\\\\ttexelColor = mapTexelToLinear( texelColor );\\\\n\\\\tdiffuseColor *= texelColor;\\\\n#endif\\\";\\r\\n\\r\\nvar map_pars_fragment = \\\"#ifdef USE_MAP\\\\n\\\\tuniform sampler2D map;\\\\n#endif\\\";\\r\\n\\r\\nvar map_particle_fragment = \\\"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\\\\n\\\\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\\\\n#endif\\\\n#ifdef USE_MAP\\\\n\\\\tvec4 mapTexel = texture2D( map, uv );\\\\n\\\\tdiffuseColor *= mapTexelToLinear( mapTexel );\\\\n#endif\\\\n#ifdef USE_ALPHAMAP\\\\n\\\\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\\\\n#endif\\\";\\r\\n\\r\\nvar map_particle_pars_fragment = \\\"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\\\\n\\\\tuniform mat3 uvTransform;\\\\n#endif\\\\n#ifdef USE_MAP\\\\n\\\\tuniform sampler2D map;\\\\n#endif\\\\n#ifdef USE_ALPHAMAP\\\\n\\\\tuniform sampler2D alphaMap;\\\\n#endif\\\";\\r\\n\\r\\nvar metalnessmap_fragment = \\\"float metalnessFactor = metalness;\\\\n#ifdef USE_METALNESSMAP\\\\n\\\\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\\\\n\\\\tmetalnessFactor *= texelMetalness.b;\\\\n#endif\\\";\\r\\n\\r\\nvar metalnessmap_pars_fragment = \\\"#ifdef USE_METALNESSMAP\\\\n\\\\tuniform sampler2D metalnessMap;\\\\n#endif\\\";\\r\\n\\r\\nvar morphnormal_vertex = \\\"#ifdef USE_MORPHNORMALS\\\\n\\\\tobjectNormal *= morphTargetBaseInfluence;\\\\n\\\\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\\\\n\\\\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\\\\n\\\\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\\\\n\\\\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\\\\n#endif\\\";\\r\\n\\r\\nvar morphtarget_pars_vertex = \\\"#ifdef USE_MORPHTARGETS\\\\n\\\\tuniform float morphTargetBaseInfluence;\\\\n\\\\t#ifndef USE_MORPHNORMALS\\\\n\\\\tuniform float morphTargetInfluences[ 8 ];\\\\n\\\\t#else\\\\n\\\\tuniform float morphTargetInfluences[ 4 ];\\\\n\\\\t#endif\\\\n#endif\\\";\\r\\n\\r\\nvar morphtarget_vertex = \\\"#ifdef USE_MORPHTARGETS\\\\n\\\\ttransformed *= morphTargetBaseInfluence;\\\\n\\\\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\\\\n\\\\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\\\\n\\\\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\\\\n\\\\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\\\\n\\\\t#ifndef USE_MORPHNORMALS\\\\n\\\\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\\\\n\\\\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\\\\n\\\\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\\\\n\\\\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\\\\n\\\\t#endif\\\\n#endif\\\";\\r\\n\\r\\nvar normal_fragment_begin = \\\"#ifdef FLAT_SHADED\\\\n\\\\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\\\\n\\\\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\\\\n\\\\tvec3 normal = normalize( cross( fdx, fdy ) );\\\\n#else\\\\n\\\\tvec3 normal = normalize( vNormal );\\\\n\\\\t#ifdef DOUBLE_SIDED\\\\n\\\\t\\\\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\\\n\\\\t#endif\\\\n\\\\t#ifdef USE_TANGENT\\\\n\\\\t\\\\tvec3 tangent = normalize( vTangent );\\\\n\\\\t\\\\tvec3 bitangent = normalize( vBitangent );\\\\n\\\\t\\\\t#ifdef DOUBLE_SIDED\\\\n\\\\t\\\\t\\\\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\\\n\\\\t\\\\t\\\\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\\\n\\\\t\\\\t#endif\\\\n\\\\t\\\\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\\\\n\\\\t\\\\t\\\\tmat3 vTBN = mat3( tangent, bitangent, normal );\\\\n\\\\t\\\\t#endif\\\\n\\\\t#endif\\\\n#endif\\\\nvec3 geometryNormal = normal;\\\";\\r\\n\\r\\nvar normal_fragment_maps = \\\"#ifdef OBJECTSPACE_NORMALMAP\\\\n\\\\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\\\n\\\\t#ifdef FLIP_SIDED\\\\n\\\\t\\\\tnormal = - normal;\\\\n\\\\t#endif\\\\n\\\\t#ifdef DOUBLE_SIDED\\\\n\\\\t\\\\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\\\n\\\\t#endif\\\\n\\\\tnormal = normalize( normalMatrix * normal );\\\\n#elif defined( TANGENTSPACE_NORMALMAP )\\\\n\\\\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\\\n\\\\tmapN.xy *= normalScale;\\\\n\\\\t#ifdef USE_TANGENT\\\\n\\\\t\\\\tnormal = normalize( vTBN * mapN );\\\\n\\\\t#else\\\\n\\\\t\\\\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\\\\n\\\\t#endif\\\\n#elif defined( USE_BUMPMAP )\\\\n\\\\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\\\n#endif\\\";\\r\\n\\r\\nvar normalmap_pars_fragment = \\\"#ifdef USE_NORMALMAP\\\\n\\\\tuniform sampler2D normalMap;\\\\n\\\\tuniform vec2 normalScale;\\\\n#endif\\\\n#ifdef OBJECTSPACE_NORMALMAP\\\\n\\\\tuniform mat3 normalMatrix;\\\\n#endif\\\\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\\\\n\\\\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\\\\n\\\\t\\\\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\\\\n\\\\t\\\\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\\\\n\\\\t\\\\tvec2 st0 = dFdx( vUv.st );\\\\n\\\\t\\\\tvec2 st1 = dFdy( vUv.st );\\\\n\\\\t\\\\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\\\\n\\\\t\\\\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\\\\n\\\\t\\\\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\\\\n\\\\t\\\\tvec3 N = normalize( surf_norm );\\\\n\\\\t\\\\tmat3 tsn = mat3( S, T, N );\\\\n\\\\t\\\\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\\\n\\\\t\\\\treturn normalize( tsn * mapN );\\\\n\\\\t}\\\\n#endif\\\";\\r\\n\\r\\nvar clearcoat_normal_fragment_begin = \\\"#ifdef CLEARCOAT\\\\n\\\\tvec3 clearcoatNormal = geometryNormal;\\\\n#endif\\\";\\r\\n\\r\\nvar clearcoat_normal_fragment_maps = \\\"#ifdef USE_CLEARCOAT_NORMALMAP\\\\n\\\\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\\\\n\\\\tclearcoatMapN.xy *= clearcoatNormalScale;\\\\n\\\\t#ifdef USE_TANGENT\\\\n\\\\t\\\\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\\\\n\\\\t#else\\\\n\\\\t\\\\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\\\\n\\\\t#endif\\\\n#endif\\\";\\r\\n\\r\\nvar clearcoat_pars_fragment = \\\"#ifdef USE_CLEARCOATMAP\\\\n\\\\tuniform sampler2D clearcoatMap;\\\\n#endif\\\\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\\\\n\\\\tuniform sampler2D clearcoatRoughnessMap;\\\\n#endif\\\\n#ifdef USE_CLEARCOAT_NORMALMAP\\\\n\\\\tuniform sampler2D clearcoatNormalMap;\\\\n\\\\tuniform vec2 clearcoatNormalScale;\\\\n#endif\\\";\\r\\n\\r\\nvar packing = \\\"vec3 packNormalToRGB( const in vec3 normal ) {\\\\n\\\\treturn normalize( normal ) * 0.5 + 0.5;\\\\n}\\\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\\\n\\\\treturn 2.0 * rgb.xyz - 1.0;\\\\n}\\\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\\\\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\\\\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\\\\nconst float ShiftRight8 = 1. / 256.;\\\\nvec4 packDepthToRGBA( const in float v ) {\\\\n\\\\tvec4 r = vec4( fract( v * PackFactors ), v );\\\\n\\\\tr.yzw -= r.xyz * ShiftRight8;\\\\treturn r * PackUpscale;\\\\n}\\\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\\\n\\\\treturn dot( v, UnpackFactors );\\\\n}\\\\nvec4 pack2HalfToRGBA( vec2 v ) {\\\\n\\\\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\\\\n\\\\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\\\\n}\\\\nvec2 unpackRGBATo2Half( vec4 v ) {\\\\n\\\\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\\\\n}\\\\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\\\\n\\\\treturn ( viewZ + near ) / ( near - far );\\\\n}\\\\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\\\\n\\\\treturn linearClipZ * ( near - far ) - near;\\\\n}\\\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\\\n\\\\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\\\\n}\\\\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\\\\n\\\\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\\\\n}\\\";\\r\\n\\r\\nvar premultiplied_alpha_fragment = \\\"#ifdef PREMULTIPLIED_ALPHA\\\\n\\\\tgl_FragColor.rgb *= gl_FragColor.a;\\\\n#endif\\\";\\r\\n\\r\\nvar project_vertex = \\\"vec4 mvPosition = vec4( transformed, 1.0 );\\\\n#ifdef USE_INSTANCING\\\\n\\\\tmvPosition = instanceMatrix * mvPosition;\\\\n#endif\\\\nmvPosition = modelViewMatrix * mvPosition;\\\\ngl_Position = projectionMatrix * mvPosition;\\\";\\r\\n\\r\\nvar dithering_fragment = \\\"#ifdef DITHERING\\\\n\\\\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\\\\n#endif\\\";\\r\\n\\r\\nvar dithering_pars_fragment = \\\"#ifdef DITHERING\\\\n\\\\tvec3 dithering( vec3 color ) {\\\\n\\\\t\\\\tfloat grid_position = rand( gl_FragCoord.xy );\\\\n\\\\t\\\\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\\\\n\\\\t\\\\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\\\\n\\\\t\\\\treturn color + dither_shift_RGB;\\\\n\\\\t}\\\\n#endif\\\";\\r\\n\\r\\nvar roughnessmap_fragment = \\\"float roughnessFactor = roughness;\\\\n#ifdef USE_ROUGHNESSMAP\\\\n\\\\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\\\\n\\\\troughnessFactor *= texelRoughness.g;\\\\n#endif\\\";\\r\\n\\r\\nvar roughnessmap_pars_fragment = \\\"#ifdef USE_ROUGHNESSMAP\\\\n\\\\tuniform sampler2D roughnessMap;\\\\n#endif\\\";\\r\\n\\r\\nvar shadowmap_pars_fragment = \\\"#ifdef USE_SHADOWMAP\\\\n\\\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\\\n\\\\t\\\\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\\\\n\\\\t\\\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\\\\n\\\\t#endif\\\\n\\\\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\\\n\\\\t\\\\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\\\\n\\\\t\\\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\\\\n\\\\t#endif\\\\n\\\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\\\n\\\\t\\\\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\\\\n\\\\t\\\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\\\\n\\\\t#endif\\\\n\\\\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\\\n\\\\t\\\\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\\\n\\\\t}\\\\n\\\\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\\\\n\\\\t\\\\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\\\\n\\\\t}\\\\n\\\\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\\\\n\\\\t\\\\tfloat occlusion = 1.0;\\\\n\\\\t\\\\tvec2 distribution = texture2DDistribution( shadow, uv );\\\\n\\\\t\\\\tfloat hard_shadow = step( compare , distribution.x );\\\\n\\\\t\\\\tif (hard_shadow != 1.0 ) {\\\\n\\\\t\\\\t\\\\tfloat distance = compare - distribution.x ;\\\\n\\\\t\\\\t\\\\tfloat variance = max( 0.00000, distribution.y * distribution.y );\\\\n\\\\t\\\\t\\\\tfloat softness_probability = variance / (variance + distance * distance );\\\\t\\\\t\\\\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\\\\t\\\\t\\\\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\\\\n\\\\t\\\\t}\\\\n\\\\t\\\\treturn occlusion;\\\\n\\\\t}\\\\n\\\\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\\\n\\\\t\\\\tfloat shadow = 1.0;\\\\n\\\\t\\\\tshadowCoord.xyz /= shadowCoord.w;\\\\n\\\\t\\\\tshadowCoord.z += shadowBias;\\\\n\\\\t\\\\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\\\n\\\\t\\\\tbool inFrustum = all( inFrustumVec );\\\\n\\\\t\\\\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\\\n\\\\t\\\\tbool frustumTest = all( frustumTestVec );\\\\n\\\\t\\\\tif ( frustumTest ) {\\\\n\\\\t\\\\t#if defined( SHADOWMAP_TYPE_PCF )\\\\n\\\\t\\\\t\\\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\\\n\\\\t\\\\t\\\\tfloat dx0 = - texelSize.x * shadowRadius;\\\\n\\\\t\\\\t\\\\tfloat dy0 = - texelSize.y * shadowRadius;\\\\n\\\\t\\\\t\\\\tfloat dx1 = + texelSize.x * shadowRadius;\\\\n\\\\t\\\\t\\\\tfloat dy1 = + texelSize.y * shadowRadius;\\\\n\\\\t\\\\t\\\\tfloat dx2 = dx0 / 2.0;\\\\n\\\\t\\\\t\\\\tfloat dy2 = dy0 / 2.0;\\\\n\\\\t\\\\t\\\\tfloat dx3 = dx1 / 2.0;\\\\n\\\\t\\\\t\\\\tfloat dy3 = dy1 / 2.0;\\\\n\\\\t\\\\t\\\\tshadow = (\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\\\n\\\\t\\\\t\\\\t) * ( 1.0 / 17.0 );\\\\n\\\\t\\\\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\\\n\\\\t\\\\t\\\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\\\n\\\\t\\\\t\\\\tfloat dx = texelSize.x;\\\\n\\\\t\\\\t\\\\tfloat dy = texelSize.y;\\\\n\\\\t\\\\t\\\\tvec2 uv = shadowCoord.xy;\\\\n\\\\t\\\\t\\\\tvec2 f = fract( uv * shadowMapSize + 0.5 );\\\\n\\\\t\\\\t\\\\tuv -= f * texelSize;\\\\n\\\\t\\\\t\\\\tshadow = (\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \\\\n\\\\t\\\\t\\\\t\\\\t\\\\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t f.x ) +\\\\n\\\\t\\\\t\\\\t\\\\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \\\\n\\\\t\\\\t\\\\t\\\\t\\\\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t f.x ) +\\\\n\\\\t\\\\t\\\\t\\\\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \\\\n\\\\t\\\\t\\\\t\\\\t\\\\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t f.y ) +\\\\n\\\\t\\\\t\\\\t\\\\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \\\\n\\\\t\\\\t\\\\t\\\\t\\\\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t f.y ) +\\\\n\\\\t\\\\t\\\\t\\\\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t  f.x ),\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t  f.x ),\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t f.y )\\\\n\\\\t\\\\t\\\\t) * ( 1.0 / 9.0 );\\\\n\\\\t\\\\t#elif defined( SHADOWMAP_TYPE_VSM )\\\\n\\\\t\\\\t\\\\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\\\\n\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\\\n\\\\t\\\\t#endif\\\\n\\\\t\\\\t}\\\\n\\\\t\\\\treturn shadow;\\\\n\\\\t}\\\\n\\\\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\\\n\\\\t\\\\tvec3 absV = abs( v );\\\\n\\\\t\\\\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\\\n\\\\t\\\\tabsV *= scaleToCube;\\\\n\\\\t\\\\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\\\n\\\\t\\\\tvec2 planar = v.xy;\\\\n\\\\t\\\\tfloat almostATexel = 1.5 * texelSizeY;\\\\n\\\\t\\\\tfloat almostOne = 1.0 - almostATexel;\\\\n\\\\t\\\\tif ( absV.z >= almostOne ) {\\\\n\\\\t\\\\t\\\\tif ( v.z > 0.0 )\\\\n\\\\t\\\\t\\\\t\\\\tplanar.x = 4.0 - v.x;\\\\n\\\\t\\\\t} else if ( absV.x >= almostOne ) {\\\\n\\\\t\\\\t\\\\tfloat signX = sign( v.x );\\\\n\\\\t\\\\t\\\\tplanar.x = v.z * signX + 2.0 * signX;\\\\n\\\\t\\\\t} else if ( absV.y >= almostOne ) {\\\\n\\\\t\\\\t\\\\tfloat signY = sign( v.y );\\\\n\\\\t\\\\t\\\\tplanar.x = v.x + 2.0 * signY + 2.0;\\\\n\\\\t\\\\t\\\\tplanar.y = v.z * signY - 2.0;\\\\n\\\\t\\\\t}\\\\n\\\\t\\\\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\\\n\\\\t}\\\\n\\\\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\\\\n\\\\t\\\\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\\\n\\\\t\\\\tvec3 lightToPosition = shadowCoord.xyz;\\\\n\\\\t\\\\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\\\\t\\\\tdp += shadowBias;\\\\n\\\\t\\\\tvec3 bd3D = normalize( lightToPosition );\\\\n\\\\t\\\\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\\\\n\\\\t\\\\t\\\\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\\\n\\\\t\\\\t\\\\treturn (\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\\\n\\\\t\\\\t\\\\t) * ( 1.0 / 9.0 );\\\\n\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\\\n\\\\t\\\\t#endif\\\\n\\\\t}\\\\n#endif\\\";\\r\\n\\r\\nvar shadowmap_pars_vertex = \\\"#ifdef USE_SHADOWMAP\\\\n\\\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\\\n\\\\t\\\\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\\\\n\\\\t\\\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\\\\n\\\\t#endif\\\\n\\\\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\\\n\\\\t\\\\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\\\\n\\\\t\\\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\\\\n\\\\t#endif\\\\n\\\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\\\n\\\\t\\\\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\\\\n\\\\t\\\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\\\\n\\\\t#endif\\\\n#endif\\\";\\r\\n\\r\\nvar shadowmap_vertex = \\\"#ifdef USE_SHADOWMAP\\\\n\\\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\\\n\\\\t#pragma unroll_loop_start\\\\n\\\\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\\\\n\\\\t\\\\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\\\\n\\\\t}\\\\n\\\\t#pragma unroll_loop_end\\\\n\\\\t#endif\\\\n\\\\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\\\n\\\\t#pragma unroll_loop_start\\\\n\\\\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\\\\n\\\\t\\\\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\\\\n\\\\t}\\\\n\\\\t#pragma unroll_loop_end\\\\n\\\\t#endif\\\\n\\\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\\\n\\\\t#pragma unroll_loop_start\\\\n\\\\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\\\\n\\\\t\\\\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\\\\n\\\\t}\\\\n\\\\t#pragma unroll_loop_end\\\\n\\\\t#endif\\\\n#endif\\\";\\r\\n\\r\\nvar shadowmask_pars_fragment = \\\"float getShadowMask() {\\\\n\\\\tfloat shadow = 1.0;\\\\n\\\\t#ifdef USE_SHADOWMAP\\\\n\\\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\\\n\\\\tDirectionalLightShadow directionalLight;\\\\n\\\\t#pragma unroll_loop_start\\\\n\\\\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\\\\n\\\\t\\\\tdirectionalLight = directionalLightShadows[ i ];\\\\n\\\\t\\\\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\\\n\\\\t}\\\\n\\\\t#pragma unroll_loop_end\\\\n\\\\t#endif\\\\n\\\\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\\\n\\\\tSpotLightShadow spotLight;\\\\n\\\\t#pragma unroll_loop_start\\\\n\\\\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\\\\n\\\\t\\\\tspotLight = spotLightShadows[ i ];\\\\n\\\\t\\\\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\\\n\\\\t}\\\\n\\\\t#pragma unroll_loop_end\\\\n\\\\t#endif\\\\n\\\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\\\n\\\\tPointLightShadow pointLight;\\\\n\\\\t#pragma unroll_loop_start\\\\n\\\\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\\\\n\\\\t\\\\tpointLight = pointLightShadows[ i ];\\\\n\\\\t\\\\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\\\\n\\\\t}\\\\n\\\\t#pragma unroll_loop_end\\\\n\\\\t#endif\\\\n\\\\t#endif\\\\n\\\\treturn shadow;\\\\n}\\\";\\r\\n\\r\\nvar skinbase_vertex = \\\"#ifdef USE_SKINNING\\\\n\\\\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\\\n\\\\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\\\n\\\\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\\\n\\\\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\\\n#endif\\\";\\r\\n\\r\\nvar skinning_pars_vertex = \\\"#ifdef USE_SKINNING\\\\n\\\\tuniform mat4 bindMatrix;\\\\n\\\\tuniform mat4 bindMatrixInverse;\\\\n\\\\t#ifdef BONE_TEXTURE\\\\n\\\\t\\\\tuniform highp sampler2D boneTexture;\\\\n\\\\t\\\\tuniform int boneTextureSize;\\\\n\\\\t\\\\tmat4 getBoneMatrix( const in float i ) {\\\\n\\\\t\\\\t\\\\tfloat j = i * 4.0;\\\\n\\\\t\\\\t\\\\tfloat x = mod( j, float( boneTextureSize ) );\\\\n\\\\t\\\\t\\\\tfloat y = floor( j / float( boneTextureSize ) );\\\\n\\\\t\\\\t\\\\tfloat dx = 1.0 / float( boneTextureSize );\\\\n\\\\t\\\\t\\\\tfloat dy = 1.0 / float( boneTextureSize );\\\\n\\\\t\\\\t\\\\ty = dy * ( y + 0.5 );\\\\n\\\\t\\\\t\\\\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\\\n\\\\t\\\\t\\\\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\\\n\\\\t\\\\t\\\\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\\\n\\\\t\\\\t\\\\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\\\n\\\\t\\\\t\\\\tmat4 bone = mat4( v1, v2, v3, v4 );\\\\n\\\\t\\\\t\\\\treturn bone;\\\\n\\\\t\\\\t}\\\\n\\\\t#else\\\\n\\\\t\\\\tuniform mat4 boneMatrices[ MAX_BONES ];\\\\n\\\\t\\\\tmat4 getBoneMatrix( const in float i ) {\\\\n\\\\t\\\\t\\\\tmat4 bone = boneMatrices[ int(i) ];\\\\n\\\\t\\\\t\\\\treturn bone;\\\\n\\\\t\\\\t}\\\\n\\\\t#endif\\\\n#endif\\\";\\r\\n\\r\\nvar skinning_vertex = \\\"#ifdef USE_SKINNING\\\\n\\\\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\\\n\\\\tvec4 skinned = vec4( 0.0 );\\\\n\\\\tskinned += boneMatX * skinVertex * skinWeight.x;\\\\n\\\\tskinned += boneMatY * skinVertex * skinWeight.y;\\\\n\\\\tskinned += boneMatZ * skinVertex * skinWeight.z;\\\\n\\\\tskinned += boneMatW * skinVertex * skinWeight.w;\\\\n\\\\ttransformed = ( bindMatrixInverse * skinned ).xyz;\\\\n#endif\\\";\\r\\n\\r\\nvar skinnormal_vertex = \\\"#ifdef USE_SKINNING\\\\n\\\\tmat4 skinMatrix = mat4( 0.0 );\\\\n\\\\tskinMatrix += skinWeight.x * boneMatX;\\\\n\\\\tskinMatrix += skinWeight.y * boneMatY;\\\\n\\\\tskinMatrix += skinWeight.z * boneMatZ;\\\\n\\\\tskinMatrix += skinWeight.w * boneMatW;\\\\n\\\\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\\\\n\\\\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\\\n\\\\t#ifdef USE_TANGENT\\\\n\\\\t\\\\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\\\\n\\\\t#endif\\\\n#endif\\\";\\r\\n\\r\\nvar specularmap_fragment = \\\"float specularStrength;\\\\n#ifdef USE_SPECULARMAP\\\\n\\\\tvec4 texelSpecular = texture2D( specularMap, vUv );\\\\n\\\\tspecularStrength = texelSpecular.r;\\\\n#else\\\\n\\\\tspecularStrength = 1.0;\\\\n#endif\\\";\\r\\n\\r\\nvar specularmap_pars_fragment = \\\"#ifdef USE_SPECULARMAP\\\\n\\\\tuniform sampler2D specularMap;\\\\n#endif\\\";\\r\\n\\r\\nvar tonemapping_fragment = \\\"#if defined( TONE_MAPPING )\\\\n\\\\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\\\n#endif\\\";\\r\\n\\r\\nvar tonemapping_pars_fragment = \\\"#ifndef saturate\\\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\\\n#endif\\\\nuniform float toneMappingExposure;\\\\nuniform float toneMappingWhitePoint;\\\\nvec3 LinearToneMapping( vec3 color ) {\\\\n\\\\treturn toneMappingExposure * color;\\\\n}\\\\nvec3 ReinhardToneMapping( vec3 color ) {\\\\n\\\\tcolor *= toneMappingExposure;\\\\n\\\\treturn saturate( color / ( vec3( 1.0 ) + color ) );\\\\n}\\\\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\\\\nvec3 Uncharted2ToneMapping( vec3 color ) {\\\\n\\\\tcolor *= toneMappingExposure;\\\\n\\\\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\\\\n}\\\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\\\n\\\\tcolor *= toneMappingExposure;\\\\n\\\\tcolor = max( vec3( 0.0 ), color - 0.004 );\\\\n\\\\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\\\n}\\\\nvec3 ACESFilmicToneMapping( vec3 color ) {\\\\n\\\\tcolor *= toneMappingExposure;\\\\n\\\\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\\\\n}\\\";\\r\\n\\r\\nvar uv_pars_fragment = \\\"#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\\\\n\\\\tvarying vec2 vUv;\\\\n#endif\\\";\\r\\n\\r\\nvar uv_pars_vertex = \\\"#ifdef USE_UV\\\\n\\\\t#ifdef UVS_VERTEX_ONLY\\\\n\\\\t\\\\tvec2 vUv;\\\\n\\\\t#else\\\\n\\\\t\\\\tvarying vec2 vUv;\\\\n\\\\t#endif\\\\n\\\\tuniform mat3 uvTransform;\\\\n#endif\\\";\\r\\n\\r\\nvar uv_vertex = \\\"#ifdef USE_UV\\\\n\\\\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\\\n#endif\\\";\\r\\n\\r\\nvar uv2_pars_fragment = \\\"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\\\n\\\\tvarying vec2 vUv2;\\\\n#endif\\\";\\r\\n\\r\\nvar uv2_pars_vertex = \\\"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\\\n\\\\tattribute vec2 uv2;\\\\n\\\\tvarying vec2 vUv2;\\\\n\\\\tuniform mat3 uv2Transform;\\\\n#endif\\\";\\r\\n\\r\\nvar uv2_vertex = \\\"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\\\n\\\\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\\\\n#endif\\\";\\r\\n\\r\\nvar worldpos_vertex = \\\"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\\\\n\\\\tvec4 worldPosition = vec4( transformed, 1.0 );\\\\n\\\\t#ifdef USE_INSTANCING\\\\n\\\\t\\\\tworldPosition = instanceMatrix * worldPosition;\\\\n\\\\t#endif\\\\n\\\\tworldPosition = modelMatrix * worldPosition;\\\\n#endif\\\";\\r\\n\\r\\nvar background_frag = \\\"uniform sampler2D t2D;\\\\nvarying vec2 vUv;\\\\nvoid main() {\\\\n\\\\tvec4 texColor = texture2D( t2D, vUv );\\\\n\\\\tgl_FragColor = mapTexelToLinear( texColor );\\\\n\\\\t#include <tonemapping_fragment>\\\\n\\\\t#include <encodings_fragment>\\\\n}\\\";\\r\\n\\r\\nvar background_vert = \\\"varying vec2 vUv;\\\\nuniform mat3 uvTransform;\\\\nvoid main() {\\\\n\\\\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\\\n\\\\tgl_Position = vec4( position.xy, 1.0, 1.0 );\\\\n}\\\";\\r\\n\\r\\nvar cube_frag = \\\"#include <envmap_common_pars_fragment>\\\\nuniform float opacity;\\\\nvarying vec3 vWorldDirection;\\\\n#include <cube_uv_reflection_fragment>\\\\nvoid main() {\\\\n\\\\tvec3 vReflect = vWorldDirection;\\\\n\\\\t#include <envmap_fragment>\\\\n\\\\tgl_FragColor = envColor;\\\\n\\\\tgl_FragColor.a *= opacity;\\\\n\\\\t#include <tonemapping_fragment>\\\\n\\\\t#include <encodings_fragment>\\\\n}\\\";\\r\\n\\r\\nvar cube_vert = \\\"varying vec3 vWorldDirection;\\\\n#include <common>\\\\nvoid main() {\\\\n\\\\tvWorldDirection = transformDirection( position, modelMatrix );\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\tgl_Position.z = gl_Position.w;\\\\n}\\\";\\r\\n\\r\\nvar depth_frag = \\\"#if DEPTH_PACKING == 3200\\\\n\\\\tuniform float opacity;\\\\n#endif\\\\n#include <common>\\\\n#include <packing>\\\\n#include <uv_pars_fragment>\\\\n#include <map_pars_fragment>\\\\n#include <alphamap_pars_fragment>\\\\n#include <logdepthbuf_pars_fragment>\\\\n#include <clipping_planes_pars_fragment>\\\\nvarying vec2 vHighPrecisionZW;\\\\nvoid main() {\\\\n\\\\t#include <clipping_planes_fragment>\\\\n\\\\tvec4 diffuseColor = vec4( 1.0 );\\\\n\\\\t#if DEPTH_PACKING == 3200\\\\n\\\\t\\\\tdiffuseColor.a = opacity;\\\\n\\\\t#endif\\\\n\\\\t#include <map_fragment>\\\\n\\\\t#include <alphamap_fragment>\\\\n\\\\t#include <alphatest_fragment>\\\\n\\\\t#include <logdepthbuf_fragment>\\\\n\\\\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\\\\n\\\\t#if DEPTH_PACKING == 3200\\\\n\\\\t\\\\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\\\\n\\\\t#elif DEPTH_PACKING == 3201\\\\n\\\\t\\\\tgl_FragColor = packDepthToRGBA( fragCoordZ );\\\\n\\\\t#endif\\\\n}\\\";\\r\\n\\r\\nvar depth_vert = \\\"#include <common>\\\\n#include <uv_pars_vertex>\\\\n#include <displacementmap_pars_vertex>\\\\n#include <morphtarget_pars_vertex>\\\\n#include <skinning_pars_vertex>\\\\n#include <logdepthbuf_pars_vertex>\\\\n#include <clipping_planes_pars_vertex>\\\\nvarying vec2 vHighPrecisionZW;\\\\nvoid main() {\\\\n\\\\t#include <uv_vertex>\\\\n\\\\t#include <skinbase_vertex>\\\\n\\\\t#ifdef USE_DISPLACEMENTMAP\\\\n\\\\t\\\\t#include <beginnormal_vertex>\\\\n\\\\t\\\\t#include <morphnormal_vertex>\\\\n\\\\t\\\\t#include <skinnormal_vertex>\\\\n\\\\t#endif\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <morphtarget_vertex>\\\\n\\\\t#include <skinning_vertex>\\\\n\\\\t#include <displacementmap_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\t#include <logdepthbuf_vertex>\\\\n\\\\t#include <clipping_planes_vertex>\\\\n\\\\tvHighPrecisionZW = gl_Position.zw;\\\\n}\\\";\\r\\n\\r\\nvar distanceRGBA_frag = \\\"#define DISTANCE\\\\nuniform vec3 referencePosition;\\\\nuniform float nearDistance;\\\\nuniform float farDistance;\\\\nvarying vec3 vWorldPosition;\\\\n#include <common>\\\\n#include <packing>\\\\n#include <uv_pars_fragment>\\\\n#include <map_pars_fragment>\\\\n#include <alphamap_pars_fragment>\\\\n#include <clipping_planes_pars_fragment>\\\\nvoid main () {\\\\n\\\\t#include <clipping_planes_fragment>\\\\n\\\\tvec4 diffuseColor = vec4( 1.0 );\\\\n\\\\t#include <map_fragment>\\\\n\\\\t#include <alphamap_fragment>\\\\n\\\\t#include <alphatest_fragment>\\\\n\\\\tfloat dist = length( vWorldPosition - referencePosition );\\\\n\\\\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\\\\n\\\\tdist = saturate( dist );\\\\n\\\\tgl_FragColor = packDepthToRGBA( dist );\\\\n}\\\";\\r\\n\\r\\nvar distanceRGBA_vert = \\\"#define DISTANCE\\\\nvarying vec3 vWorldPosition;\\\\n#include <common>\\\\n#include <uv_pars_vertex>\\\\n#include <displacementmap_pars_vertex>\\\\n#include <morphtarget_pars_vertex>\\\\n#include <skinning_pars_vertex>\\\\n#include <clipping_planes_pars_vertex>\\\\nvoid main() {\\\\n\\\\t#include <uv_vertex>\\\\n\\\\t#include <skinbase_vertex>\\\\n\\\\t#ifdef USE_DISPLACEMENTMAP\\\\n\\\\t\\\\t#include <beginnormal_vertex>\\\\n\\\\t\\\\t#include <morphnormal_vertex>\\\\n\\\\t\\\\t#include <skinnormal_vertex>\\\\n\\\\t#endif\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <morphtarget_vertex>\\\\n\\\\t#include <skinning_vertex>\\\\n\\\\t#include <displacementmap_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\t#include <worldpos_vertex>\\\\n\\\\t#include <clipping_planes_vertex>\\\\n\\\\tvWorldPosition = worldPosition.xyz;\\\\n}\\\";\\r\\n\\r\\nvar equirect_frag = \\\"uniform sampler2D tEquirect;\\\\nvarying vec3 vWorldDirection;\\\\n#include <common>\\\\nvoid main() {\\\\n\\\\tvec3 direction = normalize( vWorldDirection );\\\\n\\\\tvec2 sampleUV = equirectUv( direction );\\\\n\\\\tvec4 texColor = texture2D( tEquirect, sampleUV );\\\\n\\\\tgl_FragColor = mapTexelToLinear( texColor );\\\\n\\\\t#include <tonemapping_fragment>\\\\n\\\\t#include <encodings_fragment>\\\\n}\\\";\\r\\n\\r\\nvar equirect_vert = \\\"varying vec3 vWorldDirection;\\\\n#include <common>\\\\nvoid main() {\\\\n\\\\tvWorldDirection = transformDirection( position, modelMatrix );\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <project_vertex>\\\\n}\\\";\\r\\n\\r\\nvar linedashed_frag = \\\"uniform vec3 diffuse;\\\\nuniform float opacity;\\\\nuniform float dashSize;\\\\nuniform float totalSize;\\\\nvarying float vLineDistance;\\\\n#include <common>\\\\n#include <color_pars_fragment>\\\\n#include <fog_pars_fragment>\\\\n#include <logdepthbuf_pars_fragment>\\\\n#include <clipping_planes_pars_fragment>\\\\nvoid main() {\\\\n\\\\t#include <clipping_planes_fragment>\\\\n\\\\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\\\n\\\\t\\\\tdiscard;\\\\n\\\\t}\\\\n\\\\tvec3 outgoingLight = vec3( 0.0 );\\\\n\\\\tvec4 diffuseColor = vec4( diffuse, opacity );\\\\n\\\\t#include <logdepthbuf_fragment>\\\\n\\\\t#include <color_fragment>\\\\n\\\\toutgoingLight = diffuseColor.rgb;\\\\n\\\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\\\n\\\\t#include <tonemapping_fragment>\\\\n\\\\t#include <encodings_fragment>\\\\n\\\\t#include <fog_fragment>\\\\n\\\\t#include <premultiplied_alpha_fragment>\\\\n}\\\";\\r\\n\\r\\nvar linedashed_vert = \\\"uniform float scale;\\\\nattribute float lineDistance;\\\\nvarying float vLineDistance;\\\\n#include <common>\\\\n#include <color_pars_vertex>\\\\n#include <fog_pars_vertex>\\\\n#include <morphtarget_pars_vertex>\\\\n#include <logdepthbuf_pars_vertex>\\\\n#include <clipping_planes_pars_vertex>\\\\nvoid main() {\\\\n\\\\tvLineDistance = scale * lineDistance;\\\\n\\\\t#include <color_vertex>\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <morphtarget_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\t#include <logdepthbuf_vertex>\\\\n\\\\t#include <clipping_planes_vertex>\\\\n\\\\t#include <fog_vertex>\\\\n}\\\";\\r\\n\\r\\nvar meshbasic_frag = \\\"uniform vec3 diffuse;\\\\nuniform float opacity;\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvarying vec3 vNormal;\\\\n#endif\\\\n#include <common>\\\\n#include <dithering_pars_fragment>\\\\n#include <color_pars_fragment>\\\\n#include <uv_pars_fragment>\\\\n#include <uv2_pars_fragment>\\\\n#include <map_pars_fragment>\\\\n#include <alphamap_pars_fragment>\\\\n#include <aomap_pars_fragment>\\\\n#include <lightmap_pars_fragment>\\\\n#include <envmap_common_pars_fragment>\\\\n#include <envmap_pars_fragment>\\\\n#include <cube_uv_reflection_fragment>\\\\n#include <fog_pars_fragment>\\\\n#include <specularmap_pars_fragment>\\\\n#include <logdepthbuf_pars_fragment>\\\\n#include <clipping_planes_pars_fragment>\\\\nvoid main() {\\\\n\\\\t#include <clipping_planes_fragment>\\\\n\\\\tvec4 diffuseColor = vec4( diffuse, opacity );\\\\n\\\\t#include <logdepthbuf_fragment>\\\\n\\\\t#include <map_fragment>\\\\n\\\\t#include <color_fragment>\\\\n\\\\t#include <alphamap_fragment>\\\\n\\\\t#include <alphatest_fragment>\\\\n\\\\t#include <specularmap_fragment>\\\\n\\\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\\\n\\\\t#ifdef USE_LIGHTMAP\\\\n\\\\t\\\\n\\\\t\\\\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\\\\n\\\\t\\\\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\\\\n\\\\t#else\\\\n\\\\t\\\\treflectedLight.indirectDiffuse += vec3( 1.0 );\\\\n\\\\t#endif\\\\n\\\\t#include <aomap_fragment>\\\\n\\\\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\\\\n\\\\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\\\n\\\\t#include <envmap_fragment>\\\\n\\\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\\\n\\\\t#include <tonemapping_fragment>\\\\n\\\\t#include <encodings_fragment>\\\\n\\\\t#include <fog_fragment>\\\\n\\\\t#include <premultiplied_alpha_fragment>\\\\n\\\\t#include <dithering_fragment>\\\\n}\\\";\\r\\n\\r\\nvar meshbasic_vert = \\\"#include <common>\\\\n#include <uv_pars_vertex>\\\\n#include <uv2_pars_vertex>\\\\n#include <envmap_pars_vertex>\\\\n#include <color_pars_vertex>\\\\n#include <fog_pars_vertex>\\\\n#include <morphtarget_pars_vertex>\\\\n#include <skinning_pars_vertex>\\\\n#include <logdepthbuf_pars_vertex>\\\\n#include <clipping_planes_pars_vertex>\\\\nvoid main() {\\\\n\\\\t#include <uv_vertex>\\\\n\\\\t#include <uv2_vertex>\\\\n\\\\t#include <color_vertex>\\\\n\\\\t#include <skinbase_vertex>\\\\n\\\\t#ifdef USE_ENVMAP\\\\n\\\\t#include <beginnormal_vertex>\\\\n\\\\t#include <morphnormal_vertex>\\\\n\\\\t#include <skinnormal_vertex>\\\\n\\\\t#include <defaultnormal_vertex>\\\\n\\\\t#endif\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <morphtarget_vertex>\\\\n\\\\t#include <skinning_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\t#include <logdepthbuf_vertex>\\\\n\\\\t#include <worldpos_vertex>\\\\n\\\\t#include <clipping_planes_vertex>\\\\n\\\\t#include <envmap_vertex>\\\\n\\\\t#include <fog_vertex>\\\\n}\\\";\\r\\n\\r\\nvar meshlambert_frag = \\\"uniform vec3 diffuse;\\\\nuniform vec3 emissive;\\\\nuniform float opacity;\\\\nvarying vec3 vLightFront;\\\\nvarying vec3 vIndirectFront;\\\\n#ifdef DOUBLE_SIDED\\\\n\\\\tvarying vec3 vLightBack;\\\\n\\\\tvarying vec3 vIndirectBack;\\\\n#endif\\\\n#include <common>\\\\n#include <packing>\\\\n#include <dithering_pars_fragment>\\\\n#include <color_pars_fragment>\\\\n#include <uv_pars_fragment>\\\\n#include <uv2_pars_fragment>\\\\n#include <map_pars_fragment>\\\\n#include <alphamap_pars_fragment>\\\\n#include <aomap_pars_fragment>\\\\n#include <lightmap_pars_fragment>\\\\n#include <emissivemap_pars_fragment>\\\\n#include <envmap_common_pars_fragment>\\\\n#include <envmap_pars_fragment>\\\\n#include <cube_uv_reflection_fragment>\\\\n#include <bsdfs>\\\\n#include <lights_pars_begin>\\\\n#include <fog_pars_fragment>\\\\n#include <shadowmap_pars_fragment>\\\\n#include <shadowmask_pars_fragment>\\\\n#include <specularmap_pars_fragment>\\\\n#include <logdepthbuf_pars_fragment>\\\\n#include <clipping_planes_pars_fragment>\\\\nvoid main() {\\\\n\\\\t#include <clipping_planes_fragment>\\\\n\\\\tvec4 diffuseColor = vec4( diffuse, opacity );\\\\n\\\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\\\n\\\\tvec3 totalEmissiveRadiance = emissive;\\\\n\\\\t#include <logdepthbuf_fragment>\\\\n\\\\t#include <map_fragment>\\\\n\\\\t#include <color_fragment>\\\\n\\\\t#include <alphamap_fragment>\\\\n\\\\t#include <alphatest_fragment>\\\\n\\\\t#include <specularmap_fragment>\\\\n\\\\t#include <emissivemap_fragment>\\\\n\\\\t#ifdef DOUBLE_SIDED\\\\n\\\\t\\\\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\\\\n\\\\t#else\\\\n\\\\t\\\\treflectedLight.indirectDiffuse += vIndirectFront;\\\\n\\\\t#endif\\\\n\\\\t#include <lightmap_fragment>\\\\n\\\\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\\\\n\\\\t#ifdef DOUBLE_SIDED\\\\n\\\\t\\\\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\\\\n\\\\t#else\\\\n\\\\t\\\\treflectedLight.directDiffuse = vLightFront;\\\\n\\\\t#endif\\\\n\\\\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\\\\n\\\\t#include <aomap_fragment>\\\\n\\\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\\\n\\\\t#include <envmap_fragment>\\\\n\\\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\\\n\\\\t#include <tonemapping_fragment>\\\\n\\\\t#include <encodings_fragment>\\\\n\\\\t#include <fog_fragment>\\\\n\\\\t#include <premultiplied_alpha_fragment>\\\\n\\\\t#include <dithering_fragment>\\\\n}\\\";\\r\\n\\r\\nvar meshlambert_vert = \\\"#define LAMBERT\\\\nvarying vec3 vLightFront;\\\\nvarying vec3 vIndirectFront;\\\\n#ifdef DOUBLE_SIDED\\\\n\\\\tvarying vec3 vLightBack;\\\\n\\\\tvarying vec3 vIndirectBack;\\\\n#endif\\\\n#include <common>\\\\n#include <uv_pars_vertex>\\\\n#include <uv2_pars_vertex>\\\\n#include <envmap_pars_vertex>\\\\n#include <bsdfs>\\\\n#include <lights_pars_begin>\\\\n#include <color_pars_vertex>\\\\n#include <fog_pars_vertex>\\\\n#include <morphtarget_pars_vertex>\\\\n#include <skinning_pars_vertex>\\\\n#include <shadowmap_pars_vertex>\\\\n#include <logdepthbuf_pars_vertex>\\\\n#include <clipping_planes_pars_vertex>\\\\nvoid main() {\\\\n\\\\t#include <uv_vertex>\\\\n\\\\t#include <uv2_vertex>\\\\n\\\\t#include <color_vertex>\\\\n\\\\t#include <beginnormal_vertex>\\\\n\\\\t#include <morphnormal_vertex>\\\\n\\\\t#include <skinbase_vertex>\\\\n\\\\t#include <skinnormal_vertex>\\\\n\\\\t#include <defaultnormal_vertex>\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <morphtarget_vertex>\\\\n\\\\t#include <skinning_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\t#include <logdepthbuf_vertex>\\\\n\\\\t#include <clipping_planes_vertex>\\\\n\\\\t#include <worldpos_vertex>\\\\n\\\\t#include <envmap_vertex>\\\\n\\\\t#include <lights_lambert_vertex>\\\\n\\\\t#include <shadowmap_vertex>\\\\n\\\\t#include <fog_vertex>\\\\n}\\\";\\r\\n\\r\\nvar meshmatcap_frag = \\\"#define MATCAP\\\\nuniform vec3 diffuse;\\\\nuniform float opacity;\\\\nuniform sampler2D matcap;\\\\nvarying vec3 vViewPosition;\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvarying vec3 vNormal;\\\\n#endif\\\\n#include <common>\\\\n#include <dithering_pars_fragment>\\\\n#include <color_pars_fragment>\\\\n#include <uv_pars_fragment>\\\\n#include <map_pars_fragment>\\\\n#include <alphamap_pars_fragment>\\\\n#include <fog_pars_fragment>\\\\n#include <bumpmap_pars_fragment>\\\\n#include <normalmap_pars_fragment>\\\\n#include <logdepthbuf_pars_fragment>\\\\n#include <clipping_planes_pars_fragment>\\\\nvoid main() {\\\\n\\\\t#include <clipping_planes_fragment>\\\\n\\\\tvec4 diffuseColor = vec4( diffuse, opacity );\\\\n\\\\t#include <logdepthbuf_fragment>\\\\n\\\\t#include <map_fragment>\\\\n\\\\t#include <color_fragment>\\\\n\\\\t#include <alphamap_fragment>\\\\n\\\\t#include <alphatest_fragment>\\\\n\\\\t#include <normal_fragment_begin>\\\\n\\\\t#include <normal_fragment_maps>\\\\n\\\\tvec3 viewDir = normalize( vViewPosition );\\\\n\\\\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\\\\n\\\\tvec3 y = cross( viewDir, x );\\\\n\\\\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\\\\n\\\\t#ifdef USE_MATCAP\\\\n\\\\t\\\\tvec4 matcapColor = texture2D( matcap, uv );\\\\n\\\\t\\\\tmatcapColor = matcapTexelToLinear( matcapColor );\\\\n\\\\t#else\\\\n\\\\t\\\\tvec4 matcapColor = vec4( 1.0 );\\\\n\\\\t#endif\\\\n\\\\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\\\\n\\\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\\\n\\\\t#include <tonemapping_fragment>\\\\n\\\\t#include <encodings_fragment>\\\\n\\\\t#include <fog_fragment>\\\\n\\\\t#include <premultiplied_alpha_fragment>\\\\n\\\\t#include <dithering_fragment>\\\\n}\\\";\\r\\n\\r\\nvar meshmatcap_vert = \\\"#define MATCAP\\\\nvarying vec3 vViewPosition;\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvarying vec3 vNormal;\\\\n#endif\\\\n#include <common>\\\\n#include <uv_pars_vertex>\\\\n#include <color_pars_vertex>\\\\n#include <displacementmap_pars_vertex>\\\\n#include <fog_pars_vertex>\\\\n#include <morphtarget_pars_vertex>\\\\n#include <skinning_pars_vertex>\\\\n#include <logdepthbuf_pars_vertex>\\\\n#include <clipping_planes_pars_vertex>\\\\nvoid main() {\\\\n\\\\t#include <uv_vertex>\\\\n\\\\t#include <color_vertex>\\\\n\\\\t#include <beginnormal_vertex>\\\\n\\\\t#include <morphnormal_vertex>\\\\n\\\\t#include <skinbase_vertex>\\\\n\\\\t#include <skinnormal_vertex>\\\\n\\\\t#include <defaultnormal_vertex>\\\\n\\\\t#ifndef FLAT_SHADED\\\\n\\\\t\\\\tvNormal = normalize( transformedNormal );\\\\n\\\\t#endif\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <morphtarget_vertex>\\\\n\\\\t#include <skinning_vertex>\\\\n\\\\t#include <displacementmap_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\t#include <logdepthbuf_vertex>\\\\n\\\\t#include <clipping_planes_vertex>\\\\n\\\\t#include <fog_vertex>\\\\n\\\\tvViewPosition = - mvPosition.xyz;\\\\n}\\\";\\r\\n\\r\\nvar meshtoon_frag = \\\"#define TOON\\\\nuniform vec3 diffuse;\\\\nuniform vec3 emissive;\\\\nuniform vec3 specular;\\\\nuniform float shininess;\\\\nuniform float opacity;\\\\n#include <common>\\\\n#include <packing>\\\\n#include <dithering_pars_fragment>\\\\n#include <color_pars_fragment>\\\\n#include <uv_pars_fragment>\\\\n#include <uv2_pars_fragment>\\\\n#include <map_pars_fragment>\\\\n#include <alphamap_pars_fragment>\\\\n#include <aomap_pars_fragment>\\\\n#include <lightmap_pars_fragment>\\\\n#include <emissivemap_pars_fragment>\\\\n#include <gradientmap_pars_fragment>\\\\n#include <fog_pars_fragment>\\\\n#include <bsdfs>\\\\n#include <lights_pars_begin>\\\\n#include <lights_toon_pars_fragment>\\\\n#include <shadowmap_pars_fragment>\\\\n#include <bumpmap_pars_fragment>\\\\n#include <normalmap_pars_fragment>\\\\n#include <specularmap_pars_fragment>\\\\n#include <logdepthbuf_pars_fragment>\\\\n#include <clipping_planes_pars_fragment>\\\\nvoid main() {\\\\n\\\\t#include <clipping_planes_fragment>\\\\n\\\\tvec4 diffuseColor = vec4( diffuse, opacity );\\\\n\\\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\\\n\\\\tvec3 totalEmissiveRadiance = emissive;\\\\n\\\\t#include <logdepthbuf_fragment>\\\\n\\\\t#include <map_fragment>\\\\n\\\\t#include <color_fragment>\\\\n\\\\t#include <alphamap_fragment>\\\\n\\\\t#include <alphatest_fragment>\\\\n\\\\t#include <specularmap_fragment>\\\\n\\\\t#include <normal_fragment_begin>\\\\n\\\\t#include <normal_fragment_maps>\\\\n\\\\t#include <emissivemap_fragment>\\\\n\\\\t#include <lights_toon_fragment>\\\\n\\\\t#include <lights_fragment_begin>\\\\n\\\\t#include <lights_fragment_maps>\\\\n\\\\t#include <lights_fragment_end>\\\\n\\\\t#include <aomap_fragment>\\\\n\\\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\\\n\\\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\\\n\\\\t#include <tonemapping_fragment>\\\\n\\\\t#include <encodings_fragment>\\\\n\\\\t#include <fog_fragment>\\\\n\\\\t#include <premultiplied_alpha_fragment>\\\\n\\\\t#include <dithering_fragment>\\\\n}\\\";\\r\\n\\r\\nvar meshtoon_vert = \\\"#define TOON\\\\nvarying vec3 vViewPosition;\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvarying vec3 vNormal;\\\\n#endif\\\\n#include <common>\\\\n#include <uv_pars_vertex>\\\\n#include <uv2_pars_vertex>\\\\n#include <displacementmap_pars_vertex>\\\\n#include <color_pars_vertex>\\\\n#include <fog_pars_vertex>\\\\n#include <morphtarget_pars_vertex>\\\\n#include <skinning_pars_vertex>\\\\n#include <shadowmap_pars_vertex>\\\\n#include <logdepthbuf_pars_vertex>\\\\n#include <clipping_planes_pars_vertex>\\\\nvoid main() {\\\\n\\\\t#include <uv_vertex>\\\\n\\\\t#include <uv2_vertex>\\\\n\\\\t#include <color_vertex>\\\\n\\\\t#include <beginnormal_vertex>\\\\n\\\\t#include <morphnormal_vertex>\\\\n\\\\t#include <skinbase_vertex>\\\\n\\\\t#include <skinnormal_vertex>\\\\n\\\\t#include <defaultnormal_vertex>\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvNormal = normalize( transformedNormal );\\\\n#endif\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <morphtarget_vertex>\\\\n\\\\t#include <skinning_vertex>\\\\n\\\\t#include <displacementmap_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\t#include <logdepthbuf_vertex>\\\\n\\\\t#include <clipping_planes_vertex>\\\\n\\\\tvViewPosition = - mvPosition.xyz;\\\\n\\\\t#include <worldpos_vertex>\\\\n\\\\t#include <shadowmap_vertex>\\\\n\\\\t#include <fog_vertex>\\\\n}\\\";\\r\\n\\r\\nvar meshphong_frag = \\\"#define PHONG\\\\nuniform vec3 diffuse;\\\\nuniform vec3 emissive;\\\\nuniform vec3 specular;\\\\nuniform float shininess;\\\\nuniform float opacity;\\\\n#include <common>\\\\n#include <packing>\\\\n#include <dithering_pars_fragment>\\\\n#include <color_pars_fragment>\\\\n#include <uv_pars_fragment>\\\\n#include <uv2_pars_fragment>\\\\n#include <map_pars_fragment>\\\\n#include <alphamap_pars_fragment>\\\\n#include <aomap_pars_fragment>\\\\n#include <lightmap_pars_fragment>\\\\n#include <emissivemap_pars_fragment>\\\\n#include <envmap_common_pars_fragment>\\\\n#include <envmap_pars_fragment>\\\\n#include <cube_uv_reflection_fragment>\\\\n#include <fog_pars_fragment>\\\\n#include <bsdfs>\\\\n#include <lights_pars_begin>\\\\n#include <lights_phong_pars_fragment>\\\\n#include <shadowmap_pars_fragment>\\\\n#include <bumpmap_pars_fragment>\\\\n#include <normalmap_pars_fragment>\\\\n#include <specularmap_pars_fragment>\\\\n#include <logdepthbuf_pars_fragment>\\\\n#include <clipping_planes_pars_fragment>\\\\nvoid main() {\\\\n\\\\t#include <clipping_planes_fragment>\\\\n\\\\tvec4 diffuseColor = vec4( diffuse, opacity );\\\\n\\\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\\\n\\\\tvec3 totalEmissiveRadiance = emissive;\\\\n\\\\t#include <logdepthbuf_fragment>\\\\n\\\\t#include <map_fragment>\\\\n\\\\t#include <color_fragment>\\\\n\\\\t#include <alphamap_fragment>\\\\n\\\\t#include <alphatest_fragment>\\\\n\\\\t#include <specularmap_fragment>\\\\n\\\\t#include <normal_fragment_begin>\\\\n\\\\t#include <normal_fragment_maps>\\\\n\\\\t#include <emissivemap_fragment>\\\\n\\\\t#include <lights_phong_fragment>\\\\n\\\\t#include <lights_fragment_begin>\\\\n\\\\t#include <lights_fragment_maps>\\\\n\\\\t#include <lights_fragment_end>\\\\n\\\\t#include <aomap_fragment>\\\\n\\\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\\\n\\\\t#include <envmap_fragment>\\\\n\\\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\\\n\\\\t#include <tonemapping_fragment>\\\\n\\\\t#include <encodings_fragment>\\\\n\\\\t#include <fog_fragment>\\\\n\\\\t#include <premultiplied_alpha_fragment>\\\\n\\\\t#include <dithering_fragment>\\\\n}\\\";\\r\\n\\r\\nvar meshphong_vert = \\\"#define PHONG\\\\nvarying vec3 vViewPosition;\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvarying vec3 vNormal;\\\\n#endif\\\\n#include <common>\\\\n#include <uv_pars_vertex>\\\\n#include <uv2_pars_vertex>\\\\n#include <displacementmap_pars_vertex>\\\\n#include <envmap_pars_vertex>\\\\n#include <color_pars_vertex>\\\\n#include <fog_pars_vertex>\\\\n#include <morphtarget_pars_vertex>\\\\n#include <skinning_pars_vertex>\\\\n#include <shadowmap_pars_vertex>\\\\n#include <logdepthbuf_pars_vertex>\\\\n#include <clipping_planes_pars_vertex>\\\\nvoid main() {\\\\n\\\\t#include <uv_vertex>\\\\n\\\\t#include <uv2_vertex>\\\\n\\\\t#include <color_vertex>\\\\n\\\\t#include <beginnormal_vertex>\\\\n\\\\t#include <morphnormal_vertex>\\\\n\\\\t#include <skinbase_vertex>\\\\n\\\\t#include <skinnormal_vertex>\\\\n\\\\t#include <defaultnormal_vertex>\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvNormal = normalize( transformedNormal );\\\\n#endif\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <morphtarget_vertex>\\\\n\\\\t#include <skinning_vertex>\\\\n\\\\t#include <displacementmap_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\t#include <logdepthbuf_vertex>\\\\n\\\\t#include <clipping_planes_vertex>\\\\n\\\\tvViewPosition = - mvPosition.xyz;\\\\n\\\\t#include <worldpos_vertex>\\\\n\\\\t#include <envmap_vertex>\\\\n\\\\t#include <shadowmap_vertex>\\\\n\\\\t#include <fog_vertex>\\\\n}\\\";\\r\\n\\r\\nvar meshphysical_frag = \\\"#define STANDARD\\\\n#ifdef PHYSICAL\\\\n\\\\t#define REFLECTIVITY\\\\n\\\\t#define CLEARCOAT\\\\n\\\\t#define TRANSPARENCY\\\\n#endif\\\\nuniform vec3 diffuse;\\\\nuniform vec3 emissive;\\\\nuniform float roughness;\\\\nuniform float metalness;\\\\nuniform float opacity;\\\\n#ifdef TRANSPARENCY\\\\n\\\\tuniform float transparency;\\\\n#endif\\\\n#ifdef REFLECTIVITY\\\\n\\\\tuniform float reflectivity;\\\\n#endif\\\\n#ifdef CLEARCOAT\\\\n\\\\tuniform float clearcoat;\\\\n\\\\tuniform float clearcoatRoughness;\\\\n#endif\\\\n#ifdef USE_SHEEN\\\\n\\\\tuniform vec3 sheen;\\\\n#endif\\\\nvarying vec3 vViewPosition;\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvarying vec3 vNormal;\\\\n\\\\t#ifdef USE_TANGENT\\\\n\\\\t\\\\tvarying vec3 vTangent;\\\\n\\\\t\\\\tvarying vec3 vBitangent;\\\\n\\\\t#endif\\\\n#endif\\\\n#include <common>\\\\n#include <packing>\\\\n#include <dithering_pars_fragment>\\\\n#include <color_pars_fragment>\\\\n#include <uv_pars_fragment>\\\\n#include <uv2_pars_fragment>\\\\n#include <map_pars_fragment>\\\\n#include <alphamap_pars_fragment>\\\\n#include <aomap_pars_fragment>\\\\n#include <lightmap_pars_fragment>\\\\n#include <emissivemap_pars_fragment>\\\\n#include <bsdfs>\\\\n#include <cube_uv_reflection_fragment>\\\\n#include <envmap_common_pars_fragment>\\\\n#include <envmap_physical_pars_fragment>\\\\n#include <fog_pars_fragment>\\\\n#include <lights_pars_begin>\\\\n#include <lights_physical_pars_fragment>\\\\n#include <shadowmap_pars_fragment>\\\\n#include <bumpmap_pars_fragment>\\\\n#include <normalmap_pars_fragment>\\\\n#include <clearcoat_pars_fragment>\\\\n#include <roughnessmap_pars_fragment>\\\\n#include <metalnessmap_pars_fragment>\\\\n#include <logdepthbuf_pars_fragment>\\\\n#include <clipping_planes_pars_fragment>\\\\nvoid main() {\\\\n\\\\t#include <clipping_planes_fragment>\\\\n\\\\tvec4 diffuseColor = vec4( diffuse, opacity );\\\\n\\\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\\\n\\\\tvec3 totalEmissiveRadiance = emissive;\\\\n\\\\t#include <logdepthbuf_fragment>\\\\n\\\\t#include <map_fragment>\\\\n\\\\t#include <color_fragment>\\\\n\\\\t#include <alphamap_fragment>\\\\n\\\\t#include <alphatest_fragment>\\\\n\\\\t#include <roughnessmap_fragment>\\\\n\\\\t#include <metalnessmap_fragment>\\\\n\\\\t#include <normal_fragment_begin>\\\\n\\\\t#include <normal_fragment_maps>\\\\n\\\\t#include <clearcoat_normal_fragment_begin>\\\\n\\\\t#include <clearcoat_normal_fragment_maps>\\\\n\\\\t#include <emissivemap_fragment>\\\\n\\\\t#include <lights_physical_fragment>\\\\n\\\\t#include <lights_fragment_begin>\\\\n\\\\t#include <lights_fragment_maps>\\\\n\\\\t#include <lights_fragment_end>\\\\n\\\\t#include <aomap_fragment>\\\\n\\\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\\\n\\\\t#ifdef TRANSPARENCY\\\\n\\\\t\\\\tdiffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\\\\n\\\\t#endif\\\\n\\\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\\\n\\\\t#include <tonemapping_fragment>\\\\n\\\\t#include <encodings_fragment>\\\\n\\\\t#include <fog_fragment>\\\\n\\\\t#include <premultiplied_alpha_fragment>\\\\n\\\\t#include <dithering_fragment>\\\\n}\\\";\\r\\n\\r\\nvar meshphysical_vert = \\\"#define STANDARD\\\\nvarying vec3 vViewPosition;\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvarying vec3 vNormal;\\\\n\\\\t#ifdef USE_TANGENT\\\\n\\\\t\\\\tvarying vec3 vTangent;\\\\n\\\\t\\\\tvarying vec3 vBitangent;\\\\n\\\\t#endif\\\\n#endif\\\\n#include <common>\\\\n#include <uv_pars_vertex>\\\\n#include <uv2_pars_vertex>\\\\n#include <displacementmap_pars_vertex>\\\\n#include <color_pars_vertex>\\\\n#include <fog_pars_vertex>\\\\n#include <morphtarget_pars_vertex>\\\\n#include <skinning_pars_vertex>\\\\n#include <shadowmap_pars_vertex>\\\\n#include <logdepthbuf_pars_vertex>\\\\n#include <clipping_planes_pars_vertex>\\\\nvoid main() {\\\\n\\\\t#include <uv_vertex>\\\\n\\\\t#include <uv2_vertex>\\\\n\\\\t#include <color_vertex>\\\\n\\\\t#include <beginnormal_vertex>\\\\n\\\\t#include <morphnormal_vertex>\\\\n\\\\t#include <skinbase_vertex>\\\\n\\\\t#include <skinnormal_vertex>\\\\n\\\\t#include <defaultnormal_vertex>\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvNormal = normalize( transformedNormal );\\\\n\\\\t#ifdef USE_TANGENT\\\\n\\\\t\\\\tvTangent = normalize( transformedTangent );\\\\n\\\\t\\\\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\\\\n\\\\t#endif\\\\n#endif\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <morphtarget_vertex>\\\\n\\\\t#include <skinning_vertex>\\\\n\\\\t#include <displacementmap_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\t#include <logdepthbuf_vertex>\\\\n\\\\t#include <clipping_planes_vertex>\\\\n\\\\tvViewPosition = - mvPosition.xyz;\\\\n\\\\t#include <worldpos_vertex>\\\\n\\\\t#include <shadowmap_vertex>\\\\n\\\\t#include <fog_vertex>\\\\n}\\\";\\r\\n\\r\\nvar normal_frag = \\\"#define NORMAL\\\\nuniform float opacity;\\\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\\\\n\\\\tvarying vec3 vViewPosition;\\\\n#endif\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvarying vec3 vNormal;\\\\n\\\\t#ifdef USE_TANGENT\\\\n\\\\t\\\\tvarying vec3 vTangent;\\\\n\\\\t\\\\tvarying vec3 vBitangent;\\\\n\\\\t#endif\\\\n#endif\\\\n#include <packing>\\\\n#include <uv_pars_fragment>\\\\n#include <bumpmap_pars_fragment>\\\\n#include <normalmap_pars_fragment>\\\\n#include <logdepthbuf_pars_fragment>\\\\n#include <clipping_planes_pars_fragment>\\\\nvoid main() {\\\\n\\\\t#include <clipping_planes_fragment>\\\\n\\\\t#include <logdepthbuf_fragment>\\\\n\\\\t#include <normal_fragment_begin>\\\\n\\\\t#include <normal_fragment_maps>\\\\n\\\\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\\\\n}\\\";\\r\\n\\r\\nvar normal_vert = \\\"#define NORMAL\\\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\\\\n\\\\tvarying vec3 vViewPosition;\\\\n#endif\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvarying vec3 vNormal;\\\\n\\\\t#ifdef USE_TANGENT\\\\n\\\\t\\\\tvarying vec3 vTangent;\\\\n\\\\t\\\\tvarying vec3 vBitangent;\\\\n\\\\t#endif\\\\n#endif\\\\n#include <common>\\\\n#include <uv_pars_vertex>\\\\n#include <displacementmap_pars_vertex>\\\\n#include <morphtarget_pars_vertex>\\\\n#include <skinning_pars_vertex>\\\\n#include <logdepthbuf_pars_vertex>\\\\n#include <clipping_planes_pars_vertex>\\\\nvoid main() {\\\\n\\\\t#include <uv_vertex>\\\\n\\\\t#include <beginnormal_vertex>\\\\n\\\\t#include <morphnormal_vertex>\\\\n\\\\t#include <skinbase_vertex>\\\\n\\\\t#include <skinnormal_vertex>\\\\n\\\\t#include <defaultnormal_vertex>\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvNormal = normalize( transformedNormal );\\\\n\\\\t#ifdef USE_TANGENT\\\\n\\\\t\\\\tvTangent = normalize( transformedTangent );\\\\n\\\\t\\\\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\\\\n\\\\t#endif\\\\n#endif\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <morphtarget_vertex>\\\\n\\\\t#include <skinning_vertex>\\\\n\\\\t#include <displacementmap_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\t#include <logdepthbuf_vertex>\\\\n\\\\t#include <clipping_planes_vertex>\\\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\\\\n\\\\tvViewPosition = - mvPosition.xyz;\\\\n#endif\\\\n}\\\";\\r\\n\\r\\nvar points_frag = \\\"uniform vec3 diffuse;\\\\nuniform float opacity;\\\\n#include <common>\\\\n#include <color_pars_fragment>\\\\n#include <map_particle_pars_fragment>\\\\n#include <fog_pars_fragment>\\\\n#include <logdepthbuf_pars_fragment>\\\\n#include <clipping_planes_pars_fragment>\\\\nvoid main() {\\\\n\\\\t#include <clipping_planes_fragment>\\\\n\\\\tvec3 outgoingLight = vec3( 0.0 );\\\\n\\\\tvec4 diffuseColor = vec4( diffuse, opacity );\\\\n\\\\t#include <logdepthbuf_fragment>\\\\n\\\\t#include <map_particle_fragment>\\\\n\\\\t#include <color_fragment>\\\\n\\\\t#include <alphatest_fragment>\\\\n\\\\toutgoingLight = diffuseColor.rgb;\\\\n\\\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\\\n\\\\t#include <tonemapping_fragment>\\\\n\\\\t#include <encodings_fragment>\\\\n\\\\t#include <fog_fragment>\\\\n\\\\t#include <premultiplied_alpha_fragment>\\\\n}\\\";\\r\\n\\r\\nvar points_vert = \\\"uniform float size;\\\\nuniform float scale;\\\\n#include <common>\\\\n#include <color_pars_vertex>\\\\n#include <fog_pars_vertex>\\\\n#include <morphtarget_pars_vertex>\\\\n#include <logdepthbuf_pars_vertex>\\\\n#include <clipping_planes_pars_vertex>\\\\nvoid main() {\\\\n\\\\t#include <color_vertex>\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <morphtarget_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\tgl_PointSize = size;\\\\n\\\\t#ifdef USE_SIZEATTENUATION\\\\n\\\\t\\\\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\\\\n\\\\t\\\\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\\\\n\\\\t#endif\\\\n\\\\t#include <logdepthbuf_vertex>\\\\n\\\\t#include <clipping_planes_vertex>\\\\n\\\\t#include <worldpos_vertex>\\\\n\\\\t#include <fog_vertex>\\\\n}\\\";\\r\\n\\r\\nvar shadow_frag = \\\"uniform vec3 color;\\\\nuniform float opacity;\\\\n#include <common>\\\\n#include <packing>\\\\n#include <fog_pars_fragment>\\\\n#include <bsdfs>\\\\n#include <lights_pars_begin>\\\\n#include <shadowmap_pars_fragment>\\\\n#include <shadowmask_pars_fragment>\\\\nvoid main() {\\\\n\\\\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\\\\n\\\\t#include <tonemapping_fragment>\\\\n\\\\t#include <encodings_fragment>\\\\n\\\\t#include <fog_fragment>\\\\n}\\\";\\r\\n\\r\\nvar shadow_vert = \\\"#include <fog_pars_vertex>\\\\n#include <shadowmap_pars_vertex>\\\\nvoid main() {\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\t#include <worldpos_vertex>\\\\n\\\\t#include <shadowmap_vertex>\\\\n\\\\t#include <fog_vertex>\\\\n}\\\";\\r\\n\\r\\nvar sprite_frag = \\\"uniform vec3 diffuse;\\\\nuniform float opacity;\\\\n#include <common>\\\\n#include <uv_pars_fragment>\\\\n#include <map_pars_fragment>\\\\n#include <alphamap_pars_fragment>\\\\n#include <fog_pars_fragment>\\\\n#include <logdepthbuf_pars_fragment>\\\\n#include <clipping_planes_pars_fragment>\\\\nvoid main() {\\\\n\\\\t#include <clipping_planes_fragment>\\\\n\\\\tvec3 outgoingLight = vec3( 0.0 );\\\\n\\\\tvec4 diffuseColor = vec4( diffuse, opacity );\\\\n\\\\t#include <logdepthbuf_fragment>\\\\n\\\\t#include <map_fragment>\\\\n\\\\t#include <alphamap_fragment>\\\\n\\\\t#include <alphatest_fragment>\\\\n\\\\toutgoingLight = diffuseColor.rgb;\\\\n\\\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\\\n\\\\t#include <tonemapping_fragment>\\\\n\\\\t#include <encodings_fragment>\\\\n\\\\t#include <fog_fragment>\\\\n}\\\";\\r\\n\\r\\nvar sprite_vert = \\\"uniform float rotation;\\\\nuniform vec2 center;\\\\n#include <common>\\\\n#include <uv_pars_vertex>\\\\n#include <fog_pars_vertex>\\\\n#include <logdepthbuf_pars_vertex>\\\\n#include <clipping_planes_pars_vertex>\\\\nvoid main() {\\\\n\\\\t#include <uv_vertex>\\\\n\\\\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\\\\n\\\\tvec2 scale;\\\\n\\\\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\\\\n\\\\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\\\\n\\\\t#ifndef USE_SIZEATTENUATION\\\\n\\\\t\\\\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\\\\n\\\\t\\\\tif ( isPerspective ) scale *= - mvPosition.z;\\\\n\\\\t#endif\\\\n\\\\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\\\\n\\\\tvec2 rotatedPosition;\\\\n\\\\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\\\\n\\\\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\\\\n\\\\tmvPosition.xy += rotatedPosition;\\\\n\\\\tgl_Position = projectionMatrix * mvPosition;\\\\n\\\\t#include <logdepthbuf_vertex>\\\\n\\\\t#include <clipping_planes_vertex>\\\\n\\\\t#include <fog_vertex>\\\\n}\\\";\\r\\n\\r\\nvar ShaderChunk = {\\r\\n\\talphamap_fragment: alphamap_fragment,\\r\\n\\talphamap_pars_fragment: alphamap_pars_fragment,\\r\\n\\talphatest_fragment: alphatest_fragment,\\r\\n\\taomap_fragment: aomap_fragment,\\r\\n\\taomap_pars_fragment: aomap_pars_fragment,\\r\\n\\tbegin_vertex: begin_vertex,\\r\\n\\tbeginnormal_vertex: beginnormal_vertex,\\r\\n\\tbsdfs: bsdfs,\\r\\n\\tbumpmap_pars_fragment: bumpmap_pars_fragment,\\r\\n\\tclipping_planes_fragment: clipping_planes_fragment,\\r\\n\\tclipping_planes_pars_fragment: clipping_planes_pars_fragment,\\r\\n\\tclipping_planes_pars_vertex: clipping_planes_pars_vertex,\\r\\n\\tclipping_planes_vertex: clipping_planes_vertex,\\r\\n\\tcolor_fragment: color_fragment,\\r\\n\\tcolor_pars_fragment: color_pars_fragment,\\r\\n\\tcolor_pars_vertex: color_pars_vertex,\\r\\n\\tcolor_vertex: color_vertex,\\r\\n\\tcommon: common,\\r\\n\\tcube_uv_reflection_fragment: cube_uv_reflection_fragment,\\r\\n\\tdefaultnormal_vertex: defaultnormal_vertex,\\r\\n\\tdisplacementmap_pars_vertex: displacementmap_pars_vertex,\\r\\n\\tdisplacementmap_vertex: displacementmap_vertex,\\r\\n\\temissivemap_fragment: emissivemap_fragment,\\r\\n\\temissivemap_pars_fragment: emissivemap_pars_fragment,\\r\\n\\tencodings_fragment: encodings_fragment,\\r\\n\\tencodings_pars_fragment: encodings_pars_fragment,\\r\\n\\tenvmap_fragment: envmap_fragment,\\r\\n\\tenvmap_common_pars_fragment: envmap_common_pars_fragment,\\r\\n\\tenvmap_pars_fragment: envmap_pars_fragment,\\r\\n\\tenvmap_pars_vertex: envmap_pars_vertex,\\r\\n\\tenvmap_physical_pars_fragment: envmap_physical_pars_fragment,\\r\\n\\tenvmap_vertex: envmap_vertex,\\r\\n\\tfog_vertex: fog_vertex,\\r\\n\\tfog_pars_vertex: fog_pars_vertex,\\r\\n\\tfog_fragment: fog_fragment,\\r\\n\\tfog_pars_fragment: fog_pars_fragment,\\r\\n\\tgradientmap_pars_fragment: gradientmap_pars_fragment,\\r\\n\\tlightmap_fragment: lightmap_fragment,\\r\\n\\tlightmap_pars_fragment: lightmap_pars_fragment,\\r\\n\\tlights_lambert_vertex: lights_lambert_vertex,\\r\\n\\tlights_pars_begin: lights_pars_begin,\\r\\n\\tlights_toon_fragment: lights_toon_fragment,\\r\\n\\tlights_toon_pars_fragment: lights_toon_pars_fragment,\\r\\n\\tlights_phong_fragment: lights_phong_fragment,\\r\\n\\tlights_phong_pars_fragment: lights_phong_pars_fragment,\\r\\n\\tlights_physical_fragment: lights_physical_fragment,\\r\\n\\tlights_physical_pars_fragment: lights_physical_pars_fragment,\\r\\n\\tlights_fragment_begin: lights_fragment_begin,\\r\\n\\tlights_fragment_maps: lights_fragment_maps,\\r\\n\\tlights_fragment_end: lights_fragment_end,\\r\\n\\tlogdepthbuf_fragment: logdepthbuf_fragment,\\r\\n\\tlogdepthbuf_pars_fragment: logdepthbuf_pars_fragment,\\r\\n\\tlogdepthbuf_pars_vertex: logdepthbuf_pars_vertex,\\r\\n\\tlogdepthbuf_vertex: logdepthbuf_vertex,\\r\\n\\tmap_fragment: map_fragment,\\r\\n\\tmap_pars_fragment: map_pars_fragment,\\r\\n\\tmap_particle_fragment: map_particle_fragment,\\r\\n\\tmap_particle_pars_fragment: map_particle_pars_fragment,\\r\\n\\tmetalnessmap_fragment: metalnessmap_fragment,\\r\\n\\tmetalnessmap_pars_fragment: metalnessmap_pars_fragment,\\r\\n\\tmorphnormal_vertex: morphnormal_vertex,\\r\\n\\tmorphtarget_pars_vertex: morphtarget_pars_vertex,\\r\\n\\tmorphtarget_vertex: morphtarget_vertex,\\r\\n\\tnormal_fragment_begin: normal_fragment_begin,\\r\\n\\tnormal_fragment_maps: normal_fragment_maps,\\r\\n\\tnormalmap_pars_fragment: normalmap_pars_fragment,\\r\\n\\tclearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,\\r\\n\\tclearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,\\r\\n\\tclearcoat_pars_fragment: clearcoat_pars_fragment,\\r\\n\\tpacking: packing,\\r\\n\\tpremultiplied_alpha_fragment: premultiplied_alpha_fragment,\\r\\n\\tproject_vertex: project_vertex,\\r\\n\\tdithering_fragment: dithering_fragment,\\r\\n\\tdithering_pars_fragment: dithering_pars_fragment,\\r\\n\\troughnessmap_fragment: roughnessmap_fragment,\\r\\n\\troughnessmap_pars_fragment: roughnessmap_pars_fragment,\\r\\n\\tshadowmap_pars_fragment: shadowmap_pars_fragment,\\r\\n\\tshadowmap_pars_vertex: shadowmap_pars_vertex,\\r\\n\\tshadowmap_vertex: shadowmap_vertex,\\r\\n\\tshadowmask_pars_fragment: shadowmask_pars_fragment,\\r\\n\\tskinbase_vertex: skinbase_vertex,\\r\\n\\tskinning_pars_vertex: skinning_pars_vertex,\\r\\n\\tskinning_vertex: skinning_vertex,\\r\\n\\tskinnormal_vertex: skinnormal_vertex,\\r\\n\\tspecularmap_fragment: specularmap_fragment,\\r\\n\\tspecularmap_pars_fragment: specularmap_pars_fragment,\\r\\n\\ttonemapping_fragment: tonemapping_fragment,\\r\\n\\ttonemapping_pars_fragment: tonemapping_pars_fragment,\\r\\n\\tuv_pars_fragment: uv_pars_fragment,\\r\\n\\tuv_pars_vertex: uv_pars_vertex,\\r\\n\\tuv_vertex: uv_vertex,\\r\\n\\tuv2_pars_fragment: uv2_pars_fragment,\\r\\n\\tuv2_pars_vertex: uv2_pars_vertex,\\r\\n\\tuv2_vertex: uv2_vertex,\\r\\n\\tworldpos_vertex: worldpos_vertex,\\r\\n\\r\\n\\tbackground_frag: background_frag,\\r\\n\\tbackground_vert: background_vert,\\r\\n\\tcube_frag: cube_frag,\\r\\n\\tcube_vert: cube_vert,\\r\\n\\tdepth_frag: depth_frag,\\r\\n\\tdepth_vert: depth_vert,\\r\\n\\tdistanceRGBA_frag: distanceRGBA_frag,\\r\\n\\tdistanceRGBA_vert: distanceRGBA_vert,\\r\\n\\tequirect_frag: equirect_frag,\\r\\n\\tequirect_vert: equirect_vert,\\r\\n\\tlinedashed_frag: linedashed_frag,\\r\\n\\tlinedashed_vert: linedashed_vert,\\r\\n\\tmeshbasic_frag: meshbasic_frag,\\r\\n\\tmeshbasic_vert: meshbasic_vert,\\r\\n\\tmeshlambert_frag: meshlambert_frag,\\r\\n\\tmeshlambert_vert: meshlambert_vert,\\r\\n\\tmeshmatcap_frag: meshmatcap_frag,\\r\\n\\tmeshmatcap_vert: meshmatcap_vert,\\r\\n\\tmeshtoon_frag: meshtoon_frag,\\r\\n\\tmeshtoon_vert: meshtoon_vert,\\r\\n\\tmeshphong_frag: meshphong_frag,\\r\\n\\tmeshphong_vert: meshphong_vert,\\r\\n\\tmeshphysical_frag: meshphysical_frag,\\r\\n\\tmeshphysical_vert: meshphysical_vert,\\r\\n\\tnormal_frag: normal_frag,\\r\\n\\tnormal_vert: normal_vert,\\r\\n\\tpoints_frag: points_frag,\\r\\n\\tpoints_vert: points_vert,\\r\\n\\tshadow_frag: shadow_frag,\\r\\n\\tshadow_vert: shadow_vert,\\r\\n\\tsprite_frag: sprite_frag,\\r\\n\\tsprite_vert: sprite_vert\\r\\n};\\r\\n\\r\\n/**\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n * @author mikael emtinger / http://gomo.se/\\r\\n */\\r\\n\\r\\nvar ShaderLib = {\\r\\n\\r\\n\\tbasic: {\\r\\n\\r\\n\\t\\tuniforms: mergeUniforms( [\\r\\n\\t\\t\\tUniformsLib.common,\\r\\n\\t\\t\\tUniformsLib.specularmap,\\r\\n\\t\\t\\tUniformsLib.envmap,\\r\\n\\t\\t\\tUniformsLib.aomap,\\r\\n\\t\\t\\tUniformsLib.lightmap,\\r\\n\\t\\t\\tUniformsLib.fog\\r\\n\\t\\t] ),\\r\\n\\r\\n\\t\\tvertexShader: ShaderChunk.meshbasic_vert,\\r\\n\\t\\tfragmentShader: ShaderChunk.meshbasic_frag\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tlambert: {\\r\\n\\r\\n\\t\\tuniforms: mergeUniforms( [\\r\\n\\t\\t\\tUniformsLib.common,\\r\\n\\t\\t\\tUniformsLib.specularmap,\\r\\n\\t\\t\\tUniformsLib.envmap,\\r\\n\\t\\t\\tUniformsLib.aomap,\\r\\n\\t\\t\\tUniformsLib.lightmap,\\r\\n\\t\\t\\tUniformsLib.emissivemap,\\r\\n\\t\\t\\tUniformsLib.fog,\\r\\n\\t\\t\\tUniformsLib.lights,\\r\\n\\t\\t\\t{\\r\\n\\t\\t\\t\\temissive: { value: new Color( 0x000000 ) }\\r\\n\\t\\t\\t}\\r\\n\\t\\t] ),\\r\\n\\r\\n\\t\\tvertexShader: ShaderChunk.meshlambert_vert,\\r\\n\\t\\tfragmentShader: ShaderChunk.meshlambert_frag\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tphong: {\\r\\n\\r\\n\\t\\tuniforms: mergeUniforms( [\\r\\n\\t\\t\\tUniformsLib.common,\\r\\n\\t\\t\\tUniformsLib.specularmap,\\r\\n\\t\\t\\tUniformsLib.envmap,\\r\\n\\t\\t\\tUniformsLib.aomap,\\r\\n\\t\\t\\tUniformsLib.lightmap,\\r\\n\\t\\t\\tUniformsLib.emissivemap,\\r\\n\\t\\t\\tUniformsLib.bumpmap,\\r\\n\\t\\t\\tUniformsLib.normalmap,\\r\\n\\t\\t\\tUniformsLib.displacementmap,\\r\\n\\t\\t\\tUniformsLib.fog,\\r\\n\\t\\t\\tUniformsLib.lights,\\r\\n\\t\\t\\t{\\r\\n\\t\\t\\t\\temissive: { value: new Color( 0x000000 ) },\\r\\n\\t\\t\\t\\tspecular: { value: new Color( 0x111111 ) },\\r\\n\\t\\t\\t\\tshininess: { value: 30 }\\r\\n\\t\\t\\t}\\r\\n\\t\\t] ),\\r\\n\\r\\n\\t\\tvertexShader: ShaderChunk.meshphong_vert,\\r\\n\\t\\tfragmentShader: ShaderChunk.meshphong_frag\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tstandard: {\\r\\n\\r\\n\\t\\tuniforms: mergeUniforms( [\\r\\n\\t\\t\\tUniformsLib.common,\\r\\n\\t\\t\\tUniformsLib.envmap,\\r\\n\\t\\t\\tUniformsLib.aomap,\\r\\n\\t\\t\\tUniformsLib.lightmap,\\r\\n\\t\\t\\tUniformsLib.emissivemap,\\r\\n\\t\\t\\tUniformsLib.bumpmap,\\r\\n\\t\\t\\tUniformsLib.normalmap,\\r\\n\\t\\t\\tUniformsLib.displacementmap,\\r\\n\\t\\t\\tUniformsLib.roughnessmap,\\r\\n\\t\\t\\tUniformsLib.metalnessmap,\\r\\n\\t\\t\\tUniformsLib.fog,\\r\\n\\t\\t\\tUniformsLib.lights,\\r\\n\\t\\t\\t{\\r\\n\\t\\t\\t\\temissive: { value: new Color( 0x000000 ) },\\r\\n\\t\\t\\t\\troughness: { value: 1.0 },\\r\\n\\t\\t\\t\\tmetalness: { value: 0.0 },\\r\\n\\t\\t\\t\\tenvMapIntensity: { value: 1 } // temporary\\r\\n\\t\\t\\t}\\r\\n\\t\\t] ),\\r\\n\\r\\n\\t\\tvertexShader: ShaderChunk.meshphysical_vert,\\r\\n\\t\\tfragmentShader: ShaderChunk.meshphysical_frag\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttoon: {\\r\\n\\r\\n\\t\\tuniforms: mergeUniforms( [\\r\\n\\t\\t\\tUniformsLib.common,\\r\\n\\t\\t\\tUniformsLib.specularmap,\\r\\n\\t\\t\\tUniformsLib.aomap,\\r\\n\\t\\t\\tUniformsLib.lightmap,\\r\\n\\t\\t\\tUniformsLib.emissivemap,\\r\\n\\t\\t\\tUniformsLib.bumpmap,\\r\\n\\t\\t\\tUniformsLib.normalmap,\\r\\n\\t\\t\\tUniformsLib.displacementmap,\\r\\n\\t\\t\\tUniformsLib.gradientmap,\\r\\n\\t\\t\\tUniformsLib.fog,\\r\\n\\t\\t\\tUniformsLib.lights,\\r\\n\\t\\t\\t{\\r\\n\\t\\t\\t\\temissive: { value: new Color( 0x000000 ) },\\r\\n\\t\\t\\t\\tspecular: { value: new Color( 0x111111 ) },\\r\\n\\t\\t\\t\\tshininess: { value: 30 }\\r\\n\\t\\t\\t}\\r\\n\\t\\t] ),\\r\\n\\r\\n\\t\\tvertexShader: ShaderChunk.meshtoon_vert,\\r\\n\\t\\tfragmentShader: ShaderChunk.meshtoon_frag\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tmatcap: {\\r\\n\\r\\n\\t\\tuniforms: mergeUniforms( [\\r\\n\\t\\t\\tUniformsLib.common,\\r\\n\\t\\t\\tUniformsLib.bumpmap,\\r\\n\\t\\t\\tUniformsLib.normalmap,\\r\\n\\t\\t\\tUniformsLib.displacementmap,\\r\\n\\t\\t\\tUniformsLib.fog,\\r\\n\\t\\t\\t{\\r\\n\\t\\t\\t\\tmatcap: { value: null }\\r\\n\\t\\t\\t}\\r\\n\\t\\t] ),\\r\\n\\r\\n\\t\\tvertexShader: ShaderChunk.meshmatcap_vert,\\r\\n\\t\\tfragmentShader: ShaderChunk.meshmatcap_frag\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tpoints: {\\r\\n\\r\\n\\t\\tuniforms: mergeUniforms( [\\r\\n\\t\\t\\tUniformsLib.points,\\r\\n\\t\\t\\tUniformsLib.fog\\r\\n\\t\\t] ),\\r\\n\\r\\n\\t\\tvertexShader: ShaderChunk.points_vert,\\r\\n\\t\\tfragmentShader: ShaderChunk.points_frag\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tdashed: {\\r\\n\\r\\n\\t\\tuniforms: mergeUniforms( [\\r\\n\\t\\t\\tUniformsLib.common,\\r\\n\\t\\t\\tUniformsLib.fog,\\r\\n\\t\\t\\t{\\r\\n\\t\\t\\t\\tscale: { value: 1 },\\r\\n\\t\\t\\t\\tdashSize: { value: 1 },\\r\\n\\t\\t\\t\\ttotalSize: { value: 2 }\\r\\n\\t\\t\\t}\\r\\n\\t\\t] ),\\r\\n\\r\\n\\t\\tvertexShader: ShaderChunk.linedashed_vert,\\r\\n\\t\\tfragmentShader: ShaderChunk.linedashed_frag\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tdepth: {\\r\\n\\r\\n\\t\\tuniforms: mergeUniforms( [\\r\\n\\t\\t\\tUniformsLib.common,\\r\\n\\t\\t\\tUniformsLib.displacementmap\\r\\n\\t\\t] ),\\r\\n\\r\\n\\t\\tvertexShader: ShaderChunk.depth_vert,\\r\\n\\t\\tfragmentShader: ShaderChunk.depth_frag\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tnormal: {\\r\\n\\r\\n\\t\\tuniforms: mergeUniforms( [\\r\\n\\t\\t\\tUniformsLib.common,\\r\\n\\t\\t\\tUniformsLib.bumpmap,\\r\\n\\t\\t\\tUniformsLib.normalmap,\\r\\n\\t\\t\\tUniformsLib.displacementmap,\\r\\n\\t\\t\\t{\\r\\n\\t\\t\\t\\topacity: { value: 1.0 }\\r\\n\\t\\t\\t}\\r\\n\\t\\t] ),\\r\\n\\r\\n\\t\\tvertexShader: ShaderChunk.normal_vert,\\r\\n\\t\\tfragmentShader: ShaderChunk.normal_frag\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsprite: {\\r\\n\\r\\n\\t\\tuniforms: mergeUniforms( [\\r\\n\\t\\t\\tUniformsLib.sprite,\\r\\n\\t\\t\\tUniformsLib.fog\\r\\n\\t\\t] ),\\r\\n\\r\\n\\t\\tvertexShader: ShaderChunk.sprite_vert,\\r\\n\\t\\tfragmentShader: ShaderChunk.sprite_frag\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tbackground: {\\r\\n\\r\\n\\t\\tuniforms: {\\r\\n\\t\\t\\tuvTransform: { value: new Matrix3() },\\r\\n\\t\\t\\tt2D: { value: null },\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tvertexShader: ShaderChunk.background_vert,\\r\\n\\t\\tfragmentShader: ShaderChunk.background_frag\\r\\n\\r\\n\\t},\\r\\n\\t/* -------------------------------------------------------------------------\\r\\n\\t//\\tCube map shader\\r\\n\\t ------------------------------------------------------------------------- */\\r\\n\\r\\n\\tcube: {\\r\\n\\r\\n\\t\\tuniforms: mergeUniforms( [\\r\\n\\t\\t\\tUniformsLib.envmap,\\r\\n\\t\\t\\t{\\r\\n\\t\\t\\t\\topacity: { value: 1.0 }\\r\\n\\t\\t\\t}\\r\\n\\t\\t] ),\\r\\n\\r\\n\\t\\tvertexShader: ShaderChunk.cube_vert,\\r\\n\\t\\tfragmentShader: ShaderChunk.cube_frag\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tequirect: {\\r\\n\\r\\n\\t\\tuniforms: {\\r\\n\\t\\t\\ttEquirect: { value: null },\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tvertexShader: ShaderChunk.equirect_vert,\\r\\n\\t\\tfragmentShader: ShaderChunk.equirect_frag\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tdistanceRGBA: {\\r\\n\\r\\n\\t\\tuniforms: mergeUniforms( [\\r\\n\\t\\t\\tUniformsLib.common,\\r\\n\\t\\t\\tUniformsLib.displacementmap,\\r\\n\\t\\t\\t{\\r\\n\\t\\t\\t\\treferencePosition: { value: new Vector3() },\\r\\n\\t\\t\\t\\tnearDistance: { value: 1 },\\r\\n\\t\\t\\t\\tfarDistance: { value: 1000 }\\r\\n\\t\\t\\t}\\r\\n\\t\\t] ),\\r\\n\\r\\n\\t\\tvertexShader: ShaderChunk.distanceRGBA_vert,\\r\\n\\t\\tfragmentShader: ShaderChunk.distanceRGBA_frag\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tshadow: {\\r\\n\\r\\n\\t\\tuniforms: mergeUniforms( [\\r\\n\\t\\t\\tUniformsLib.lights,\\r\\n\\t\\t\\tUniformsLib.fog,\\r\\n\\t\\t\\t{\\r\\n\\t\\t\\t\\tcolor: { value: new Color( 0x00000 ) },\\r\\n\\t\\t\\t\\topacity: { value: 1.0 }\\r\\n\\t\\t\\t},\\r\\n\\t\\t] ),\\r\\n\\r\\n\\t\\tvertexShader: ShaderChunk.shadow_vert,\\r\\n\\t\\tfragmentShader: ShaderChunk.shadow_frag\\r\\n\\r\\n\\t}\\r\\n\\r\\n};\\r\\n\\r\\nShaderLib.physical = {\\r\\n\\r\\n\\tuniforms: mergeUniforms( [\\r\\n\\t\\tShaderLib.standard.uniforms,\\r\\n\\t\\t{\\r\\n\\t\\t\\tclearcoat: { value: 0 },\\r\\n\\t\\t\\tclearcoatMap: { value: null },\\r\\n\\t\\t\\tclearcoatRoughness: { value: 0 },\\r\\n\\t\\t\\tclearcoatRoughnessMap: { value: null },\\r\\n\\t\\t\\tclearcoatNormalScale: { value: new Vector2( 1, 1 ) },\\r\\n\\t\\t\\tclearcoatNormalMap: { value: null },\\r\\n\\t\\t\\tsheen: { value: new Color( 0x000000 ) },\\r\\n\\t\\t\\ttransparency: { value: 0 },\\r\\n\\t\\t}\\r\\n\\t] ),\\r\\n\\r\\n\\tvertexShader: ShaderChunk.meshphysical_vert,\\r\\n\\tfragmentShader: ShaderChunk.meshphysical_frag\\r\\n\\r\\n};\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nfunction WebGLBackground( renderer, state, objects, premultipliedAlpha ) {\\r\\n\\r\\n\\tvar clearColor = new Color( 0x000000 );\\r\\n\\tvar clearAlpha = 0;\\r\\n\\r\\n\\tvar planeMesh;\\r\\n\\tvar boxMesh;\\r\\n\\r\\n\\tvar currentBackground = null;\\r\\n\\tvar currentBackgroundVersion = 0;\\r\\n\\tvar currentTonemapping = null;\\r\\n\\r\\n\\tfunction render( renderList, scene, camera, forceClear ) {\\r\\n\\r\\n\\t\\tvar background = scene.background;\\r\\n\\r\\n\\t\\t// Ignore background in AR\\r\\n\\t\\t// TODO: Reconsider this.\\r\\n\\r\\n\\t\\tvar xr = renderer.xr;\\r\\n\\t\\tvar session = xr.getSession && xr.getSession();\\r\\n\\r\\n\\t\\tif ( session && session.environmentBlendMode === 'additive' ) {\\r\\n\\r\\n\\t\\t\\tbackground = null;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( background === null ) {\\r\\n\\r\\n\\t\\t\\tsetClear( clearColor, clearAlpha );\\r\\n\\r\\n\\t\\t} else if ( background && background.isColor ) {\\r\\n\\r\\n\\t\\t\\tsetClear( background, 1 );\\r\\n\\t\\t\\tforceClear = true;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( renderer.autoClear || forceClear ) {\\r\\n\\r\\n\\t\\t\\trenderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( background && ( background.isCubeTexture || background.isWebGLCubeRenderTarget || background.mapping === CubeUVReflectionMapping ) ) {\\r\\n\\r\\n\\t\\t\\tif ( boxMesh === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tboxMesh = new Mesh(\\r\\n\\t\\t\\t\\t\\tnew BoxBufferGeometry( 1, 1, 1 ),\\r\\n\\t\\t\\t\\t\\tnew ShaderMaterial( {\\r\\n\\t\\t\\t\\t\\t\\ttype: 'BackgroundCubeMaterial',\\r\\n\\t\\t\\t\\t\\t\\tuniforms: cloneUniforms( ShaderLib.cube.uniforms ),\\r\\n\\t\\t\\t\\t\\t\\tvertexShader: ShaderLib.cube.vertexShader,\\r\\n\\t\\t\\t\\t\\t\\tfragmentShader: ShaderLib.cube.fragmentShader,\\r\\n\\t\\t\\t\\t\\t\\tside: BackSide,\\r\\n\\t\\t\\t\\t\\t\\tdepthTest: false,\\r\\n\\t\\t\\t\\t\\t\\tdepthWrite: false,\\r\\n\\t\\t\\t\\t\\t\\tfog: false\\r\\n\\t\\t\\t\\t\\t} )\\r\\n\\t\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\t\\tboxMesh.geometry.deleteAttribute( 'normal' );\\r\\n\\t\\t\\t\\tboxMesh.geometry.deleteAttribute( 'uv' );\\r\\n\\r\\n\\t\\t\\t\\tboxMesh.onBeforeRender = function ( renderer, scene, camera ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.matrixWorld.copyPosition( camera.matrixWorld );\\r\\n\\r\\n\\t\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\t\\t// enable code injection for non-built-in material\\r\\n\\t\\t\\t\\tObject.defineProperty( boxMesh.material, 'envMap', {\\r\\n\\r\\n\\t\\t\\t\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\treturn this.uniforms.envMap.value;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t} );\\r\\n\\r\\n\\t\\t\\t\\tobjects.update( boxMesh );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar texture = background.isWebGLCubeRenderTarget ? background.texture : background;\\r\\n\\r\\n\\t\\t\\tboxMesh.material.uniforms.envMap.value = texture;\\r\\n\\t\\t\\tboxMesh.material.uniforms.flipEnvMap.value = texture.isCubeTexture ? - 1 : 1;\\r\\n\\r\\n\\t\\t\\tif ( currentBackground !== background ||\\r\\n\\t\\t\\t\\tcurrentBackgroundVersion !== texture.version ||\\r\\n\\t\\t\\t\\tcurrentTonemapping !== renderer.toneMapping ) {\\r\\n\\r\\n\\t\\t\\t\\tboxMesh.material.needsUpdate = true;\\r\\n\\r\\n\\t\\t\\t\\tcurrentBackground = background;\\r\\n\\t\\t\\t\\tcurrentBackgroundVersion = texture.version;\\r\\n\\t\\t\\t\\tcurrentTonemapping = renderer.toneMapping;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// push to the pre-sorted opaque render list\\r\\n\\t\\t\\trenderList.unshift( boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null );\\r\\n\\r\\n\\t\\t} else if ( background && background.isTexture ) {\\r\\n\\r\\n\\t\\t\\tif ( planeMesh === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tplaneMesh = new Mesh(\\r\\n\\t\\t\\t\\t\\tnew PlaneBufferGeometry( 2, 2 ),\\r\\n\\t\\t\\t\\t\\tnew ShaderMaterial( {\\r\\n\\t\\t\\t\\t\\t\\ttype: 'BackgroundMaterial',\\r\\n\\t\\t\\t\\t\\t\\tuniforms: cloneUniforms( ShaderLib.background.uniforms ),\\r\\n\\t\\t\\t\\t\\t\\tvertexShader: ShaderLib.background.vertexShader,\\r\\n\\t\\t\\t\\t\\t\\tfragmentShader: ShaderLib.background.fragmentShader,\\r\\n\\t\\t\\t\\t\\t\\tside: FrontSide,\\r\\n\\t\\t\\t\\t\\t\\tdepthTest: false,\\r\\n\\t\\t\\t\\t\\t\\tdepthWrite: false,\\r\\n\\t\\t\\t\\t\\t\\tfog: false\\r\\n\\t\\t\\t\\t\\t} )\\r\\n\\t\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\t\\tplaneMesh.geometry.deleteAttribute( 'normal' );\\r\\n\\r\\n\\t\\t\\t\\t// enable code injection for non-built-in material\\r\\n\\t\\t\\t\\tObject.defineProperty( planeMesh.material, 'map', {\\r\\n\\r\\n\\t\\t\\t\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\treturn this.uniforms.t2D.value;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t} );\\r\\n\\r\\n\\t\\t\\t\\tobjects.update( planeMesh );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tplaneMesh.material.uniforms.t2D.value = background;\\r\\n\\r\\n\\t\\t\\tif ( background.matrixAutoUpdate === true ) {\\r\\n\\r\\n\\t\\t\\t\\tbackground.updateMatrix();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tplaneMesh.material.uniforms.uvTransform.value.copy( background.matrix );\\r\\n\\r\\n\\t\\t\\tif ( currentBackground !== background ||\\r\\n\\t\\t\\t\\tcurrentBackgroundVersion !== background.version ||\\r\\n\\t\\t\\t\\tcurrentTonemapping !== renderer.toneMapping ) {\\r\\n\\r\\n\\t\\t\\t\\tplaneMesh.material.needsUpdate = true;\\r\\n\\r\\n\\t\\t\\t\\tcurrentBackground = background;\\r\\n\\t\\t\\t\\tcurrentBackgroundVersion = background.version;\\r\\n\\t\\t\\t\\tcurrentTonemapping = renderer.toneMapping;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\r\\n\\t\\t\\t// push to the pre-sorted opaque render list\\r\\n\\t\\t\\trenderList.unshift( planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction setClear( color, alpha ) {\\r\\n\\r\\n\\t\\tstate.buffers.color.setClear( color.r, color.g, color.b, alpha, premultipliedAlpha );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn {\\r\\n\\r\\n\\t\\tgetClearColor: function () {\\r\\n\\r\\n\\t\\t\\treturn clearColor;\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tsetClearColor: function ( color, alpha ) {\\r\\n\\r\\n\\t\\t\\tclearColor.set( color );\\r\\n\\t\\t\\tclearAlpha = alpha !== undefined ? alpha : 1;\\r\\n\\t\\t\\tsetClear( clearColor, clearAlpha );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tgetClearAlpha: function () {\\r\\n\\r\\n\\t\\t\\treturn clearAlpha;\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tsetClearAlpha: function ( alpha ) {\\r\\n\\r\\n\\t\\t\\tclearAlpha = alpha;\\r\\n\\t\\t\\tsetClear( clearColor, clearAlpha );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\trender: render\\r\\n\\r\\n\\t};\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nfunction WebGLBufferRenderer( gl, extensions, info, capabilities ) {\\r\\n\\r\\n\\tvar isWebGL2 = capabilities.isWebGL2;\\r\\n\\r\\n\\tvar mode;\\r\\n\\r\\n\\tfunction setMode( value ) {\\r\\n\\r\\n\\t\\tmode = value;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction render( start, count ) {\\r\\n\\r\\n\\t\\tgl.drawArrays( mode, start, count );\\r\\n\\r\\n\\t\\tinfo.update( count, mode );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction renderInstances( geometry, start, count, primcount ) {\\r\\n\\r\\n\\t\\tif ( primcount === 0 ) return;\\r\\n\\r\\n\\t\\tvar extension, methodName;\\r\\n\\r\\n\\t\\tif ( isWebGL2 ) {\\r\\n\\r\\n\\t\\t\\textension = gl;\\r\\n\\t\\t\\tmethodName = 'drawArraysInstanced';\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\textension = extensions.get( 'ANGLE_instanced_arrays' );\\r\\n\\t\\t\\tmethodName = 'drawArraysInstancedANGLE';\\r\\n\\r\\n\\t\\t\\tif ( extension === null ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\\r\\n\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\textension[ methodName ]( mode, start, count, primcount );\\r\\n\\r\\n\\t\\tinfo.update( count, mode, primcount );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tthis.setMode = setMode;\\r\\n\\tthis.render = render;\\r\\n\\tthis.renderInstances = renderInstances;\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nfunction WebGLCapabilities( gl, extensions, parameters ) {\\r\\n\\r\\n\\tvar maxAnisotropy;\\r\\n\\r\\n\\tfunction getMaxAnisotropy() {\\r\\n\\r\\n\\t\\tif ( maxAnisotropy !== undefined ) return maxAnisotropy;\\r\\n\\r\\n\\t\\tvar extension = extensions.get( 'EXT_texture_filter_anisotropic' );\\r\\n\\r\\n\\t\\tif ( extension !== null ) {\\r\\n\\r\\n\\t\\t\\tmaxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tmaxAnisotropy = 0;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn maxAnisotropy;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction getMaxPrecision( precision ) {\\r\\n\\r\\n\\t\\tif ( precision === 'highp' ) {\\r\\n\\r\\n\\t\\t\\tif ( gl.getShaderPrecisionFormat( 35633, 36338 ).precision > 0 &&\\r\\n\\t\\t\\t\\tgl.getShaderPrecisionFormat( 35632, 36338 ).precision > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\treturn 'highp';\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tprecision = 'mediump';\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( precision === 'mediump' ) {\\r\\n\\r\\n\\t\\t\\tif ( gl.getShaderPrecisionFormat( 35633, 36337 ).precision > 0 &&\\r\\n\\t\\t\\t\\tgl.getShaderPrecisionFormat( 35632, 36337 ).precision > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\treturn 'mediump';\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn 'lowp';\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t/* eslint-disable no-undef */\\r\\n\\tvar isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext ) ||\\r\\n\\t\\t( typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext );\\r\\n\\t/* eslint-enable no-undef */\\r\\n\\r\\n\\tvar precision = parameters.precision !== undefined ? parameters.precision : 'highp';\\r\\n\\tvar maxPrecision = getMaxPrecision( precision );\\r\\n\\r\\n\\tif ( maxPrecision !== precision ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );\\r\\n\\t\\tprecision = maxPrecision;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tvar logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;\\r\\n\\r\\n\\tvar maxTextures = gl.getParameter( 34930 );\\r\\n\\tvar maxVertexTextures = gl.getParameter( 35660 );\\r\\n\\tvar maxTextureSize = gl.getParameter( 3379 );\\r\\n\\tvar maxCubemapSize = gl.getParameter( 34076 );\\r\\n\\r\\n\\tvar maxAttributes = gl.getParameter( 34921 );\\r\\n\\tvar maxVertexUniforms = gl.getParameter( 36347 );\\r\\n\\tvar maxVaryings = gl.getParameter( 36348 );\\r\\n\\tvar maxFragmentUniforms = gl.getParameter( 36349 );\\r\\n\\r\\n\\tvar vertexTextures = maxVertexTextures > 0;\\r\\n\\tvar floatFragmentTextures = isWebGL2 || !! extensions.get( 'OES_texture_float' );\\r\\n\\tvar floatVertexTextures = vertexTextures && floatFragmentTextures;\\r\\n\\r\\n\\tvar maxSamples = isWebGL2 ? gl.getParameter( 36183 ) : 0;\\r\\n\\r\\n\\treturn {\\r\\n\\r\\n\\t\\tisWebGL2: isWebGL2,\\r\\n\\r\\n\\t\\tgetMaxAnisotropy: getMaxAnisotropy,\\r\\n\\t\\tgetMaxPrecision: getMaxPrecision,\\r\\n\\r\\n\\t\\tprecision: precision,\\r\\n\\t\\tlogarithmicDepthBuffer: logarithmicDepthBuffer,\\r\\n\\r\\n\\t\\tmaxTextures: maxTextures,\\r\\n\\t\\tmaxVertexTextures: maxVertexTextures,\\r\\n\\t\\tmaxTextureSize: maxTextureSize,\\r\\n\\t\\tmaxCubemapSize: maxCubemapSize,\\r\\n\\r\\n\\t\\tmaxAttributes: maxAttributes,\\r\\n\\t\\tmaxVertexUniforms: maxVertexUniforms,\\r\\n\\t\\tmaxVaryings: maxVaryings,\\r\\n\\t\\tmaxFragmentUniforms: maxFragmentUniforms,\\r\\n\\r\\n\\t\\tvertexTextures: vertexTextures,\\r\\n\\t\\tfloatFragmentTextures: floatFragmentTextures,\\r\\n\\t\\tfloatVertexTextures: floatVertexTextures,\\r\\n\\r\\n\\t\\tmaxSamples: maxSamples\\r\\n\\r\\n\\t};\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * @author tschw\\r\\n */\\r\\n\\r\\nfunction WebGLClipping() {\\r\\n\\r\\n\\tvar scope = this,\\r\\n\\r\\n\\t\\tglobalState = null,\\r\\n\\t\\tnumGlobalPlanes = 0,\\r\\n\\t\\tlocalClippingEnabled = false,\\r\\n\\t\\trenderingShadows = false,\\r\\n\\r\\n\\t\\tplane = new Plane(),\\r\\n\\t\\tviewNormalMatrix = new Matrix3(),\\r\\n\\r\\n\\t\\tuniform = { value: null, needsUpdate: false };\\r\\n\\r\\n\\tthis.uniform = uniform;\\r\\n\\tthis.numPlanes = 0;\\r\\n\\tthis.numIntersection = 0;\\r\\n\\r\\n\\tthis.init = function ( planes, enableLocalClipping, camera ) {\\r\\n\\r\\n\\t\\tvar enabled =\\r\\n\\t\\t\\tplanes.length !== 0 ||\\r\\n\\t\\t\\tenableLocalClipping ||\\r\\n\\t\\t\\t// enable state of previous frame - the clipping code has to\\r\\n\\t\\t\\t// run another frame in order to reset the state:\\r\\n\\t\\t\\tnumGlobalPlanes !== 0 ||\\r\\n\\t\\t\\tlocalClippingEnabled;\\r\\n\\r\\n\\t\\tlocalClippingEnabled = enableLocalClipping;\\r\\n\\r\\n\\t\\tglobalState = projectPlanes( planes, camera, 0 );\\r\\n\\t\\tnumGlobalPlanes = planes.length;\\r\\n\\r\\n\\t\\treturn enabled;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.beginShadows = function () {\\r\\n\\r\\n\\t\\trenderingShadows = true;\\r\\n\\t\\tprojectPlanes( null );\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.endShadows = function () {\\r\\n\\r\\n\\t\\trenderingShadows = false;\\r\\n\\t\\tresetGlobalState();\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.setState = function ( planes, clipIntersection, clipShadows, camera, cache, fromCache ) {\\r\\n\\r\\n\\t\\tif ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {\\r\\n\\r\\n\\t\\t\\t// there's no local clipping\\r\\n\\r\\n\\t\\t\\tif ( renderingShadows ) {\\r\\n\\r\\n\\t\\t\\t\\t// there's no global clipping\\r\\n\\r\\n\\t\\t\\t\\tprojectPlanes( null );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tresetGlobalState();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tvar nGlobal = renderingShadows ? 0 : numGlobalPlanes,\\r\\n\\t\\t\\t\\tlGlobal = nGlobal * 4,\\r\\n\\r\\n\\t\\t\\t\\tdstArray = cache.clippingState || null;\\r\\n\\r\\n\\t\\t\\tuniform.value = dstArray; // ensure unique state\\r\\n\\r\\n\\t\\t\\tdstArray = projectPlanes( planes, camera, lGlobal, fromCache );\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i !== lGlobal; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\tdstArray[ i ] = globalState[ i ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tcache.clippingState = dstArray;\\r\\n\\t\\t\\tthis.numIntersection = clipIntersection ? this.numPlanes : 0;\\r\\n\\t\\t\\tthis.numPlanes += nGlobal;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tfunction resetGlobalState() {\\r\\n\\r\\n\\t\\tif ( uniform.value !== globalState ) {\\r\\n\\r\\n\\t\\t\\tuniform.value = globalState;\\r\\n\\t\\t\\tuniform.needsUpdate = numGlobalPlanes > 0;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tscope.numPlanes = numGlobalPlanes;\\r\\n\\t\\tscope.numIntersection = 0;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction projectPlanes( planes, camera, dstOffset, skipTransform ) {\\r\\n\\r\\n\\t\\tvar nPlanes = planes !== null ? planes.length : 0,\\r\\n\\t\\t\\tdstArray = null;\\r\\n\\r\\n\\t\\tif ( nPlanes !== 0 ) {\\r\\n\\r\\n\\t\\t\\tdstArray = uniform.value;\\r\\n\\r\\n\\t\\t\\tif ( skipTransform !== true || dstArray === null ) {\\r\\n\\r\\n\\t\\t\\t\\tvar flatSize = dstOffset + nPlanes * 4,\\r\\n\\t\\t\\t\\t\\tviewMatrix = camera.matrixWorldInverse;\\r\\n\\r\\n\\t\\t\\t\\tviewNormalMatrix.getNormalMatrix( viewMatrix );\\r\\n\\r\\n\\t\\t\\t\\tif ( dstArray === null || dstArray.length < flatSize ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tdstArray = new Float32Array( flatSize );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tplane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );\\r\\n\\r\\n\\t\\t\\t\\t\\tplane.normal.toArray( dstArray, i4 );\\r\\n\\t\\t\\t\\t\\tdstArray[ i4 + 3 ] = plane.constant;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tuniform.value = dstArray;\\r\\n\\t\\t\\tuniform.needsUpdate = true;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tscope.numPlanes = nPlanes;\\r\\n\\t\\tscope.numIntersection = 0;\\r\\n\\r\\n\\t\\treturn dstArray;\\r\\n\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nfunction WebGLExtensions( gl ) {\\r\\n\\r\\n\\tvar extensions = {};\\r\\n\\r\\n\\treturn {\\r\\n\\r\\n\\t\\tget: function ( name ) {\\r\\n\\r\\n\\t\\t\\tif ( extensions[ name ] !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\treturn extensions[ name ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar extension;\\r\\n\\r\\n\\t\\t\\tswitch ( name ) {\\r\\n\\r\\n\\t\\t\\t\\tcase 'WEBGL_depth_texture':\\r\\n\\t\\t\\t\\t\\textension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\tcase 'EXT_texture_filter_anisotropic':\\r\\n\\t\\t\\t\\t\\textension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\tcase 'WEBGL_compressed_texture_s3tc':\\r\\n\\t\\t\\t\\t\\textension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\tcase 'WEBGL_compressed_texture_pvrtc':\\r\\n\\t\\t\\t\\t\\textension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\tdefault:\\r\\n\\t\\t\\t\\t\\textension = gl.getExtension( name );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( extension === null ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\textensions[ name ] = extension;\\r\\n\\r\\n\\t\\t\\treturn extension;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t};\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nfunction WebGLGeometries( gl, attributes, info ) {\\r\\n\\r\\n\\tvar geometries = new WeakMap();\\r\\n\\tvar wireframeAttributes = new WeakMap();\\r\\n\\r\\n\\tfunction onGeometryDispose( event ) {\\r\\n\\r\\n\\t\\tvar geometry = event.target;\\r\\n\\t\\tvar buffergeometry = geometries.get( geometry );\\r\\n\\r\\n\\t\\tif ( buffergeometry.index !== null ) {\\r\\n\\r\\n\\t\\t\\tattributes.remove( buffergeometry.index );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfor ( var name in buffergeometry.attributes ) {\\r\\n\\r\\n\\t\\t\\tattributes.remove( buffergeometry.attributes[ name ] );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tgeometry.removeEventListener( 'dispose', onGeometryDispose );\\r\\n\\r\\n\\t\\tgeometries.delete( geometry );\\r\\n\\r\\n\\t\\tvar attribute = wireframeAttributes.get( buffergeometry );\\r\\n\\r\\n\\t\\tif ( attribute ) {\\r\\n\\r\\n\\t\\t\\tattributes.remove( attribute );\\r\\n\\t\\t\\twireframeAttributes.delete( buffergeometry );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\tinfo.memory.geometries --;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction get( object, geometry ) {\\r\\n\\r\\n\\t\\tvar buffergeometry = geometries.get( geometry );\\r\\n\\r\\n\\t\\tif ( buffergeometry ) return buffergeometry;\\r\\n\\r\\n\\t\\tgeometry.addEventListener( 'dispose', onGeometryDispose );\\r\\n\\r\\n\\t\\tif ( geometry.isBufferGeometry ) {\\r\\n\\r\\n\\t\\t\\tbuffergeometry = geometry;\\r\\n\\r\\n\\t\\t} else if ( geometry.isGeometry ) {\\r\\n\\r\\n\\t\\t\\tif ( geometry._bufferGeometry === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tgeometry._bufferGeometry = new BufferGeometry().setFromObject( object );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tbuffergeometry = geometry._bufferGeometry;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tgeometries.set( geometry, buffergeometry );\\r\\n\\r\\n\\t\\tinfo.memory.geometries ++;\\r\\n\\r\\n\\t\\treturn buffergeometry;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction update( geometry ) {\\r\\n\\r\\n\\t\\tvar index = geometry.index;\\r\\n\\t\\tvar geometryAttributes = geometry.attributes;\\r\\n\\r\\n\\t\\tif ( index !== null ) {\\r\\n\\r\\n\\t\\t\\tattributes.update( index, 34963 );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfor ( var name in geometryAttributes ) {\\r\\n\\r\\n\\t\\t\\tattributes.update( geometryAttributes[ name ], 34962 );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// morph targets\\r\\n\\r\\n\\t\\tvar morphAttributes = geometry.morphAttributes;\\r\\n\\r\\n\\t\\tfor ( var name in morphAttributes ) {\\r\\n\\r\\n\\t\\t\\tvar array = morphAttributes[ name ];\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = array.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tattributes.update( array[ i ], 34962 );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction updateWireframeAttribute( geometry ) {\\r\\n\\r\\n\\t\\tvar indices = [];\\r\\n\\r\\n\\t\\tvar geometryIndex = geometry.index;\\r\\n\\t\\tvar geometryPosition = geometry.attributes.position;\\r\\n\\t\\tvar version = 0;\\r\\n\\r\\n\\t\\tif ( geometryIndex !== null ) {\\r\\n\\r\\n\\t\\t\\tvar array = geometryIndex.array;\\r\\n\\t\\t\\tversion = geometryIndex.version;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\\r\\n\\r\\n\\t\\t\\t\\tvar a = array[ i + 0 ];\\r\\n\\t\\t\\t\\tvar b = array[ i + 1 ];\\r\\n\\t\\t\\t\\tvar c = array[ i + 2 ];\\r\\n\\r\\n\\t\\t\\t\\tindices.push( a, b, b, c, c, a );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tvar array = geometryPosition.array;\\r\\n\\t\\t\\tversion = geometryPosition.version;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {\\r\\n\\r\\n\\t\\t\\t\\tvar a = i + 0;\\r\\n\\t\\t\\t\\tvar b = i + 1;\\r\\n\\t\\t\\t\\tvar c = i + 2;\\r\\n\\r\\n\\t\\t\\t\\tindices.push( a, b, b, c, c, a );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar attribute = new ( arrayMax( indices ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );\\r\\n\\t\\tattribute.version = version;\\r\\n\\r\\n\\t\\tattributes.update( attribute, 34963 );\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\tvar previousAttribute = wireframeAttributes.get( geometry );\\r\\n\\r\\n\\t\\tif ( previousAttribute ) attributes.remove( previousAttribute );\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\twireframeAttributes.set( geometry, attribute );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction getWireframeAttribute( geometry ) {\\r\\n\\r\\n\\t\\tvar currentAttribute = wireframeAttributes.get( geometry );\\r\\n\\r\\n\\t\\tif ( currentAttribute ) {\\r\\n\\r\\n\\t\\t\\tvar geometryIndex = geometry.index;\\r\\n\\r\\n\\t\\t\\tif ( geometryIndex !== null ) {\\r\\n\\r\\n\\t\\t\\t\\t// if the attribute is obsolete, create a new one\\r\\n\\r\\n\\t\\t\\t\\tif ( currentAttribute.version < geometryIndex.version ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tupdateWireframeAttribute( geometry );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tupdateWireframeAttribute( geometry );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn wireframeAttributes.get( geometry );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn {\\r\\n\\r\\n\\t\\tget: get,\\r\\n\\t\\tupdate: update,\\r\\n\\r\\n\\t\\tgetWireframeAttribute: getWireframeAttribute\\r\\n\\r\\n\\t};\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nfunction WebGLIndexedBufferRenderer( gl, extensions, info, capabilities ) {\\r\\n\\r\\n\\tvar isWebGL2 = capabilities.isWebGL2;\\r\\n\\r\\n\\tvar mode;\\r\\n\\r\\n\\tfunction setMode( value ) {\\r\\n\\r\\n\\t\\tmode = value;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tvar type, bytesPerElement;\\r\\n\\r\\n\\tfunction setIndex( value ) {\\r\\n\\r\\n\\t\\ttype = value.type;\\r\\n\\t\\tbytesPerElement = value.bytesPerElement;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction render( start, count ) {\\r\\n\\r\\n\\t\\tgl.drawElements( mode, count, type, start * bytesPerElement );\\r\\n\\r\\n\\t\\tinfo.update( count, mode );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction renderInstances( geometry, start, count, primcount ) {\\r\\n\\r\\n\\t\\tif ( primcount === 0 ) return;\\r\\n\\r\\n\\t\\tvar extension, methodName;\\r\\n\\r\\n\\t\\tif ( isWebGL2 ) {\\r\\n\\r\\n\\t\\t\\textension = gl;\\r\\n\\t\\t\\tmethodName = 'drawElementsInstanced';\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\textension = extensions.get( 'ANGLE_instanced_arrays' );\\r\\n\\t\\t\\tmethodName = 'drawElementsInstancedANGLE';\\r\\n\\r\\n\\t\\t\\tif ( extension === null ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\\r\\n\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\textension[ methodName ]( mode, count, type, start * bytesPerElement, primcount );\\r\\n\\r\\n\\t\\tinfo.update( count, mode, primcount );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tthis.setMode = setMode;\\r\\n\\tthis.setIndex = setIndex;\\r\\n\\tthis.render = render;\\r\\n\\tthis.renderInstances = renderInstances;\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * @author Mugen87 / https://github.com/Mugen87\\r\\n */\\r\\n\\r\\nfunction WebGLInfo( gl ) {\\r\\n\\r\\n\\tvar memory = {\\r\\n\\t\\tgeometries: 0,\\r\\n\\t\\ttextures: 0\\r\\n\\t};\\r\\n\\r\\n\\tvar render = {\\r\\n\\t\\tframe: 0,\\r\\n\\t\\tcalls: 0,\\r\\n\\t\\ttriangles: 0,\\r\\n\\t\\tpoints: 0,\\r\\n\\t\\tlines: 0\\r\\n\\t};\\r\\n\\r\\n\\tfunction update( count, mode, instanceCount ) {\\r\\n\\r\\n\\t\\tinstanceCount = instanceCount || 1;\\r\\n\\r\\n\\t\\trender.calls ++;\\r\\n\\r\\n\\t\\tswitch ( mode ) {\\r\\n\\r\\n\\t\\t\\tcase 4:\\r\\n\\t\\t\\t\\trender.triangles += instanceCount * ( count / 3 );\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tcase 1:\\r\\n\\t\\t\\t\\trender.lines += instanceCount * ( count / 2 );\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tcase 3:\\r\\n\\t\\t\\t\\trender.lines += instanceCount * ( count - 1 );\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tcase 2:\\r\\n\\t\\t\\t\\trender.lines += instanceCount * count;\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tcase 0:\\r\\n\\t\\t\\t\\trender.points += instanceCount * count;\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tdefault:\\r\\n\\t\\t\\t\\tconsole.error( 'THREE.WebGLInfo: Unknown draw mode:', mode );\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction reset() {\\r\\n\\r\\n\\t\\trender.frame ++;\\r\\n\\t\\trender.calls = 0;\\r\\n\\t\\trender.triangles = 0;\\r\\n\\t\\trender.points = 0;\\r\\n\\t\\trender.lines = 0;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn {\\r\\n\\t\\tmemory: memory,\\r\\n\\t\\trender: render,\\r\\n\\t\\tprograms: null,\\r\\n\\t\\tautoReset: true,\\r\\n\\t\\treset: reset,\\r\\n\\t\\tupdate: update\\r\\n\\t};\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nfunction absNumericalSort( a, b ) {\\r\\n\\r\\n\\treturn Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );\\r\\n\\r\\n}\\r\\n\\r\\nfunction WebGLMorphtargets( gl ) {\\r\\n\\r\\n\\tvar influencesList = {};\\r\\n\\tvar morphInfluences = new Float32Array( 8 );\\r\\n\\r\\n\\tfunction update( object, geometry, material, program ) {\\r\\n\\r\\n\\t\\tvar objectInfluences = object.morphTargetInfluences;\\r\\n\\r\\n\\t\\t// When object doesn't have morph target influences defined, we treat it as a 0-length array\\r\\n\\t\\t// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences\\r\\n\\r\\n\\t\\tvar length = objectInfluences === undefined ? 0 : objectInfluences.length;\\r\\n\\r\\n\\t\\tvar influences = influencesList[ geometry.id ];\\r\\n\\r\\n\\t\\tif ( influences === undefined ) {\\r\\n\\r\\n\\t\\t\\t// initialise list\\r\\n\\r\\n\\t\\t\\tinfluences = [];\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tinfluences[ i ] = [ i, 0 ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tinfluencesList[ geometry.id ] = influences;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar morphTargets = material.morphTargets && geometry.morphAttributes.position;\\r\\n\\t\\tvar morphNormals = material.morphNormals && geometry.morphAttributes.normal;\\r\\n\\r\\n\\t\\t// Remove current morphAttributes\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < length; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar influence = influences[ i ];\\r\\n\\r\\n\\t\\t\\tif ( influence[ 1 ] !== 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( morphTargets ) geometry.deleteAttribute( 'morphTarget' + i );\\r\\n\\t\\t\\t\\tif ( morphNormals ) geometry.deleteAttribute( 'morphNormal' + i );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Collect influences\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < length; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar influence = influences[ i ];\\r\\n\\r\\n\\t\\t\\tinfluence[ 0 ] = i;\\r\\n\\t\\t\\tinfluence[ 1 ] = objectInfluences[ i ];\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tinfluences.sort( absNumericalSort );\\r\\n\\r\\n\\t\\t// Add morphAttributes\\r\\n\\r\\n\\t\\tvar morphInfluencesSum = 0;\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < 8; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar influence = influences[ i ];\\r\\n\\r\\n\\t\\t\\tif ( influence ) {\\r\\n\\r\\n\\t\\t\\t\\tvar index = influence[ 0 ];\\r\\n\\t\\t\\t\\tvar value = influence[ 1 ];\\r\\n\\r\\n\\t\\t\\t\\tif ( value ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( morphTargets ) geometry.setAttribute( 'morphTarget' + i, morphTargets[ index ] );\\r\\n\\t\\t\\t\\t\\tif ( morphNormals ) geometry.setAttribute( 'morphNormal' + i, morphNormals[ index ] );\\r\\n\\r\\n\\t\\t\\t\\t\\tmorphInfluences[ i ] = value;\\r\\n\\t\\t\\t\\t\\tmorphInfluencesSum += value;\\r\\n\\t\\t\\t\\t\\tcontinue;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tmorphInfluences[ i ] = 0;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// GLSL shader uses formula baseinfluence * base + sum(target * influence)\\r\\n\\t\\t// This allows us to switch between absolute morphs and relative morphs without changing shader code\\r\\n\\t\\t// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)\\r\\n\\t\\tvar morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;\\r\\n\\r\\n\\t\\tprogram.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );\\r\\n\\t\\tprogram.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn {\\r\\n\\r\\n\\t\\tupdate: update\\r\\n\\r\\n\\t};\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nfunction WebGLObjects( gl, geometries, attributes, info ) {\\r\\n\\r\\n\\tvar updateMap = new WeakMap();\\r\\n\\r\\n\\tfunction update( object ) {\\r\\n\\r\\n\\t\\tvar frame = info.render.frame;\\r\\n\\r\\n\\t\\tvar geometry = object.geometry;\\r\\n\\t\\tvar buffergeometry = geometries.get( object, geometry );\\r\\n\\r\\n\\t\\t// Update once per frame\\r\\n\\r\\n\\t\\tif ( updateMap.get( buffergeometry ) !== frame ) {\\r\\n\\r\\n\\t\\t\\tif ( geometry.isGeometry ) {\\r\\n\\r\\n\\t\\t\\t\\tbuffergeometry.updateFromObject( object );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tgeometries.update( buffergeometry );\\r\\n\\r\\n\\t\\t\\tupdateMap.set( buffergeometry, frame );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( object.isInstancedMesh ) {\\r\\n\\r\\n\\t\\t\\tattributes.update( object.instanceMatrix, 34962 );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn buffergeometry;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction dispose() {\\r\\n\\r\\n\\t\\tupdateMap = new WeakMap();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn {\\r\\n\\r\\n\\t\\tupdate: update,\\r\\n\\t\\tdispose: dispose\\r\\n\\r\\n\\t};\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nfunction CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\\r\\n\\r\\n\\timages = images !== undefined ? images : [];\\r\\n\\tmapping = mapping !== undefined ? mapping : CubeReflectionMapping;\\r\\n\\tformat = format !== undefined ? format : RGBFormat;\\r\\n\\r\\n\\tTexture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\\r\\n\\r\\n\\tthis.flipY = false;\\r\\n\\r\\n}\\r\\n\\r\\nCubeTexture.prototype = Object.create( Texture.prototype );\\r\\nCubeTexture.prototype.constructor = CubeTexture;\\r\\n\\r\\nCubeTexture.prototype.isCubeTexture = true;\\r\\n\\r\\nObject.defineProperty( CubeTexture.prototype, 'images', {\\r\\n\\r\\n\\tget: function () {\\r\\n\\r\\n\\t\\treturn this.image;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tset: function ( value ) {\\r\\n\\r\\n\\t\\tthis.image = value;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author Takahiro https://github.com/takahirox\\r\\n */\\r\\n\\r\\nfunction DataTexture2DArray( data, width, height, depth ) {\\r\\n\\r\\n\\tTexture.call( this, null );\\r\\n\\r\\n\\tthis.image = { data: data || null, width: width || 1, height: height || 1, depth: depth || 1 };\\r\\n\\r\\n\\tthis.magFilter = NearestFilter;\\r\\n\\tthis.minFilter = NearestFilter;\\r\\n\\r\\n\\tthis.wrapR = ClampToEdgeWrapping;\\r\\n\\r\\n\\tthis.generateMipmaps = false;\\r\\n\\tthis.flipY = false;\\r\\n\\r\\n\\tthis.needsUpdate = true;\\r\\n\\r\\n}\\r\\n\\r\\nDataTexture2DArray.prototype = Object.create( Texture.prototype );\\r\\nDataTexture2DArray.prototype.constructor = DataTexture2DArray;\\r\\nDataTexture2DArray.prototype.isDataTexture2DArray = true;\\r\\n\\r\\n/**\\r\\n * @author Artur Trzesiok\\r\\n */\\r\\n\\r\\nfunction DataTexture3D( data, width, height, depth ) {\\r\\n\\r\\n\\t// We're going to add .setXXX() methods for setting properties later.\\r\\n\\t// Users can still set in DataTexture3D directly.\\r\\n\\t//\\r\\n\\t//\\tvar texture = new THREE.DataTexture3D( data, width, height, depth );\\r\\n\\t// \\ttexture.anisotropy = 16;\\r\\n\\t//\\r\\n\\t// See #14839\\r\\n\\r\\n\\tTexture.call( this, null );\\r\\n\\r\\n\\tthis.image = { data: data || null, width: width || 1, height: height || 1, depth: depth || 1 };\\r\\n\\r\\n\\tthis.magFilter = NearestFilter;\\r\\n\\tthis.minFilter = NearestFilter;\\r\\n\\r\\n\\tthis.wrapR = ClampToEdgeWrapping;\\r\\n\\r\\n\\tthis.generateMipmaps = false;\\r\\n\\tthis.flipY = false;\\r\\n\\r\\n\\tthis.needsUpdate = true;\\r\\n\\r\\n\\r\\n}\\r\\n\\r\\nDataTexture3D.prototype = Object.create( Texture.prototype );\\r\\nDataTexture3D.prototype.constructor = DataTexture3D;\\r\\nDataTexture3D.prototype.isDataTexture3D = true;\\r\\n\\r\\n/**\\r\\n * @author tschw\\r\\n * @author Mugen87 / https://github.com/Mugen87\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n *\\r\\n * Uniforms of a program.\\r\\n * Those form a tree structure with a special top-level container for the root,\\r\\n * which you get by calling 'new WebGLUniforms( gl, program )'.\\r\\n *\\r\\n *\\r\\n * Properties of inner nodes including the top-level container:\\r\\n *\\r\\n * .seq - array of nested uniforms\\r\\n * .map - nested uniforms by name\\r\\n *\\r\\n *\\r\\n * Methods of all nodes except the top-level container:\\r\\n *\\r\\n * .setValue( gl, value, [textures] )\\r\\n *\\r\\n * \\t\\tuploads a uniform value(s)\\r\\n *  \\tthe 'textures' parameter is needed for sampler uniforms\\r\\n *\\r\\n *\\r\\n * Static methods of the top-level container (textures factorizations):\\r\\n *\\r\\n * .upload( gl, seq, values, textures )\\r\\n *\\r\\n * \\t\\tsets uniforms in 'seq' to 'values[id].value'\\r\\n *\\r\\n * .seqWithValue( seq, values ) : filteredSeq\\r\\n *\\r\\n * \\t\\tfilters 'seq' entries with corresponding entry in values\\r\\n *\\r\\n *\\r\\n * Methods of the top-level container (textures factorizations):\\r\\n *\\r\\n * .setValue( gl, name, value, textures )\\r\\n *\\r\\n * \\t\\tsets uniform with  name 'name' to 'value'\\r\\n *\\r\\n * .setOptional( gl, obj, prop )\\r\\n *\\r\\n * \\t\\tlike .set for an optional property of the object\\r\\n *\\r\\n */\\r\\n\\r\\nvar emptyTexture = new Texture();\\r\\nvar emptyTexture2dArray = new DataTexture2DArray();\\r\\nvar emptyTexture3d = new DataTexture3D();\\r\\nvar emptyCubeTexture = new CubeTexture();\\r\\n\\r\\n// --- Utilities ---\\r\\n\\r\\n// Array Caches (provide typed arrays for temporary by size)\\r\\n\\r\\nvar arrayCacheF32 = [];\\r\\nvar arrayCacheI32 = [];\\r\\n\\r\\n// Float32Array caches used for uploading Matrix uniforms\\r\\n\\r\\nvar mat4array = new Float32Array( 16 );\\r\\nvar mat3array = new Float32Array( 9 );\\r\\nvar mat2array = new Float32Array( 4 );\\r\\n\\r\\n// Flattening for arrays of vectors and matrices\\r\\n\\r\\nfunction flatten( array, nBlocks, blockSize ) {\\r\\n\\r\\n\\tvar firstElem = array[ 0 ];\\r\\n\\r\\n\\tif ( firstElem <= 0 || firstElem > 0 ) return array;\\r\\n\\t// unoptimized: ! isNaN( firstElem )\\r\\n\\t// see http://jacksondunstan.com/articles/983\\r\\n\\r\\n\\tvar n = nBlocks * blockSize,\\r\\n\\t\\tr = arrayCacheF32[ n ];\\r\\n\\r\\n\\tif ( r === undefined ) {\\r\\n\\r\\n\\t\\tr = new Float32Array( n );\\r\\n\\t\\tarrayCacheF32[ n ] = r;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tif ( nBlocks !== 0 ) {\\r\\n\\r\\n\\t\\tfirstElem.toArray( r, 0 );\\r\\n\\r\\n\\t\\tfor ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {\\r\\n\\r\\n\\t\\t\\toffset += blockSize;\\r\\n\\t\\t\\tarray[ i ].toArray( r, offset );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn r;\\r\\n\\r\\n}\\r\\n\\r\\nfunction arraysEqual( a, b ) {\\r\\n\\r\\n\\tif ( a.length !== b.length ) return false;\\r\\n\\r\\n\\tfor ( var i = 0, l = a.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\tif ( a[ i ] !== b[ i ] ) return false;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn true;\\r\\n\\r\\n}\\r\\n\\r\\nfunction copyArray( a, b ) {\\r\\n\\r\\n\\tfor ( var i = 0, l = b.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\ta[ i ] = b[ i ];\\r\\n\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\\r\\n// Texture unit allocation\\r\\n\\r\\nfunction allocTexUnits( textures, n ) {\\r\\n\\r\\n\\tvar r = arrayCacheI32[ n ];\\r\\n\\r\\n\\tif ( r === undefined ) {\\r\\n\\r\\n\\t\\tr = new Int32Array( n );\\r\\n\\t\\tarrayCacheI32[ n ] = r;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfor ( var i = 0; i !== n; ++ i )\\r\\n\\t\\tr[ i ] = textures.allocateTextureUnit();\\r\\n\\r\\n\\treturn r;\\r\\n\\r\\n}\\r\\n\\r\\n// --- Setters ---\\r\\n\\r\\n// Note: Defining these methods externally, because they come in a bunch\\r\\n// and this way their names minify.\\r\\n\\r\\n// Single scalar\\r\\n\\r\\nfunction setValueV1f( gl, v ) {\\r\\n\\r\\n\\tvar cache = this.cache;\\r\\n\\r\\n\\tif ( cache[ 0 ] === v ) return;\\r\\n\\r\\n\\tgl.uniform1f( this.addr, v );\\r\\n\\r\\n\\tcache[ 0 ] = v;\\r\\n\\r\\n}\\r\\n\\r\\n// Single float vector (from flat array or THREE.VectorN)\\r\\n\\r\\nfunction setValueV2f( gl, v ) {\\r\\n\\r\\n\\tvar cache = this.cache;\\r\\n\\r\\n\\tif ( v.x !== undefined ) {\\r\\n\\r\\n\\t\\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {\\r\\n\\r\\n\\t\\t\\tgl.uniform2f( this.addr, v.x, v.y );\\r\\n\\r\\n\\t\\t\\tcache[ 0 ] = v.x;\\r\\n\\t\\t\\tcache[ 1 ] = v.y;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} else {\\r\\n\\r\\n\\t\\tif ( arraysEqual( cache, v ) ) return;\\r\\n\\r\\n\\t\\tgl.uniform2fv( this.addr, v );\\r\\n\\r\\n\\t\\tcopyArray( cache, v );\\r\\n\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\\r\\nfunction setValueV3f( gl, v ) {\\r\\n\\r\\n\\tvar cache = this.cache;\\r\\n\\r\\n\\tif ( v.x !== undefined ) {\\r\\n\\r\\n\\t\\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {\\r\\n\\r\\n\\t\\t\\tgl.uniform3f( this.addr, v.x, v.y, v.z );\\r\\n\\r\\n\\t\\t\\tcache[ 0 ] = v.x;\\r\\n\\t\\t\\tcache[ 1 ] = v.y;\\r\\n\\t\\t\\tcache[ 2 ] = v.z;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} else if ( v.r !== undefined ) {\\r\\n\\r\\n\\t\\tif ( cache[ 0 ] !== v.r || cache[ 1 ] !== v.g || cache[ 2 ] !== v.b ) {\\r\\n\\r\\n\\t\\t\\tgl.uniform3f( this.addr, v.r, v.g, v.b );\\r\\n\\r\\n\\t\\t\\tcache[ 0 ] = v.r;\\r\\n\\t\\t\\tcache[ 1 ] = v.g;\\r\\n\\t\\t\\tcache[ 2 ] = v.b;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} else {\\r\\n\\r\\n\\t\\tif ( arraysEqual( cache, v ) ) return;\\r\\n\\r\\n\\t\\tgl.uniform3fv( this.addr, v );\\r\\n\\r\\n\\t\\tcopyArray( cache, v );\\r\\n\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\\r\\nfunction setValueV4f( gl, v ) {\\r\\n\\r\\n\\tvar cache = this.cache;\\r\\n\\r\\n\\tif ( v.x !== undefined ) {\\r\\n\\r\\n\\t\\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {\\r\\n\\r\\n\\t\\t\\tgl.uniform4f( this.addr, v.x, v.y, v.z, v.w );\\r\\n\\r\\n\\t\\t\\tcache[ 0 ] = v.x;\\r\\n\\t\\t\\tcache[ 1 ] = v.y;\\r\\n\\t\\t\\tcache[ 2 ] = v.z;\\r\\n\\t\\t\\tcache[ 3 ] = v.w;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} else {\\r\\n\\r\\n\\t\\tif ( arraysEqual( cache, v ) ) return;\\r\\n\\r\\n\\t\\tgl.uniform4fv( this.addr, v );\\r\\n\\r\\n\\t\\tcopyArray( cache, v );\\r\\n\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\\r\\n// Single matrix (from flat array or MatrixN)\\r\\n\\r\\nfunction setValueM2( gl, v ) {\\r\\n\\r\\n\\tvar cache = this.cache;\\r\\n\\tvar elements = v.elements;\\r\\n\\r\\n\\tif ( elements === undefined ) {\\r\\n\\r\\n\\t\\tif ( arraysEqual( cache, v ) ) return;\\r\\n\\r\\n\\t\\tgl.uniformMatrix2fv( this.addr, false, v );\\r\\n\\r\\n\\t\\tcopyArray( cache, v );\\r\\n\\r\\n\\t} else {\\r\\n\\r\\n\\t\\tif ( arraysEqual( cache, elements ) ) return;\\r\\n\\r\\n\\t\\tmat2array.set( elements );\\r\\n\\r\\n\\t\\tgl.uniformMatrix2fv( this.addr, false, mat2array );\\r\\n\\r\\n\\t\\tcopyArray( cache, elements );\\r\\n\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\\r\\nfunction setValueM3( gl, v ) {\\r\\n\\r\\n\\tvar cache = this.cache;\\r\\n\\tvar elements = v.elements;\\r\\n\\r\\n\\tif ( elements === undefined ) {\\r\\n\\r\\n\\t\\tif ( arraysEqual( cache, v ) ) return;\\r\\n\\r\\n\\t\\tgl.uniformMatrix3fv( this.addr, false, v );\\r\\n\\r\\n\\t\\tcopyArray( cache, v );\\r\\n\\r\\n\\t} else {\\r\\n\\r\\n\\t\\tif ( arraysEqual( cache, elements ) ) return;\\r\\n\\r\\n\\t\\tmat3array.set( elements );\\r\\n\\r\\n\\t\\tgl.uniformMatrix3fv( this.addr, false, mat3array );\\r\\n\\r\\n\\t\\tcopyArray( cache, elements );\\r\\n\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\\r\\nfunction setValueM4( gl, v ) {\\r\\n\\r\\n\\tvar cache = this.cache;\\r\\n\\tvar elements = v.elements;\\r\\n\\r\\n\\tif ( elements === undefined ) {\\r\\n\\r\\n\\t\\tif ( arraysEqual( cache, v ) ) return;\\r\\n\\r\\n\\t\\tgl.uniformMatrix4fv( this.addr, false, v );\\r\\n\\r\\n\\t\\tcopyArray( cache, v );\\r\\n\\r\\n\\t} else {\\r\\n\\r\\n\\t\\tif ( arraysEqual( cache, elements ) ) return;\\r\\n\\r\\n\\t\\tmat4array.set( elements );\\r\\n\\r\\n\\t\\tgl.uniformMatrix4fv( this.addr, false, mat4array );\\r\\n\\r\\n\\t\\tcopyArray( cache, elements );\\r\\n\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\\r\\n// Single texture (2D / Cube)\\r\\n\\r\\nfunction setValueT1( gl, v, textures ) {\\r\\n\\r\\n\\tvar cache = this.cache;\\r\\n\\tvar unit = textures.allocateTextureUnit();\\r\\n\\r\\n\\tif ( cache[ 0 ] !== unit ) {\\r\\n\\r\\n\\t\\tgl.uniform1i( this.addr, unit );\\r\\n\\t\\tcache[ 0 ] = unit;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\ttextures.safeSetTexture2D( v || emptyTexture, unit );\\r\\n\\r\\n}\\r\\n\\r\\nfunction setValueT2DArray1( gl, v, textures ) {\\r\\n\\r\\n\\tvar cache = this.cache;\\r\\n\\tvar unit = textures.allocateTextureUnit();\\r\\n\\r\\n\\tif ( cache[ 0 ] !== unit ) {\\r\\n\\r\\n\\t\\tgl.uniform1i( this.addr, unit );\\r\\n\\t\\tcache[ 0 ] = unit;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\ttextures.setTexture2DArray( v || emptyTexture2dArray, unit );\\r\\n\\r\\n}\\r\\n\\r\\nfunction setValueT3D1( gl, v, textures ) {\\r\\n\\r\\n\\tvar cache = this.cache;\\r\\n\\tvar unit = textures.allocateTextureUnit();\\r\\n\\r\\n\\tif ( cache[ 0 ] !== unit ) {\\r\\n\\r\\n\\t\\tgl.uniform1i( this.addr, unit );\\r\\n\\t\\tcache[ 0 ] = unit;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\ttextures.setTexture3D( v || emptyTexture3d, unit );\\r\\n\\r\\n}\\r\\n\\r\\nfunction setValueT6( gl, v, textures ) {\\r\\n\\r\\n\\tvar cache = this.cache;\\r\\n\\tvar unit = textures.allocateTextureUnit();\\r\\n\\r\\n\\tif ( cache[ 0 ] !== unit ) {\\r\\n\\r\\n\\t\\tgl.uniform1i( this.addr, unit );\\r\\n\\t\\tcache[ 0 ] = unit;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\ttextures.safeSetTextureCube( v || emptyCubeTexture, unit );\\r\\n\\r\\n}\\r\\n\\r\\n// Integer / Boolean vectors or arrays thereof (always flat arrays)\\r\\n\\r\\nfunction setValueV1i( gl, v ) {\\r\\n\\r\\n\\tvar cache = this.cache;\\r\\n\\r\\n\\tif ( cache[ 0 ] === v ) return;\\r\\n\\r\\n\\tgl.uniform1i( this.addr, v );\\r\\n\\r\\n\\tcache[ 0 ] = v;\\r\\n\\r\\n}\\r\\n\\r\\nfunction setValueV2i( gl, v ) {\\r\\n\\r\\n\\tvar cache = this.cache;\\r\\n\\r\\n\\tif ( arraysEqual( cache, v ) ) return;\\r\\n\\r\\n\\tgl.uniform2iv( this.addr, v );\\r\\n\\r\\n\\tcopyArray( cache, v );\\r\\n\\r\\n}\\r\\n\\r\\nfunction setValueV3i( gl, v ) {\\r\\n\\r\\n\\tvar cache = this.cache;\\r\\n\\r\\n\\tif ( arraysEqual( cache, v ) ) return;\\r\\n\\r\\n\\tgl.uniform3iv( this.addr, v );\\r\\n\\r\\n\\tcopyArray( cache, v );\\r\\n\\r\\n}\\r\\n\\r\\nfunction setValueV4i( gl, v ) {\\r\\n\\r\\n\\tvar cache = this.cache;\\r\\n\\r\\n\\tif ( arraysEqual( cache, v ) ) return;\\r\\n\\r\\n\\tgl.uniform4iv( this.addr, v );\\r\\n\\r\\n\\tcopyArray( cache, v );\\r\\n\\r\\n}\\r\\n\\r\\n// uint\\r\\n\\r\\nfunction setValueV1ui( gl, v ) {\\r\\n\\r\\n\\tvar cache = this.cache;\\r\\n\\r\\n\\tif ( cache[ 0 ] === v ) return;\\r\\n\\r\\n\\tgl.uniform1ui( this.addr, v );\\r\\n\\r\\n\\tcache[ 0 ] = v;\\r\\n\\r\\n}\\r\\n\\r\\n// Helper to pick the right setter for the singular case\\r\\n\\r\\nfunction getSingularSetter( type ) {\\r\\n\\r\\n\\tswitch ( type ) {\\r\\n\\r\\n\\t\\tcase 0x1406: return setValueV1f; // FLOAT\\r\\n\\t\\tcase 0x8b50: return setValueV2f; // _VEC2\\r\\n\\t\\tcase 0x8b51: return setValueV3f; // _VEC3\\r\\n\\t\\tcase 0x8b52: return setValueV4f; // _VEC4\\r\\n\\r\\n\\t\\tcase 0x8b5a: return setValueM2; // _MAT2\\r\\n\\t\\tcase 0x8b5b: return setValueM3; // _MAT3\\r\\n\\t\\tcase 0x8b5c: return setValueM4; // _MAT4\\r\\n\\r\\n\\t\\tcase 0x1404: case 0x8b56: return setValueV1i; // INT, BOOL\\r\\n\\t\\tcase 0x8b53: case 0x8b57: return setValueV2i; // _VEC2\\r\\n\\t\\tcase 0x8b54: case 0x8b58: return setValueV3i; // _VEC3\\r\\n\\t\\tcase 0x8b55: case 0x8b59: return setValueV4i; // _VEC4\\r\\n\\r\\n\\t\\tcase 0x1405: return setValueV1ui; // UINT\\r\\n\\r\\n\\t\\tcase 0x8b5e: // SAMPLER_2D\\r\\n\\t\\tcase 0x8d66: // SAMPLER_EXTERNAL_OES\\r\\n\\t\\tcase 0x8dca: // INT_SAMPLER_2D\\r\\n\\t\\tcase 0x8dd2: // UNSIGNED_INT_SAMPLER_2D\\r\\n\\t\\tcase 0x8b62: // SAMPLER_2D_SHADOW\\r\\n\\t\\t\\treturn setValueT1;\\r\\n\\r\\n\\t\\tcase 0x8b5f: // SAMPLER_3D\\r\\n\\t\\tcase 0x8dcb: // INT_SAMPLER_3D\\r\\n\\t\\tcase 0x8dd3: // UNSIGNED_INT_SAMPLER_3D\\r\\n\\t\\t\\treturn setValueT3D1;\\r\\n\\r\\n\\t\\tcase 0x8b60: // SAMPLER_CUBE\\r\\n\\t\\tcase 0x8dcc: // INT_SAMPLER_CUBE\\r\\n\\t\\tcase 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE\\r\\n\\t\\tcase 0x8dc5: // SAMPLER_CUBE_SHADOW\\r\\n\\t\\t\\treturn setValueT6;\\r\\n\\r\\n\\t\\tcase 0x8dc1: // SAMPLER_2D_ARRAY\\r\\n\\t\\tcase 0x8dcf: // INT_SAMPLER_2D_ARRAY\\r\\n\\t\\tcase 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY\\r\\n\\t\\tcase 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW\\r\\n\\t\\t\\treturn setValueT2DArray1;\\r\\n\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\\r\\n// Array of scalars\\r\\nfunction setValueV1fArray( gl, v ) {\\r\\n\\r\\n\\tgl.uniform1fv( this.addr, v );\\r\\n\\r\\n}\\r\\n\\r\\n// Integer / Boolean vectors or arrays thereof (always flat arrays)\\r\\nfunction setValueV1iArray( gl, v ) {\\r\\n\\r\\n\\tgl.uniform1iv( this.addr, v );\\r\\n\\r\\n}\\r\\n\\r\\nfunction setValueV2iArray( gl, v ) {\\r\\n\\r\\n\\tgl.uniform2iv( this.addr, v );\\r\\n\\r\\n}\\r\\n\\r\\nfunction setValueV3iArray( gl, v ) {\\r\\n\\r\\n\\tgl.uniform3iv( this.addr, v );\\r\\n\\r\\n}\\r\\n\\r\\nfunction setValueV4iArray( gl, v ) {\\r\\n\\r\\n\\tgl.uniform4iv( this.addr, v );\\r\\n\\r\\n}\\r\\n\\r\\n\\r\\n// Array of vectors (flat or from THREE classes)\\r\\n\\r\\nfunction setValueV2fArray( gl, v ) {\\r\\n\\r\\n\\tvar data = flatten( v, this.size, 2 );\\r\\n\\r\\n\\tgl.uniform2fv( this.addr, data );\\r\\n\\r\\n}\\r\\n\\r\\nfunction setValueV3fArray( gl, v ) {\\r\\n\\r\\n\\tvar data = flatten( v, this.size, 3 );\\r\\n\\r\\n\\tgl.uniform3fv( this.addr, data );\\r\\n\\r\\n}\\r\\n\\r\\nfunction setValueV4fArray( gl, v ) {\\r\\n\\r\\n\\tvar data = flatten( v, this.size, 4 );\\r\\n\\r\\n\\tgl.uniform4fv( this.addr, data );\\r\\n\\r\\n}\\r\\n\\r\\n// Array of matrices (flat or from THREE clases)\\r\\n\\r\\nfunction setValueM2Array( gl, v ) {\\r\\n\\r\\n\\tvar data = flatten( v, this.size, 4 );\\r\\n\\r\\n\\tgl.uniformMatrix2fv( this.addr, false, data );\\r\\n\\r\\n}\\r\\n\\r\\nfunction setValueM3Array( gl, v ) {\\r\\n\\r\\n\\tvar data = flatten( v, this.size, 9 );\\r\\n\\r\\n\\tgl.uniformMatrix3fv( this.addr, false, data );\\r\\n\\r\\n}\\r\\n\\r\\nfunction setValueM4Array( gl, v ) {\\r\\n\\r\\n\\tvar data = flatten( v, this.size, 16 );\\r\\n\\r\\n\\tgl.uniformMatrix4fv( this.addr, false, data );\\r\\n\\r\\n}\\r\\n\\r\\n// Array of textures (2D / Cube)\\r\\n\\r\\nfunction setValueT1Array( gl, v, textures ) {\\r\\n\\r\\n\\tvar n = v.length;\\r\\n\\r\\n\\tvar units = allocTexUnits( textures, n );\\r\\n\\r\\n\\tgl.uniform1iv( this.addr, units );\\r\\n\\r\\n\\tfor ( var i = 0; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\ttextures.safeSetTexture2D( v[ i ] || emptyTexture, units[ i ] );\\r\\n\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\\r\\nfunction setValueT6Array( gl, v, textures ) {\\r\\n\\r\\n\\tvar n = v.length;\\r\\n\\r\\n\\tvar units = allocTexUnits( textures, n );\\r\\n\\r\\n\\tgl.uniform1iv( this.addr, units );\\r\\n\\r\\n\\tfor ( var i = 0; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\ttextures.safeSetTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );\\r\\n\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\\r\\n// Helper to pick the right setter for a pure (bottom-level) array\\r\\n\\r\\nfunction getPureArraySetter( type ) {\\r\\n\\r\\n\\tswitch ( type ) {\\r\\n\\r\\n\\t\\tcase 0x1406: return setValueV1fArray; // FLOAT\\r\\n\\t\\tcase 0x8b50: return setValueV2fArray; // _VEC2\\r\\n\\t\\tcase 0x8b51: return setValueV3fArray; // _VEC3\\r\\n\\t\\tcase 0x8b52: return setValueV4fArray; // _VEC4\\r\\n\\r\\n\\t\\tcase 0x8b5a: return setValueM2Array; // _MAT2\\r\\n\\t\\tcase 0x8b5b: return setValueM3Array; // _MAT3\\r\\n\\t\\tcase 0x8b5c: return setValueM4Array; // _MAT4\\r\\n\\r\\n\\t\\tcase 0x1404: case 0x8b56: return setValueV1iArray; // INT, BOOL\\r\\n\\t\\tcase 0x8b53: case 0x8b57: return setValueV2iArray; // _VEC2\\r\\n\\t\\tcase 0x8b54: case 0x8b58: return setValueV3iArray; // _VEC3\\r\\n\\t\\tcase 0x8b55: case 0x8b59: return setValueV4iArray; // _VEC4\\r\\n\\r\\n\\t\\tcase 0x8b5e: // SAMPLER_2D\\r\\n\\t\\tcase 0x8d66: // SAMPLER_EXTERNAL_OES\\r\\n\\t\\tcase 0x8dca: // INT_SAMPLER_2D\\r\\n\\t\\tcase 0x8dd2: // UNSIGNED_INT_SAMPLER_2D\\r\\n\\t\\tcase 0x8b62: // SAMPLER_2D_SHADOW\\r\\n\\t\\t\\treturn setValueT1Array;\\r\\n\\r\\n\\t\\tcase 0x8b60: // SAMPLER_CUBE\\r\\n\\t\\tcase 0x8dcc: // INT_SAMPLER_CUBE\\r\\n\\t\\tcase 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE\\r\\n\\t\\tcase 0x8dc5: // SAMPLER_CUBE_SHADOW\\r\\n\\t\\t\\treturn setValueT6Array;\\r\\n\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\\r\\n// --- Uniform Classes ---\\r\\n\\r\\nfunction SingleUniform( id, activeInfo, addr ) {\\r\\n\\r\\n\\tthis.id = id;\\r\\n\\tthis.addr = addr;\\r\\n\\tthis.cache = [];\\r\\n\\tthis.setValue = getSingularSetter( activeInfo.type );\\r\\n\\r\\n\\t// this.path = activeInfo.name; // DEBUG\\r\\n\\r\\n}\\r\\n\\r\\nfunction PureArrayUniform( id, activeInfo, addr ) {\\r\\n\\r\\n\\tthis.id = id;\\r\\n\\tthis.addr = addr;\\r\\n\\tthis.cache = [];\\r\\n\\tthis.size = activeInfo.size;\\r\\n\\tthis.setValue = getPureArraySetter( activeInfo.type );\\r\\n\\r\\n\\t// this.path = activeInfo.name; // DEBUG\\r\\n\\r\\n}\\r\\n\\r\\nPureArrayUniform.prototype.updateCache = function ( data ) {\\r\\n\\r\\n\\tvar cache = this.cache;\\r\\n\\r\\n\\tif ( data instanceof Float32Array && cache.length !== data.length ) {\\r\\n\\r\\n\\t\\tthis.cache = new Float32Array( data.length );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tcopyArray( cache, data );\\r\\n\\r\\n};\\r\\n\\r\\nfunction StructuredUniform( id ) {\\r\\n\\r\\n\\tthis.id = id;\\r\\n\\r\\n\\tthis.seq = [];\\r\\n\\tthis.map = {};\\r\\n\\r\\n}\\r\\n\\r\\nStructuredUniform.prototype.setValue = function ( gl, value, textures ) {\\r\\n\\r\\n\\tvar seq = this.seq;\\r\\n\\r\\n\\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\tvar u = seq[ i ];\\r\\n\\t\\tu.setValue( gl, value[ u.id ], textures );\\r\\n\\r\\n\\t}\\r\\n\\r\\n};\\r\\n\\r\\n// --- Top-level ---\\r\\n\\r\\n// Parser - builds up the property tree from the path strings\\r\\n\\r\\nvar RePathPart = /([\\\\w\\\\d_]+)(\\\\])?(\\\\[|\\\\.)?/g;\\r\\n\\r\\n// extracts\\r\\n// \\t- the identifier (member name or array index)\\r\\n//  - followed by an optional right bracket (found when array index)\\r\\n//  - followed by an optional left bracket or dot (type of subscript)\\r\\n//\\r\\n// Note: These portions can be read in a non-overlapping fashion and\\r\\n// allow straightforward parsing of the hierarchy that WebGL encodes\\r\\n// in the uniform names.\\r\\n\\r\\nfunction addUniform( container, uniformObject ) {\\r\\n\\r\\n\\tcontainer.seq.push( uniformObject );\\r\\n\\tcontainer.map[ uniformObject.id ] = uniformObject;\\r\\n\\r\\n}\\r\\n\\r\\nfunction parseUniform( activeInfo, addr, container ) {\\r\\n\\r\\n\\tvar path = activeInfo.name,\\r\\n\\t\\tpathLength = path.length;\\r\\n\\r\\n\\t// reset RegExp object, because of the early exit of a previous run\\r\\n\\tRePathPart.lastIndex = 0;\\r\\n\\r\\n\\twhile ( true ) {\\r\\n\\r\\n\\t\\tvar match = RePathPart.exec( path ),\\r\\n\\t\\t\\tmatchEnd = RePathPart.lastIndex,\\r\\n\\r\\n\\t\\t\\tid = match[ 1 ],\\r\\n\\t\\t\\tidIsIndex = match[ 2 ] === ']',\\r\\n\\t\\t\\tsubscript = match[ 3 ];\\r\\n\\r\\n\\t\\tif ( idIsIndex ) id = id | 0; // convert to integer\\r\\n\\r\\n\\t\\tif ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {\\r\\n\\r\\n\\t\\t\\t// bare name or \\\"pure\\\" bottom-level array \\\"[0]\\\" suffix\\r\\n\\r\\n\\t\\t\\taddUniform( container, subscript === undefined ?\\r\\n\\t\\t\\t\\tnew SingleUniform( id, activeInfo, addr ) :\\r\\n\\t\\t\\t\\tnew PureArrayUniform( id, activeInfo, addr ) );\\r\\n\\r\\n\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t// step into inner node / create it in case it doesn't exist\\r\\n\\r\\n\\t\\t\\tvar map = container.map, next = map[ id ];\\r\\n\\r\\n\\t\\t\\tif ( next === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tnext = new StructuredUniform( id );\\r\\n\\t\\t\\t\\taddUniform( container, next );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tcontainer = next;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\\r\\n// Root Container\\r\\n\\r\\nfunction WebGLUniforms( gl, program ) {\\r\\n\\r\\n\\tthis.seq = [];\\r\\n\\tthis.map = {};\\r\\n\\r\\n\\tvar n = gl.getProgramParameter( program, 35718 );\\r\\n\\r\\n\\tfor ( var i = 0; i < n; ++ i ) {\\r\\n\\r\\n\\t\\tvar info = gl.getActiveUniform( program, i ),\\r\\n\\t\\t\\taddr = gl.getUniformLocation( program, info.name );\\r\\n\\r\\n\\t\\tparseUniform( info, addr, this );\\r\\n\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\\r\\nWebGLUniforms.prototype.setValue = function ( gl, name, value, textures ) {\\r\\n\\r\\n\\tvar u = this.map[ name ];\\r\\n\\r\\n\\tif ( u !== undefined ) u.setValue( gl, value, textures );\\r\\n\\r\\n};\\r\\n\\r\\nWebGLUniforms.prototype.setOptional = function ( gl, object, name ) {\\r\\n\\r\\n\\tvar v = object[ name ];\\r\\n\\r\\n\\tif ( v !== undefined ) this.setValue( gl, name, v );\\r\\n\\r\\n};\\r\\n\\r\\n\\r\\n// Static interface\\r\\n\\r\\nWebGLUniforms.upload = function ( gl, seq, values, textures ) {\\r\\n\\r\\n\\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\tvar u = seq[ i ],\\r\\n\\t\\t\\tv = values[ u.id ];\\r\\n\\r\\n\\t\\tif ( v.needsUpdate !== false ) {\\r\\n\\r\\n\\t\\t\\t// note: always updating when .needsUpdate is undefined\\r\\n\\t\\t\\tu.setValue( gl, v.value, textures );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n};\\r\\n\\r\\nWebGLUniforms.seqWithValue = function ( seq, values ) {\\r\\n\\r\\n\\tvar r = [];\\r\\n\\r\\n\\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\tvar u = seq[ i ];\\r\\n\\t\\tif ( u.id in values ) r.push( u );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn r;\\r\\n\\r\\n};\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nfunction WebGLShader( gl, type, string ) {\\r\\n\\r\\n\\tvar shader = gl.createShader( type );\\r\\n\\r\\n\\tgl.shaderSource( shader, string );\\r\\n\\tgl.compileShader( shader );\\r\\n\\r\\n\\treturn shader;\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nvar programIdCount = 0;\\r\\n\\r\\nfunction addLineNumbers( string ) {\\r\\n\\r\\n\\tvar lines = string.split( '\\\\n' );\\r\\n\\r\\n\\tfor ( var i = 0; i < lines.length; i ++ ) {\\r\\n\\r\\n\\t\\tlines[ i ] = ( i + 1 ) + ': ' + lines[ i ];\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn lines.join( '\\\\n' );\\r\\n\\r\\n}\\r\\n\\r\\nfunction getEncodingComponents( encoding ) {\\r\\n\\r\\n\\tswitch ( encoding ) {\\r\\n\\r\\n\\t\\tcase LinearEncoding:\\r\\n\\t\\t\\treturn [ 'Linear', '( value )' ];\\r\\n\\t\\tcase sRGBEncoding:\\r\\n\\t\\t\\treturn [ 'sRGB', '( value )' ];\\r\\n\\t\\tcase RGBEEncoding:\\r\\n\\t\\t\\treturn [ 'RGBE', '( value )' ];\\r\\n\\t\\tcase RGBM7Encoding:\\r\\n\\t\\t\\treturn [ 'RGBM', '( value, 7.0 )' ];\\r\\n\\t\\tcase RGBM16Encoding:\\r\\n\\t\\t\\treturn [ 'RGBM', '( value, 16.0 )' ];\\r\\n\\t\\tcase RGBDEncoding:\\r\\n\\t\\t\\treturn [ 'RGBD', '( value, 256.0 )' ];\\r\\n\\t\\tcase GammaEncoding:\\r\\n\\t\\t\\treturn [ 'Gamma', '( value, float( GAMMA_FACTOR ) )' ];\\r\\n\\t\\tcase LogLuvEncoding:\\r\\n\\t\\t\\treturn [ 'LogLuv', '( value )' ];\\r\\n\\t\\tdefault:\\r\\n\\t\\t\\tthrow new Error( 'unsupported encoding: ' + encoding );\\r\\n\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\\r\\nfunction getShaderErrors( gl, shader, type ) {\\r\\n\\r\\n\\tvar status = gl.getShaderParameter( shader, 35713 );\\r\\n\\tvar log = gl.getShaderInfoLog( shader ).trim();\\r\\n\\r\\n\\tif ( status && log === '' ) return '';\\r\\n\\r\\n\\t// --enable-privileged-webgl-extension\\r\\n\\t// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\\r\\n\\r\\n\\tvar source = gl.getShaderSource( shader );\\r\\n\\r\\n\\treturn 'THREE.WebGLShader: gl.getShaderInfoLog() ' + type + '\\\\n' + log + addLineNumbers( source );\\r\\n\\r\\n}\\r\\n\\r\\nfunction getTexelDecodingFunction( functionName, encoding ) {\\r\\n\\r\\n\\tvar components = getEncodingComponents( encoding );\\r\\n\\treturn 'vec4 ' + functionName + '( vec4 value ) { return ' + components[ 0 ] + 'ToLinear' + components[ 1 ] + '; }';\\r\\n\\r\\n}\\r\\n\\r\\nfunction getTexelEncodingFunction( functionName, encoding ) {\\r\\n\\r\\n\\tvar components = getEncodingComponents( encoding );\\r\\n\\treturn 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[ 0 ] + components[ 1 ] + '; }';\\r\\n\\r\\n}\\r\\n\\r\\nfunction getToneMappingFunction( functionName, toneMapping ) {\\r\\n\\r\\n\\tvar toneMappingName;\\r\\n\\r\\n\\tswitch ( toneMapping ) {\\r\\n\\r\\n\\t\\tcase LinearToneMapping:\\r\\n\\t\\t\\ttoneMappingName = 'Linear';\\r\\n\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\tcase ReinhardToneMapping:\\r\\n\\t\\t\\ttoneMappingName = 'Reinhard';\\r\\n\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\tcase Uncharted2ToneMapping:\\r\\n\\t\\t\\ttoneMappingName = 'Uncharted2';\\r\\n\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\tcase CineonToneMapping:\\r\\n\\t\\t\\ttoneMappingName = 'OptimizedCineon';\\r\\n\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\tcase ACESFilmicToneMapping:\\r\\n\\t\\t\\ttoneMappingName = 'ACESFilmic';\\r\\n\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\tdefault:\\r\\n\\t\\t\\tthrow new Error( 'unsupported toneMapping: ' + toneMapping );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';\\r\\n\\r\\n}\\r\\n\\r\\nfunction generateExtensions( parameters ) {\\r\\n\\r\\n\\tvar chunks = [\\r\\n\\t\\t( parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ) ? '#extension GL_OES_standard_derivatives : enable' : '',\\r\\n\\t\\t( parameters.extensionFragDepth || parameters.logarithmicDepthBuffer ) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '',\\r\\n\\t\\t( parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ) ? '#extension GL_EXT_draw_buffers : require' : '',\\r\\n\\t\\t( parameters.extensionShaderTextureLOD || parameters.envMap ) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''\\r\\n\\t];\\r\\n\\r\\n\\treturn chunks.filter( filterEmptyLine ).join( '\\\\n' );\\r\\n\\r\\n}\\r\\n\\r\\nfunction generateDefines( defines ) {\\r\\n\\r\\n\\tvar chunks = [];\\r\\n\\r\\n\\tfor ( var name in defines ) {\\r\\n\\r\\n\\t\\tvar value = defines[ name ];\\r\\n\\r\\n\\t\\tif ( value === false ) continue;\\r\\n\\r\\n\\t\\tchunks.push( '#define ' + name + ' ' + value );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn chunks.join( '\\\\n' );\\r\\n\\r\\n}\\r\\n\\r\\nfunction fetchAttributeLocations( gl, program ) {\\r\\n\\r\\n\\tvar attributes = {};\\r\\n\\r\\n\\tvar n = gl.getProgramParameter( program, 35721 );\\r\\n\\r\\n\\tfor ( var i = 0; i < n; i ++ ) {\\r\\n\\r\\n\\t\\tvar info = gl.getActiveAttrib( program, i );\\r\\n\\t\\tvar name = info.name;\\r\\n\\r\\n\\t\\t// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );\\r\\n\\r\\n\\t\\tattributes[ name ] = gl.getAttribLocation( program, name );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn attributes;\\r\\n\\r\\n}\\r\\n\\r\\nfunction filterEmptyLine( string ) {\\r\\n\\r\\n\\treturn string !== '';\\r\\n\\r\\n}\\r\\n\\r\\nfunction replaceLightNums( string, parameters ) {\\r\\n\\r\\n\\treturn string\\r\\n\\t\\t.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )\\r\\n\\t\\t.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )\\r\\n\\t\\t.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )\\r\\n\\t\\t.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )\\r\\n\\t\\t.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights )\\r\\n\\t\\t.replace( /NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows )\\r\\n\\t\\t.replace( /NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows )\\r\\n\\t\\t.replace( /NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows );\\r\\n\\r\\n}\\r\\n\\r\\nfunction replaceClippingPlaneNums( string, parameters ) {\\r\\n\\r\\n\\treturn string\\r\\n\\t\\t.replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes )\\r\\n\\t\\t.replace( /UNION_CLIPPING_PLANES/g, ( parameters.numClippingPlanes - parameters.numClipIntersection ) );\\r\\n\\r\\n}\\r\\n\\r\\n// Resolve Includes\\r\\n\\r\\nvar includePattern = /^[ \\\\t]*#include +<([\\\\w\\\\d./]+)>/gm;\\r\\n\\r\\nfunction resolveIncludes( string ) {\\r\\n\\r\\n\\treturn string.replace( includePattern, includeReplacer );\\r\\n\\r\\n}\\r\\n\\r\\nfunction includeReplacer( match, include ) {\\r\\n\\r\\n\\tvar string = ShaderChunk[ include ];\\r\\n\\r\\n\\tif ( string === undefined ) {\\r\\n\\r\\n\\t\\tthrow new Error( 'Can not resolve #include <' + include + '>' );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn resolveIncludes( string );\\r\\n\\r\\n}\\r\\n\\r\\n// Unroll Loops\\r\\n\\r\\nvar deprecatedUnrollLoopPattern = /#pragma unroll_loop[\\\\s]+?for \\\\( int i \\\\= (\\\\d+)\\\\; i < (\\\\d+)\\\\; i \\\\+\\\\+ \\\\) \\\\{([\\\\s\\\\S]+?)(?=\\\\})\\\\}/g;\\r\\nvar unrollLoopPattern = /#pragma unroll_loop_start[\\\\s]+?for \\\\( int i \\\\= (\\\\d+)\\\\; i < (\\\\d+)\\\\; i \\\\+\\\\+ \\\\) \\\\{([\\\\s\\\\S]+?)(?=\\\\})\\\\}[\\\\s]+?#pragma unroll_loop_end/g;\\r\\n\\r\\nfunction unrollLoops( string ) {\\r\\n\\r\\n\\treturn string\\r\\n\\t\\t.replace( unrollLoopPattern, loopReplacer )\\r\\n\\t\\t.replace( deprecatedUnrollLoopPattern, deprecatedLoopReplacer );\\r\\n\\r\\n}\\r\\n\\r\\nfunction deprecatedLoopReplacer( match, start, end, snippet ) {\\r\\n\\r\\n\\tconsole.warn( 'WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.' );\\r\\n\\treturn loopReplacer( match, start, end, snippet );\\r\\n\\r\\n}\\r\\n\\r\\nfunction loopReplacer( match, start, end, snippet ) {\\r\\n\\r\\n\\tvar string = '';\\r\\n\\r\\n\\tfor ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {\\r\\n\\r\\n\\t\\tstring += snippet\\r\\n\\t\\t\\t.replace( /\\\\[ i \\\\]/g, '[ ' + i + ' ]' )\\r\\n\\t\\t\\t.replace( /UNROLLED_LOOP_INDEX/g, i );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn string;\\r\\n\\r\\n}\\r\\n\\r\\n//\\r\\n\\r\\nfunction generatePrecision( parameters ) {\\r\\n\\r\\n\\tvar precisionstring = \\\"precision \\\" + parameters.precision + \\\" float;\\\\nprecision \\\" + parameters.precision + \\\" int;\\\";\\r\\n\\r\\n\\tif ( parameters.precision === \\\"highp\\\" ) {\\r\\n\\r\\n\\t\\tprecisionstring += \\\"\\\\n#define HIGH_PRECISION\\\";\\r\\n\\r\\n\\t} else if ( parameters.precision === \\\"mediump\\\" ) {\\r\\n\\r\\n\\t\\tprecisionstring += \\\"\\\\n#define MEDIUM_PRECISION\\\";\\r\\n\\r\\n\\t} else if ( parameters.precision === \\\"lowp\\\" ) {\\r\\n\\r\\n\\t\\tprecisionstring += \\\"\\\\n#define LOW_PRECISION\\\";\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn precisionstring;\\r\\n\\r\\n}\\r\\n\\r\\nfunction generateShadowMapTypeDefine( parameters ) {\\r\\n\\r\\n\\tvar shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\\r\\n\\r\\n\\tif ( parameters.shadowMapType === PCFShadowMap ) {\\r\\n\\r\\n\\t\\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\\r\\n\\r\\n\\t} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {\\r\\n\\r\\n\\t\\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\\r\\n\\r\\n\\t} else if ( parameters.shadowMapType === VSMShadowMap ) {\\r\\n\\r\\n\\t\\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn shadowMapTypeDefine;\\r\\n\\r\\n}\\r\\n\\r\\nfunction generateEnvMapTypeDefine( parameters ) {\\r\\n\\r\\n\\tvar envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\\r\\n\\r\\n\\tif ( parameters.envMap ) {\\r\\n\\r\\n\\t\\tswitch ( parameters.envMapMode ) {\\r\\n\\r\\n\\t\\t\\tcase CubeReflectionMapping:\\r\\n\\t\\t\\tcase CubeRefractionMapping:\\r\\n\\t\\t\\t\\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE';\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tcase CubeUVReflectionMapping:\\r\\n\\t\\t\\tcase CubeUVRefractionMapping:\\r\\n\\t\\t\\t\\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tcase EquirectangularReflectionMapping:\\r\\n\\t\\t\\tcase EquirectangularRefractionMapping:\\r\\n\\t\\t\\t\\tenvMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tcase SphericalReflectionMapping:\\r\\n\\t\\t\\t\\tenvMapTypeDefine = 'ENVMAP_TYPE_SPHERE';\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn envMapTypeDefine;\\r\\n\\r\\n}\\r\\n\\r\\nfunction generateEnvMapModeDefine( parameters ) {\\r\\n\\r\\n\\tvar envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\\r\\n\\r\\n\\tif ( parameters.envMap ) {\\r\\n\\r\\n\\t\\tswitch ( parameters.envMapMode ) {\\r\\n\\r\\n\\t\\t\\tcase CubeRefractionMapping:\\r\\n\\t\\t\\tcase EquirectangularRefractionMapping:\\r\\n\\t\\t\\t\\tenvMapModeDefine = 'ENVMAP_MODE_REFRACTION';\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn envMapModeDefine;\\r\\n\\r\\n}\\r\\n\\r\\nfunction generateEnvMapBlendingDefine( parameters ) {\\r\\n\\r\\n\\tvar envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';\\r\\n\\r\\n\\tif ( parameters.envMap ) {\\r\\n\\r\\n\\t\\tswitch ( parameters.combine ) {\\r\\n\\r\\n\\t\\t\\tcase MultiplyOperation:\\r\\n\\t\\t\\t\\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tcase MixOperation:\\r\\n\\t\\t\\t\\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tcase AddOperation:\\r\\n\\t\\t\\t\\tenvMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn envMapBlendingDefine;\\r\\n\\r\\n}\\r\\n\\r\\nfunction WebGLProgram( renderer, cacheKey, parameters ) {\\r\\n\\r\\n\\tvar gl = renderer.getContext();\\r\\n\\r\\n\\tvar defines = parameters.defines;\\r\\n\\r\\n\\tvar vertexShader = parameters.vertexShader;\\r\\n\\tvar fragmentShader = parameters.fragmentShader;\\r\\n\\tvar shadowMapTypeDefine = generateShadowMapTypeDefine( parameters );\\r\\n\\tvar envMapTypeDefine = generateEnvMapTypeDefine( parameters );\\r\\n\\tvar envMapModeDefine = generateEnvMapModeDefine( parameters );\\r\\n\\tvar envMapBlendingDefine = generateEnvMapBlendingDefine( parameters );\\r\\n\\r\\n\\r\\n\\tvar gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;\\r\\n\\r\\n\\tvar customExtensions = parameters.isWebGL2 ? '' : generateExtensions( parameters );\\r\\n\\r\\n\\tvar customDefines = generateDefines( defines );\\r\\n\\r\\n\\tvar program = gl.createProgram();\\r\\n\\r\\n\\tvar prefixVertex, prefixFragment;\\r\\n\\r\\n\\tif ( parameters.isRawShaderMaterial ) {\\r\\n\\r\\n\\t\\tprefixVertex = [\\r\\n\\r\\n\\t\\t\\tcustomDefines\\r\\n\\r\\n\\t\\t].filter( filterEmptyLine ).join( '\\\\n' );\\r\\n\\r\\n\\t\\tif ( prefixVertex.length > 0 ) {\\r\\n\\r\\n\\t\\t\\tprefixVertex += '\\\\n';\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tprefixFragment = [\\r\\n\\r\\n\\t\\t\\tcustomExtensions,\\r\\n\\t\\t\\tcustomDefines\\r\\n\\r\\n\\t\\t].filter( filterEmptyLine ).join( '\\\\n' );\\r\\n\\r\\n\\t\\tif ( prefixFragment.length > 0 ) {\\r\\n\\r\\n\\t\\t\\tprefixFragment += '\\\\n';\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} else {\\r\\n\\r\\n\\t\\tprefixVertex = [\\r\\n\\r\\n\\t\\t\\tgeneratePrecision( parameters ),\\r\\n\\r\\n\\t\\t\\t'#define SHADER_NAME ' + parameters.shaderName,\\r\\n\\r\\n\\t\\t\\tcustomDefines,\\r\\n\\r\\n\\t\\t\\tparameters.instancing ? '#define USE_INSTANCING' : '',\\r\\n\\t\\t\\tparameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',\\r\\n\\r\\n\\t\\t\\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\\r\\n\\r\\n\\t\\t\\t'#define MAX_BONES ' + parameters.maxBones,\\r\\n\\t\\t\\t( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\\r\\n\\t\\t\\t( parameters.useFog && parameters.fogExp2 ) ? '#define FOG_EXP2' : '',\\r\\n\\r\\n\\t\\t\\tparameters.map ? '#define USE_MAP' : '',\\r\\n\\t\\t\\tparameters.envMap ? '#define USE_ENVMAP' : '',\\r\\n\\t\\t\\tparameters.envMap ? '#define ' + envMapModeDefine : '',\\r\\n\\t\\t\\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\\r\\n\\t\\t\\tparameters.aoMap ? '#define USE_AOMAP' : '',\\r\\n\\t\\t\\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\\r\\n\\t\\t\\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\\r\\n\\t\\t\\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\\r\\n\\t\\t\\t( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',\\r\\n\\t\\t\\t( parameters.normalMap && parameters.tangentSpaceNormalMap ) ? '#define TANGENTSPACE_NORMALMAP' : '',\\r\\n\\r\\n\\t\\t\\tparameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',\\r\\n\\t\\t\\tparameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',\\r\\n\\t\\t\\tparameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',\\r\\n\\t\\t\\tparameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',\\r\\n\\t\\t\\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\\r\\n\\t\\t\\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\\r\\n\\t\\t\\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\\r\\n\\t\\t\\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\\r\\n\\r\\n\\t\\t\\tparameters.vertexTangents ? '#define USE_TANGENT' : '',\\r\\n\\t\\t\\tparameters.vertexColors ? '#define USE_COLOR' : '',\\r\\n\\t\\t\\tparameters.vertexUvs ? '#define USE_UV' : '',\\r\\n\\t\\t\\tparameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',\\r\\n\\r\\n\\t\\t\\tparameters.flatShading ? '#define FLAT_SHADED' : '',\\r\\n\\r\\n\\t\\t\\tparameters.skinning ? '#define USE_SKINNING' : '',\\r\\n\\t\\t\\tparameters.useVertexTexture ? '#define BONE_TEXTURE' : '',\\r\\n\\r\\n\\t\\t\\tparameters.morphTargets ? '#define USE_MORPHTARGETS' : '',\\r\\n\\t\\t\\tparameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',\\r\\n\\t\\t\\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\\r\\n\\t\\t\\tparameters.flipSided ? '#define FLIP_SIDED' : '',\\r\\n\\r\\n\\t\\t\\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\\r\\n\\t\\t\\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\\r\\n\\r\\n\\t\\t\\tparameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',\\r\\n\\r\\n\\t\\t\\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\\r\\n\\t\\t\\t( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\\r\\n\\r\\n\\t\\t\\t'uniform mat4 modelMatrix;',\\r\\n\\t\\t\\t'uniform mat4 modelViewMatrix;',\\r\\n\\t\\t\\t'uniform mat4 projectionMatrix;',\\r\\n\\t\\t\\t'uniform mat4 viewMatrix;',\\r\\n\\t\\t\\t'uniform mat3 normalMatrix;',\\r\\n\\t\\t\\t'uniform vec3 cameraPosition;',\\r\\n\\t\\t\\t'uniform bool isOrthographic;',\\r\\n\\r\\n\\t\\t\\t'#ifdef USE_INSTANCING',\\r\\n\\r\\n\\t\\t\\t' attribute mat4 instanceMatrix;',\\r\\n\\r\\n\\t\\t\\t'#endif',\\r\\n\\r\\n\\t\\t\\t'attribute vec3 position;',\\r\\n\\t\\t\\t'attribute vec3 normal;',\\r\\n\\t\\t\\t'attribute vec2 uv;',\\r\\n\\r\\n\\t\\t\\t'#ifdef USE_TANGENT',\\r\\n\\r\\n\\t\\t\\t'\\tattribute vec4 tangent;',\\r\\n\\r\\n\\t\\t\\t'#endif',\\r\\n\\r\\n\\t\\t\\t'#ifdef USE_COLOR',\\r\\n\\r\\n\\t\\t\\t'\\tattribute vec3 color;',\\r\\n\\r\\n\\t\\t\\t'#endif',\\r\\n\\r\\n\\t\\t\\t'#ifdef USE_MORPHTARGETS',\\r\\n\\r\\n\\t\\t\\t'\\tattribute vec3 morphTarget0;',\\r\\n\\t\\t\\t'\\tattribute vec3 morphTarget1;',\\r\\n\\t\\t\\t'\\tattribute vec3 morphTarget2;',\\r\\n\\t\\t\\t'\\tattribute vec3 morphTarget3;',\\r\\n\\r\\n\\t\\t\\t'\\t#ifdef USE_MORPHNORMALS',\\r\\n\\r\\n\\t\\t\\t'\\t\\tattribute vec3 morphNormal0;',\\r\\n\\t\\t\\t'\\t\\tattribute vec3 morphNormal1;',\\r\\n\\t\\t\\t'\\t\\tattribute vec3 morphNormal2;',\\r\\n\\t\\t\\t'\\t\\tattribute vec3 morphNormal3;',\\r\\n\\r\\n\\t\\t\\t'\\t#else',\\r\\n\\r\\n\\t\\t\\t'\\t\\tattribute vec3 morphTarget4;',\\r\\n\\t\\t\\t'\\t\\tattribute vec3 morphTarget5;',\\r\\n\\t\\t\\t'\\t\\tattribute vec3 morphTarget6;',\\r\\n\\t\\t\\t'\\t\\tattribute vec3 morphTarget7;',\\r\\n\\r\\n\\t\\t\\t'\\t#endif',\\r\\n\\r\\n\\t\\t\\t'#endif',\\r\\n\\r\\n\\t\\t\\t'#ifdef USE_SKINNING',\\r\\n\\r\\n\\t\\t\\t'\\tattribute vec4 skinIndex;',\\r\\n\\t\\t\\t'\\tattribute vec4 skinWeight;',\\r\\n\\r\\n\\t\\t\\t'#endif',\\r\\n\\r\\n\\t\\t\\t'\\\\n'\\r\\n\\r\\n\\t\\t].filter( filterEmptyLine ).join( '\\\\n' );\\r\\n\\r\\n\\t\\tprefixFragment = [\\r\\n\\r\\n\\t\\t\\tcustomExtensions,\\r\\n\\r\\n\\t\\t\\tgeneratePrecision( parameters ),\\r\\n\\r\\n\\t\\t\\t'#define SHADER_NAME ' + parameters.shaderName,\\r\\n\\r\\n\\t\\t\\tcustomDefines,\\r\\n\\r\\n\\t\\t\\tparameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + ( parameters.alphaTest % 1 ? '' : '.0' ) : '', // add '.0' if integer\\r\\n\\r\\n\\t\\t\\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\\r\\n\\r\\n\\t\\t\\t( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\\r\\n\\t\\t\\t( parameters.useFog && parameters.fogExp2 ) ? '#define FOG_EXP2' : '',\\r\\n\\r\\n\\t\\t\\tparameters.map ? '#define USE_MAP' : '',\\r\\n\\t\\t\\tparameters.matcap ? '#define USE_MATCAP' : '',\\r\\n\\t\\t\\tparameters.envMap ? '#define USE_ENVMAP' : '',\\r\\n\\t\\t\\tparameters.envMap ? '#define ' + envMapTypeDefine : '',\\r\\n\\t\\t\\tparameters.envMap ? '#define ' + envMapModeDefine : '',\\r\\n\\t\\t\\tparameters.envMap ? '#define ' + envMapBlendingDefine : '',\\r\\n\\t\\t\\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\\r\\n\\t\\t\\tparameters.aoMap ? '#define USE_AOMAP' : '',\\r\\n\\t\\t\\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\\r\\n\\t\\t\\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\\r\\n\\t\\t\\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\\r\\n\\t\\t\\t( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',\\r\\n\\t\\t\\t( parameters.normalMap && parameters.tangentSpaceNormalMap ) ? '#define TANGENTSPACE_NORMALMAP' : '',\\r\\n\\t\\t\\tparameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',\\r\\n\\t\\t\\tparameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',\\r\\n\\t\\t\\tparameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',\\r\\n\\t\\t\\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\\r\\n\\t\\t\\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\\r\\n\\t\\t\\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\\r\\n\\t\\t\\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\\r\\n\\r\\n\\t\\t\\tparameters.sheen ? '#define USE_SHEEN' : '',\\r\\n\\r\\n\\t\\t\\tparameters.vertexTangents ? '#define USE_TANGENT' : '',\\r\\n\\t\\t\\tparameters.vertexColors ? '#define USE_COLOR' : '',\\r\\n\\t\\t\\tparameters.vertexUvs ? '#define USE_UV' : '',\\r\\n\\t\\t\\tparameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',\\r\\n\\r\\n\\t\\t\\tparameters.gradientMap ? '#define USE_GRADIENTMAP' : '',\\r\\n\\r\\n\\t\\t\\tparameters.flatShading ? '#define FLAT_SHADED' : '',\\r\\n\\r\\n\\t\\t\\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\\r\\n\\t\\t\\tparameters.flipSided ? '#define FLIP_SIDED' : '',\\r\\n\\r\\n\\t\\t\\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\\r\\n\\t\\t\\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\\r\\n\\r\\n\\t\\t\\tparameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',\\r\\n\\r\\n\\t\\t\\tparameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',\\r\\n\\r\\n\\t\\t\\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\\r\\n\\t\\t\\t( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\\r\\n\\r\\n\\t\\t\\t( ( parameters.extensionShaderTextureLOD || parameters.envMap ) && parameters.rendererExtensionShaderTextureLod ) ? '#define TEXTURE_LOD_EXT' : '',\\r\\n\\r\\n\\t\\t\\t'uniform mat4 viewMatrix;',\\r\\n\\t\\t\\t'uniform vec3 cameraPosition;',\\r\\n\\t\\t\\t'uniform bool isOrthographic;',\\r\\n\\r\\n\\t\\t\\t( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',\\r\\n\\t\\t\\t( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below\\r\\n\\t\\t\\t( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',\\r\\n\\r\\n\\t\\t\\tparameters.dithering ? '#define DITHERING' : '',\\r\\n\\r\\n\\t\\t\\t( parameters.outputEncoding || parameters.mapEncoding || parameters.matcapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding || parameters.lightMapEncoding ) ?\\r\\n\\t\\t\\t\\tShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below\\r\\n\\t\\t\\tparameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',\\r\\n\\t\\t\\tparameters.matcapEncoding ? getTexelDecodingFunction( 'matcapTexelToLinear', parameters.matcapEncoding ) : '',\\r\\n\\t\\t\\tparameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',\\r\\n\\t\\t\\tparameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',\\r\\n\\t\\t\\tparameters.lightMapEncoding ? getTexelDecodingFunction( 'lightMapTexelToLinear', parameters.lightMapEncoding ) : '',\\r\\n\\t\\t\\tparameters.outputEncoding ? getTexelEncodingFunction( 'linearToOutputTexel', parameters.outputEncoding ) : '',\\r\\n\\r\\n\\t\\t\\tparameters.depthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '',\\r\\n\\r\\n\\t\\t\\t'\\\\n'\\r\\n\\r\\n\\t\\t].filter( filterEmptyLine ).join( '\\\\n' );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tvertexShader = resolveIncludes( vertexShader );\\r\\n\\tvertexShader = replaceLightNums( vertexShader, parameters );\\r\\n\\tvertexShader = replaceClippingPlaneNums( vertexShader, parameters );\\r\\n\\r\\n\\tfragmentShader = resolveIncludes( fragmentShader );\\r\\n\\tfragmentShader = replaceLightNums( fragmentShader, parameters );\\r\\n\\tfragmentShader = replaceClippingPlaneNums( fragmentShader, parameters );\\r\\n\\r\\n\\tvertexShader = unrollLoops( vertexShader );\\r\\n\\tfragmentShader = unrollLoops( fragmentShader );\\r\\n\\r\\n\\tif ( parameters.isWebGL2 && ! parameters.isRawShaderMaterial ) {\\r\\n\\r\\n\\t\\tvar isGLSL3ShaderMaterial = false;\\r\\n\\r\\n\\t\\tvar versionRegex = /^\\\\s*#version\\\\s+300\\\\s+es\\\\s*\\\\n/;\\r\\n\\r\\n\\t\\tif ( parameters.isShaderMaterial &&\\r\\n\\t\\t\\tvertexShader.match( versionRegex ) !== null &&\\r\\n\\t\\t\\tfragmentShader.match( versionRegex ) !== null ) {\\r\\n\\r\\n\\t\\t\\tisGLSL3ShaderMaterial = true;\\r\\n\\r\\n\\t\\t\\tvertexShader = vertexShader.replace( versionRegex, '' );\\r\\n\\t\\t\\tfragmentShader = fragmentShader.replace( versionRegex, '' );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// GLSL 3.0 conversion\\r\\n\\r\\n\\t\\tprefixVertex = [\\r\\n\\t\\t\\t'#version 300 es\\\\n',\\r\\n\\t\\t\\t'#define attribute in',\\r\\n\\t\\t\\t'#define varying out',\\r\\n\\t\\t\\t'#define texture2D texture'\\r\\n\\t\\t].join( '\\\\n' ) + '\\\\n' + prefixVertex;\\r\\n\\r\\n\\t\\tprefixFragment = [\\r\\n\\t\\t\\t'#version 300 es\\\\n',\\r\\n\\t\\t\\t'#define varying in',\\r\\n\\t\\t\\tisGLSL3ShaderMaterial ? '' : 'out highp vec4 pc_fragColor;',\\r\\n\\t\\t\\tisGLSL3ShaderMaterial ? '' : '#define gl_FragColor pc_fragColor',\\r\\n\\t\\t\\t'#define gl_FragDepthEXT gl_FragDepth',\\r\\n\\t\\t\\t'#define texture2D texture',\\r\\n\\t\\t\\t'#define textureCube texture',\\r\\n\\t\\t\\t'#define texture2DProj textureProj',\\r\\n\\t\\t\\t'#define texture2DLodEXT textureLod',\\r\\n\\t\\t\\t'#define texture2DProjLodEXT textureProjLod',\\r\\n\\t\\t\\t'#define textureCubeLodEXT textureLod',\\r\\n\\t\\t\\t'#define texture2DGradEXT textureGrad',\\r\\n\\t\\t\\t'#define texture2DProjGradEXT textureProjGrad',\\r\\n\\t\\t\\t'#define textureCubeGradEXT textureGrad'\\r\\n\\t\\t].join( '\\\\n' ) + '\\\\n' + prefixFragment;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tvar vertexGlsl = prefixVertex + vertexShader;\\r\\n\\tvar fragmentGlsl = prefixFragment + fragmentShader;\\r\\n\\r\\n\\t// console.log( '*VERTEX*', vertexGlsl );\\r\\n\\t// console.log( '*FRAGMENT*', fragmentGlsl );\\r\\n\\r\\n\\tvar glVertexShader = WebGLShader( gl, 35633, vertexGlsl );\\r\\n\\tvar glFragmentShader = WebGLShader( gl, 35632, fragmentGlsl );\\r\\n\\r\\n\\tgl.attachShader( program, glVertexShader );\\r\\n\\tgl.attachShader( program, glFragmentShader );\\r\\n\\r\\n\\t// Force a particular attribute to index 0.\\r\\n\\r\\n\\tif ( parameters.index0AttributeName !== undefined ) {\\r\\n\\r\\n\\t\\tgl.bindAttribLocation( program, 0, parameters.index0AttributeName );\\r\\n\\r\\n\\t} else if ( parameters.morphTargets === true ) {\\r\\n\\r\\n\\t\\t// programs with morphTargets displace position out of attribute 0\\r\\n\\t\\tgl.bindAttribLocation( program, 0, 'position' );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tgl.linkProgram( program );\\r\\n\\r\\n\\t// check for link errors\\r\\n\\tif ( renderer.debug.checkShaderErrors ) {\\r\\n\\r\\n\\t\\tvar programLog = gl.getProgramInfoLog( program ).trim();\\r\\n\\t\\tvar vertexLog = gl.getShaderInfoLog( glVertexShader ).trim();\\r\\n\\t\\tvar fragmentLog = gl.getShaderInfoLog( glFragmentShader ).trim();\\r\\n\\r\\n\\t\\tvar runnable = true;\\r\\n\\t\\tvar haveDiagnostics = true;\\r\\n\\r\\n\\t\\tif ( gl.getProgramParameter( program, 35714 ) === false ) {\\r\\n\\r\\n\\t\\t\\trunnable = false;\\r\\n\\r\\n\\t\\t\\tvar vertexErrors = getShaderErrors( gl, glVertexShader, 'vertex' );\\r\\n\\t\\t\\tvar fragmentErrors = getShaderErrors( gl, glFragmentShader, 'fragment' );\\r\\n\\r\\n\\t\\t\\tconsole.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), '35715', gl.getProgramParameter( program, 35715 ), 'gl.getProgramInfoLog', programLog, vertexErrors, fragmentErrors );\\r\\n\\r\\n\\t\\t} else if ( programLog !== '' ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );\\r\\n\\r\\n\\t\\t} else if ( vertexLog === '' || fragmentLog === '' ) {\\r\\n\\r\\n\\t\\t\\thaveDiagnostics = false;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( haveDiagnostics ) {\\r\\n\\r\\n\\t\\t\\tthis.diagnostics = {\\r\\n\\r\\n\\t\\t\\t\\trunnable: runnable,\\r\\n\\r\\n\\t\\t\\t\\tprogramLog: programLog,\\r\\n\\r\\n\\t\\t\\t\\tvertexShader: {\\r\\n\\r\\n\\t\\t\\t\\t\\tlog: vertexLog,\\r\\n\\t\\t\\t\\t\\tprefix: prefixVertex\\r\\n\\r\\n\\t\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\t\\tfragmentShader: {\\r\\n\\r\\n\\t\\t\\t\\t\\tlog: fragmentLog,\\r\\n\\t\\t\\t\\t\\tprefix: prefixFragment\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// Clean up\\r\\n\\r\\n\\t// Crashes in iOS9 and iOS10. #18402\\r\\n\\t// gl.detachShader( program, glVertexShader );\\r\\n\\t// gl.detachShader( program, glFragmentShader );\\r\\n\\r\\n\\tgl.deleteShader( glVertexShader );\\r\\n\\tgl.deleteShader( glFragmentShader );\\r\\n\\r\\n\\t// set up caching for uniform locations\\r\\n\\r\\n\\tvar cachedUniforms;\\r\\n\\r\\n\\tthis.getUniforms = function () {\\r\\n\\r\\n\\t\\tif ( cachedUniforms === undefined ) {\\r\\n\\r\\n\\t\\t\\tcachedUniforms = new WebGLUniforms( gl, program );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn cachedUniforms;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t// set up caching for attribute locations\\r\\n\\r\\n\\tvar cachedAttributes;\\r\\n\\r\\n\\tthis.getAttributes = function () {\\r\\n\\r\\n\\t\\tif ( cachedAttributes === undefined ) {\\r\\n\\r\\n\\t\\t\\tcachedAttributes = fetchAttributeLocations( gl, program );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn cachedAttributes;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t// free resource\\r\\n\\r\\n\\tthis.destroy = function () {\\r\\n\\r\\n\\t\\tgl.deleteProgram( program );\\r\\n\\t\\tthis.program = undefined;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tthis.name = parameters.shaderName;\\r\\n\\tthis.id = programIdCount ++;\\r\\n\\tthis.cacheKey = cacheKey;\\r\\n\\tthis.usedTimes = 1;\\r\\n\\tthis.program = program;\\r\\n\\tthis.vertexShader = glVertexShader;\\r\\n\\tthis.fragmentShader = glFragmentShader;\\r\\n\\r\\n\\treturn this;\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nfunction WebGLPrograms( renderer, extensions, capabilities ) {\\r\\n\\r\\n\\tvar programs = [];\\r\\n\\r\\n\\tvar isWebGL2 = capabilities.isWebGL2;\\r\\n\\tvar logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;\\r\\n\\tvar floatVertexTextures = capabilities.floatVertexTextures;\\r\\n\\tvar precision = capabilities.precision;\\r\\n\\tvar maxVertexUniforms = capabilities.maxVertexUniforms;\\r\\n\\tvar vertexTextures = capabilities.vertexTextures;\\r\\n\\r\\n\\tvar shaderIDs = {\\r\\n\\t\\tMeshDepthMaterial: 'depth',\\r\\n\\t\\tMeshDistanceMaterial: 'distanceRGBA',\\r\\n\\t\\tMeshNormalMaterial: 'normal',\\r\\n\\t\\tMeshBasicMaterial: 'basic',\\r\\n\\t\\tMeshLambertMaterial: 'lambert',\\r\\n\\t\\tMeshPhongMaterial: 'phong',\\r\\n\\t\\tMeshToonMaterial: 'toon',\\r\\n\\t\\tMeshStandardMaterial: 'physical',\\r\\n\\t\\tMeshPhysicalMaterial: 'physical',\\r\\n\\t\\tMeshMatcapMaterial: 'matcap',\\r\\n\\t\\tLineBasicMaterial: 'basic',\\r\\n\\t\\tLineDashedMaterial: 'dashed',\\r\\n\\t\\tPointsMaterial: 'points',\\r\\n\\t\\tShadowMaterial: 'shadow',\\r\\n\\t\\tSpriteMaterial: 'sprite'\\r\\n\\t};\\r\\n\\r\\n\\tvar parameterNames = [\\r\\n\\t\\t\\\"precision\\\", \\\"isWebGL2\\\", \\\"supportsVertexTextures\\\", \\\"outputEncoding\\\", \\\"instancing\\\",\\r\\n\\t\\t\\\"map\\\", \\\"mapEncoding\\\", \\\"matcap\\\", \\\"matcapEncoding\\\", \\\"envMap\\\", \\\"envMapMode\\\", \\\"envMapEncoding\\\", \\\"envMapCubeUV\\\",\\r\\n\\t\\t\\\"lightMap\\\", \\\"lightMapEncoding\\\", \\\"aoMap\\\", \\\"emissiveMap\\\", \\\"emissiveMapEncoding\\\", \\\"bumpMap\\\", \\\"normalMap\\\", \\\"objectSpaceNormalMap\\\", \\\"tangentSpaceNormalMap\\\", \\\"clearcoatMap\\\", \\\"clearcoatRoughnessMap\\\", \\\"clearcoatNormalMap\\\", \\\"displacementMap\\\", \\\"specularMap\\\",\\r\\n\\t\\t\\\"roughnessMap\\\", \\\"metalnessMap\\\", \\\"gradientMap\\\",\\r\\n\\t\\t\\\"alphaMap\\\", \\\"combine\\\", \\\"vertexColors\\\", \\\"vertexTangents\\\", \\\"vertexUvs\\\", \\\"uvsVertexOnly\\\", \\\"fog\\\", \\\"useFog\\\", \\\"fogExp2\\\",\\r\\n\\t\\t\\\"flatShading\\\", \\\"sizeAttenuation\\\", \\\"logarithmicDepthBuffer\\\", \\\"skinning\\\",\\r\\n\\t\\t\\\"maxBones\\\", \\\"useVertexTexture\\\", \\\"morphTargets\\\", \\\"morphNormals\\\",\\r\\n\\t\\t\\\"maxMorphTargets\\\", \\\"maxMorphNormals\\\", \\\"premultipliedAlpha\\\",\\r\\n\\t\\t\\\"numDirLights\\\", \\\"numPointLights\\\", \\\"numSpotLights\\\", \\\"numHemiLights\\\", \\\"numRectAreaLights\\\",\\r\\n\\t\\t\\\"numDirLightShadows\\\", \\\"numPointLightShadows\\\", \\\"numSpotLightShadows\\\",\\r\\n\\t\\t\\\"shadowMapEnabled\\\", \\\"shadowMapType\\\", \\\"toneMapping\\\", 'physicallyCorrectLights',\\r\\n\\t\\t\\\"alphaTest\\\", \\\"doubleSided\\\", \\\"flipSided\\\", \\\"numClippingPlanes\\\", \\\"numClipIntersection\\\", \\\"depthPacking\\\", \\\"dithering\\\",\\r\\n\\t\\t\\\"sheen\\\"\\r\\n\\t];\\r\\n\\r\\n\\tfunction getShaderObject( material, shaderID ) {\\r\\n\\r\\n\\t\\tvar shaderobject;\\r\\n\\r\\n\\t\\tif ( shaderID ) {\\r\\n\\r\\n\\t\\t\\tvar shader = ShaderLib[ shaderID ];\\r\\n\\r\\n\\t\\t\\tshaderobject = {\\r\\n\\t\\t\\t\\tname: material.type,\\r\\n\\t\\t\\t\\tuniforms: UniformsUtils.clone( shader.uniforms ),\\r\\n\\t\\t\\t\\tvertexShader: shader.vertexShader,\\r\\n\\t\\t\\t\\tfragmentShader: shader.fragmentShader\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tshaderobject = {\\r\\n\\t\\t\\t\\tname: material.type,\\r\\n\\t\\t\\t\\tuniforms: material.uniforms,\\r\\n\\t\\t\\t\\tvertexShader: material.vertexShader,\\r\\n\\t\\t\\t\\tfragmentShader: material.fragmentShader\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn shaderobject;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction allocateBones( object ) {\\r\\n\\r\\n\\t\\tvar skeleton = object.skeleton;\\r\\n\\t\\tvar bones = skeleton.bones;\\r\\n\\r\\n\\t\\tif ( floatVertexTextures ) {\\r\\n\\r\\n\\t\\t\\treturn 1024;\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t// default for when object is not specified\\r\\n\\t\\t\\t// ( for example when prebuilding shader to be used with multiple objects )\\r\\n\\t\\t\\t//\\r\\n\\t\\t\\t//  - leave some extra space for other uniforms\\r\\n\\t\\t\\t//  - limit here is ANGLE's 254 max uniform vectors\\r\\n\\t\\t\\t//    (up to 54 should be safe)\\r\\n\\r\\n\\t\\t\\tvar nVertexUniforms = maxVertexUniforms;\\r\\n\\t\\t\\tvar nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );\\r\\n\\r\\n\\t\\t\\tvar maxBones = Math.min( nVertexMatrices, bones.length );\\r\\n\\r\\n\\t\\t\\tif ( maxBones < bones.length ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.' );\\r\\n\\t\\t\\t\\treturn 0;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn maxBones;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction getTextureEncodingFromMap( map ) {\\r\\n\\r\\n\\t\\tvar encoding;\\r\\n\\r\\n\\t\\tif ( ! map ) {\\r\\n\\r\\n\\t\\t\\tencoding = LinearEncoding;\\r\\n\\r\\n\\t\\t} else if ( map.isTexture ) {\\r\\n\\r\\n\\t\\t\\tencoding = map.encoding;\\r\\n\\r\\n\\t\\t} else if ( map.isWebGLRenderTarget ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( \\\"THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.\\\" );\\r\\n\\t\\t\\tencoding = map.texture.encoding;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn encoding;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tthis.getParameters = function ( material, lights, shadows, scene, nClipPlanes, nClipIntersection, object ) {\\r\\n\\r\\n\\t\\tvar fog = scene.fog;\\r\\n\\t\\tvar environment = material.isMeshStandardMaterial ? scene.environment : null;\\r\\n\\r\\n\\t\\tvar envMap = material.envMap || environment;\\r\\n\\r\\n\\t\\tvar shaderID = shaderIDs[ material.type ];\\r\\n\\r\\n\\t\\t// heuristics to create shader parameters according to lights in the scene\\r\\n\\t\\t// (not to blow over maxLights budget)\\r\\n\\r\\n\\t\\tvar maxBones = object.isSkinnedMesh ? allocateBones( object ) : 0;\\r\\n\\r\\n\\t\\tif ( material.precision !== null ) {\\r\\n\\r\\n\\t\\t\\tprecision = capabilities.getMaxPrecision( material.precision );\\r\\n\\r\\n\\t\\t\\tif ( precision !== material.precision ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar shaderobject = getShaderObject( material, shaderID );\\r\\n\\t\\tmaterial.onBeforeCompile( shaderobject, renderer );\\r\\n\\r\\n\\t\\tvar currentRenderTarget = renderer.getRenderTarget();\\r\\n\\r\\n\\t\\tvar parameters = {\\r\\n\\r\\n\\t\\t\\tisWebGL2: isWebGL2,\\r\\n\\r\\n\\t\\t\\tshaderID: shaderID,\\r\\n\\t\\t\\tshaderName: shaderobject.name,\\r\\n\\r\\n\\t\\t\\tuniforms: shaderobject.uniforms,\\r\\n\\t\\t\\tvertexShader: shaderobject.vertexShader,\\r\\n\\t\\t\\tfragmentShader: shaderobject.fragmentShader,\\r\\n\\t\\t\\tdefines: material.defines,\\r\\n\\r\\n\\t\\t\\tisRawShaderMaterial: material.isRawShaderMaterial,\\r\\n\\t\\t\\tisShaderMaterial: material.isShaderMaterial,\\r\\n\\r\\n\\t\\t\\tprecision: precision,\\r\\n\\r\\n\\t\\t\\tinstancing: object.isInstancedMesh === true,\\r\\n\\r\\n\\t\\t\\tsupportsVertexTextures: vertexTextures,\\r\\n\\t\\t\\toutputEncoding: ( currentRenderTarget !== null ) ? getTextureEncodingFromMap( currentRenderTarget.texture ) : renderer.outputEncoding,\\r\\n\\t\\t\\tmap: !! material.map,\\r\\n\\t\\t\\tmapEncoding: getTextureEncodingFromMap( material.map ),\\r\\n\\t\\t\\tmatcap: !! material.matcap,\\r\\n\\t\\t\\tmatcapEncoding: getTextureEncodingFromMap( material.matcap ),\\r\\n\\t\\t\\tenvMap: !! envMap,\\r\\n\\t\\t\\tenvMapMode: envMap && envMap.mapping,\\r\\n\\t\\t\\tenvMapEncoding: getTextureEncodingFromMap( envMap ),\\r\\n\\t\\t\\tenvMapCubeUV: ( !! envMap ) && ( ( envMap.mapping === CubeUVReflectionMapping ) || ( envMap.mapping === CubeUVRefractionMapping ) ),\\r\\n\\t\\t\\tlightMap: !! material.lightMap,\\r\\n\\t\\t\\tlightMapEncoding: getTextureEncodingFromMap( material.lightMap ),\\r\\n\\t\\t\\taoMap: !! material.aoMap,\\r\\n\\t\\t\\temissiveMap: !! material.emissiveMap,\\r\\n\\t\\t\\temissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap ),\\r\\n\\t\\t\\tbumpMap: !! material.bumpMap,\\r\\n\\t\\t\\tnormalMap: !! material.normalMap,\\r\\n\\t\\t\\tobjectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,\\r\\n\\t\\t\\ttangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,\\r\\n\\t\\t\\tclearcoatMap: !! material.clearcoatMap,\\r\\n\\t\\t\\tclearcoatRoughnessMap: !! material.clearcoatRoughnessMap,\\r\\n\\t\\t\\tclearcoatNormalMap: !! material.clearcoatNormalMap,\\r\\n\\t\\t\\tdisplacementMap: !! material.displacementMap,\\r\\n\\t\\t\\troughnessMap: !! material.roughnessMap,\\r\\n\\t\\t\\tmetalnessMap: !! material.metalnessMap,\\r\\n\\t\\t\\tspecularMap: !! material.specularMap,\\r\\n\\t\\t\\talphaMap: !! material.alphaMap,\\r\\n\\r\\n\\t\\t\\tgradientMap: !! material.gradientMap,\\r\\n\\r\\n\\t\\t\\tsheen: !! material.sheen,\\r\\n\\r\\n\\t\\t\\tcombine: material.combine,\\r\\n\\r\\n\\t\\t\\tvertexTangents: ( material.normalMap && material.vertexTangents ),\\r\\n\\t\\t\\tvertexColors: material.vertexColors,\\r\\n\\t\\t\\tvertexUvs: !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatMap || !! material.clearcoatRoughnessMap || !! material.clearcoatNormalMap || !! material.displacementMap,\\r\\n\\t\\t\\tuvsVertexOnly: ! ( !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatNormalMap ) && !! material.displacementMap,\\r\\n\\r\\n\\t\\t\\tfog: !! fog,\\r\\n\\t\\t\\tuseFog: material.fog,\\r\\n\\t\\t\\tfogExp2: ( fog && fog.isFogExp2 ),\\r\\n\\r\\n\\t\\t\\tflatShading: material.flatShading,\\r\\n\\r\\n\\t\\t\\tsizeAttenuation: material.sizeAttenuation,\\r\\n\\t\\t\\tlogarithmicDepthBuffer: logarithmicDepthBuffer,\\r\\n\\r\\n\\t\\t\\tskinning: material.skinning && maxBones > 0,\\r\\n\\t\\t\\tmaxBones: maxBones,\\r\\n\\t\\t\\tuseVertexTexture: floatVertexTextures,\\r\\n\\r\\n\\t\\t\\tmorphTargets: material.morphTargets,\\r\\n\\t\\t\\tmorphNormals: material.morphNormals,\\r\\n\\t\\t\\tmaxMorphTargets: renderer.maxMorphTargets,\\r\\n\\t\\t\\tmaxMorphNormals: renderer.maxMorphNormals,\\r\\n\\r\\n\\t\\t\\tnumDirLights: lights.directional.length,\\r\\n\\t\\t\\tnumPointLights: lights.point.length,\\r\\n\\t\\t\\tnumSpotLights: lights.spot.length,\\r\\n\\t\\t\\tnumRectAreaLights: lights.rectArea.length,\\r\\n\\t\\t\\tnumHemiLights: lights.hemi.length,\\r\\n\\r\\n\\t\\t\\tnumDirLightShadows: lights.directionalShadowMap.length,\\r\\n\\t\\t\\tnumPointLightShadows: lights.pointShadowMap.length,\\r\\n\\t\\t\\tnumSpotLightShadows: lights.spotShadowMap.length,\\r\\n\\r\\n\\t\\t\\tnumClippingPlanes: nClipPlanes,\\r\\n\\t\\t\\tnumClipIntersection: nClipIntersection,\\r\\n\\r\\n\\t\\t\\tdithering: material.dithering,\\r\\n\\r\\n\\t\\t\\tshadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,\\r\\n\\t\\t\\tshadowMapType: renderer.shadowMap.type,\\r\\n\\r\\n\\t\\t\\ttoneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,\\r\\n\\t\\t\\tphysicallyCorrectLights: renderer.physicallyCorrectLights,\\r\\n\\r\\n\\t\\t\\tpremultipliedAlpha: material.premultipliedAlpha,\\r\\n\\r\\n\\t\\t\\talphaTest: material.alphaTest,\\r\\n\\t\\t\\tdoubleSided: material.side === DoubleSide,\\r\\n\\t\\t\\tflipSided: material.side === BackSide,\\r\\n\\r\\n\\t\\t\\tdepthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false,\\r\\n\\r\\n\\t\\t\\tindex0AttributeName: material.index0AttributeName,\\r\\n\\r\\n\\t\\t\\textensionDerivatives: material.extensions && material.extensions.derivatives,\\r\\n\\t\\t\\textensionFragDepth: material.extensions && material.extensions.fragDepth,\\r\\n\\t\\t\\textensionDrawBuffers: material.extensions && material.extensions.drawBuffers,\\r\\n\\t\\t\\textensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,\\r\\n\\r\\n\\t\\t\\trendererExtensionFragDepth: isWebGL2 || extensions.get( 'EXT_frag_depth' ) !== null,\\r\\n\\t\\t\\trendererExtensionDrawBuffers: isWebGL2 || extensions.get( 'WEBGL_draw_buffers' ) !== null,\\r\\n\\t\\t\\trendererExtensionShaderTextureLod: isWebGL2 || extensions.get( 'EXT_shader_texture_lod' ) !== null,\\r\\n\\r\\n\\t\\t\\tonBeforeCompile: material.onBeforeCompile\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\treturn parameters;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.getProgramCacheKey = function ( parameters ) {\\r\\n\\r\\n\\t\\tvar array = [];\\r\\n\\r\\n\\t\\tif ( parameters.shaderID ) {\\r\\n\\r\\n\\t\\t\\tarray.push( parameters.shaderID );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tarray.push( parameters.fragmentShader );\\r\\n\\t\\t\\tarray.push( parameters.vertexShader );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( parameters.defines !== undefined ) {\\r\\n\\r\\n\\t\\t\\tfor ( var name in parameters.defines ) {\\r\\n\\r\\n\\t\\t\\t\\tarray.push( name );\\r\\n\\t\\t\\t\\tarray.push( parameters.defines[ name ] );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( parameters.isRawShaderMaterial === undefined ) {\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < parameterNames.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tarray.push( parameters[ parameterNames[ i ] ] );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tarray.push( renderer.outputEncoding );\\r\\n\\t\\t\\tarray.push( renderer.gammaFactor );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tarray.push( parameters.onBeforeCompile.toString() );\\r\\n\\r\\n\\t\\treturn array.join();\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.acquireProgram = function ( parameters, cacheKey ) {\\r\\n\\r\\n\\t\\tvar program;\\r\\n\\r\\n\\t\\t// Check if code has been already compiled\\r\\n\\t\\tfor ( var p = 0, pl = programs.length; p < pl; p ++ ) {\\r\\n\\r\\n\\t\\t\\tvar preexistingProgram = programs[ p ];\\r\\n\\r\\n\\t\\t\\tif ( preexistingProgram.cacheKey === cacheKey ) {\\r\\n\\r\\n\\t\\t\\t\\tprogram = preexistingProgram;\\r\\n\\t\\t\\t\\t++ program.usedTimes;\\r\\n\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( program === undefined ) {\\r\\n\\r\\n\\t\\t\\tprogram = new WebGLProgram( renderer, cacheKey, parameters );\\r\\n\\t\\t\\tprograms.push( program );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn program;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.releaseProgram = function ( program ) {\\r\\n\\r\\n\\t\\tif ( -- program.usedTimes === 0 ) {\\r\\n\\r\\n\\t\\t\\t// Remove from unordered set\\r\\n\\t\\t\\tvar i = programs.indexOf( program );\\r\\n\\t\\t\\tprograms[ i ] = programs[ programs.length - 1 ];\\r\\n\\t\\t\\tprograms.pop();\\r\\n\\r\\n\\t\\t\\t// Free WebGL resources\\r\\n\\t\\t\\tprogram.destroy();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t// Exposed for resource monitoring & error feedback via renderer.info:\\r\\n\\tthis.programs = programs;\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * @author fordacious / fordacious.github.io\\r\\n */\\r\\n\\r\\nfunction WebGLProperties() {\\r\\n\\r\\n\\tvar properties = new WeakMap();\\r\\n\\r\\n\\tfunction get( object ) {\\r\\n\\r\\n\\t\\tvar map = properties.get( object );\\r\\n\\r\\n\\t\\tif ( map === undefined ) {\\r\\n\\r\\n\\t\\t\\tmap = {};\\r\\n\\t\\t\\tproperties.set( object, map );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn map;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction remove( object ) {\\r\\n\\r\\n\\t\\tproperties.delete( object );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction update( object, key, value ) {\\r\\n\\r\\n\\t\\tproperties.get( object )[ key ] = value;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction dispose() {\\r\\n\\r\\n\\t\\tproperties = new WeakMap();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn {\\r\\n\\t\\tget: get,\\r\\n\\t\\tremove: remove,\\r\\n\\t\\tupdate: update,\\r\\n\\t\\tdispose: dispose\\r\\n\\t};\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nfunction painterSortStable( a, b ) {\\r\\n\\r\\n\\tif ( a.groupOrder !== b.groupOrder ) {\\r\\n\\r\\n\\t\\treturn a.groupOrder - b.groupOrder;\\r\\n\\r\\n\\t} else if ( a.renderOrder !== b.renderOrder ) {\\r\\n\\r\\n\\t\\treturn a.renderOrder - b.renderOrder;\\r\\n\\r\\n\\t} else if ( a.program !== b.program ) {\\r\\n\\r\\n\\t\\treturn a.program.id - b.program.id;\\r\\n\\r\\n\\t} else if ( a.material.id !== b.material.id ) {\\r\\n\\r\\n\\t\\treturn a.material.id - b.material.id;\\r\\n\\r\\n\\t} else if ( a.z !== b.z ) {\\r\\n\\r\\n\\t\\treturn a.z - b.z;\\r\\n\\r\\n\\t} else {\\r\\n\\r\\n\\t\\treturn a.id - b.id;\\r\\n\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\\r\\nfunction reversePainterSortStable( a, b ) {\\r\\n\\r\\n\\tif ( a.groupOrder !== b.groupOrder ) {\\r\\n\\r\\n\\t\\treturn a.groupOrder - b.groupOrder;\\r\\n\\r\\n\\t} else if ( a.renderOrder !== b.renderOrder ) {\\r\\n\\r\\n\\t\\treturn a.renderOrder - b.renderOrder;\\r\\n\\r\\n\\t} else if ( a.z !== b.z ) {\\r\\n\\r\\n\\t\\treturn b.z - a.z;\\r\\n\\r\\n\\t} else {\\r\\n\\r\\n\\t\\treturn a.id - b.id;\\r\\n\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\\r\\n\\r\\nfunction WebGLRenderList() {\\r\\n\\r\\n\\tvar renderItems = [];\\r\\n\\tvar renderItemsIndex = 0;\\r\\n\\r\\n\\tvar opaque = [];\\r\\n\\tvar transparent = [];\\r\\n\\r\\n\\tvar defaultProgram = { id: - 1 };\\r\\n\\r\\n\\tfunction init() {\\r\\n\\r\\n\\t\\trenderItemsIndex = 0;\\r\\n\\r\\n\\t\\topaque.length = 0;\\r\\n\\t\\ttransparent.length = 0;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction getNextRenderItem( object, geometry, material, groupOrder, z, group ) {\\r\\n\\r\\n\\t\\tvar renderItem = renderItems[ renderItemsIndex ];\\r\\n\\r\\n\\t\\tif ( renderItem === undefined ) {\\r\\n\\r\\n\\t\\t\\trenderItem = {\\r\\n\\t\\t\\t\\tid: object.id,\\r\\n\\t\\t\\t\\tobject: object,\\r\\n\\t\\t\\t\\tgeometry: geometry,\\r\\n\\t\\t\\t\\tmaterial: material,\\r\\n\\t\\t\\t\\tprogram: material.program || defaultProgram,\\r\\n\\t\\t\\t\\tgroupOrder: groupOrder,\\r\\n\\t\\t\\t\\trenderOrder: object.renderOrder,\\r\\n\\t\\t\\t\\tz: z,\\r\\n\\t\\t\\t\\tgroup: group\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\trenderItems[ renderItemsIndex ] = renderItem;\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\trenderItem.id = object.id;\\r\\n\\t\\t\\trenderItem.object = object;\\r\\n\\t\\t\\trenderItem.geometry = geometry;\\r\\n\\t\\t\\trenderItem.material = material;\\r\\n\\t\\t\\trenderItem.program = material.program || defaultProgram;\\r\\n\\t\\t\\trenderItem.groupOrder = groupOrder;\\r\\n\\t\\t\\trenderItem.renderOrder = object.renderOrder;\\r\\n\\t\\t\\trenderItem.z = z;\\r\\n\\t\\t\\trenderItem.group = group;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\trenderItemsIndex ++;\\r\\n\\r\\n\\t\\treturn renderItem;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction push( object, geometry, material, groupOrder, z, group ) {\\r\\n\\r\\n\\t\\tvar renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );\\r\\n\\r\\n\\t\\t( material.transparent === true ? transparent : opaque ).push( renderItem );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction unshift( object, geometry, material, groupOrder, z, group ) {\\r\\n\\r\\n\\t\\tvar renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );\\r\\n\\r\\n\\t\\t( material.transparent === true ? transparent : opaque ).unshift( renderItem );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction sort( customOpaqueSort, customTransparentSort ) {\\r\\n\\r\\n\\t\\tif ( opaque.length > 1 ) opaque.sort( customOpaqueSort || painterSortStable );\\r\\n\\t\\tif ( transparent.length > 1 ) transparent.sort( customTransparentSort || reversePainterSortStable );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction finish() {\\r\\n\\r\\n\\t\\t// Clear references from inactive renderItems in the list\\r\\n\\r\\n\\t\\tfor ( var i = renderItemsIndex, il = renderItems.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar renderItem = renderItems[ i ];\\r\\n\\r\\n\\t\\t\\tif ( renderItem.id === null ) break;\\r\\n\\r\\n\\t\\t\\trenderItem.id = null;\\r\\n\\t\\t\\trenderItem.object = null;\\r\\n\\t\\t\\trenderItem.geometry = null;\\r\\n\\t\\t\\trenderItem.material = null;\\r\\n\\t\\t\\trenderItem.program = null;\\r\\n\\t\\t\\trenderItem.group = null;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn {\\r\\n\\t\\topaque: opaque,\\r\\n\\t\\ttransparent: transparent,\\r\\n\\r\\n\\t\\tinit: init,\\r\\n\\t\\tpush: push,\\r\\n\\t\\tunshift: unshift,\\r\\n\\t\\tfinish: finish,\\r\\n\\r\\n\\t\\tsort: sort\\r\\n\\t};\\r\\n\\r\\n}\\r\\n\\r\\nfunction WebGLRenderLists() {\\r\\n\\r\\n\\tvar lists = new WeakMap();\\r\\n\\r\\n\\tfunction onSceneDispose( event ) {\\r\\n\\r\\n\\t\\tvar scene = event.target;\\r\\n\\r\\n\\t\\tscene.removeEventListener( 'dispose', onSceneDispose );\\r\\n\\r\\n\\t\\tlists.delete( scene );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction get( scene, camera ) {\\r\\n\\r\\n\\t\\tvar cameras = lists.get( scene );\\r\\n\\t\\tvar list;\\r\\n\\t\\tif ( cameras === undefined ) {\\r\\n\\r\\n\\t\\t\\tlist = new WebGLRenderList();\\r\\n\\t\\t\\tlists.set( scene, new WeakMap() );\\r\\n\\t\\t\\tlists.get( scene ).set( camera, list );\\r\\n\\r\\n\\t\\t\\tscene.addEventListener( 'dispose', onSceneDispose );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tlist = cameras.get( camera );\\r\\n\\t\\t\\tif ( list === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tlist = new WebGLRenderList();\\r\\n\\t\\t\\t\\tcameras.set( camera, list );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn list;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction dispose() {\\r\\n\\r\\n\\t\\tlists = new WeakMap();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn {\\r\\n\\t\\tget: get,\\r\\n\\t\\tdispose: dispose\\r\\n\\t};\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nfunction UniformsCache() {\\r\\n\\r\\n\\tvar lights = {};\\r\\n\\r\\n\\treturn {\\r\\n\\r\\n\\t\\tget: function ( light ) {\\r\\n\\r\\n\\t\\t\\tif ( lights[ light.id ] !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\treturn lights[ light.id ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar uniforms;\\r\\n\\r\\n\\t\\t\\tswitch ( light.type ) {\\r\\n\\r\\n\\t\\t\\t\\tcase 'DirectionalLight':\\r\\n\\t\\t\\t\\t\\tuniforms = {\\r\\n\\t\\t\\t\\t\\t\\tdirection: new Vector3(),\\r\\n\\t\\t\\t\\t\\t\\tcolor: new Color()\\r\\n\\t\\t\\t\\t\\t};\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\tcase 'SpotLight':\\r\\n\\t\\t\\t\\t\\tuniforms = {\\r\\n\\t\\t\\t\\t\\t\\tposition: new Vector3(),\\r\\n\\t\\t\\t\\t\\t\\tdirection: new Vector3(),\\r\\n\\t\\t\\t\\t\\t\\tcolor: new Color(),\\r\\n\\t\\t\\t\\t\\t\\tdistance: 0,\\r\\n\\t\\t\\t\\t\\t\\tconeCos: 0,\\r\\n\\t\\t\\t\\t\\t\\tpenumbraCos: 0,\\r\\n\\t\\t\\t\\t\\t\\tdecay: 0\\r\\n\\t\\t\\t\\t\\t};\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\tcase 'PointLight':\\r\\n\\t\\t\\t\\t\\tuniforms = {\\r\\n\\t\\t\\t\\t\\t\\tposition: new Vector3(),\\r\\n\\t\\t\\t\\t\\t\\tcolor: new Color(),\\r\\n\\t\\t\\t\\t\\t\\tdistance: 0,\\r\\n\\t\\t\\t\\t\\t\\tdecay: 0\\r\\n\\t\\t\\t\\t\\t};\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\tcase 'HemisphereLight':\\r\\n\\t\\t\\t\\t\\tuniforms = {\\r\\n\\t\\t\\t\\t\\t\\tdirection: new Vector3(),\\r\\n\\t\\t\\t\\t\\t\\tskyColor: new Color(),\\r\\n\\t\\t\\t\\t\\t\\tgroundColor: new Color()\\r\\n\\t\\t\\t\\t\\t};\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\tcase 'RectAreaLight':\\r\\n\\t\\t\\t\\t\\tuniforms = {\\r\\n\\t\\t\\t\\t\\t\\tcolor: new Color(),\\r\\n\\t\\t\\t\\t\\t\\tposition: new Vector3(),\\r\\n\\t\\t\\t\\t\\t\\thalfWidth: new Vector3(),\\r\\n\\t\\t\\t\\t\\t\\thalfHeight: new Vector3()\\r\\n\\t\\t\\t\\t\\t};\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tlights[ light.id ] = uniforms;\\r\\n\\r\\n\\t\\t\\treturn uniforms;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t};\\r\\n\\r\\n}\\r\\n\\r\\nfunction ShadowUniformsCache() {\\r\\n\\r\\n\\tvar lights = {};\\r\\n\\r\\n\\treturn {\\r\\n\\r\\n\\t\\tget: function ( light ) {\\r\\n\\r\\n\\t\\t\\tif ( lights[ light.id ] !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\treturn lights[ light.id ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar uniforms;\\r\\n\\r\\n\\t\\t\\tswitch ( light.type ) {\\r\\n\\r\\n\\t\\t\\t\\tcase 'DirectionalLight':\\r\\n\\t\\t\\t\\t\\tuniforms = {\\r\\n\\t\\t\\t\\t\\t\\tshadowBias: 0,\\r\\n\\t\\t\\t\\t\\t\\tshadowRadius: 1,\\r\\n\\t\\t\\t\\t\\t\\tshadowMapSize: new Vector2()\\r\\n\\t\\t\\t\\t\\t};\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\tcase 'SpotLight':\\r\\n\\t\\t\\t\\t\\tuniforms = {\\r\\n\\t\\t\\t\\t\\t\\tshadowBias: 0,\\r\\n\\t\\t\\t\\t\\t\\tshadowRadius: 1,\\r\\n\\t\\t\\t\\t\\t\\tshadowMapSize: new Vector2()\\r\\n\\t\\t\\t\\t\\t};\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\tcase 'PointLight':\\r\\n\\t\\t\\t\\t\\tuniforms = {\\r\\n\\t\\t\\t\\t\\t\\tshadowBias: 0,\\r\\n\\t\\t\\t\\t\\t\\tshadowRadius: 1,\\r\\n\\t\\t\\t\\t\\t\\tshadowMapSize: new Vector2(),\\r\\n\\t\\t\\t\\t\\t\\tshadowCameraNear: 1,\\r\\n\\t\\t\\t\\t\\t\\tshadowCameraFar: 1000\\r\\n\\t\\t\\t\\t\\t};\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t// TODO (abelnation): set RectAreaLight shadow uniforms\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tlights[ light.id ] = uniforms;\\r\\n\\r\\n\\t\\t\\treturn uniforms;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t};\\r\\n\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\nvar nextVersion = 0;\\r\\n\\r\\nfunction shadowCastingLightsFirst( lightA, lightB ) {\\r\\n\\r\\n\\treturn ( lightB.castShadow ? 1 : 0 ) - ( lightA.castShadow ? 1 : 0 );\\r\\n\\r\\n}\\r\\n\\r\\nfunction WebGLLights() {\\r\\n\\r\\n\\tvar cache = new UniformsCache();\\r\\n\\r\\n\\tvar shadowCache = ShadowUniformsCache();\\r\\n\\r\\n\\tvar state = {\\r\\n\\r\\n\\t\\tversion: 0,\\r\\n\\r\\n\\t\\thash: {\\r\\n\\t\\t\\tdirectionalLength: - 1,\\r\\n\\t\\t\\tpointLength: - 1,\\r\\n\\t\\t\\tspotLength: - 1,\\r\\n\\t\\t\\trectAreaLength: - 1,\\r\\n\\t\\t\\themiLength: - 1,\\r\\n\\r\\n\\t\\t\\tnumDirectionalShadows: - 1,\\r\\n\\t\\t\\tnumPointShadows: - 1,\\r\\n\\t\\t\\tnumSpotShadows: - 1\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tambient: [ 0, 0, 0 ],\\r\\n\\t\\tprobe: [],\\r\\n\\t\\tdirectional: [],\\r\\n\\t\\tdirectionalShadow: [],\\r\\n\\t\\tdirectionalShadowMap: [],\\r\\n\\t\\tdirectionalShadowMatrix: [],\\r\\n\\t\\tspot: [],\\r\\n\\t\\tspotShadow: [],\\r\\n\\t\\tspotShadowMap: [],\\r\\n\\t\\tspotShadowMatrix: [],\\r\\n\\t\\trectArea: [],\\r\\n\\t\\tpoint: [],\\r\\n\\t\\tpointShadow: [],\\r\\n\\t\\tpointShadowMap: [],\\r\\n\\t\\tpointShadowMatrix: [],\\r\\n\\t\\themi: []\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tfor ( var i = 0; i < 9; i ++ ) state.probe.push( new Vector3() );\\r\\n\\r\\n\\tvar vector3 = new Vector3();\\r\\n\\tvar matrix4 = new Matrix4();\\r\\n\\tvar matrix42 = new Matrix4();\\r\\n\\r\\n\\tfunction setup( lights, shadows, camera ) {\\r\\n\\r\\n\\t\\tvar r = 0, g = 0, b = 0;\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < 9; i ++ ) state.probe[ i ].set( 0, 0, 0 );\\r\\n\\r\\n\\t\\tvar directionalLength = 0;\\r\\n\\t\\tvar pointLength = 0;\\r\\n\\t\\tvar spotLength = 0;\\r\\n\\t\\tvar rectAreaLength = 0;\\r\\n\\t\\tvar hemiLength = 0;\\r\\n\\r\\n\\t\\tvar numDirectionalShadows = 0;\\r\\n\\t\\tvar numPointShadows = 0;\\r\\n\\t\\tvar numSpotShadows = 0;\\r\\n\\r\\n\\t\\tvar viewMatrix = camera.matrixWorldInverse;\\r\\n\\r\\n\\t\\tlights.sort( shadowCastingLightsFirst );\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = lights.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar light = lights[ i ];\\r\\n\\r\\n\\t\\t\\tvar color = light.color;\\r\\n\\t\\t\\tvar intensity = light.intensity;\\r\\n\\t\\t\\tvar distance = light.distance;\\r\\n\\r\\n\\t\\t\\tvar shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;\\r\\n\\r\\n\\t\\t\\tif ( light.isAmbientLight ) {\\r\\n\\r\\n\\t\\t\\t\\tr += color.r * intensity;\\r\\n\\t\\t\\t\\tg += color.g * intensity;\\r\\n\\t\\t\\t\\tb += color.b * intensity;\\r\\n\\r\\n\\t\\t\\t} else if ( light.isLightProbe ) {\\r\\n\\r\\n\\t\\t\\t\\tfor ( var j = 0; j < 9; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tstate.probe[ j ].addScaledVector( light.sh.coefficients[ j ], intensity );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} else if ( light.isDirectionalLight ) {\\r\\n\\r\\n\\t\\t\\t\\tvar uniforms = cache.get( light );\\r\\n\\r\\n\\t\\t\\t\\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\\r\\n\\t\\t\\t\\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\\r\\n\\t\\t\\t\\tvector3.setFromMatrixPosition( light.target.matrixWorld );\\r\\n\\t\\t\\t\\tuniforms.direction.sub( vector3 );\\r\\n\\t\\t\\t\\tuniforms.direction.transformDirection( viewMatrix );\\r\\n\\r\\n\\t\\t\\t\\tif ( light.castShadow ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar shadow = light.shadow;\\r\\n\\r\\n\\t\\t\\t\\t\\tvar shadowUniforms = shadowCache.get( light );\\r\\n\\r\\n\\t\\t\\t\\t\\tshadowUniforms.shadowBias = shadow.bias;\\r\\n\\t\\t\\t\\t\\tshadowUniforms.shadowRadius = shadow.radius;\\r\\n\\t\\t\\t\\t\\tshadowUniforms.shadowMapSize = shadow.mapSize;\\r\\n\\r\\n\\t\\t\\t\\t\\tstate.directionalShadow[ directionalLength ] = shadowUniforms;\\r\\n\\t\\t\\t\\t\\tstate.directionalShadowMap[ directionalLength ] = shadowMap;\\r\\n\\t\\t\\t\\t\\tstate.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;\\r\\n\\r\\n\\t\\t\\t\\t\\tnumDirectionalShadows ++;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tstate.directional[ directionalLength ] = uniforms;\\r\\n\\r\\n\\t\\t\\t\\tdirectionalLength ++;\\r\\n\\r\\n\\t\\t\\t} else if ( light.isSpotLight ) {\\r\\n\\r\\n\\t\\t\\t\\tvar uniforms = cache.get( light );\\r\\n\\r\\n\\t\\t\\t\\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\\r\\n\\t\\t\\t\\tuniforms.position.applyMatrix4( viewMatrix );\\r\\n\\r\\n\\t\\t\\t\\tuniforms.color.copy( color ).multiplyScalar( intensity );\\r\\n\\t\\t\\t\\tuniforms.distance = distance;\\r\\n\\r\\n\\t\\t\\t\\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\\r\\n\\t\\t\\t\\tvector3.setFromMatrixPosition( light.target.matrixWorld );\\r\\n\\t\\t\\t\\tuniforms.direction.sub( vector3 );\\r\\n\\t\\t\\t\\tuniforms.direction.transformDirection( viewMatrix );\\r\\n\\r\\n\\t\\t\\t\\tuniforms.coneCos = Math.cos( light.angle );\\r\\n\\t\\t\\t\\tuniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );\\r\\n\\t\\t\\t\\tuniforms.decay = light.decay;\\r\\n\\r\\n\\t\\t\\t\\tif ( light.castShadow ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar shadow = light.shadow;\\r\\n\\r\\n\\t\\t\\t\\t\\tvar shadowUniforms = shadowCache.get( light );\\r\\n\\r\\n\\t\\t\\t\\t\\tshadowUniforms.shadowBias = shadow.bias;\\r\\n\\t\\t\\t\\t\\tshadowUniforms.shadowRadius = shadow.radius;\\r\\n\\t\\t\\t\\t\\tshadowUniforms.shadowMapSize = shadow.mapSize;\\r\\n\\r\\n\\t\\t\\t\\t\\tstate.spotShadow[ spotLength ] = shadowUniforms;\\r\\n\\t\\t\\t\\t\\tstate.spotShadowMap[ spotLength ] = shadowMap;\\r\\n\\t\\t\\t\\t\\tstate.spotShadowMatrix[ spotLength ] = light.shadow.matrix;\\r\\n\\r\\n\\t\\t\\t\\t\\tnumSpotShadows ++;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tstate.spot[ spotLength ] = uniforms;\\r\\n\\r\\n\\t\\t\\t\\tspotLength ++;\\r\\n\\r\\n\\t\\t\\t} else if ( light.isRectAreaLight ) {\\r\\n\\r\\n\\t\\t\\t\\tvar uniforms = cache.get( light );\\r\\n\\r\\n\\t\\t\\t\\t// (a) intensity is the total visible light emitted\\r\\n\\t\\t\\t\\t//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );\\r\\n\\r\\n\\t\\t\\t\\t// (b) intensity is the brightness of the light\\r\\n\\t\\t\\t\\tuniforms.color.copy( color ).multiplyScalar( intensity );\\r\\n\\r\\n\\t\\t\\t\\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\\r\\n\\t\\t\\t\\tuniforms.position.applyMatrix4( viewMatrix );\\r\\n\\r\\n\\t\\t\\t\\t// extract local rotation of light to derive width/height half vectors\\r\\n\\t\\t\\t\\tmatrix42.identity();\\r\\n\\t\\t\\t\\tmatrix4.copy( light.matrixWorld );\\r\\n\\t\\t\\t\\tmatrix4.premultiply( viewMatrix );\\r\\n\\t\\t\\t\\tmatrix42.extractRotation( matrix4 );\\r\\n\\r\\n\\t\\t\\t\\tuniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );\\r\\n\\t\\t\\t\\tuniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );\\r\\n\\r\\n\\t\\t\\t\\tuniforms.halfWidth.applyMatrix4( matrix42 );\\r\\n\\t\\t\\t\\tuniforms.halfHeight.applyMatrix4( matrix42 );\\r\\n\\r\\n\\t\\t\\t\\t// TODO (abelnation): RectAreaLight distance?\\r\\n\\t\\t\\t\\t// uniforms.distance = distance;\\r\\n\\r\\n\\t\\t\\t\\tstate.rectArea[ rectAreaLength ] = uniforms;\\r\\n\\r\\n\\t\\t\\t\\trectAreaLength ++;\\r\\n\\r\\n\\t\\t\\t} else if ( light.isPointLight ) {\\r\\n\\r\\n\\t\\t\\t\\tvar uniforms = cache.get( light );\\r\\n\\r\\n\\t\\t\\t\\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\\r\\n\\t\\t\\t\\tuniforms.position.applyMatrix4( viewMatrix );\\r\\n\\r\\n\\t\\t\\t\\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\\r\\n\\t\\t\\t\\tuniforms.distance = light.distance;\\r\\n\\t\\t\\t\\tuniforms.decay = light.decay;\\r\\n\\r\\n\\t\\t\\t\\tif ( light.castShadow ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar shadow = light.shadow;\\r\\n\\r\\n\\t\\t\\t\\t\\tvar shadowUniforms = shadowCache.get( light );\\r\\n\\r\\n\\t\\t\\t\\t\\tshadowUniforms.shadowBias = shadow.bias;\\r\\n\\t\\t\\t\\t\\tshadowUniforms.shadowRadius = shadow.radius;\\r\\n\\t\\t\\t\\t\\tshadowUniforms.shadowMapSize = shadow.mapSize;\\r\\n\\t\\t\\t\\t\\tshadowUniforms.shadowCameraNear = shadow.camera.near;\\r\\n\\t\\t\\t\\t\\tshadowUniforms.shadowCameraFar = shadow.camera.far;\\r\\n\\r\\n\\t\\t\\t\\t\\tstate.pointShadow[ pointLength ] = shadowUniforms;\\r\\n\\t\\t\\t\\t\\tstate.pointShadowMap[ pointLength ] = shadowMap;\\r\\n\\t\\t\\t\\t\\tstate.pointShadowMatrix[ pointLength ] = light.shadow.matrix;\\r\\n\\r\\n\\t\\t\\t\\t\\tnumPointShadows ++;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tstate.point[ pointLength ] = uniforms;\\r\\n\\r\\n\\t\\t\\t\\tpointLength ++;\\r\\n\\r\\n\\t\\t\\t} else if ( light.isHemisphereLight ) {\\r\\n\\r\\n\\t\\t\\t\\tvar uniforms = cache.get( light );\\r\\n\\r\\n\\t\\t\\t\\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\\r\\n\\t\\t\\t\\tuniforms.direction.transformDirection( viewMatrix );\\r\\n\\t\\t\\t\\tuniforms.direction.normalize();\\r\\n\\r\\n\\t\\t\\t\\tuniforms.skyColor.copy( light.color ).multiplyScalar( intensity );\\r\\n\\t\\t\\t\\tuniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );\\r\\n\\r\\n\\t\\t\\t\\tstate.hemi[ hemiLength ] = uniforms;\\r\\n\\r\\n\\t\\t\\t\\themiLength ++;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tstate.ambient[ 0 ] = r;\\r\\n\\t\\tstate.ambient[ 1 ] = g;\\r\\n\\t\\tstate.ambient[ 2 ] = b;\\r\\n\\r\\n\\t\\tvar hash = state.hash;\\r\\n\\r\\n\\t\\tif ( hash.directionalLength !== directionalLength ||\\r\\n\\t\\t\\thash.pointLength !== pointLength ||\\r\\n\\t\\t\\thash.spotLength !== spotLength ||\\r\\n\\t\\t\\thash.rectAreaLength !== rectAreaLength ||\\r\\n\\t\\t\\thash.hemiLength !== hemiLength ||\\r\\n\\t\\t\\thash.numDirectionalShadows !== numDirectionalShadows ||\\r\\n\\t\\t\\thash.numPointShadows !== numPointShadows ||\\r\\n\\t\\t\\thash.numSpotShadows !== numSpotShadows ) {\\r\\n\\r\\n\\t\\t\\tstate.directional.length = directionalLength;\\r\\n\\t\\t\\tstate.spot.length = spotLength;\\r\\n\\t\\t\\tstate.rectArea.length = rectAreaLength;\\r\\n\\t\\t\\tstate.point.length = pointLength;\\r\\n\\t\\t\\tstate.hemi.length = hemiLength;\\r\\n\\r\\n\\t\\t\\tstate.directionalShadow.length = numDirectionalShadows;\\r\\n\\t\\t\\tstate.directionalShadowMap.length = numDirectionalShadows;\\r\\n\\t\\t\\tstate.pointShadow.length = numPointShadows;\\r\\n\\t\\t\\tstate.pointShadowMap.length = numPointShadows;\\r\\n\\t\\t\\tstate.spotShadow.length = numSpotShadows;\\r\\n\\t\\t\\tstate.spotShadowMap.length = numSpotShadows;\\r\\n\\t\\t\\tstate.directionalShadowMatrix.length = numDirectionalShadows;\\r\\n\\t\\t\\tstate.pointShadowMatrix.length = numPointShadows;\\r\\n\\t\\t\\tstate.spotShadowMatrix.length = numSpotShadows;\\r\\n\\r\\n\\t\\t\\thash.directionalLength = directionalLength;\\r\\n\\t\\t\\thash.pointLength = pointLength;\\r\\n\\t\\t\\thash.spotLength = spotLength;\\r\\n\\t\\t\\thash.rectAreaLength = rectAreaLength;\\r\\n\\t\\t\\thash.hemiLength = hemiLength;\\r\\n\\r\\n\\t\\t\\thash.numDirectionalShadows = numDirectionalShadows;\\r\\n\\t\\t\\thash.numPointShadows = numPointShadows;\\r\\n\\t\\t\\thash.numSpotShadows = numSpotShadows;\\r\\n\\r\\n\\t\\t\\tstate.version = nextVersion ++;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn {\\r\\n\\t\\tsetup: setup,\\r\\n\\t\\tstate: state\\r\\n\\t};\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * @author Mugen87 / https://github.com/Mugen87\\r\\n */\\r\\n\\r\\nfunction WebGLRenderState() {\\r\\n\\r\\n\\tvar lights = new WebGLLights();\\r\\n\\r\\n\\tvar lightsArray = [];\\r\\n\\tvar shadowsArray = [];\\r\\n\\r\\n\\tfunction init() {\\r\\n\\r\\n\\t\\tlightsArray.length = 0;\\r\\n\\t\\tshadowsArray.length = 0;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction pushLight( light ) {\\r\\n\\r\\n\\t\\tlightsArray.push( light );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction pushShadow( shadowLight ) {\\r\\n\\r\\n\\t\\tshadowsArray.push( shadowLight );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction setupLights( camera ) {\\r\\n\\r\\n\\t\\tlights.setup( lightsArray, shadowsArray, camera );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tvar state = {\\r\\n\\t\\tlightsArray: lightsArray,\\r\\n\\t\\tshadowsArray: shadowsArray,\\r\\n\\r\\n\\t\\tlights: lights\\r\\n\\t};\\r\\n\\r\\n\\treturn {\\r\\n\\t\\tinit: init,\\r\\n\\t\\tstate: state,\\r\\n\\t\\tsetupLights: setupLights,\\r\\n\\r\\n\\t\\tpushLight: pushLight,\\r\\n\\t\\tpushShadow: pushShadow\\r\\n\\t};\\r\\n\\r\\n}\\r\\n\\r\\nfunction WebGLRenderStates() {\\r\\n\\r\\n\\tvar renderStates = new WeakMap();\\r\\n\\r\\n\\tfunction onSceneDispose( event ) {\\r\\n\\r\\n\\t\\tvar scene = event.target;\\r\\n\\r\\n\\t\\tscene.removeEventListener( 'dispose', onSceneDispose );\\r\\n\\r\\n\\t\\trenderStates.delete( scene );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction get( scene, camera ) {\\r\\n\\r\\n\\t\\tvar renderState;\\r\\n\\r\\n\\t\\tif ( renderStates.has( scene ) === false ) {\\r\\n\\r\\n\\t\\t\\trenderState = new WebGLRenderState();\\r\\n\\t\\t\\trenderStates.set( scene, new WeakMap() );\\r\\n\\t\\t\\trenderStates.get( scene ).set( camera, renderState );\\r\\n\\r\\n\\t\\t\\tscene.addEventListener( 'dispose', onSceneDispose );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tif ( renderStates.get( scene ).has( camera ) === false ) {\\r\\n\\r\\n\\t\\t\\t\\trenderState = new WebGLRenderState();\\r\\n\\t\\t\\t\\trenderStates.get( scene ).set( camera, renderState );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\trenderState = renderStates.get( scene ).get( camera );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn renderState;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction dispose() {\\r\\n\\r\\n\\t\\trenderStates = new WeakMap();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn {\\r\\n\\t\\tget: get,\\r\\n\\t\\tdispose: dispose\\r\\n\\t};\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n * @author bhouston / https://clara.io\\r\\n * @author WestLangley / http://github.com/WestLangley\\r\\n *\\r\\n * parameters = {\\r\\n *\\r\\n *  opacity: <float>,\\r\\n *\\r\\n *  map: new THREE.Texture( <Image> ),\\r\\n *\\r\\n *  alphaMap: new THREE.Texture( <Image> ),\\r\\n *\\r\\n *  displacementMap: new THREE.Texture( <Image> ),\\r\\n *  displacementScale: <float>,\\r\\n *  displacementBias: <float>,\\r\\n *\\r\\n *  wireframe: <boolean>,\\r\\n *  wireframeLinewidth: <float>\\r\\n * }\\r\\n */\\r\\n\\r\\nfunction MeshDepthMaterial( parameters ) {\\r\\n\\r\\n\\tMaterial.call( this );\\r\\n\\r\\n\\tthis.type = 'MeshDepthMaterial';\\r\\n\\r\\n\\tthis.depthPacking = BasicDepthPacking;\\r\\n\\r\\n\\tthis.skinning = false;\\r\\n\\tthis.morphTargets = false;\\r\\n\\r\\n\\tthis.map = null;\\r\\n\\r\\n\\tthis.alphaMap = null;\\r\\n\\r\\n\\tthis.displacementMap = null;\\r\\n\\tthis.displacementScale = 1;\\r\\n\\tthis.displacementBias = 0;\\r\\n\\r\\n\\tthis.wireframe = false;\\r\\n\\tthis.wireframeLinewidth = 1;\\r\\n\\r\\n\\tthis.fog = false;\\r\\n\\r\\n\\tthis.setValues( parameters );\\r\\n\\r\\n}\\r\\n\\r\\nMeshDepthMaterial.prototype = Object.create( Material.prototype );\\r\\nMeshDepthMaterial.prototype.constructor = MeshDepthMaterial;\\r\\n\\r\\nMeshDepthMaterial.prototype.isMeshDepthMaterial = true;\\r\\n\\r\\nMeshDepthMaterial.prototype.copy = function ( source ) {\\r\\n\\r\\n\\tMaterial.prototype.copy.call( this, source );\\r\\n\\r\\n\\tthis.depthPacking = source.depthPacking;\\r\\n\\r\\n\\tthis.skinning = source.skinning;\\r\\n\\tthis.morphTargets = source.morphTargets;\\r\\n\\r\\n\\tthis.map = source.map;\\r\\n\\r\\n\\tthis.alphaMap = source.alphaMap;\\r\\n\\r\\n\\tthis.displacementMap = source.displacementMap;\\r\\n\\tthis.displacementScale = source.displacementScale;\\r\\n\\tthis.displacementBias = source.displacementBias;\\r\\n\\r\\n\\tthis.wireframe = source.wireframe;\\r\\n\\tthis.wireframeLinewidth = source.wireframeLinewidth;\\r\\n\\r\\n\\treturn this;\\r\\n\\r\\n};\\r\\n\\r\\n/**\\r\\n * @author WestLangley / http://github.com/WestLangley\\r\\n *\\r\\n * parameters = {\\r\\n *\\r\\n *  referencePosition: <float>,\\r\\n *  nearDistance: <float>,\\r\\n *  farDistance: <float>,\\r\\n *\\r\\n *  skinning: <bool>,\\r\\n *  morphTargets: <bool>,\\r\\n *\\r\\n *  map: new THREE.Texture( <Image> ),\\r\\n *\\r\\n *  alphaMap: new THREE.Texture( <Image> ),\\r\\n *\\r\\n *  displacementMap: new THREE.Texture( <Image> ),\\r\\n *  displacementScale: <float>,\\r\\n *  displacementBias: <float>\\r\\n *\\r\\n * }\\r\\n */\\r\\n\\r\\nfunction MeshDistanceMaterial( parameters ) {\\r\\n\\r\\n\\tMaterial.call( this );\\r\\n\\r\\n\\tthis.type = 'MeshDistanceMaterial';\\r\\n\\r\\n\\tthis.referencePosition = new Vector3();\\r\\n\\tthis.nearDistance = 1;\\r\\n\\tthis.farDistance = 1000;\\r\\n\\r\\n\\tthis.skinning = false;\\r\\n\\tthis.morphTargets = false;\\r\\n\\r\\n\\tthis.map = null;\\r\\n\\r\\n\\tthis.alphaMap = null;\\r\\n\\r\\n\\tthis.displacementMap = null;\\r\\n\\tthis.displacementScale = 1;\\r\\n\\tthis.displacementBias = 0;\\r\\n\\r\\n\\tthis.fog = false;\\r\\n\\r\\n\\tthis.setValues( parameters );\\r\\n\\r\\n}\\r\\n\\r\\nMeshDistanceMaterial.prototype = Object.create( Material.prototype );\\r\\nMeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;\\r\\n\\r\\nMeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;\\r\\n\\r\\nMeshDistanceMaterial.prototype.copy = function ( source ) {\\r\\n\\r\\n\\tMaterial.prototype.copy.call( this, source );\\r\\n\\r\\n\\tthis.referencePosition.copy( source.referencePosition );\\r\\n\\tthis.nearDistance = source.nearDistance;\\r\\n\\tthis.farDistance = source.farDistance;\\r\\n\\r\\n\\tthis.skinning = source.skinning;\\r\\n\\tthis.morphTargets = source.morphTargets;\\r\\n\\r\\n\\tthis.map = source.map;\\r\\n\\r\\n\\tthis.alphaMap = source.alphaMap;\\r\\n\\r\\n\\tthis.displacementMap = source.displacementMap;\\r\\n\\tthis.displacementScale = source.displacementScale;\\r\\n\\tthis.displacementBias = source.displacementBias;\\r\\n\\r\\n\\treturn this;\\r\\n\\r\\n};\\r\\n\\r\\nvar vsm_frag = \\\"uniform sampler2D shadow_pass;\\\\nuniform vec2 resolution;\\\\nuniform float radius;\\\\n#include <packing>\\\\nvoid main() {\\\\n  float mean = 0.0;\\\\n  float squared_mean = 0.0;\\\\n\\\\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\\\\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\\\\n    #ifdef HORIZONAL_PASS\\\\n      vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\\\\n      mean += distribution.x;\\\\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\\\\n    #else\\\\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\\\\n      mean += depth;\\\\n      squared_mean += depth * depth;\\\\n    #endif\\\\n  }\\\\n  mean = mean * HALF_SAMPLE_RATE;\\\\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\\\\n  float std_dev = sqrt( squared_mean - mean * mean );\\\\n  gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\\\\n}\\\";\\r\\n\\r\\nvar vsm_vert = \\\"void main() {\\\\n\\\\tgl_Position = vec4( position, 1.0 );\\\\n}\\\";\\r\\n\\r\\n/**\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nfunction WebGLShadowMap( _renderer, _objects, maxTextureSize ) {\\r\\n\\r\\n\\tvar _frustum = new Frustum(),\\r\\n\\r\\n\\t\\t_shadowMapSize = new Vector2(),\\r\\n\\t\\t_viewportSize = new Vector2(),\\r\\n\\r\\n\\t\\t_viewport = new Vector4(),\\r\\n\\r\\n\\t\\t_depthMaterials = [],\\r\\n\\t\\t_distanceMaterials = [],\\r\\n\\r\\n\\t\\t_materialCache = {};\\r\\n\\r\\n\\tvar shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };\\r\\n\\r\\n\\tvar shadowMaterialVertical = new ShaderMaterial( {\\r\\n\\r\\n\\t\\tdefines: {\\r\\n\\t\\t\\tSAMPLE_RATE: 2.0 / 8.0,\\r\\n\\t\\t\\tHALF_SAMPLE_RATE: 1.0 / 8.0\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tuniforms: {\\r\\n\\t\\t\\tshadow_pass: { value: null },\\r\\n\\t\\t\\tresolution: { value: new Vector2() },\\r\\n\\t\\t\\tradius: { value: 4.0 }\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tvertexShader: vsm_vert,\\r\\n\\r\\n\\t\\tfragmentShader: vsm_frag\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\tvar shadowMaterialHorizonal = shadowMaterialVertical.clone();\\r\\n\\tshadowMaterialHorizonal.defines.HORIZONAL_PASS = 1;\\r\\n\\r\\n\\tvar fullScreenTri = new BufferGeometry();\\r\\n\\tfullScreenTri.setAttribute(\\r\\n\\t\\t\\\"position\\\",\\r\\n\\t\\tnew BufferAttribute(\\r\\n\\t\\t\\tnew Float32Array( [ - 1, - 1, 0.5, 3, - 1, 0.5, - 1, 3, 0.5 ] ),\\r\\n\\t\\t\\t3\\r\\n\\t\\t)\\r\\n\\t);\\r\\n\\r\\n\\tvar fullScreenMesh = new Mesh( fullScreenTri, shadowMaterialVertical );\\r\\n\\r\\n\\tvar scope = this;\\r\\n\\r\\n\\tthis.enabled = false;\\r\\n\\r\\n\\tthis.autoUpdate = true;\\r\\n\\tthis.needsUpdate = false;\\r\\n\\r\\n\\tthis.type = PCFShadowMap;\\r\\n\\r\\n\\tthis.render = function ( lights, scene, camera ) {\\r\\n\\r\\n\\t\\tif ( scope.enabled === false ) return;\\r\\n\\t\\tif ( scope.autoUpdate === false && scope.needsUpdate === false ) return;\\r\\n\\r\\n\\t\\tif ( lights.length === 0 ) return;\\r\\n\\r\\n\\t\\tvar currentRenderTarget = _renderer.getRenderTarget();\\r\\n\\t\\tvar activeCubeFace = _renderer.getActiveCubeFace();\\r\\n\\t\\tvar activeMipmapLevel = _renderer.getActiveMipmapLevel();\\r\\n\\r\\n\\t\\tvar _state = _renderer.state;\\r\\n\\r\\n\\t\\t// Set GL state for depth map.\\r\\n\\t\\t_state.setBlending( NoBlending );\\r\\n\\t\\t_state.buffers.color.setClear( 1, 1, 1, 1 );\\r\\n\\t\\t_state.buffers.depth.setTest( true );\\r\\n\\t\\t_state.setScissorTest( false );\\r\\n\\r\\n\\t\\t// render depth map\\r\\n\\r\\n\\t\\tfor ( var i = 0, il = lights.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar light = lights[ i ];\\r\\n\\t\\t\\tvar shadow = light.shadow;\\r\\n\\r\\n\\t\\t\\tif ( shadow === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );\\r\\n\\t\\t\\t\\tcontinue;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t_shadowMapSize.copy( shadow.mapSize );\\r\\n\\r\\n\\t\\t\\tvar shadowFrameExtents = shadow.getFrameExtents();\\r\\n\\r\\n\\t\\t\\t_shadowMapSize.multiply( shadowFrameExtents );\\r\\n\\r\\n\\t\\t\\t_viewportSize.copy( shadow.mapSize );\\r\\n\\r\\n\\t\\t\\tif ( _shadowMapSize.x > maxTextureSize || _shadowMapSize.y > maxTextureSize ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( _shadowMapSize.x > maxTextureSize ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t_viewportSize.x = Math.floor( maxTextureSize / shadowFrameExtents.x );\\r\\n\\t\\t\\t\\t\\t_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;\\r\\n\\t\\t\\t\\t\\tshadow.mapSize.x = _viewportSize.x;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( _shadowMapSize.y > maxTextureSize ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t_viewportSize.y = Math.floor( maxTextureSize / shadowFrameExtents.y );\\r\\n\\t\\t\\t\\t\\t_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;\\r\\n\\t\\t\\t\\t\\tshadow.mapSize.y = _viewportSize.y;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( shadow.map === null && ! shadow.isPointLightShadow && this.type === VSMShadowMap ) {\\r\\n\\r\\n\\t\\t\\t\\tvar pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat };\\r\\n\\r\\n\\t\\t\\t\\tshadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\\r\\n\\t\\t\\t\\tshadow.map.texture.name = light.name + \\\".shadowMap\\\";\\r\\n\\r\\n\\t\\t\\t\\tshadow.mapPass = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\\r\\n\\r\\n\\t\\t\\t\\tshadow.camera.updateProjectionMatrix();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( shadow.map === null ) {\\r\\n\\r\\n\\t\\t\\t\\tvar pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };\\r\\n\\r\\n\\t\\t\\t\\tshadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\\r\\n\\t\\t\\t\\tshadow.map.texture.name = light.name + \\\".shadowMap\\\";\\r\\n\\r\\n\\t\\t\\t\\tshadow.camera.updateProjectionMatrix();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t_renderer.setRenderTarget( shadow.map );\\r\\n\\t\\t\\t_renderer.clear();\\r\\n\\r\\n\\t\\t\\tvar viewportCount = shadow.getViewportCount();\\r\\n\\r\\n\\t\\t\\tfor ( var vp = 0; vp < viewportCount; vp ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar viewport = shadow.getViewport( vp );\\r\\n\\r\\n\\t\\t\\t\\t_viewport.set(\\r\\n\\t\\t\\t\\t\\t_viewportSize.x * viewport.x,\\r\\n\\t\\t\\t\\t\\t_viewportSize.y * viewport.y,\\r\\n\\t\\t\\t\\t\\t_viewportSize.x * viewport.z,\\r\\n\\t\\t\\t\\t\\t_viewportSize.y * viewport.w\\r\\n\\t\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\t\\t_state.viewport( _viewport );\\r\\n\\r\\n\\t\\t\\t\\tshadow.updateMatrices( light, vp );\\r\\n\\r\\n\\t\\t\\t\\t_frustum = shadow.getFrustum();\\r\\n\\r\\n\\t\\t\\t\\trenderObject( scene, camera, shadow.camera, light, this.type );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// do blur pass for VSM\\r\\n\\r\\n\\t\\t\\tif ( ! shadow.isPointLightShadow && this.type === VSMShadowMap ) {\\r\\n\\r\\n\\t\\t\\t\\tVSMPass( shadow, camera );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tscope.needsUpdate = false;\\r\\n\\r\\n\\t\\t_renderer.setRenderTarget( currentRenderTarget, activeCubeFace, activeMipmapLevel );\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tfunction VSMPass( shadow, camera ) {\\r\\n\\r\\n\\t\\tvar geometry = _objects.update( fullScreenMesh );\\r\\n\\r\\n\\t\\t// vertical pass\\r\\n\\r\\n\\t\\tshadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;\\r\\n\\t\\tshadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;\\r\\n\\t\\tshadowMaterialVertical.uniforms.radius.value = shadow.radius;\\r\\n\\t\\t_renderer.setRenderTarget( shadow.mapPass );\\r\\n\\t\\t_renderer.clear();\\r\\n\\t\\t_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null );\\r\\n\\r\\n\\t\\t// horizonal pass\\r\\n\\r\\n\\t\\tshadowMaterialHorizonal.uniforms.shadow_pass.value = shadow.mapPass.texture;\\r\\n\\t\\tshadowMaterialHorizonal.uniforms.resolution.value = shadow.mapSize;\\r\\n\\t\\tshadowMaterialHorizonal.uniforms.radius.value = shadow.radius;\\r\\n\\t\\t_renderer.setRenderTarget( shadow.map );\\r\\n\\t\\t_renderer.clear();\\r\\n\\t\\t_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialHorizonal, fullScreenMesh, null );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction getDepthMaterialVariant( useMorphing, useSkinning, useInstancing ) {\\r\\n\\r\\n\\t\\tvar index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;\\r\\n\\r\\n\\t\\tvar material = _depthMaterials[ index ];\\r\\n\\r\\n\\t\\tif ( material === undefined ) {\\r\\n\\r\\n\\t\\t\\tmaterial = new MeshDepthMaterial( {\\r\\n\\r\\n\\t\\t\\t\\tdepthPacking: RGBADepthPacking,\\r\\n\\r\\n\\t\\t\\t\\tmorphTargets: useMorphing,\\r\\n\\t\\t\\t\\tskinning: useSkinning\\r\\n\\r\\n\\t\\t\\t} );\\r\\n\\r\\n\\t\\t\\t_depthMaterials[ index ] = material;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn material;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction getDistanceMaterialVariant( useMorphing, useSkinning, useInstancing ) {\\r\\n\\r\\n\\t\\tvar index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;\\r\\n\\r\\n\\t\\tvar material = _distanceMaterials[ index ];\\r\\n\\r\\n\\t\\tif ( material === undefined ) {\\r\\n\\r\\n\\t\\t\\tmaterial = new MeshDistanceMaterial( {\\r\\n\\r\\n\\t\\t\\t\\tmorphTargets: useMorphing,\\r\\n\\t\\t\\t\\tskinning: useSkinning\\r\\n\\r\\n\\t\\t\\t} );\\r\\n\\r\\n\\t\\t\\t_distanceMaterials[ index ] = material;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn material;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction getDepthMaterial( object, geometry, material, light, shadowCameraNear, shadowCameraFar, type ) {\\r\\n\\r\\n\\t\\tvar result = null;\\r\\n\\r\\n\\t\\tvar getMaterialVariant = getDepthMaterialVariant;\\r\\n\\t\\tvar customMaterial = object.customDepthMaterial;\\r\\n\\r\\n\\t\\tif ( light.isPointLight === true ) {\\r\\n\\r\\n\\t\\t\\tgetMaterialVariant = getDistanceMaterialVariant;\\r\\n\\t\\t\\tcustomMaterial = object.customDistanceMaterial;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( customMaterial === undefined ) {\\r\\n\\r\\n\\t\\t\\tvar useMorphing = false;\\r\\n\\r\\n\\t\\t\\tif ( material.morphTargets === true ) {\\r\\n\\r\\n\\t\\t\\t\\tuseMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar useSkinning = false;\\r\\n\\r\\n\\t\\t\\tif ( object.isSkinnedMesh === true ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( material.skinning === true ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tuseSkinning = true;\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar useInstancing = object.isInstancedMesh === true;\\r\\n\\r\\n\\t\\t\\tresult = getMaterialVariant( useMorphing, useSkinning, useInstancing );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tresult = customMaterial;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( _renderer.localClippingEnabled &&\\r\\n\\t\\t\\t\\tmaterial.clipShadows === true &&\\r\\n\\t\\t\\t\\tmaterial.clippingPlanes.length !== 0 ) {\\r\\n\\r\\n\\t\\t\\t// in this case we need a unique material instance reflecting the\\r\\n\\t\\t\\t// appropriate state\\r\\n\\r\\n\\t\\t\\tvar keyA = result.uuid, keyB = material.uuid;\\r\\n\\r\\n\\t\\t\\tvar materialsForVariant = _materialCache[ keyA ];\\r\\n\\r\\n\\t\\t\\tif ( materialsForVariant === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tmaterialsForVariant = {};\\r\\n\\t\\t\\t\\t_materialCache[ keyA ] = materialsForVariant;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar cachedMaterial = materialsForVariant[ keyB ];\\r\\n\\r\\n\\t\\t\\tif ( cachedMaterial === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tcachedMaterial = result.clone();\\r\\n\\t\\t\\t\\tmaterialsForVariant[ keyB ] = cachedMaterial;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tresult = cachedMaterial;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tresult.visible = material.visible;\\r\\n\\t\\tresult.wireframe = material.wireframe;\\r\\n\\r\\n\\t\\tif ( type === VSMShadowMap ) {\\r\\n\\r\\n\\t\\t\\tresult.side = ( material.shadowSide !== null ) ? material.shadowSide : material.side;\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tresult.side = ( material.shadowSide !== null ) ? material.shadowSide : shadowSide[ material.side ];\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tresult.clipShadows = material.clipShadows;\\r\\n\\t\\tresult.clippingPlanes = material.clippingPlanes;\\r\\n\\t\\tresult.clipIntersection = material.clipIntersection;\\r\\n\\r\\n\\t\\tresult.wireframeLinewidth = material.wireframeLinewidth;\\r\\n\\t\\tresult.linewidth = material.linewidth;\\r\\n\\r\\n\\t\\tif ( light.isPointLight === true && result.isMeshDistanceMaterial === true ) {\\r\\n\\r\\n\\t\\t\\tresult.referencePosition.setFromMatrixPosition( light.matrixWorld );\\r\\n\\t\\t\\tresult.nearDistance = shadowCameraNear;\\r\\n\\t\\t\\tresult.farDistance = shadowCameraFar;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn result;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction renderObject( object, camera, shadowCamera, light, type ) {\\r\\n\\r\\n\\t\\tif ( object.visible === false ) return;\\r\\n\\r\\n\\t\\tvar visible = object.layers.test( camera.layers );\\r\\n\\r\\n\\t\\tif ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {\\r\\n\\r\\n\\t\\t\\tif ( ( object.castShadow || ( object.receiveShadow && type === VSMShadowMap ) ) && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {\\r\\n\\r\\n\\t\\t\\t\\tobject.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\\r\\n\\r\\n\\t\\t\\t\\tvar geometry = _objects.update( object );\\r\\n\\t\\t\\t\\tvar material = object.material;\\r\\n\\r\\n\\t\\t\\t\\tif ( Array.isArray( material ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar groups = geometry.groups;\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var k = 0, kl = groups.length; k < kl; k ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar group = groups[ k ];\\r\\n\\t\\t\\t\\t\\t\\tvar groupMaterial = material[ group.materialIndex ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( groupMaterial && groupMaterial.visible ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tvar depthMaterial = getDepthMaterial( object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t} else if ( material.visible ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar depthMaterial = getDepthMaterial( object, geometry, material, light, shadowCamera.near, shadowCamera.far, type );\\r\\n\\r\\n\\t\\t\\t\\t\\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar children = object.children;\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\trenderObject( children[ i ], camera, shadowCamera, light, type );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nfunction WebGLState( gl, extensions, capabilities ) {\\r\\n\\r\\n\\tvar isWebGL2 = capabilities.isWebGL2;\\r\\n\\r\\n\\tfunction ColorBuffer() {\\r\\n\\r\\n\\t\\tvar locked = false;\\r\\n\\r\\n\\t\\tvar color = new Vector4();\\r\\n\\t\\tvar currentColorMask = null;\\r\\n\\t\\tvar currentColorClear = new Vector4( 0, 0, 0, 0 );\\r\\n\\r\\n\\t\\treturn {\\r\\n\\r\\n\\t\\t\\tsetMask: function ( colorMask ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( currentColorMask !== colorMask && ! locked ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tgl.colorMask( colorMask, colorMask, colorMask, colorMask );\\r\\n\\t\\t\\t\\t\\tcurrentColorMask = colorMask;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\tsetLocked: function ( lock ) {\\r\\n\\r\\n\\t\\t\\t\\tlocked = lock;\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\tsetClear: function ( r, g, b, a, premultipliedAlpha ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( premultipliedAlpha === true ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tr *= a; g *= a; b *= a;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tcolor.set( r, g, b, a );\\r\\n\\r\\n\\t\\t\\t\\tif ( currentColorClear.equals( color ) === false ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tgl.clearColor( r, g, b, a );\\r\\n\\t\\t\\t\\t\\tcurrentColorClear.copy( color );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\treset: function () {\\r\\n\\r\\n\\t\\t\\t\\tlocked = false;\\r\\n\\r\\n\\t\\t\\t\\tcurrentColorMask = null;\\r\\n\\t\\t\\t\\tcurrentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction DepthBuffer() {\\r\\n\\r\\n\\t\\tvar locked = false;\\r\\n\\r\\n\\t\\tvar currentDepthMask = null;\\r\\n\\t\\tvar currentDepthFunc = null;\\r\\n\\t\\tvar currentDepthClear = null;\\r\\n\\r\\n\\t\\treturn {\\r\\n\\r\\n\\t\\t\\tsetTest: function ( depthTest ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( depthTest ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tenable( 2929 );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tdisable( 2929 );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\tsetMask: function ( depthMask ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( currentDepthMask !== depthMask && ! locked ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tgl.depthMask( depthMask );\\r\\n\\t\\t\\t\\t\\tcurrentDepthMask = depthMask;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\tsetFunc: function ( depthFunc ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( currentDepthFunc !== depthFunc ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( depthFunc ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tswitch ( depthFunc ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tcase NeverDepth:\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.depthFunc( 512 );\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tcase AlwaysDepth:\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.depthFunc( 519 );\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tcase LessDepth:\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.depthFunc( 513 );\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tcase LessEqualDepth:\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.depthFunc( 515 );\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tcase EqualDepth:\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.depthFunc( 514 );\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tcase GreaterEqualDepth:\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.depthFunc( 518 );\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tcase GreaterDepth:\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.depthFunc( 516 );\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tcase NotEqualDepth:\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.depthFunc( 517 );\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tdefault:\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.depthFunc( 515 );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tgl.depthFunc( 515 );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tcurrentDepthFunc = depthFunc;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\tsetLocked: function ( lock ) {\\r\\n\\r\\n\\t\\t\\t\\tlocked = lock;\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\tsetClear: function ( depth ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( currentDepthClear !== depth ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tgl.clearDepth( depth );\\r\\n\\t\\t\\t\\t\\tcurrentDepthClear = depth;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\treset: function () {\\r\\n\\r\\n\\t\\t\\t\\tlocked = false;\\r\\n\\r\\n\\t\\t\\t\\tcurrentDepthMask = null;\\r\\n\\t\\t\\t\\tcurrentDepthFunc = null;\\r\\n\\t\\t\\t\\tcurrentDepthClear = null;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction StencilBuffer() {\\r\\n\\r\\n\\t\\tvar locked = false;\\r\\n\\r\\n\\t\\tvar currentStencilMask = null;\\r\\n\\t\\tvar currentStencilFunc = null;\\r\\n\\t\\tvar currentStencilRef = null;\\r\\n\\t\\tvar currentStencilFuncMask = null;\\r\\n\\t\\tvar currentStencilFail = null;\\r\\n\\t\\tvar currentStencilZFail = null;\\r\\n\\t\\tvar currentStencilZPass = null;\\r\\n\\t\\tvar currentStencilClear = null;\\r\\n\\r\\n\\t\\treturn {\\r\\n\\r\\n\\t\\t\\tsetTest: function ( stencilTest ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( ! locked ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( stencilTest ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tenable( 2960 );\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tdisable( 2960 );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\tsetMask: function ( stencilMask ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( currentStencilMask !== stencilMask && ! locked ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tgl.stencilMask( stencilMask );\\r\\n\\t\\t\\t\\t\\tcurrentStencilMask = stencilMask;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\tsetFunc: function ( stencilFunc, stencilRef, stencilMask ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( currentStencilFunc !== stencilFunc ||\\r\\n\\t\\t\\t\\t     currentStencilRef \\t!== stencilRef \\t||\\r\\n\\t\\t\\t\\t     currentStencilFuncMask !== stencilMask ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tgl.stencilFunc( stencilFunc, stencilRef, stencilMask );\\r\\n\\r\\n\\t\\t\\t\\t\\tcurrentStencilFunc = stencilFunc;\\r\\n\\t\\t\\t\\t\\tcurrentStencilRef = stencilRef;\\r\\n\\t\\t\\t\\t\\tcurrentStencilFuncMask = stencilMask;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\tsetOp: function ( stencilFail, stencilZFail, stencilZPass ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( currentStencilFail\\t !== stencilFail \\t||\\r\\n\\t\\t\\t\\t     currentStencilZFail !== stencilZFail ||\\r\\n\\t\\t\\t\\t     currentStencilZPass !== stencilZPass ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tgl.stencilOp( stencilFail, stencilZFail, stencilZPass );\\r\\n\\r\\n\\t\\t\\t\\t\\tcurrentStencilFail = stencilFail;\\r\\n\\t\\t\\t\\t\\tcurrentStencilZFail = stencilZFail;\\r\\n\\t\\t\\t\\t\\tcurrentStencilZPass = stencilZPass;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\tsetLocked: function ( lock ) {\\r\\n\\r\\n\\t\\t\\t\\tlocked = lock;\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\tsetClear: function ( stencil ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( currentStencilClear !== stencil ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tgl.clearStencil( stencil );\\r\\n\\t\\t\\t\\t\\tcurrentStencilClear = stencil;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\treset: function () {\\r\\n\\r\\n\\t\\t\\t\\tlocked = false;\\r\\n\\r\\n\\t\\t\\t\\tcurrentStencilMask = null;\\r\\n\\t\\t\\t\\tcurrentStencilFunc = null;\\r\\n\\t\\t\\t\\tcurrentStencilRef = null;\\r\\n\\t\\t\\t\\tcurrentStencilFuncMask = null;\\r\\n\\t\\t\\t\\tcurrentStencilFail = null;\\r\\n\\t\\t\\t\\tcurrentStencilZFail = null;\\r\\n\\t\\t\\t\\tcurrentStencilZPass = null;\\r\\n\\t\\t\\t\\tcurrentStencilClear = null;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tvar colorBuffer = new ColorBuffer();\\r\\n\\tvar depthBuffer = new DepthBuffer();\\r\\n\\tvar stencilBuffer = new StencilBuffer();\\r\\n\\r\\n\\tvar maxVertexAttributes = gl.getParameter( 34921 );\\r\\n\\tvar newAttributes = new Uint8Array( maxVertexAttributes );\\r\\n\\tvar enabledAttributes = new Uint8Array( maxVertexAttributes );\\r\\n\\tvar attributeDivisors = new Uint8Array( maxVertexAttributes );\\r\\n\\r\\n\\tvar enabledCapabilities = {};\\r\\n\\r\\n\\tvar currentProgram = null;\\r\\n\\r\\n\\tvar currentBlendingEnabled = null;\\r\\n\\tvar currentBlending = null;\\r\\n\\tvar currentBlendEquation = null;\\r\\n\\tvar currentBlendSrc = null;\\r\\n\\tvar currentBlendDst = null;\\r\\n\\tvar currentBlendEquationAlpha = null;\\r\\n\\tvar currentBlendSrcAlpha = null;\\r\\n\\tvar currentBlendDstAlpha = null;\\r\\n\\tvar currentPremultipledAlpha = false;\\r\\n\\r\\n\\tvar currentFlipSided = null;\\r\\n\\tvar currentCullFace = null;\\r\\n\\r\\n\\tvar currentLineWidth = null;\\r\\n\\r\\n\\tvar currentPolygonOffsetFactor = null;\\r\\n\\tvar currentPolygonOffsetUnits = null;\\r\\n\\r\\n\\tvar maxTextures = gl.getParameter( 35661 );\\r\\n\\r\\n\\tvar lineWidthAvailable = false;\\r\\n\\tvar version = 0;\\r\\n\\tvar glVersion = gl.getParameter( 7938 );\\r\\n\\r\\n\\tif ( glVersion.indexOf( 'WebGL' ) !== - 1 ) {\\r\\n\\r\\n\\t\\tversion = parseFloat( /^WebGL\\\\ ([0-9])/.exec( glVersion )[ 1 ] );\\r\\n\\t\\tlineWidthAvailable = ( version >= 1.0 );\\r\\n\\r\\n\\t} else if ( glVersion.indexOf( 'OpenGL ES' ) !== - 1 ) {\\r\\n\\r\\n\\t\\tversion = parseFloat( /^OpenGL\\\\ ES\\\\ ([0-9])/.exec( glVersion )[ 1 ] );\\r\\n\\t\\tlineWidthAvailable = ( version >= 2.0 );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tvar currentTextureSlot = null;\\r\\n\\tvar currentBoundTextures = {};\\r\\n\\r\\n\\tvar currentScissor = new Vector4();\\r\\n\\tvar currentViewport = new Vector4();\\r\\n\\r\\n\\tfunction createTexture( type, target, count ) {\\r\\n\\r\\n\\t\\tvar data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.\\r\\n\\t\\tvar texture = gl.createTexture();\\r\\n\\r\\n\\t\\tgl.bindTexture( type, texture );\\r\\n\\t\\tgl.texParameteri( type, 10241, 9728 );\\r\\n\\t\\tgl.texParameteri( type, 10240, 9728 );\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < count; i ++ ) {\\r\\n\\r\\n\\t\\t\\tgl.texImage2D( target + i, 0, 6408, 1, 1, 0, 6408, 5121, data );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn texture;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tvar emptyTextures = {};\\r\\n\\temptyTextures[ 3553 ] = createTexture( 3553, 3553, 1 );\\r\\n\\temptyTextures[ 34067 ] = createTexture( 34067, 34069, 6 );\\r\\n\\r\\n\\t// init\\r\\n\\r\\n\\tcolorBuffer.setClear( 0, 0, 0, 1 );\\r\\n\\tdepthBuffer.setClear( 1 );\\r\\n\\tstencilBuffer.setClear( 0 );\\r\\n\\r\\n\\tenable( 2929 );\\r\\n\\tdepthBuffer.setFunc( LessEqualDepth );\\r\\n\\r\\n\\tsetFlipSided( false );\\r\\n\\tsetCullFace( CullFaceBack );\\r\\n\\tenable( 2884 );\\r\\n\\r\\n\\tsetBlending( NoBlending );\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tfunction initAttributes() {\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = newAttributes.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\tnewAttributes[ i ] = 0;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction enableAttribute( attribute ) {\\r\\n\\r\\n\\t\\tenableAttributeAndDivisor( attribute, 0 );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction enableAttributeAndDivisor( attribute, meshPerAttribute ) {\\r\\n\\r\\n\\t\\tnewAttributes[ attribute ] = 1;\\r\\n\\r\\n\\t\\tif ( enabledAttributes[ attribute ] === 0 ) {\\r\\n\\r\\n\\t\\t\\tgl.enableVertexAttribArray( attribute );\\r\\n\\t\\t\\tenabledAttributes[ attribute ] = 1;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( attributeDivisors[ attribute ] !== meshPerAttribute ) {\\r\\n\\r\\n\\t\\t\\tvar extension = isWebGL2 ? gl : extensions.get( 'ANGLE_instanced_arrays' );\\r\\n\\r\\n\\t\\t\\textension[ isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE' ]( attribute, meshPerAttribute );\\r\\n\\t\\t\\tattributeDivisors[ attribute ] = meshPerAttribute;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction disableUnusedAttributes() {\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {\\r\\n\\r\\n\\t\\t\\tif ( enabledAttributes[ i ] !== newAttributes[ i ] ) {\\r\\n\\r\\n\\t\\t\\t\\tgl.disableVertexAttribArray( i );\\r\\n\\t\\t\\t\\tenabledAttributes[ i ] = 0;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction vertexAttribPointer( index, size, type, normalized, stride, offset ) {\\r\\n\\r\\n\\t\\tif ( isWebGL2 === true && ( type === 5124 || type === 5125 ) ) {\\r\\n\\r\\n\\t\\t\\tgl.vertexAttribIPointer( index, size, type, normalized, stride, offset );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tgl.vertexAttribPointer( index, size, type, normalized, stride, offset );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction enable( id ) {\\r\\n\\r\\n\\t\\tif ( enabledCapabilities[ id ] !== true ) {\\r\\n\\r\\n\\t\\t\\tgl.enable( id );\\r\\n\\t\\t\\tenabledCapabilities[ id ] = true;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction disable( id ) {\\r\\n\\r\\n\\t\\tif ( enabledCapabilities[ id ] !== false ) {\\r\\n\\r\\n\\t\\t\\tgl.disable( id );\\r\\n\\t\\t\\tenabledCapabilities[ id ] = false;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction useProgram( program ) {\\r\\n\\r\\n\\t\\tif ( currentProgram !== program ) {\\r\\n\\r\\n\\t\\t\\tgl.useProgram( program );\\r\\n\\r\\n\\t\\t\\tcurrentProgram = program;\\r\\n\\r\\n\\t\\t\\treturn true;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn false;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tvar equationToGL = {\\r\\n\\t\\t[ AddEquation ]: 32774,\\r\\n\\t\\t[ SubtractEquation ]: 32778,\\r\\n\\t\\t[ ReverseSubtractEquation ]: 32779\\r\\n\\t};\\r\\n\\r\\n\\tif ( isWebGL2 ) {\\r\\n\\r\\n\\t\\tequationToGL[ MinEquation ] = 32775;\\r\\n\\t\\tequationToGL[ MaxEquation ] = 32776;\\r\\n\\r\\n\\t} else {\\r\\n\\r\\n\\t\\tvar extension = extensions.get( 'EXT_blend_minmax' );\\r\\n\\r\\n\\t\\tif ( extension !== null ) {\\r\\n\\r\\n\\t\\t\\tequationToGL[ MinEquation ] = extension.MIN_EXT;\\r\\n\\t\\t\\tequationToGL[ MaxEquation ] = extension.MAX_EXT;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tvar factorToGL = {\\r\\n\\t\\t[ ZeroFactor ]: 0,\\r\\n\\t\\t[ OneFactor ]: 1,\\r\\n\\t\\t[ SrcColorFactor ]: 768,\\r\\n\\t\\t[ SrcAlphaFactor ]: 770,\\r\\n\\t\\t[ SrcAlphaSaturateFactor ]: 776,\\r\\n\\t\\t[ DstColorFactor ]: 774,\\r\\n\\t\\t[ DstAlphaFactor ]: 772,\\r\\n\\t\\t[ OneMinusSrcColorFactor ]: 769,\\r\\n\\t\\t[ OneMinusSrcAlphaFactor ]: 771,\\r\\n\\t\\t[ OneMinusDstColorFactor ]: 775,\\r\\n\\t\\t[ OneMinusDstAlphaFactor ]: 773\\r\\n\\t};\\r\\n\\r\\n\\tfunction setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {\\r\\n\\r\\n\\t\\tif ( blending === NoBlending ) {\\r\\n\\r\\n\\t\\t\\tif ( currentBlendingEnabled ) {\\r\\n\\r\\n\\t\\t\\t\\tdisable( 3042 );\\r\\n\\t\\t\\t\\tcurrentBlendingEnabled = false;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( ! currentBlendingEnabled ) {\\r\\n\\r\\n\\t\\t\\tenable( 3042 );\\r\\n\\t\\t\\tcurrentBlendingEnabled = true;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( blending !== CustomBlending ) {\\r\\n\\r\\n\\t\\t\\tif ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tgl.blendEquation( 32774 );\\r\\n\\r\\n\\t\\t\\t\\t\\tcurrentBlendEquation = AddEquation;\\r\\n\\t\\t\\t\\t\\tcurrentBlendEquationAlpha = AddEquation;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( premultipliedAlpha ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tswitch ( blending ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tcase NormalBlending:\\r\\n\\t\\t\\t\\t\\t\\t\\tgl.blendFuncSeparate( 1, 771, 1, 771 );\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tcase AdditiveBlending:\\r\\n\\t\\t\\t\\t\\t\\t\\tgl.blendFunc( 1, 1 );\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tcase SubtractiveBlending:\\r\\n\\t\\t\\t\\t\\t\\t\\tgl.blendFuncSeparate( 0, 0, 769, 771 );\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tcase MultiplyBlending:\\r\\n\\t\\t\\t\\t\\t\\t\\tgl.blendFuncSeparate( 0, 768, 0, 770 );\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tdefault:\\r\\n\\t\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.WebGLState: Invalid blending: ', blending );\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tswitch ( blending ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tcase NormalBlending:\\r\\n\\t\\t\\t\\t\\t\\t\\tgl.blendFuncSeparate( 770, 771, 1, 771 );\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tcase AdditiveBlending:\\r\\n\\t\\t\\t\\t\\t\\t\\tgl.blendFunc( 770, 1 );\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tcase SubtractiveBlending:\\r\\n\\t\\t\\t\\t\\t\\t\\tgl.blendFunc( 0, 769 );\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tcase MultiplyBlending:\\r\\n\\t\\t\\t\\t\\t\\t\\tgl.blendFunc( 0, 768 );\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tdefault:\\r\\n\\t\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.WebGLState: Invalid blending: ', blending );\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tcurrentBlendSrc = null;\\r\\n\\t\\t\\t\\tcurrentBlendDst = null;\\r\\n\\t\\t\\t\\tcurrentBlendSrcAlpha = null;\\r\\n\\t\\t\\t\\tcurrentBlendDstAlpha = null;\\r\\n\\r\\n\\t\\t\\t\\tcurrentBlending = blending;\\r\\n\\t\\t\\t\\tcurrentPremultipledAlpha = premultipliedAlpha;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// custom blending\\r\\n\\r\\n\\t\\tblendEquationAlpha = blendEquationAlpha || blendEquation;\\r\\n\\t\\tblendSrcAlpha = blendSrcAlpha || blendSrc;\\r\\n\\t\\tblendDstAlpha = blendDstAlpha || blendDst;\\r\\n\\r\\n\\t\\tif ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {\\r\\n\\r\\n\\t\\t\\tgl.blendEquationSeparate( equationToGL[ blendEquation ], equationToGL[ blendEquationAlpha ] );\\r\\n\\r\\n\\t\\t\\tcurrentBlendEquation = blendEquation;\\r\\n\\t\\t\\tcurrentBlendEquationAlpha = blendEquationAlpha;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {\\r\\n\\r\\n\\t\\t\\tgl.blendFuncSeparate( factorToGL[ blendSrc ], factorToGL[ blendDst ], factorToGL[ blendSrcAlpha ], factorToGL[ blendDstAlpha ] );\\r\\n\\r\\n\\t\\t\\tcurrentBlendSrc = blendSrc;\\r\\n\\t\\t\\tcurrentBlendDst = blendDst;\\r\\n\\t\\t\\tcurrentBlendSrcAlpha = blendSrcAlpha;\\r\\n\\t\\t\\tcurrentBlendDstAlpha = blendDstAlpha;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tcurrentBlending = blending;\\r\\n\\t\\tcurrentPremultipledAlpha = null;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction setMaterial( material, frontFaceCW ) {\\r\\n\\r\\n\\t\\tmaterial.side === DoubleSide\\r\\n\\t\\t\\t? disable( 2884 )\\r\\n\\t\\t\\t: enable( 2884 );\\r\\n\\r\\n\\t\\tvar flipSided = ( material.side === BackSide );\\r\\n\\t\\tif ( frontFaceCW ) flipSided = ! flipSided;\\r\\n\\r\\n\\t\\tsetFlipSided( flipSided );\\r\\n\\r\\n\\t\\t( material.blending === NormalBlending && material.transparent === false )\\r\\n\\t\\t\\t? setBlending( NoBlending )\\r\\n\\t\\t\\t: setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );\\r\\n\\r\\n\\t\\tdepthBuffer.setFunc( material.depthFunc );\\r\\n\\t\\tdepthBuffer.setTest( material.depthTest );\\r\\n\\t\\tdepthBuffer.setMask( material.depthWrite );\\r\\n\\t\\tcolorBuffer.setMask( material.colorWrite );\\r\\n\\r\\n\\t\\tvar stencilWrite = material.stencilWrite;\\r\\n\\t\\tstencilBuffer.setTest( stencilWrite );\\r\\n\\t\\tif ( stencilWrite ) {\\r\\n\\r\\n\\t\\t\\tstencilBuffer.setMask( material.stencilWriteMask );\\r\\n\\t\\t\\tstencilBuffer.setFunc( material.stencilFunc, material.stencilRef, material.stencilFuncMask );\\r\\n\\t\\t\\tstencilBuffer.setOp( material.stencilFail, material.stencilZFail, material.stencilZPass );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tsetPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tfunction setFlipSided( flipSided ) {\\r\\n\\r\\n\\t\\tif ( currentFlipSided !== flipSided ) {\\r\\n\\r\\n\\t\\t\\tif ( flipSided ) {\\r\\n\\r\\n\\t\\t\\t\\tgl.frontFace( 2304 );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tgl.frontFace( 2305 );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tcurrentFlipSided = flipSided;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction setCullFace( cullFace ) {\\r\\n\\r\\n\\t\\tif ( cullFace !== CullFaceNone ) {\\r\\n\\r\\n\\t\\t\\tenable( 2884 );\\r\\n\\r\\n\\t\\t\\tif ( cullFace !== currentCullFace ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( cullFace === CullFaceBack ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tgl.cullFace( 1029 );\\r\\n\\r\\n\\t\\t\\t\\t} else if ( cullFace === CullFaceFront ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tgl.cullFace( 1028 );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tgl.cullFace( 1032 );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tdisable( 2884 );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tcurrentCullFace = cullFace;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction setLineWidth( width ) {\\r\\n\\r\\n\\t\\tif ( width !== currentLineWidth ) {\\r\\n\\r\\n\\t\\t\\tif ( lineWidthAvailable ) gl.lineWidth( width );\\r\\n\\r\\n\\t\\t\\tcurrentLineWidth = width;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction setPolygonOffset( polygonOffset, factor, units ) {\\r\\n\\r\\n\\t\\tif ( polygonOffset ) {\\r\\n\\r\\n\\t\\t\\tenable( 32823 );\\r\\n\\r\\n\\t\\t\\tif ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {\\r\\n\\r\\n\\t\\t\\t\\tgl.polygonOffset( factor, units );\\r\\n\\r\\n\\t\\t\\t\\tcurrentPolygonOffsetFactor = factor;\\r\\n\\t\\t\\t\\tcurrentPolygonOffsetUnits = units;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tdisable( 32823 );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction setScissorTest( scissorTest ) {\\r\\n\\r\\n\\t\\tif ( scissorTest ) {\\r\\n\\r\\n\\t\\t\\tenable( 3089 );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tdisable( 3089 );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// texture\\r\\n\\r\\n\\tfunction activeTexture( webglSlot ) {\\r\\n\\r\\n\\t\\tif ( webglSlot === undefined ) webglSlot = 33984 + maxTextures - 1;\\r\\n\\r\\n\\t\\tif ( currentTextureSlot !== webglSlot ) {\\r\\n\\r\\n\\t\\t\\tgl.activeTexture( webglSlot );\\r\\n\\t\\t\\tcurrentTextureSlot = webglSlot;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction bindTexture( webglType, webglTexture ) {\\r\\n\\r\\n\\t\\tif ( currentTextureSlot === null ) {\\r\\n\\r\\n\\t\\t\\tactiveTexture();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar boundTexture = currentBoundTextures[ currentTextureSlot ];\\r\\n\\r\\n\\t\\tif ( boundTexture === undefined ) {\\r\\n\\r\\n\\t\\t\\tboundTexture = { type: undefined, texture: undefined };\\r\\n\\t\\t\\tcurrentBoundTextures[ currentTextureSlot ] = boundTexture;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {\\r\\n\\r\\n\\t\\t\\tgl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );\\r\\n\\r\\n\\t\\t\\tboundTexture.type = webglType;\\r\\n\\t\\t\\tboundTexture.texture = webglTexture;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction unbindTexture() {\\r\\n\\r\\n\\t\\tvar boundTexture = currentBoundTextures[ currentTextureSlot ];\\r\\n\\r\\n\\t\\tif ( boundTexture !== undefined && boundTexture.type !== undefined ) {\\r\\n\\r\\n\\t\\t\\tgl.bindTexture( boundTexture.type, null );\\r\\n\\r\\n\\t\\t\\tboundTexture.type = undefined;\\r\\n\\t\\t\\tboundTexture.texture = undefined;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction compressedTexImage2D() {\\r\\n\\r\\n\\t\\ttry {\\r\\n\\r\\n\\t\\t\\tgl.compressedTexImage2D.apply( gl, arguments );\\r\\n\\r\\n\\t\\t} catch ( error ) {\\r\\n\\r\\n\\t\\t\\tconsole.error( 'THREE.WebGLState:', error );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction texImage2D() {\\r\\n\\r\\n\\t\\ttry {\\r\\n\\r\\n\\t\\t\\tgl.texImage2D.apply( gl, arguments );\\r\\n\\r\\n\\t\\t} catch ( error ) {\\r\\n\\r\\n\\t\\t\\tconsole.error( 'THREE.WebGLState:', error );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction texImage3D() {\\r\\n\\r\\n\\t\\ttry {\\r\\n\\r\\n\\t\\t\\tgl.texImage3D.apply( gl, arguments );\\r\\n\\r\\n\\t\\t} catch ( error ) {\\r\\n\\r\\n\\t\\t\\tconsole.error( 'THREE.WebGLState:', error );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tfunction scissor( scissor ) {\\r\\n\\r\\n\\t\\tif ( currentScissor.equals( scissor ) === false ) {\\r\\n\\r\\n\\t\\t\\tgl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );\\r\\n\\t\\t\\tcurrentScissor.copy( scissor );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction viewport( viewport ) {\\r\\n\\r\\n\\t\\tif ( currentViewport.equals( viewport ) === false ) {\\r\\n\\r\\n\\t\\t\\tgl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );\\r\\n\\t\\t\\tcurrentViewport.copy( viewport );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tfunction reset() {\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < enabledAttributes.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\tif ( enabledAttributes[ i ] === 1 ) {\\r\\n\\r\\n\\t\\t\\t\\tgl.disableVertexAttribArray( i );\\r\\n\\t\\t\\t\\tenabledAttributes[ i ] = 0;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tenabledCapabilities = {};\\r\\n\\r\\n\\t\\tcurrentTextureSlot = null;\\r\\n\\t\\tcurrentBoundTextures = {};\\r\\n\\r\\n\\t\\tcurrentProgram = null;\\r\\n\\r\\n\\t\\tcurrentBlending = null;\\r\\n\\r\\n\\t\\tcurrentFlipSided = null;\\r\\n\\t\\tcurrentCullFace = null;\\r\\n\\r\\n\\t\\tcolorBuffer.reset();\\r\\n\\t\\tdepthBuffer.reset();\\r\\n\\t\\tstencilBuffer.reset();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn {\\r\\n\\r\\n\\t\\tbuffers: {\\r\\n\\t\\t\\tcolor: colorBuffer,\\r\\n\\t\\t\\tdepth: depthBuffer,\\r\\n\\t\\t\\tstencil: stencilBuffer\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tinitAttributes: initAttributes,\\r\\n\\t\\tenableAttribute: enableAttribute,\\r\\n\\t\\tenableAttributeAndDivisor: enableAttributeAndDivisor,\\r\\n\\t\\tdisableUnusedAttributes: disableUnusedAttributes,\\r\\n\\t\\tvertexAttribPointer: vertexAttribPointer,\\r\\n\\t\\tenable: enable,\\r\\n\\t\\tdisable: disable,\\r\\n\\r\\n\\t\\tuseProgram: useProgram,\\r\\n\\r\\n\\t\\tsetBlending: setBlending,\\r\\n\\t\\tsetMaterial: setMaterial,\\r\\n\\r\\n\\t\\tsetFlipSided: setFlipSided,\\r\\n\\t\\tsetCullFace: setCullFace,\\r\\n\\r\\n\\t\\tsetLineWidth: setLineWidth,\\r\\n\\t\\tsetPolygonOffset: setPolygonOffset,\\r\\n\\r\\n\\t\\tsetScissorTest: setScissorTest,\\r\\n\\r\\n\\t\\tactiveTexture: activeTexture,\\r\\n\\t\\tbindTexture: bindTexture,\\r\\n\\t\\tunbindTexture: unbindTexture,\\r\\n\\t\\tcompressedTexImage2D: compressedTexImage2D,\\r\\n\\t\\ttexImage2D: texImage2D,\\r\\n\\t\\ttexImage3D: texImage3D,\\r\\n\\r\\n\\t\\tscissor: scissor,\\r\\n\\t\\tviewport: viewport,\\r\\n\\r\\n\\t\\treset: reset\\r\\n\\r\\n\\t};\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) {\\r\\n\\r\\n\\tvar isWebGL2 = capabilities.isWebGL2;\\r\\n\\tvar maxTextures = capabilities.maxTextures;\\r\\n\\tvar maxCubemapSize = capabilities.maxCubemapSize;\\r\\n\\tvar maxTextureSize = capabilities.maxTextureSize;\\r\\n\\tvar maxSamples = capabilities.maxSamples;\\r\\n\\r\\n\\tvar _videoTextures = new WeakMap();\\r\\n\\tvar _canvas;\\r\\n\\r\\n\\t// cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,\\r\\n\\t// also OffscreenCanvas.getContext(\\\"webgl\\\"), but not OffscreenCanvas.getContext(\\\"2d\\\")!\\r\\n\\t// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).\\r\\n\\r\\n\\tvar useOffscreenCanvas = false;\\r\\n\\r\\n\\ttry {\\r\\n\\r\\n\\t\\tuseOffscreenCanvas = typeof OffscreenCanvas !== 'undefined'\\r\\n\\t\\t\\t&& ( new OffscreenCanvas( 1, 1 ).getContext( \\\"2d\\\" ) ) !== null;\\r\\n\\r\\n\\t} catch ( err ) {\\r\\n\\r\\n\\t\\t// Ignore any errors\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction createCanvas( width, height ) {\\r\\n\\r\\n\\t\\t// Use OffscreenCanvas when available. Specially needed in web workers\\r\\n\\r\\n\\t\\treturn useOffscreenCanvas ?\\r\\n\\t\\t\\tnew OffscreenCanvas( width, height ) :\\r\\n\\t\\t\\tdocument.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction resizeImage( image, needsPowerOfTwo, needsNewCanvas, maxSize ) {\\r\\n\\r\\n\\t\\tvar scale = 1;\\r\\n\\r\\n\\t\\t// handle case if texture exceeds max size\\r\\n\\r\\n\\t\\tif ( image.width > maxSize || image.height > maxSize ) {\\r\\n\\r\\n\\t\\t\\tscale = maxSize / Math.max( image.width, image.height );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// only perform resize if necessary\\r\\n\\r\\n\\t\\tif ( scale < 1 || needsPowerOfTwo === true ) {\\r\\n\\r\\n\\t\\t\\t// only perform resize for certain image types\\r\\n\\r\\n\\t\\t\\tif ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||\\r\\n\\t\\t\\t\\t( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||\\r\\n\\t\\t\\t\\t( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {\\r\\n\\r\\n\\t\\t\\t\\tvar floor = needsPowerOfTwo ? MathUtils.floorPowerOfTwo : Math.floor;\\r\\n\\r\\n\\t\\t\\t\\tvar width = floor( scale * image.width );\\r\\n\\t\\t\\t\\tvar height = floor( scale * image.height );\\r\\n\\r\\n\\t\\t\\t\\tif ( _canvas === undefined ) _canvas = createCanvas( width, height );\\r\\n\\r\\n\\t\\t\\t\\t// cube textures can't reuse the same canvas\\r\\n\\r\\n\\t\\t\\t\\tvar canvas = needsNewCanvas ? createCanvas( width, height ) : _canvas;\\r\\n\\r\\n\\t\\t\\t\\tcanvas.width = width;\\r\\n\\t\\t\\t\\tcanvas.height = height;\\r\\n\\r\\n\\t\\t\\t\\tvar context = canvas.getContext( '2d' );\\r\\n\\t\\t\\t\\tcontext.drawImage( image, 0, 0, width, height );\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').' );\\r\\n\\r\\n\\t\\t\\t\\treturn canvas;\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tif ( 'data' in image ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').' );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\treturn image;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn image;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction isPowerOfTwo( image ) {\\r\\n\\r\\n\\t\\treturn MathUtils.isPowerOfTwo( image.width ) && MathUtils.isPowerOfTwo( image.height );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction textureNeedsPowerOfTwo( texture ) {\\r\\n\\r\\n\\t\\tif ( isWebGL2 ) return false;\\r\\n\\r\\n\\t\\treturn ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||\\r\\n\\t\\t\\t( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction textureNeedsGenerateMipmaps( texture, supportsMips ) {\\r\\n\\r\\n\\t\\treturn texture.generateMipmaps && supportsMips &&\\r\\n\\t\\t\\ttexture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction generateMipmap( target, texture, width, height ) {\\r\\n\\r\\n\\t\\t_gl.generateMipmap( target );\\r\\n\\r\\n\\t\\tvar textureProperties = properties.get( texture );\\r\\n\\r\\n\\t\\t// Note: Math.log( x ) * Math.LOG2E used instead of Math.log2( x ) which is not supported by IE11\\r\\n\\t\\ttextureProperties.__maxMipLevel = Math.log( Math.max( width, height ) ) * Math.LOG2E;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction getInternalFormat( internalFormatName, glFormat, glType ) {\\r\\n\\r\\n\\t\\tif ( isWebGL2 === false ) return glFormat;\\r\\n\\r\\n\\t\\tif ( internalFormatName !== null ) {\\r\\n\\r\\n\\t\\t\\tif ( _gl[ internalFormatName ] !== undefined ) return _gl[ internalFormatName ];\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \\\\'' + internalFormatName + '\\\\'' );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar internalFormat = glFormat;\\r\\n\\r\\n\\t\\tif ( glFormat === 6403 ) {\\r\\n\\r\\n\\t\\t\\tif ( glType === 5126 ) internalFormat = 33326;\\r\\n\\t\\t\\tif ( glType === 5131 ) internalFormat = 33325;\\r\\n\\t\\t\\tif ( glType === 5121 ) internalFormat = 33321;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( glFormat === 6407 ) {\\r\\n\\r\\n\\t\\t\\tif ( glType === 5126 ) internalFormat = 34837;\\r\\n\\t\\t\\tif ( glType === 5131 ) internalFormat = 34843;\\r\\n\\t\\t\\tif ( glType === 5121 ) internalFormat = 32849;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( glFormat === 6408 ) {\\r\\n\\r\\n\\t\\t\\tif ( glType === 5126 ) internalFormat = 34836;\\r\\n\\t\\t\\tif ( glType === 5131 ) internalFormat = 34842;\\r\\n\\t\\t\\tif ( glType === 5121 ) internalFormat = 32856;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( internalFormat === 33325 || internalFormat === 33326 ||\\r\\n\\t\\t\\tinternalFormat === 34842 || internalFormat === 34836 ) {\\r\\n\\r\\n\\t\\t\\textensions.get( 'EXT_color_buffer_float' );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn internalFormat;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// Fallback filters for non-power-of-2 textures\\r\\n\\r\\n\\tfunction filterFallback( f ) {\\r\\n\\r\\n\\t\\tif ( f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter ) {\\r\\n\\r\\n\\t\\t\\treturn 9728;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn 9729;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tfunction onTextureDispose( event ) {\\r\\n\\r\\n\\t\\tvar texture = event.target;\\r\\n\\r\\n\\t\\ttexture.removeEventListener( 'dispose', onTextureDispose );\\r\\n\\r\\n\\t\\tdeallocateTexture( texture );\\r\\n\\r\\n\\t\\tif ( texture.isVideoTexture ) {\\r\\n\\r\\n\\t\\t\\t_videoTextures.delete( texture );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tinfo.memory.textures --;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction onRenderTargetDispose( event ) {\\r\\n\\r\\n\\t\\tvar renderTarget = event.target;\\r\\n\\r\\n\\t\\trenderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\\r\\n\\r\\n\\t\\tdeallocateRenderTarget( renderTarget );\\r\\n\\r\\n\\t\\tinfo.memory.textures --;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tfunction deallocateTexture( texture ) {\\r\\n\\r\\n\\t\\tvar textureProperties = properties.get( texture );\\r\\n\\r\\n\\t\\tif ( textureProperties.__webglInit === undefined ) return;\\r\\n\\r\\n\\t\\t_gl.deleteTexture( textureProperties.__webglTexture );\\r\\n\\r\\n\\t\\tproperties.remove( texture );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction deallocateRenderTarget( renderTarget ) {\\r\\n\\r\\n\\t\\tvar renderTargetProperties = properties.get( renderTarget );\\r\\n\\t\\tvar textureProperties = properties.get( renderTarget.texture );\\r\\n\\r\\n\\t\\tif ( ! renderTarget ) return;\\r\\n\\r\\n\\t\\tif ( textureProperties.__webglTexture !== undefined ) {\\r\\n\\r\\n\\t\\t\\t_gl.deleteTexture( textureProperties.__webglTexture );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( renderTarget.depthTexture ) {\\r\\n\\r\\n\\t\\t\\trenderTarget.depthTexture.dispose();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( renderTarget.isWebGLCubeRenderTarget ) {\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );\\r\\n\\t\\t\\t\\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );\\r\\n\\t\\t\\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );\\r\\n\\t\\t\\tif ( renderTargetProperties.__webglMultisampledFramebuffer ) _gl.deleteFramebuffer( renderTargetProperties.__webglMultisampledFramebuffer );\\r\\n\\t\\t\\tif ( renderTargetProperties.__webglColorRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglColorRenderbuffer );\\r\\n\\t\\t\\tif ( renderTargetProperties.__webglDepthRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthRenderbuffer );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tproperties.remove( renderTarget.texture );\\r\\n\\t\\tproperties.remove( renderTarget );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tvar textureUnits = 0;\\r\\n\\r\\n\\tfunction resetTextureUnits() {\\r\\n\\r\\n\\t\\ttextureUnits = 0;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction allocateTextureUnit() {\\r\\n\\r\\n\\t\\tvar textureUnit = textureUnits;\\r\\n\\r\\n\\t\\tif ( textureUnit >= maxTextures ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\ttextureUnits += 1;\\r\\n\\r\\n\\t\\treturn textureUnit;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tfunction setTexture2D( texture, slot ) {\\r\\n\\r\\n\\t\\tvar textureProperties = properties.get( texture );\\r\\n\\r\\n\\t\\tif ( texture.isVideoTexture ) updateVideoTexture( texture );\\r\\n\\r\\n\\t\\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\\r\\n\\r\\n\\t\\t\\tvar image = texture.image;\\r\\n\\r\\n\\t\\t\\tif ( image === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined' );\\r\\n\\r\\n\\t\\t\\t} else if ( image.complete === false ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete' );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tuploadTexture( textureProperties, texture, slot );\\r\\n\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tstate.activeTexture( 33984 + slot );\\r\\n\\t\\tstate.bindTexture( 3553, textureProperties.__webglTexture );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction setTexture2DArray( texture, slot ) {\\r\\n\\r\\n\\t\\tvar textureProperties = properties.get( texture );\\r\\n\\r\\n\\t\\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\\r\\n\\r\\n\\t\\t\\tuploadTexture( textureProperties, texture, slot );\\r\\n\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tstate.activeTexture( 33984 + slot );\\r\\n\\t\\tstate.bindTexture( 35866, textureProperties.__webglTexture );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction setTexture3D( texture, slot ) {\\r\\n\\r\\n\\t\\tvar textureProperties = properties.get( texture );\\r\\n\\r\\n\\t\\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\\r\\n\\r\\n\\t\\t\\tuploadTexture( textureProperties, texture, slot );\\r\\n\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tstate.activeTexture( 33984 + slot );\\r\\n\\t\\tstate.bindTexture( 32879, textureProperties.__webglTexture );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction setTextureCube( texture, slot ) {\\r\\n\\r\\n\\t\\tif ( texture.image.length !== 6 ) return;\\r\\n\\r\\n\\t\\tvar textureProperties = properties.get( texture );\\r\\n\\r\\n\\t\\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\\r\\n\\r\\n\\t\\t\\tinitTexture( textureProperties, texture );\\r\\n\\r\\n\\t\\t\\tstate.activeTexture( 33984 + slot );\\r\\n\\t\\t\\tstate.bindTexture( 34067, textureProperties.__webglTexture );\\r\\n\\r\\n\\t\\t\\t_gl.pixelStorei( 37440, texture.flipY );\\r\\n\\r\\n\\t\\t\\tvar isCompressed = ( texture && ( texture.isCompressedTexture || texture.image[ 0 ].isCompressedTexture ) );\\r\\n\\t\\t\\tvar isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );\\r\\n\\r\\n\\t\\t\\tvar cubeImage = [];\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( ! isCompressed && ! isDataTexture ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tcubeImage[ i ] = resizeImage( texture.image[ i ], false, true, maxCubemapSize );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tcubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar image = cubeImage[ 0 ],\\r\\n\\t\\t\\t\\tsupportsMips = isPowerOfTwo( image ) || isWebGL2,\\r\\n\\t\\t\\t\\tglFormat = utils.convert( texture.format ),\\r\\n\\t\\t\\t\\tglType = utils.convert( texture.type ),\\r\\n\\t\\t\\t\\tglInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );\\r\\n\\r\\n\\t\\t\\tsetTextureParameters( 34067, texture, supportsMips );\\r\\n\\r\\n\\t\\t\\tvar mipmaps;\\r\\n\\r\\n\\t\\t\\tif ( isCompressed ) {\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tmipmaps = cubeImage[ i ].mipmaps;\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var j = 0; j < mipmaps.length; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar mipmap = mipmaps[ j ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( glFormat !== null ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstate.compressedTexImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tstate.texImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\ttextureProperties.__maxMipLevel = mipmaps.length - 1;\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tmipmaps = texture.mipmaps;\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( isDataTexture ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tstate.texImage2D( 34069 + i, 0, glInternalFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tfor ( var j = 0; j < mipmaps.length; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tvar mipmap = mipmaps[ j ];\\r\\n\\t\\t\\t\\t\\t\\t\\tvar mipmapImage = mipmap.image[ i ].image;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tstate.texImage2D( 34069 + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tstate.texImage2D( 34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[ i ] );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tfor ( var j = 0; j < mipmaps.length; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tvar mipmap = mipmaps[ j ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tstate.texImage2D( 34069 + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[ i ] );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\ttextureProperties.__maxMipLevel = mipmaps.length;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {\\r\\n\\r\\n\\t\\t\\t\\t// We assume images for cube map have the same size.\\r\\n\\t\\t\\t\\tgenerateMipmap( 34067, texture, image.width, image.height );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\ttextureProperties.__version = texture.version;\\r\\n\\r\\n\\t\\t\\tif ( texture.onUpdate ) texture.onUpdate( texture );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tstate.activeTexture( 33984 + slot );\\r\\n\\t\\t\\tstate.bindTexture( 34067, textureProperties.__webglTexture );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction setTextureCubeDynamic( texture, slot ) {\\r\\n\\r\\n\\t\\tstate.activeTexture( 33984 + slot );\\r\\n\\t\\tstate.bindTexture( 34067, properties.get( texture ).__webglTexture );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tvar wrappingToGL = {\\r\\n\\t\\t[ RepeatWrapping ]: 10497,\\r\\n\\t\\t[ ClampToEdgeWrapping ]: 33071,\\r\\n\\t\\t[ MirroredRepeatWrapping ]: 33648\\r\\n\\t};\\r\\n\\r\\n\\tvar filterToGL = {\\r\\n\\t\\t[ NearestFilter ]: 9728,\\r\\n\\t\\t[ NearestMipmapNearestFilter ]: 9984,\\r\\n\\t\\t[ NearestMipmapLinearFilter ]: 9986,\\r\\n\\r\\n\\t\\t[ LinearFilter ]: 9729,\\r\\n\\t\\t[ LinearMipmapNearestFilter ]: 9985,\\r\\n\\t\\t[ LinearMipmapLinearFilter ]: 9987\\r\\n\\t};\\r\\n\\r\\n\\tfunction setTextureParameters( textureType, texture, supportsMips ) {\\r\\n\\r\\n\\t\\tif ( supportsMips ) {\\r\\n\\r\\n\\t\\t\\t_gl.texParameteri( textureType, 10242, wrappingToGL[ texture.wrapS ] );\\r\\n\\t\\t\\t_gl.texParameteri( textureType, 10243, wrappingToGL[ texture.wrapT ] );\\r\\n\\r\\n\\t\\t\\tif ( textureType === 32879 || textureType === 35866 ) {\\r\\n\\r\\n\\t\\t\\t\\t_gl.texParameteri( textureType, 32882, wrappingToGL[ texture.wrapR ] );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t_gl.texParameteri( textureType, 10240, filterToGL[ texture.magFilter ] );\\r\\n\\t\\t\\t_gl.texParameteri( textureType, 10241, filterToGL[ texture.minFilter ] );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t_gl.texParameteri( textureType, 10242, 33071 );\\r\\n\\t\\t\\t_gl.texParameteri( textureType, 10243, 33071 );\\r\\n\\r\\n\\t\\t\\tif ( textureType === 32879 || textureType === 35866 ) {\\r\\n\\r\\n\\t\\t\\t\\t_gl.texParameteri( textureType, 32882, 33071 );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.' );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t_gl.texParameteri( textureType, 10240, filterFallback( texture.magFilter ) );\\r\\n\\t\\t\\t_gl.texParameteri( textureType, 10241, filterFallback( texture.minFilter ) );\\r\\n\\r\\n\\t\\t\\tif ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.' );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar extension = extensions.get( 'EXT_texture_filter_anisotropic' );\\r\\n\\r\\n\\t\\tif ( extension ) {\\r\\n\\r\\n\\t\\t\\tif ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;\\r\\n\\t\\t\\tif ( texture.type === HalfFloatType && ( isWebGL2 || extensions.get( 'OES_texture_half_float_linear' ) ) === null ) return;\\r\\n\\r\\n\\t\\t\\tif ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {\\r\\n\\r\\n\\t\\t\\t\\t_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );\\r\\n\\t\\t\\t\\tproperties.get( texture ).__currentAnisotropy = texture.anisotropy;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction initTexture( textureProperties, texture ) {\\r\\n\\r\\n\\t\\tif ( textureProperties.__webglInit === undefined ) {\\r\\n\\r\\n\\t\\t\\ttextureProperties.__webglInit = true;\\r\\n\\r\\n\\t\\t\\ttexture.addEventListener( 'dispose', onTextureDispose );\\r\\n\\r\\n\\t\\t\\ttextureProperties.__webglTexture = _gl.createTexture();\\r\\n\\r\\n\\t\\t\\tinfo.memory.textures ++;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction uploadTexture( textureProperties, texture, slot ) {\\r\\n\\r\\n\\t\\tvar textureType = 3553;\\r\\n\\r\\n\\t\\tif ( texture.isDataTexture2DArray ) textureType = 35866;\\r\\n\\t\\tif ( texture.isDataTexture3D ) textureType = 32879;\\r\\n\\r\\n\\t\\tinitTexture( textureProperties, texture );\\r\\n\\r\\n\\t\\tstate.activeTexture( 33984 + slot );\\r\\n\\t\\tstate.bindTexture( textureType, textureProperties.__webglTexture );\\r\\n\\r\\n\\t\\t_gl.pixelStorei( 37440, texture.flipY );\\r\\n\\t\\t_gl.pixelStorei( 37441, texture.premultiplyAlpha );\\r\\n\\t\\t_gl.pixelStorei( 3317, texture.unpackAlignment );\\r\\n\\r\\n\\t\\tvar needsPowerOfTwo = textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( texture.image ) === false;\\r\\n\\t\\tvar image = resizeImage( texture.image, needsPowerOfTwo, false, maxTextureSize );\\r\\n\\r\\n\\t\\tvar supportsMips = isPowerOfTwo( image ) || isWebGL2,\\r\\n\\t\\t\\tglFormat = utils.convert( texture.format ),\\r\\n\\t\\t\\tglType = utils.convert( texture.type ),\\r\\n\\t\\t\\tglInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );\\r\\n\\r\\n\\t\\tsetTextureParameters( textureType, texture, supportsMips );\\r\\n\\r\\n\\t\\tvar mipmap, mipmaps = texture.mipmaps;\\r\\n\\r\\n\\t\\tif ( texture.isDepthTexture ) {\\r\\n\\r\\n\\t\\t\\t// populate depth texture with dummy data\\r\\n\\r\\n\\t\\t\\tglInternalFormat = 6402;\\r\\n\\r\\n\\t\\t\\tif ( isWebGL2 ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( texture.type === FloatType ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tglInternalFormat = 36012;\\r\\n\\r\\n\\t\\t\\t\\t} else if ( texture.type === UnsignedIntType ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tglInternalFormat = 33190;\\r\\n\\r\\n\\t\\t\\t\\t} else if ( texture.type === UnsignedInt248Type ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tglInternalFormat = 35056;\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tglInternalFormat = 33189; // WebGL2 requires sized internalformat for glTexImage2D\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tif ( texture.type === FloatType ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.error( 'WebGLRenderer: Floating point depth texture requires WebGL2.' );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// validation checks for WebGL 1\\r\\n\\r\\n\\t\\t\\tif ( texture.format === DepthFormat && glInternalFormat === 6402 ) {\\r\\n\\r\\n\\t\\t\\t\\t// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are\\r\\n\\t\\t\\t\\t// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT\\r\\n\\t\\t\\t\\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\\r\\n\\t\\t\\t\\tif ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );\\r\\n\\r\\n\\t\\t\\t\\t\\ttexture.type = UnsignedShortType;\\r\\n\\t\\t\\t\\t\\tglType = utils.convert( texture.type );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( texture.format === DepthStencilFormat && glInternalFormat === 6402 ) {\\r\\n\\r\\n\\t\\t\\t\\t// Depth stencil textures need the DEPTH_STENCIL internal format\\r\\n\\t\\t\\t\\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\\r\\n\\t\\t\\t\\tglInternalFormat = 34041;\\r\\n\\r\\n\\t\\t\\t\\t// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are\\r\\n\\t\\t\\t\\t// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.\\r\\n\\t\\t\\t\\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\\r\\n\\t\\t\\t\\tif ( texture.type !== UnsignedInt248Type ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );\\r\\n\\r\\n\\t\\t\\t\\t\\ttexture.type = UnsignedInt248Type;\\r\\n\\t\\t\\t\\t\\tglType = utils.convert( texture.type );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t//\\r\\n\\r\\n\\t\\t\\tstate.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );\\r\\n\\r\\n\\t\\t} else if ( texture.isDataTexture ) {\\r\\n\\r\\n\\t\\t\\t// use manually created mipmaps if available\\r\\n\\t\\t\\t// if there are no manual mipmaps\\r\\n\\t\\t\\t// set 0 level mipmap and then use GL to generate other mipmap levels\\r\\n\\r\\n\\t\\t\\tif ( mipmaps.length > 0 && supportsMips ) {\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tmipmap = mipmaps[ i ];\\r\\n\\t\\t\\t\\t\\tstate.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\ttexture.generateMipmaps = false;\\r\\n\\t\\t\\t\\ttextureProperties.__maxMipLevel = mipmaps.length - 1;\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tstate.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data );\\r\\n\\t\\t\\t\\ttextureProperties.__maxMipLevel = 0;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t} else if ( texture.isCompressedTexture ) {\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tmipmap = mipmaps[ i ];\\r\\n\\r\\n\\t\\t\\t\\tif ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( glFormat !== null ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tstate.compressedTexImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tstate.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\ttextureProperties.__maxMipLevel = mipmaps.length - 1;\\r\\n\\r\\n\\t\\t} else if ( texture.isDataTexture2DArray ) {\\r\\n\\r\\n\\t\\t\\tstate.texImage3D( 35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );\\r\\n\\t\\t\\ttextureProperties.__maxMipLevel = 0;\\r\\n\\r\\n\\t\\t} else if ( texture.isDataTexture3D ) {\\r\\n\\r\\n\\t\\t\\tstate.texImage3D( 32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );\\r\\n\\t\\t\\ttextureProperties.__maxMipLevel = 0;\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t// regular Texture (image, video, canvas)\\r\\n\\r\\n\\t\\t\\t// use manually created mipmaps if available\\r\\n\\t\\t\\t// if there are no manual mipmaps\\r\\n\\t\\t\\t// set 0 level mipmap and then use GL to generate other mipmap levels\\r\\n\\r\\n\\t\\t\\tif ( mipmaps.length > 0 && supportsMips ) {\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tmipmap = mipmaps[ i ];\\r\\n\\t\\t\\t\\t\\tstate.texImage2D( 3553, i, glInternalFormat, glFormat, glType, mipmap );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\ttexture.generateMipmaps = false;\\r\\n\\t\\t\\t\\ttextureProperties.__maxMipLevel = mipmaps.length - 1;\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tstate.texImage2D( 3553, 0, glInternalFormat, glFormat, glType, image );\\r\\n\\t\\t\\t\\ttextureProperties.__maxMipLevel = 0;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {\\r\\n\\r\\n\\t\\t\\tgenerateMipmap( textureType, texture, image.width, image.height );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\ttextureProperties.__version = texture.version;\\r\\n\\r\\n\\t\\tif ( texture.onUpdate ) texture.onUpdate( texture );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// Render targets\\r\\n\\r\\n\\t// Setup storage for target texture and bind it to correct framebuffer\\r\\n\\tfunction setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {\\r\\n\\r\\n\\t\\tvar glFormat = utils.convert( renderTarget.texture.format );\\r\\n\\t\\tvar glType = utils.convert( renderTarget.texture.type );\\r\\n\\t\\tvar glInternalFormat = getInternalFormat( renderTarget.texture.internalFormat, glFormat, glType );\\r\\n\\t\\tstate.texImage2D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\\r\\n\\t\\t_gl.bindFramebuffer( 36160, framebuffer );\\r\\n\\t\\t_gl.framebufferTexture2D( 36160, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );\\r\\n\\t\\t_gl.bindFramebuffer( 36160, null );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// Setup storage for internal depth/stencil buffers and bind to correct framebuffer\\r\\n\\tfunction setupRenderBufferStorage( renderbuffer, renderTarget, isMultisample ) {\\r\\n\\r\\n\\t\\t_gl.bindRenderbuffer( 36161, renderbuffer );\\r\\n\\r\\n\\t\\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\\r\\n\\r\\n\\t\\t\\tvar glInternalFormat = 33189;\\r\\n\\r\\n\\t\\t\\tif ( isMultisample ) {\\r\\n\\r\\n\\t\\t\\t\\tvar depthTexture = renderTarget.depthTexture;\\r\\n\\r\\n\\t\\t\\t\\tif ( depthTexture && depthTexture.isDepthTexture ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( depthTexture.type === FloatType ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tglInternalFormat = 36012;\\r\\n\\r\\n\\t\\t\\t\\t\\t} else if ( depthTexture.type === UnsignedIntType ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tglInternalFormat = 33190;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tvar samples = getRenderTargetSamples( renderTarget );\\r\\n\\r\\n\\t\\t\\t\\t_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t_gl.renderbufferStorage( 36161, glInternalFormat, renderTarget.width, renderTarget.height );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t_gl.framebufferRenderbuffer( 36160, 36096, 36161, renderbuffer );\\r\\n\\r\\n\\t\\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\\r\\n\\r\\n\\t\\t\\tif ( isMultisample ) {\\r\\n\\r\\n\\t\\t\\t\\tvar samples = getRenderTargetSamples( renderTarget );\\r\\n\\r\\n\\t\\t\\t\\t_gl.renderbufferStorageMultisample( 36161, samples, 35056, renderTarget.width, renderTarget.height );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t_gl.renderbufferStorage( 36161, 34041, renderTarget.width, renderTarget.height );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\r\\n\\t\\t\\t_gl.framebufferRenderbuffer( 36160, 33306, 36161, renderbuffer );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tvar glFormat = utils.convert( renderTarget.texture.format );\\r\\n\\t\\t\\tvar glType = utils.convert( renderTarget.texture.type );\\r\\n\\t\\t\\tvar glInternalFormat = getInternalFormat( renderTarget.texture.internalFormat, glFormat, glType );\\r\\n\\r\\n\\t\\t\\tif ( isMultisample ) {\\r\\n\\r\\n\\t\\t\\t\\tvar samples = getRenderTargetSamples( renderTarget );\\r\\n\\r\\n\\t\\t\\t\\t_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t_gl.renderbufferStorage( 36161, glInternalFormat, renderTarget.width, renderTarget.height );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t_gl.bindRenderbuffer( 36161, null );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// Setup resources for a Depth Texture for a FBO (needs an extension)\\r\\n\\tfunction setupDepthTexture( framebuffer, renderTarget ) {\\r\\n\\r\\n\\t\\tvar isCube = ( renderTarget && renderTarget.isWebGLCubeRenderTarget );\\r\\n\\t\\tif ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );\\r\\n\\r\\n\\t\\t_gl.bindFramebuffer( 36160, framebuffer );\\r\\n\\r\\n\\t\\tif ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {\\r\\n\\r\\n\\t\\t\\tthrow new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// upload an empty depth texture with framebuffer size\\r\\n\\t\\tif ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||\\r\\n\\t\\t\\t\\trenderTarget.depthTexture.image.width !== renderTarget.width ||\\r\\n\\t\\t\\t\\trenderTarget.depthTexture.image.height !== renderTarget.height ) {\\r\\n\\r\\n\\t\\t\\trenderTarget.depthTexture.image.width = renderTarget.width;\\r\\n\\t\\t\\trenderTarget.depthTexture.image.height = renderTarget.height;\\r\\n\\t\\t\\trenderTarget.depthTexture.needsUpdate = true;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tsetTexture2D( renderTarget.depthTexture, 0 );\\r\\n\\r\\n\\t\\tvar webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;\\r\\n\\r\\n\\t\\tif ( renderTarget.depthTexture.format === DepthFormat ) {\\r\\n\\r\\n\\t\\t\\t_gl.framebufferTexture2D( 36160, 36096, 3553, webglDepthTexture, 0 );\\r\\n\\r\\n\\t\\t} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {\\r\\n\\r\\n\\t\\t\\t_gl.framebufferTexture2D( 36160, 33306, 3553, webglDepthTexture, 0 );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tthrow new Error( 'Unknown depthTexture format' );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// Setup GL resources for a non-texture depth buffer\\r\\n\\tfunction setupDepthRenderbuffer( renderTarget ) {\\r\\n\\r\\n\\t\\tvar renderTargetProperties = properties.get( renderTarget );\\r\\n\\r\\n\\t\\tvar isCube = ( renderTarget.isWebGLCubeRenderTarget === true );\\r\\n\\r\\n\\t\\tif ( renderTarget.depthTexture ) {\\r\\n\\r\\n\\t\\t\\tif ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );\\r\\n\\r\\n\\t\\t\\tsetupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tif ( isCube ) {\\r\\n\\r\\n\\t\\t\\t\\trenderTargetProperties.__webglDepthbuffer = [];\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t_gl.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer[ i ] );\\r\\n\\t\\t\\t\\t\\trenderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();\\r\\n\\t\\t\\t\\t\\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget, false );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t_gl.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer );\\r\\n\\t\\t\\t\\trenderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();\\r\\n\\t\\t\\t\\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget, false );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t_gl.bindFramebuffer( 36160, null );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// Set up GL resources for the render target\\r\\n\\tfunction setupRenderTarget( renderTarget ) {\\r\\n\\r\\n\\t\\tvar renderTargetProperties = properties.get( renderTarget );\\r\\n\\t\\tvar textureProperties = properties.get( renderTarget.texture );\\r\\n\\r\\n\\t\\trenderTarget.addEventListener( 'dispose', onRenderTargetDispose );\\r\\n\\r\\n\\t\\ttextureProperties.__webglTexture = _gl.createTexture();\\r\\n\\r\\n\\t\\tinfo.memory.textures ++;\\r\\n\\r\\n\\t\\tvar isCube = ( renderTarget.isWebGLCubeRenderTarget === true );\\r\\n\\t\\tvar isMultisample = ( renderTarget.isWebGLMultisampleRenderTarget === true );\\r\\n\\t\\tvar supportsMips = isPowerOfTwo( renderTarget ) || isWebGL2;\\r\\n\\r\\n\\t\\t// Handles WebGL2 RGBFormat fallback - #18858\\r\\n\\r\\n\\t\\tif ( isWebGL2 && renderTarget.texture.format === RGBFormat && ( renderTarget.texture.type === FloatType || renderTarget.texture.type === HalfFloatType ) ) {\\r\\n\\r\\n\\t\\t\\trenderTarget.texture.format = RGBAFormat;\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.' );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Setup framebuffer\\r\\n\\r\\n\\t\\tif ( isCube ) {\\r\\n\\r\\n\\t\\t\\trenderTargetProperties.__webglFramebuffer = [];\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\trenderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\trenderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();\\r\\n\\r\\n\\t\\t\\tif ( isMultisample ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( isWebGL2 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\trenderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();\\r\\n\\t\\t\\t\\t\\trenderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();\\r\\n\\r\\n\\t\\t\\t\\t\\t_gl.bindRenderbuffer( 36161, renderTargetProperties.__webglColorRenderbuffer );\\r\\n\\r\\n\\t\\t\\t\\t\\tvar glFormat = utils.convert( renderTarget.texture.format );\\r\\n\\t\\t\\t\\t\\tvar glType = utils.convert( renderTarget.texture.type );\\r\\n\\t\\t\\t\\t\\tvar glInternalFormat = getInternalFormat( renderTarget.texture.internalFormat, glFormat, glType );\\r\\n\\t\\t\\t\\t\\tvar samples = getRenderTargetSamples( renderTarget );\\r\\n\\t\\t\\t\\t\\t_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );\\r\\n\\r\\n\\t\\t\\t\\t\\t_gl.bindFramebuffer( 36160, renderTargetProperties.__webglMultisampledFramebuffer );\\r\\n\\t\\t\\t\\t\\t_gl.framebufferRenderbuffer( 36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer );\\r\\n\\t\\t\\t\\t\\t_gl.bindRenderbuffer( 36161, null );\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( renderTarget.depthBuffer ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\trenderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();\\r\\n\\t\\t\\t\\t\\t\\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t_gl.bindFramebuffer( 36160, null );\\r\\n\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Setup color buffer\\r\\n\\r\\n\\t\\tif ( isCube ) {\\r\\n\\r\\n\\t\\t\\tstate.bindTexture( 34067, textureProperties.__webglTexture );\\r\\n\\t\\t\\tsetTextureParameters( 34067, renderTarget.texture, supportsMips );\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, 36064, 34069 + i );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( textureNeedsGenerateMipmaps( renderTarget.texture, supportsMips ) ) {\\r\\n\\r\\n\\t\\t\\t\\tgenerateMipmap( 34067, renderTarget.texture, renderTarget.width, renderTarget.height );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tstate.bindTexture( 34067, null );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tstate.bindTexture( 3553, textureProperties.__webglTexture );\\r\\n\\t\\t\\tsetTextureParameters( 3553, renderTarget.texture, supportsMips );\\r\\n\\t\\t\\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, 36064, 3553 );\\r\\n\\r\\n\\t\\t\\tif ( textureNeedsGenerateMipmaps( renderTarget.texture, supportsMips ) ) {\\r\\n\\r\\n\\t\\t\\t\\tgenerateMipmap( 3553, renderTarget.texture, renderTarget.width, renderTarget.height );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tstate.bindTexture( 3553, null );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Setup depth and stencil buffers\\r\\n\\r\\n\\t\\tif ( renderTarget.depthBuffer ) {\\r\\n\\r\\n\\t\\t\\tsetupDepthRenderbuffer( renderTarget );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction updateRenderTargetMipmap( renderTarget ) {\\r\\n\\r\\n\\t\\tvar texture = renderTarget.texture;\\r\\n\\t\\tvar supportsMips = isPowerOfTwo( renderTarget ) || isWebGL2;\\r\\n\\r\\n\\t\\tif ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {\\r\\n\\r\\n\\t\\t\\tvar target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;\\r\\n\\t\\t\\tvar webglTexture = properties.get( texture ).__webglTexture;\\r\\n\\r\\n\\t\\t\\tstate.bindTexture( target, webglTexture );\\r\\n\\t\\t\\tgenerateMipmap( target, texture, renderTarget.width, renderTarget.height );\\r\\n\\t\\t\\tstate.bindTexture( target, null );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction updateMultisampleRenderTarget( renderTarget ) {\\r\\n\\r\\n\\t\\tif ( renderTarget.isWebGLMultisampleRenderTarget ) {\\r\\n\\r\\n\\t\\t\\tif ( isWebGL2 ) {\\r\\n\\r\\n\\t\\t\\t\\tvar renderTargetProperties = properties.get( renderTarget );\\r\\n\\r\\n\\t\\t\\t\\t_gl.bindFramebuffer( 36008, renderTargetProperties.__webglMultisampledFramebuffer );\\r\\n\\t\\t\\t\\t_gl.bindFramebuffer( 36009, renderTargetProperties.__webglFramebuffer );\\r\\n\\r\\n\\t\\t\\t\\tvar width = renderTarget.width;\\r\\n\\t\\t\\t\\tvar height = renderTarget.height;\\r\\n\\t\\t\\t\\tvar mask = 16384;\\r\\n\\r\\n\\t\\t\\t\\tif ( renderTarget.depthBuffer ) mask |= 256;\\r\\n\\t\\t\\t\\tif ( renderTarget.stencilBuffer ) mask |= 1024;\\r\\n\\r\\n\\t\\t\\t\\t_gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, 9728 );\\r\\n\\r\\n\\t\\t\\t\\t_gl.bindFramebuffer( 36160, renderTargetProperties.__webglMultisampledFramebuffer ); // see #18905\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction getRenderTargetSamples( renderTarget ) {\\r\\n\\r\\n\\t\\treturn ( isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ) ?\\r\\n\\t\\t\\tMath.min( maxSamples, renderTarget.samples ) : 0;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction updateVideoTexture( texture ) {\\r\\n\\r\\n\\t\\tvar frame = info.render.frame;\\r\\n\\r\\n\\t\\t// Check the last frame we updated the VideoTexture\\r\\n\\r\\n\\t\\tif ( _videoTextures.get( texture ) !== frame ) {\\r\\n\\r\\n\\t\\t\\t_videoTextures.set( texture, frame );\\r\\n\\t\\t\\ttexture.update();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// backwards compatibility\\r\\n\\r\\n\\tvar warnedTexture2D = false;\\r\\n\\tvar warnedTextureCube = false;\\r\\n\\r\\n\\tfunction safeSetTexture2D( texture, slot ) {\\r\\n\\r\\n\\t\\tif ( texture && texture.isWebGLRenderTarget ) {\\r\\n\\r\\n\\t\\t\\tif ( warnedTexture2D === false ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( \\\"THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.\\\" );\\r\\n\\t\\t\\t\\twarnedTexture2D = true;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\ttexture = texture.texture;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tsetTexture2D( texture, slot );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction safeSetTextureCube( texture, slot ) {\\r\\n\\r\\n\\t\\tif ( texture && texture.isWebGLCubeRenderTarget ) {\\r\\n\\r\\n\\t\\t\\tif ( warnedTextureCube === false ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( \\\"THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.\\\" );\\r\\n\\t\\t\\t\\twarnedTextureCube = true;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\ttexture = texture.texture;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// currently relying on the fact that WebGLCubeRenderTarget.texture is a Texture and NOT a CubeTexture\\r\\n\\t\\t// TODO: unify these code paths\\r\\n\\t\\tif ( ( texture && texture.isCubeTexture ) ||\\r\\n\\t\\t\\t( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {\\r\\n\\r\\n\\t\\t\\t// CompressedTexture can have Array in image :/\\r\\n\\r\\n\\t\\t\\t// this function alone should take care of cube textures\\r\\n\\t\\t\\tsetTextureCube( texture, slot );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t// assumed: texture property of THREE.WebGLCubeRenderTarget\\r\\n\\t\\t\\tsetTextureCubeDynamic( texture, slot );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tthis.allocateTextureUnit = allocateTextureUnit;\\r\\n\\tthis.resetTextureUnits = resetTextureUnits;\\r\\n\\r\\n\\tthis.setTexture2D = setTexture2D;\\r\\n\\tthis.setTexture2DArray = setTexture2DArray;\\r\\n\\tthis.setTexture3D = setTexture3D;\\r\\n\\tthis.setTextureCube = setTextureCube;\\r\\n\\tthis.setTextureCubeDynamic = setTextureCubeDynamic;\\r\\n\\tthis.setupRenderTarget = setupRenderTarget;\\r\\n\\tthis.updateRenderTargetMipmap = updateRenderTargetMipmap;\\r\\n\\tthis.updateMultisampleRenderTarget = updateMultisampleRenderTarget;\\r\\n\\r\\n\\tthis.safeSetTexture2D = safeSetTexture2D;\\r\\n\\tthis.safeSetTextureCube = safeSetTextureCube;\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * @author thespite / http://www.twitter.com/thespite\\r\\n */\\r\\n\\r\\nfunction WebGLUtils( gl, extensions, capabilities ) {\\r\\n\\r\\n\\tvar isWebGL2 = capabilities.isWebGL2;\\r\\n\\r\\n\\tfunction convert( p ) {\\r\\n\\r\\n\\t\\tvar extension;\\r\\n\\r\\n\\t\\tif ( p === UnsignedByteType ) return 5121;\\r\\n\\t\\tif ( p === UnsignedShort4444Type ) return 32819;\\r\\n\\t\\tif ( p === UnsignedShort5551Type ) return 32820;\\r\\n\\t\\tif ( p === UnsignedShort565Type ) return 33635;\\r\\n\\r\\n\\t\\tif ( p === ByteType ) return 5120;\\r\\n\\t\\tif ( p === ShortType ) return 5122;\\r\\n\\t\\tif ( p === UnsignedShortType ) return 5123;\\r\\n\\t\\tif ( p === IntType ) return 5124;\\r\\n\\t\\tif ( p === UnsignedIntType ) return 5125;\\r\\n\\t\\tif ( p === FloatType ) return 5126;\\r\\n\\r\\n\\t\\tif ( p === HalfFloatType ) {\\r\\n\\r\\n\\t\\t\\tif ( isWebGL2 ) return 5131;\\r\\n\\r\\n\\t\\t\\textension = extensions.get( 'OES_texture_half_float' );\\r\\n\\r\\n\\t\\t\\tif ( extension !== null ) {\\r\\n\\r\\n\\t\\t\\t\\treturn extension.HALF_FLOAT_OES;\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\treturn null;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( p === AlphaFormat ) return 6406;\\r\\n\\t\\tif ( p === RGBFormat ) return 6407;\\r\\n\\t\\tif ( p === RGBAFormat ) return 6408;\\r\\n\\t\\tif ( p === LuminanceFormat ) return 6409;\\r\\n\\t\\tif ( p === LuminanceAlphaFormat ) return 6410;\\r\\n\\t\\tif ( p === DepthFormat ) return 6402;\\r\\n\\t\\tif ( p === DepthStencilFormat ) return 34041;\\r\\n\\t\\tif ( p === RedFormat ) return 6403;\\r\\n\\r\\n\\t\\t// WebGL2 formats.\\r\\n\\r\\n\\t\\tif ( p === RedIntegerFormat ) return 36244;\\r\\n\\t\\tif ( p === RGFormat ) return 33319;\\r\\n\\t\\tif ( p === RGIntegerFormat ) return 33320;\\r\\n\\t\\tif ( p === RGBIntegerFormat ) return 36248;\\r\\n\\t\\tif ( p === RGBAIntegerFormat ) return 36249;\\r\\n\\r\\n\\t\\tif ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||\\r\\n\\t\\t\\tp === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {\\r\\n\\r\\n\\t\\t\\textension = extensions.get( 'WEBGL_compressed_texture_s3tc' );\\r\\n\\r\\n\\t\\t\\tif ( extension !== null ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\\r\\n\\t\\t\\t\\tif ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\\r\\n\\t\\t\\t\\tif ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\\r\\n\\t\\t\\t\\tif ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\treturn null;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||\\r\\n\\t\\t\\tp === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {\\r\\n\\r\\n\\t\\t\\textension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );\\r\\n\\r\\n\\t\\t\\tif ( extension !== null ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\\r\\n\\t\\t\\t\\tif ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\\r\\n\\t\\t\\t\\tif ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\\r\\n\\t\\t\\t\\tif ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\treturn null;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( p === RGB_ETC1_Format ) {\\r\\n\\r\\n\\t\\t\\textension = extensions.get( 'WEBGL_compressed_texture_etc1' );\\r\\n\\r\\n\\t\\t\\tif ( extension !== null ) {\\r\\n\\r\\n\\t\\t\\t\\treturn extension.COMPRESSED_RGB_ETC1_WEBGL;\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\treturn null;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format ) {\\r\\n\\r\\n\\t\\t\\textension = extensions.get( 'WEBGL_compressed_texture_etc' );\\r\\n\\r\\n\\t\\t\\tif ( extension !== null ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( p === RGB_ETC2_Format ) return extension.COMPRESSED_RGB8_ETC2;\\r\\n\\t\\t\\t\\tif ( p === RGBA_ETC2_EAC_Format ) return extension.COMPRESSED_RGBA8_ETC2_EAC;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||\\r\\n\\t\\t\\tp === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||\\r\\n\\t\\t\\tp === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||\\r\\n\\t\\t\\tp === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||\\r\\n\\t\\t\\tp === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ||\\r\\n\\t\\t\\tp === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format ||\\r\\n\\t\\t\\tp === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format ||\\r\\n\\t\\t\\tp === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format ||\\r\\n\\t\\t\\tp === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format ||\\r\\n\\t\\t\\tp === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format ) {\\r\\n\\r\\n\\t\\t\\textension = extensions.get( 'WEBGL_compressed_texture_astc' );\\r\\n\\r\\n\\t\\t\\tif ( extension !== null ) {\\r\\n\\r\\n\\t\\t\\t\\t// TODO Complete?\\r\\n\\r\\n\\t\\t\\t\\treturn p;\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\treturn null;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( p === RGBA_BPTC_Format ) {\\r\\n\\r\\n\\t\\t\\textension = extensions.get( 'EXT_texture_compression_bptc' );\\r\\n\\r\\n\\t\\t\\tif ( extension !== null ) {\\r\\n\\r\\n\\t\\t\\t\\t// TODO Complete?\\r\\n\\r\\n\\t\\t\\t\\treturn p;\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\treturn null;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( p === UnsignedInt248Type ) {\\r\\n\\r\\n\\t\\t\\tif ( isWebGL2 ) return 34042;\\r\\n\\r\\n\\t\\t\\textension = extensions.get( 'WEBGL_depth_texture' );\\r\\n\\r\\n\\t\\t\\tif ( extension !== null ) {\\r\\n\\r\\n\\t\\t\\t\\treturn extension.UNSIGNED_INT_24_8_WEBGL;\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\treturn null;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn { convert: convert };\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nfunction ArrayCamera( array ) {\\r\\n\\r\\n\\tPerspectiveCamera.call( this );\\r\\n\\r\\n\\tthis.cameras = array || [];\\r\\n\\r\\n}\\r\\n\\r\\nArrayCamera.prototype = Object.assign( Object.create( PerspectiveCamera.prototype ), {\\r\\n\\r\\n\\tconstructor: ArrayCamera,\\r\\n\\r\\n\\tisArrayCamera: true\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nfunction Group() {\\r\\n\\r\\n\\tObject3D.call( this );\\r\\n\\r\\n\\tthis.type = 'Group';\\r\\n\\r\\n}\\r\\n\\r\\nGroup.prototype = Object.assign( Object.create( Object3D.prototype ), {\\r\\n\\r\\n\\tconstructor: Group,\\r\\n\\r\\n\\tisGroup: true\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author Mugen87 / https://github.com/Mugen87\\r\\n */\\r\\n\\r\\nfunction WebXRController() {\\r\\n\\r\\n\\tthis._targetRay = null;\\r\\n\\tthis._grip = null;\\r\\n\\r\\n}\\r\\n\\r\\nObject.assign( WebXRController.prototype, {\\r\\n\\r\\n\\tconstructor: WebXRController,\\r\\n\\r\\n\\tgetTargetRaySpace: function () {\\r\\n\\r\\n\\t\\tif ( this._targetRay === null ) {\\r\\n\\r\\n\\t\\t\\tthis._targetRay = new Group();\\r\\n\\t\\t\\tthis._targetRay.matrixAutoUpdate = false;\\r\\n\\t\\t\\tthis._targetRay.visible = false;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this._targetRay;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetGripSpace: function () {\\r\\n\\r\\n\\t\\tif ( this._grip === null ) {\\r\\n\\r\\n\\t\\t\\tthis._grip = new Group();\\r\\n\\t\\t\\tthis._grip.matrixAutoUpdate = false;\\r\\n\\t\\t\\tthis._grip.visible = false;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this._grip;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tdispatchEvent: function ( event ) {\\r\\n\\r\\n\\t\\tif ( this._targetRay !== null ) {\\r\\n\\r\\n\\t\\t\\tthis._targetRay.dispatchEvent( event );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( this._grip !== null ) {\\r\\n\\r\\n\\t\\t\\tthis._grip.dispatchEvent( event );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tdisconnect: function ( inputSource ) {\\r\\n\\r\\n\\t\\tthis.dispatchEvent( { type: 'disconnected', data: inputSource } );\\r\\n\\r\\n\\t\\tif ( this._targetRay !== null ) {\\r\\n\\r\\n\\t\\t\\tthis._targetRay.visible = false;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( this._grip !== null ) {\\r\\n\\r\\n\\t\\t\\tthis._grip.visible = false;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tupdate: function ( inputSource, frame, referenceSpace ) {\\r\\n\\r\\n\\t\\tvar inputPose = null;\\r\\n\\t\\tvar gripPose = null;\\r\\n\\r\\n\\t\\tvar targetRay = this._targetRay;\\r\\n\\t\\tvar grip = this._grip;\\r\\n\\r\\n\\t\\tif ( inputSource ) {\\r\\n\\r\\n\\t\\t\\tif ( targetRay !== null ) {\\r\\n\\r\\n\\t\\t\\t\\tinputPose = frame.getPose( inputSource.targetRaySpace, referenceSpace );\\r\\n\\r\\n\\t\\t\\t\\tif ( inputPose !== null ) {\\r\\n\\r\\n\\t\\t\\t\\t\\ttargetRay.matrix.fromArray( inputPose.transform.matrix );\\r\\n\\t\\t\\t\\t\\ttargetRay.matrix.decompose( targetRay.position, targetRay.rotation, targetRay.scale );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( grip !== null && inputSource.gripSpace ) {\\r\\n\\r\\n\\t\\t\\t\\tgripPose = frame.getPose( inputSource.gripSpace, referenceSpace );\\r\\n\\r\\n\\t\\t\\t\\tif ( gripPose !== null ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tgrip.matrix.fromArray( gripPose.transform.matrix );\\r\\n\\t\\t\\t\\t\\tgrip.matrix.decompose( grip.position, grip.rotation, grip.scale );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( targetRay !== null ) {\\r\\n\\r\\n\\t\\t\\ttargetRay.visible = ( inputPose !== null );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( grip !== null ) {\\r\\n\\r\\n\\t\\t\\tgrip.visible = ( gripPose !== null );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nfunction WebXRManager( renderer, gl ) {\\r\\n\\r\\n\\tvar scope = this;\\r\\n\\r\\n\\tvar session = null;\\r\\n\\r\\n\\tvar framebufferScaleFactor = 1.0;\\r\\n\\r\\n\\tvar referenceSpace = null;\\r\\n\\tvar referenceSpaceType = 'local-floor';\\r\\n\\r\\n\\tvar pose = null;\\r\\n\\r\\n\\tvar controllers = [];\\r\\n\\tvar inputSourcesMap = new Map();\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tvar cameraL = new PerspectiveCamera();\\r\\n\\tcameraL.layers.enable( 1 );\\r\\n\\tcameraL.viewport = new Vector4();\\r\\n\\r\\n\\tvar cameraR = new PerspectiveCamera();\\r\\n\\tcameraR.layers.enable( 2 );\\r\\n\\tcameraR.viewport = new Vector4();\\r\\n\\r\\n\\tvar cameras = [ cameraL, cameraR ];\\r\\n\\r\\n\\tvar cameraVR = new ArrayCamera();\\r\\n\\tcameraVR.layers.enable( 1 );\\r\\n\\tcameraVR.layers.enable( 2 );\\r\\n\\r\\n\\tvar _currentDepthNear = null;\\r\\n\\tvar _currentDepthFar = null;\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tthis.enabled = false;\\r\\n\\r\\n\\tthis.isPresenting = false;\\r\\n\\r\\n\\tthis.getController = function ( index ) {\\r\\n\\r\\n\\t\\tvar controller = controllers[ index ];\\r\\n\\r\\n\\t\\tif ( controller === undefined ) {\\r\\n\\r\\n\\t\\t\\tcontroller = new WebXRController();\\r\\n\\t\\t\\tcontrollers[ index ] = controller;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn controller.getTargetRaySpace();\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.getControllerGrip = function ( index ) {\\r\\n\\r\\n\\t\\tvar controller = controllers[ index ];\\r\\n\\r\\n\\t\\tif ( controller === undefined ) {\\r\\n\\r\\n\\t\\t\\tcontroller = new WebXRController();\\r\\n\\t\\t\\tcontrollers[ index ] = controller;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn controller.getGripSpace();\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tfunction onSessionEvent( event ) {\\r\\n\\r\\n\\t\\tvar controller = inputSourcesMap.get( event.inputSource );\\r\\n\\r\\n\\t\\tif ( controller ) {\\r\\n\\r\\n\\t\\t\\tcontroller.dispatchEvent( { type: event.type } );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction onSessionEnd() {\\r\\n\\r\\n\\t\\tinputSourcesMap.forEach( function ( controller, inputSource ) {\\r\\n\\r\\n\\t\\t\\tcontroller.disconnect( inputSource );\\r\\n\\r\\n\\t\\t} );\\r\\n\\r\\n\\t\\tinputSourcesMap.clear();\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\trenderer.setFramebuffer( null );\\r\\n\\t\\trenderer.setRenderTarget( renderer.getRenderTarget() ); // Hack #15830\\r\\n\\t\\tanimation.stop();\\r\\n\\r\\n\\t\\tscope.isPresenting = false;\\r\\n\\r\\n\\t\\tscope.dispatchEvent( { type: 'sessionend' } );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction onRequestReferenceSpace( value ) {\\r\\n\\r\\n\\t\\treferenceSpace = value;\\r\\n\\r\\n\\t\\tanimation.setContext( session );\\r\\n\\t\\tanimation.start();\\r\\n\\r\\n\\t\\tscope.isPresenting = true;\\r\\n\\r\\n\\t\\tscope.dispatchEvent( { type: 'sessionstart' } );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tthis.setFramebufferScaleFactor = function ( value ) {\\r\\n\\r\\n\\t\\tframebufferScaleFactor = value;\\r\\n\\r\\n\\t\\tif ( scope.isPresenting === true ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebXRManager: Cannot change framebuffer scale while presenting.' );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.setReferenceSpaceType = function ( value ) {\\r\\n\\r\\n\\t\\treferenceSpaceType = value;\\r\\n\\r\\n\\t\\tif ( scope.isPresenting === true ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebXRManager: Cannot change reference space type while presenting.' );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.getReferenceSpace = function () {\\r\\n\\r\\n\\t\\treturn referenceSpace;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.getSession = function () {\\r\\n\\r\\n\\t\\treturn session;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.setSession = function ( value ) {\\r\\n\\r\\n\\t\\tsession = value;\\r\\n\\r\\n\\t\\tif ( session !== null ) {\\r\\n\\r\\n\\t\\t\\tsession.addEventListener( 'select', onSessionEvent );\\r\\n\\t\\t\\tsession.addEventListener( 'selectstart', onSessionEvent );\\r\\n\\t\\t\\tsession.addEventListener( 'selectend', onSessionEvent );\\r\\n\\t\\t\\tsession.addEventListener( 'squeeze', onSessionEvent );\\r\\n\\t\\t\\tsession.addEventListener( 'squeezestart', onSessionEvent );\\r\\n\\t\\t\\tsession.addEventListener( 'squeezeend', onSessionEvent );\\r\\n\\t\\t\\tsession.addEventListener( 'end', onSessionEnd );\\r\\n\\r\\n\\t\\t\\tvar attributes = gl.getContextAttributes();\\r\\n\\r\\n\\t\\t\\tif ( attributes.xrCompatible !== true ) {\\r\\n\\r\\n\\t\\t\\t\\tgl.makeXRCompatible();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar layerInit = {\\r\\n\\t\\t\\t\\tantialias: attributes.antialias,\\r\\n\\t\\t\\t\\talpha: attributes.alpha,\\r\\n\\t\\t\\t\\tdepth: attributes.depth,\\r\\n\\t\\t\\t\\tstencil: attributes.stencil,\\r\\n\\t\\t\\t\\tframebufferScaleFactor: framebufferScaleFactor\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\t// eslint-disable-next-line no-undef\\r\\n\\t\\t\\tvar baseLayer = new XRWebGLLayer( session, gl, layerInit );\\r\\n\\r\\n\\t\\t\\tsession.updateRenderState( { baseLayer: baseLayer } );\\r\\n\\r\\n\\t\\t\\tsession.requestReferenceSpace( referenceSpaceType ).then( onRequestReferenceSpace );\\r\\n\\r\\n\\t\\t\\t//\\r\\n\\r\\n\\t\\t\\tsession.addEventListener( 'inputsourceschange', updateInputSources );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tfunction updateInputSources( event ) {\\r\\n\\r\\n\\t\\tvar inputSources = session.inputSources;\\r\\n\\r\\n\\t\\t// Assign inputSources to available controllers\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < controllers.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\tinputSourcesMap.set( inputSources[ i ], controllers[ i ] );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Notify disconnected\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < event.removed.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar inputSource = event.removed[ i ];\\r\\n\\t\\t\\tvar controller = inputSourcesMap.get( inputSource );\\r\\n\\r\\n\\t\\t\\tif ( controller ) {\\r\\n\\r\\n\\t\\t\\t\\tcontroller.dispatchEvent( { type: 'disconnected', data: inputSource } );\\r\\n\\t\\t\\t\\tinputSourcesMap.delete( inputSource );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Notify connected\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < event.added.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar inputSource = event.added[ i ];\\r\\n\\t\\t\\tvar controller = inputSourcesMap.get( inputSource );\\r\\n\\r\\n\\t\\t\\tif ( controller ) {\\r\\n\\r\\n\\t\\t\\t\\tcontroller.dispatchEvent( { type: 'connected', data: inputSource } );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tvar cameraLPos = new Vector3();\\r\\n\\tvar cameraRPos = new Vector3();\\r\\n\\r\\n\\t/**\\r\\n\\t * @author jsantell / https://www.jsantell.com/\\r\\n\\t *\\r\\n\\t * Assumes 2 cameras that are parallel and share an X-axis, and that\\r\\n\\t * the cameras' projection and world matrices have already been set.\\r\\n\\t * And that near and far planes are identical for both cameras.\\r\\n\\t * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765\\r\\n\\t */\\r\\n\\tfunction setProjectionFromUnion( camera, cameraL, cameraR ) {\\r\\n\\r\\n\\t\\tcameraLPos.setFromMatrixPosition( cameraL.matrixWorld );\\r\\n\\t\\tcameraRPos.setFromMatrixPosition( cameraR.matrixWorld );\\r\\n\\r\\n\\t\\tvar ipd = cameraLPos.distanceTo( cameraRPos );\\r\\n\\r\\n\\t\\tvar projL = cameraL.projectionMatrix.elements;\\r\\n\\t\\tvar projR = cameraR.projectionMatrix.elements;\\r\\n\\r\\n\\t\\t// VR systems will have identical far and near planes, and\\r\\n\\t\\t// most likely identical top and bottom frustum extents.\\r\\n\\t\\t// Use the left camera for these values.\\r\\n\\t\\tvar near = projL[ 14 ] / ( projL[ 10 ] - 1 );\\r\\n\\t\\tvar far = projL[ 14 ] / ( projL[ 10 ] + 1 );\\r\\n\\t\\tvar topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ];\\r\\n\\t\\tvar bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ];\\r\\n\\r\\n\\t\\tvar leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ];\\r\\n\\t\\tvar rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ];\\r\\n\\t\\tvar left = near * leftFov;\\r\\n\\t\\tvar right = near * rightFov;\\r\\n\\r\\n\\t\\t// Calculate the new camera's position offset from the\\r\\n\\t\\t// left camera. xOffset should be roughly half `ipd`.\\r\\n\\t\\tvar zOffset = ipd / ( - leftFov + rightFov );\\r\\n\\t\\tvar xOffset = zOffset * - leftFov;\\r\\n\\r\\n\\t\\t// TODO: Better way to apply this offset?\\r\\n\\t\\tcameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );\\r\\n\\t\\tcamera.translateX( xOffset );\\r\\n\\t\\tcamera.translateZ( zOffset );\\r\\n\\t\\tcamera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale );\\r\\n\\t\\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\\r\\n\\r\\n\\t\\t// Find the union of the frustum values of the cameras and scale\\r\\n\\t\\t// the values so that the near plane's position does not change in world space,\\r\\n\\t\\t// although must now be relative to the new union camera.\\r\\n\\t\\tvar near2 = near + zOffset;\\r\\n\\t\\tvar far2 = far + zOffset;\\r\\n\\t\\tvar left2 = left - xOffset;\\r\\n\\t\\tvar right2 = right + ( ipd - xOffset );\\r\\n\\t\\tvar top2 = topFov * far / far2 * near2;\\r\\n\\t\\tvar bottom2 = bottomFov * far / far2 * near2;\\r\\n\\r\\n\\t\\tcamera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction updateCamera( camera, parent ) {\\r\\n\\r\\n\\t\\tif ( parent === null ) {\\r\\n\\r\\n\\t\\t\\tcamera.matrixWorld.copy( camera.matrix );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tcamera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tthis.getCamera = function ( camera ) {\\r\\n\\r\\n\\t\\tcameraVR.near = cameraR.near = cameraL.near = camera.near;\\r\\n\\t\\tcameraVR.far = cameraR.far = cameraL.far = camera.far;\\r\\n\\r\\n\\t\\tif ( _currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far ) {\\r\\n\\r\\n\\t\\t\\t// Note that the new renderState won't apply until the next frame. See #18320\\r\\n\\r\\n\\t\\t\\tsession.updateRenderState( {\\r\\n\\t\\t\\t\\tdepthNear: cameraVR.near,\\r\\n\\t\\t\\t\\tdepthFar: cameraVR.far\\r\\n\\t\\t\\t} );\\r\\n\\r\\n\\t\\t\\t_currentDepthNear = cameraVR.near;\\r\\n\\t\\t\\t_currentDepthFar = cameraVR.far;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar parent = camera.parent;\\r\\n\\t\\tvar cameras = cameraVR.cameras;\\r\\n\\r\\n\\t\\tupdateCamera( cameraVR, parent );\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < cameras.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\tupdateCamera( cameras[ i ], parent );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// update camera and its children\\r\\n\\r\\n\\t\\tcamera.matrixWorld.copy( cameraVR.matrixWorld );\\r\\n\\r\\n\\t\\tvar children = camera.children;\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\tchildren[ i ].updateMatrixWorld( true );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// update projection matrix for proper view frustum culling\\r\\n\\r\\n\\t\\tif ( cameras.length === 2 ) {\\r\\n\\r\\n\\t\\t\\tsetProjectionFromUnion( cameraVR, cameraL, cameraR );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t// assume single camera setup (AR)\\r\\n\\r\\n\\t\\t\\tcameraVR.projectionMatrix.copy( cameraL.projectionMatrix );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn cameraVR;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t// Animation Loop\\r\\n\\r\\n\\tvar onAnimationFrameCallback = null;\\r\\n\\r\\n\\tfunction onAnimationFrame( time, frame ) {\\r\\n\\r\\n\\t\\tpose = frame.getViewerPose( referenceSpace );\\r\\n\\r\\n\\t\\tif ( pose !== null ) {\\r\\n\\r\\n\\t\\t\\tvar views = pose.views;\\r\\n\\t\\t\\tvar baseLayer = session.renderState.baseLayer;\\r\\n\\r\\n\\t\\t\\trenderer.setFramebuffer( baseLayer.framebuffer );\\r\\n\\r\\n\\t\\t\\tvar cameraVRNeedsUpdate = false;\\r\\n\\r\\n\\t\\t\\t// check if it's necessary to rebuild cameraVR's camera list\\r\\n\\r\\n\\t\\t\\tif ( views.length !== cameraVR.cameras.length ) {\\r\\n\\r\\n\\t\\t\\t\\tcameraVR.cameras.length = 0;\\r\\n\\t\\t\\t\\tcameraVRNeedsUpdate = true;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < views.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar view = views[ i ];\\r\\n\\t\\t\\t\\tvar viewport = baseLayer.getViewport( view );\\r\\n\\r\\n\\t\\t\\t\\tvar camera = cameras[ i ];\\r\\n\\t\\t\\t\\tcamera.matrix.fromArray( view.transform.matrix );\\r\\n\\t\\t\\t\\tcamera.projectionMatrix.fromArray( view.projectionMatrix );\\r\\n\\t\\t\\t\\tcamera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );\\r\\n\\r\\n\\t\\t\\t\\tif ( i === 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tcameraVR.matrix.copy( camera.matrix );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( cameraVRNeedsUpdate === true ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tcameraVR.cameras.push( camera );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\tvar inputSources = session.inputSources;\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < controllers.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar controller = controllers[ i ];\\r\\n\\t\\t\\tvar inputSource = inputSources[ i ];\\r\\n\\r\\n\\t\\t\\tcontroller.update( inputSource, frame, referenceSpace );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( onAnimationFrameCallback ) onAnimationFrameCallback( time, frame );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tvar animation = new WebGLAnimation();\\r\\n\\tanimation.setAnimationLoop( onAnimationFrame );\\r\\n\\r\\n\\tthis.setAnimationLoop = function ( callback ) {\\r\\n\\r\\n\\t\\tonAnimationFrameCallback = callback;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.dispose = function () {};\\r\\n\\r\\n}\\r\\n\\r\\nObject.assign( WebXRManager.prototype, EventDispatcher.prototype );\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nfunction WebGLMaterials( properties ) {\\r\\n\\r\\n\\tfunction refreshFogUniforms( uniforms, fog ) {\\r\\n\\r\\n\\t\\tuniforms.fogColor.value.copy( fog.color );\\r\\n\\r\\n\\t\\tif ( fog.isFog ) {\\r\\n\\r\\n\\t\\t\\tuniforms.fogNear.value = fog.near;\\r\\n\\t\\t\\tuniforms.fogFar.value = fog.far;\\r\\n\\r\\n\\t\\t} else if ( fog.isFogExp2 ) {\\r\\n\\r\\n\\t\\t\\tuniforms.fogDensity.value = fog.density;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction refreshMaterialUniforms( uniforms, material, environment, pixelRatio, height ) {\\r\\n\\r\\n\\t\\tif ( material.isMeshBasicMaterial ) {\\r\\n\\r\\n\\t\\t\\trefreshUniformsCommon( uniforms, material );\\r\\n\\r\\n\\t\\t} else if ( material.isMeshLambertMaterial ) {\\r\\n\\r\\n\\t\\t\\trefreshUniformsCommon( uniforms, material );\\r\\n\\t\\t\\trefreshUniformsLambert( uniforms, material );\\r\\n\\r\\n\\t\\t} else if ( material.isMeshToonMaterial ) {\\r\\n\\r\\n\\t\\t\\trefreshUniformsCommon( uniforms, material );\\r\\n\\t\\t\\trefreshUniformsToon( uniforms, material );\\r\\n\\r\\n\\t\\t} else if ( material.isMeshPhongMaterial ) {\\r\\n\\r\\n\\t\\t\\trefreshUniformsCommon( uniforms, material );\\r\\n\\t\\t\\trefreshUniformsPhong( uniforms, material );\\r\\n\\r\\n\\t\\t} else if ( material.isMeshStandardMaterial ) {\\r\\n\\r\\n\\t\\t\\trefreshUniformsCommon( uniforms, material, environment );\\r\\n\\r\\n\\t\\t\\tif ( material.isMeshPhysicalMaterial ) {\\r\\n\\r\\n\\t\\t\\t\\trefreshUniformsPhysical( uniforms, material, environment );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\trefreshUniformsStandard( uniforms, material, environment );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t} else if ( material.isMeshMatcapMaterial ) {\\r\\n\\r\\n\\t\\t\\trefreshUniformsCommon( uniforms, material );\\r\\n\\t\\t\\trefreshUniformsMatcap( uniforms, material );\\r\\n\\r\\n\\t\\t} else if ( material.isMeshDepthMaterial ) {\\r\\n\\r\\n\\t\\t\\trefreshUniformsCommon( uniforms, material );\\r\\n\\t\\t\\trefreshUniformsDepth( uniforms, material );\\r\\n\\r\\n\\t\\t} else if ( material.isMeshDistanceMaterial ) {\\r\\n\\r\\n\\t\\t\\trefreshUniformsCommon( uniforms, material );\\r\\n\\t\\t\\trefreshUniformsDistance( uniforms, material );\\r\\n\\r\\n\\t\\t} else if ( material.isMeshNormalMaterial ) {\\r\\n\\r\\n\\t\\t\\trefreshUniformsCommon( uniforms, material );\\r\\n\\t\\t\\trefreshUniformsNormal( uniforms, material );\\r\\n\\r\\n\\t\\t} else if ( material.isLineBasicMaterial ) {\\r\\n\\r\\n\\t\\t\\trefreshUniformsLine( uniforms, material );\\r\\n\\r\\n\\t\\t\\tif ( material.isLineDashedMaterial ) {\\r\\n\\r\\n\\t\\t\\t\\trefreshUniformsDash( uniforms, material );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t} else if ( material.isPointsMaterial ) {\\r\\n\\r\\n\\t\\t\\trefreshUniformsPoints( uniforms, material, pixelRatio, height );\\r\\n\\r\\n\\t\\t} else if ( material.isSpriteMaterial ) {\\r\\n\\r\\n\\t\\t\\trefreshUniformsSprites( uniforms, material );\\r\\n\\r\\n\\t\\t} else if ( material.isShadowMaterial ) {\\r\\n\\r\\n\\t\\t\\tuniforms.color.value.copy( material.color );\\r\\n\\t\\t\\tuniforms.opacity.value = material.opacity;\\r\\n\\r\\n\\t\\t} else if ( material.isShaderMaterial ) {\\r\\n\\r\\n\\t\\t\\tmaterial.uniformsNeedUpdate = false; // #15581\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction refreshUniformsCommon( uniforms, material, environment ) {\\r\\n\\r\\n\\t\\tuniforms.opacity.value = material.opacity;\\r\\n\\r\\n\\t\\tif ( material.color ) {\\r\\n\\r\\n\\t\\t\\tuniforms.diffuse.value.copy( material.color );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( material.emissive ) {\\r\\n\\r\\n\\t\\t\\tuniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( material.map ) {\\r\\n\\r\\n\\t\\t\\tuniforms.map.value = material.map;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( material.alphaMap ) {\\r\\n\\r\\n\\t\\t\\tuniforms.alphaMap.value = material.alphaMap;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( material.specularMap ) {\\r\\n\\r\\n\\t\\t\\tuniforms.specularMap.value = material.specularMap;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar envMap = material.envMap || environment;\\r\\n\\r\\n\\t\\tif ( envMap ) {\\r\\n\\r\\n\\t\\t\\tuniforms.envMap.value = envMap;\\r\\n\\r\\n\\t\\t\\tuniforms.flipEnvMap.value = envMap.isCubeTexture ? - 1 : 1;\\r\\n\\r\\n\\t\\t\\tuniforms.reflectivity.value = material.reflectivity;\\r\\n\\t\\t\\tuniforms.refractionRatio.value = material.refractionRatio;\\r\\n\\r\\n\\t\\t\\tuniforms.maxMipLevel.value = properties.get( envMap ).__maxMipLevel;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( material.lightMap ) {\\r\\n\\r\\n\\t\\t\\tuniforms.lightMap.value = material.lightMap;\\r\\n\\t\\t\\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( material.aoMap ) {\\r\\n\\r\\n\\t\\t\\tuniforms.aoMap.value = material.aoMap;\\r\\n\\t\\t\\tuniforms.aoMapIntensity.value = material.aoMapIntensity;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// uv repeat and offset setting priorities\\r\\n\\t\\t// 1. color map\\r\\n\\t\\t// 2. specular map\\r\\n\\t\\t// 3. normal map\\r\\n\\t\\t// 4. bump map\\r\\n\\t\\t// 5. alpha map\\r\\n\\t\\t// 6. emissive map\\r\\n\\r\\n\\t\\tvar uvScaleMap;\\r\\n\\r\\n\\t\\tif ( material.map ) {\\r\\n\\r\\n\\t\\t\\tuvScaleMap = material.map;\\r\\n\\r\\n\\t\\t} else if ( material.specularMap ) {\\r\\n\\r\\n\\t\\t\\tuvScaleMap = material.specularMap;\\r\\n\\r\\n\\t\\t} else if ( material.displacementMap ) {\\r\\n\\r\\n\\t\\t\\tuvScaleMap = material.displacementMap;\\r\\n\\r\\n\\t\\t} else if ( material.normalMap ) {\\r\\n\\r\\n\\t\\t\\tuvScaleMap = material.normalMap;\\r\\n\\r\\n\\t\\t} else if ( material.bumpMap ) {\\r\\n\\r\\n\\t\\t\\tuvScaleMap = material.bumpMap;\\r\\n\\r\\n\\t\\t} else if ( material.roughnessMap ) {\\r\\n\\r\\n\\t\\t\\tuvScaleMap = material.roughnessMap;\\r\\n\\r\\n\\t\\t} else if ( material.metalnessMap ) {\\r\\n\\r\\n\\t\\t\\tuvScaleMap = material.metalnessMap;\\r\\n\\r\\n\\t\\t} else if ( material.alphaMap ) {\\r\\n\\r\\n\\t\\t\\tuvScaleMap = material.alphaMap;\\r\\n\\r\\n\\t\\t} else if ( material.emissiveMap ) {\\r\\n\\r\\n\\t\\t\\tuvScaleMap = material.emissiveMap;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( uvScaleMap !== undefined ) {\\r\\n\\r\\n\\t\\t\\t// backwards compatibility\\r\\n\\t\\t\\tif ( uvScaleMap.isWebGLRenderTarget ) {\\r\\n\\r\\n\\t\\t\\t\\tuvScaleMap = uvScaleMap.texture;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( uvScaleMap.matrixAutoUpdate === true ) {\\r\\n\\r\\n\\t\\t\\t\\tuvScaleMap.updateMatrix();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tuniforms.uvTransform.value.copy( uvScaleMap.matrix );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// uv repeat and offset setting priorities for uv2\\r\\n\\t\\t// 1. ao map\\r\\n\\t\\t// 2. light map\\r\\n\\r\\n\\t\\tvar uv2ScaleMap;\\r\\n\\r\\n\\t\\tif ( material.aoMap ) {\\r\\n\\r\\n\\t\\t\\tuv2ScaleMap = material.aoMap;\\r\\n\\r\\n\\t\\t} else if ( material.lightMap ) {\\r\\n\\r\\n\\t\\t\\tuv2ScaleMap = material.lightMap;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( uv2ScaleMap !== undefined ) {\\r\\n\\r\\n\\t\\t\\t// backwards compatibility\\r\\n\\t\\t\\tif ( uv2ScaleMap.isWebGLRenderTarget ) {\\r\\n\\r\\n\\t\\t\\t\\tuv2ScaleMap = uv2ScaleMap.texture;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( uv2ScaleMap.matrixAutoUpdate === true ) {\\r\\n\\r\\n\\t\\t\\t\\tuv2ScaleMap.updateMatrix();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tuniforms.uv2Transform.value.copy( uv2ScaleMap.matrix );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction refreshUniformsLine( uniforms, material ) {\\r\\n\\r\\n\\t\\tuniforms.diffuse.value.copy( material.color );\\r\\n\\t\\tuniforms.opacity.value = material.opacity;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction refreshUniformsDash( uniforms, material ) {\\r\\n\\r\\n\\t\\tuniforms.dashSize.value = material.dashSize;\\r\\n\\t\\tuniforms.totalSize.value = material.dashSize + material.gapSize;\\r\\n\\t\\tuniforms.scale.value = material.scale;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction refreshUniformsPoints( uniforms, material, pixelRatio, height ) {\\r\\n\\r\\n\\t\\tuniforms.diffuse.value.copy( material.color );\\r\\n\\t\\tuniforms.opacity.value = material.opacity;\\r\\n\\t\\tuniforms.size.value = material.size * pixelRatio;\\r\\n\\t\\tuniforms.scale.value = height * 0.5;\\r\\n\\r\\n\\t\\tif ( material.map ) {\\r\\n\\r\\n\\t\\t\\tuniforms.map.value = material.map;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( material.alphaMap ) {\\r\\n\\r\\n\\t\\t\\tuniforms.alphaMap.value = material.alphaMap;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// uv repeat and offset setting priorities\\r\\n\\t\\t// 1. color map\\r\\n\\t\\t// 2. alpha map\\r\\n\\r\\n\\t\\tvar uvScaleMap;\\r\\n\\r\\n\\t\\tif ( material.map ) {\\r\\n\\r\\n\\t\\t\\tuvScaleMap = material.map;\\r\\n\\r\\n\\t\\t} else if ( material.alphaMap ) {\\r\\n\\r\\n\\t\\t\\tuvScaleMap = material.alphaMap;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( uvScaleMap !== undefined ) {\\r\\n\\r\\n\\t\\t\\tif ( uvScaleMap.matrixAutoUpdate === true ) {\\r\\n\\r\\n\\t\\t\\t\\tuvScaleMap.updateMatrix();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tuniforms.uvTransform.value.copy( uvScaleMap.matrix );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction refreshUniformsSprites( uniforms, material ) {\\r\\n\\r\\n\\t\\tuniforms.diffuse.value.copy( material.color );\\r\\n\\t\\tuniforms.opacity.value = material.opacity;\\r\\n\\t\\tuniforms.rotation.value = material.rotation;\\r\\n\\r\\n\\t\\tif ( material.map ) {\\r\\n\\r\\n\\t\\t\\tuniforms.map.value = material.map;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( material.alphaMap ) {\\r\\n\\r\\n\\t\\t\\tuniforms.alphaMap.value = material.alphaMap;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// uv repeat and offset setting priorities\\r\\n\\t\\t// 1. color map\\r\\n\\t\\t// 2. alpha map\\r\\n\\r\\n\\t\\tvar uvScaleMap;\\r\\n\\r\\n\\t\\tif ( material.map ) {\\r\\n\\r\\n\\t\\t\\tuvScaleMap = material.map;\\r\\n\\r\\n\\t\\t} else if ( material.alphaMap ) {\\r\\n\\r\\n\\t\\t\\tuvScaleMap = material.alphaMap;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( uvScaleMap !== undefined ) {\\r\\n\\r\\n\\t\\t\\tif ( uvScaleMap.matrixAutoUpdate === true ) {\\r\\n\\r\\n\\t\\t\\t\\tuvScaleMap.updateMatrix();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tuniforms.uvTransform.value.copy( uvScaleMap.matrix );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction refreshUniformsLambert( uniforms, material ) {\\r\\n\\r\\n\\t\\tif ( material.emissiveMap ) {\\r\\n\\r\\n\\t\\t\\tuniforms.emissiveMap.value = material.emissiveMap;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction refreshUniformsPhong( uniforms, material ) {\\r\\n\\r\\n\\t\\tuniforms.specular.value.copy( material.specular );\\r\\n\\t\\tuniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )\\r\\n\\r\\n\\t\\tif ( material.emissiveMap ) {\\r\\n\\r\\n\\t\\t\\tuniforms.emissiveMap.value = material.emissiveMap;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( material.bumpMap ) {\\r\\n\\r\\n\\t\\t\\tuniforms.bumpMap.value = material.bumpMap;\\r\\n\\t\\t\\tuniforms.bumpScale.value = material.bumpScale;\\r\\n\\t\\t\\tif ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( material.normalMap ) {\\r\\n\\r\\n\\t\\t\\tuniforms.normalMap.value = material.normalMap;\\r\\n\\t\\t\\tuniforms.normalScale.value.copy( material.normalScale );\\r\\n\\t\\t\\tif ( material.side === BackSide ) uniforms.normalScale.value.negate();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( material.displacementMap ) {\\r\\n\\r\\n\\t\\t\\tuniforms.displacementMap.value = material.displacementMap;\\r\\n\\t\\t\\tuniforms.displacementScale.value = material.displacementScale;\\r\\n\\t\\t\\tuniforms.displacementBias.value = material.displacementBias;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction refreshUniformsToon( uniforms, material ) {\\r\\n\\r\\n\\t\\tuniforms.specular.value.copy( material.specular );\\r\\n\\t\\tuniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )\\r\\n\\r\\n\\t\\tif ( material.gradientMap ) {\\r\\n\\r\\n\\t\\t\\tuniforms.gradientMap.value = material.gradientMap;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( material.emissiveMap ) {\\r\\n\\r\\n\\t\\t\\tuniforms.emissiveMap.value = material.emissiveMap;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( material.bumpMap ) {\\r\\n\\r\\n\\t\\t\\tuniforms.bumpMap.value = material.bumpMap;\\r\\n\\t\\t\\tuniforms.bumpScale.value = material.bumpScale;\\r\\n\\t\\t\\tif ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( material.normalMap ) {\\r\\n\\r\\n\\t\\t\\tuniforms.normalMap.value = material.normalMap;\\r\\n\\t\\t\\tuniforms.normalScale.value.copy( material.normalScale );\\r\\n\\t\\t\\tif ( material.side === BackSide ) uniforms.normalScale.value.negate();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( material.displacementMap ) {\\r\\n\\r\\n\\t\\t\\tuniforms.displacementMap.value = material.displacementMap;\\r\\n\\t\\t\\tuniforms.displacementScale.value = material.displacementScale;\\r\\n\\t\\t\\tuniforms.displacementBias.value = material.displacementBias;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction refreshUniformsStandard( uniforms, material, environment ) {\\r\\n\\r\\n\\t\\tuniforms.roughness.value = material.roughness;\\r\\n\\t\\tuniforms.metalness.value = material.metalness;\\r\\n\\r\\n\\t\\tif ( material.roughnessMap ) {\\r\\n\\r\\n\\t\\t\\tuniforms.roughnessMap.value = material.roughnessMap;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( material.metalnessMap ) {\\r\\n\\r\\n\\t\\t\\tuniforms.metalnessMap.value = material.metalnessMap;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( material.emissiveMap ) {\\r\\n\\r\\n\\t\\t\\tuniforms.emissiveMap.value = material.emissiveMap;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( material.bumpMap ) {\\r\\n\\r\\n\\t\\t\\tuniforms.bumpMap.value = material.bumpMap;\\r\\n\\t\\t\\tuniforms.bumpScale.value = material.bumpScale;\\r\\n\\t\\t\\tif ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( material.normalMap ) {\\r\\n\\r\\n\\t\\t\\tuniforms.normalMap.value = material.normalMap;\\r\\n\\t\\t\\tuniforms.normalScale.value.copy( material.normalScale );\\r\\n\\t\\t\\tif ( material.side === BackSide ) uniforms.normalScale.value.negate();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( material.displacementMap ) {\\r\\n\\r\\n\\t\\t\\tuniforms.displacementMap.value = material.displacementMap;\\r\\n\\t\\t\\tuniforms.displacementScale.value = material.displacementScale;\\r\\n\\t\\t\\tuniforms.displacementBias.value = material.displacementBias;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( material.envMap || environment ) {\\r\\n\\r\\n\\t\\t\\t//uniforms.envMap.value = material.envMap; // part of uniforms common\\r\\n\\t\\t\\tuniforms.envMapIntensity.value = material.envMapIntensity;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction refreshUniformsPhysical( uniforms, material, environment ) {\\r\\n\\r\\n\\t\\trefreshUniformsStandard( uniforms, material, environment );\\r\\n\\r\\n\\t\\tuniforms.reflectivity.value = material.reflectivity; // also part of uniforms common\\r\\n\\r\\n\\t\\tuniforms.clearcoat.value = material.clearcoat;\\r\\n\\t\\tuniforms.clearcoatRoughness.value = material.clearcoatRoughness;\\r\\n\\t\\tif ( material.sheen ) uniforms.sheen.value.copy( material.sheen );\\r\\n\\r\\n\\t\\tif ( material.clearcoatMap ) {\\r\\n\\r\\n\\t\\t\\tuniforms.clearcoatMap.value = material.clearcoatMap;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( material.clearcoatRoughnessMap ) {\\r\\n\\r\\n\\t\\t\\tuniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( material.clearcoatNormalMap ) {\\r\\n\\r\\n\\t\\t\\tuniforms.clearcoatNormalScale.value.copy( material.clearcoatNormalScale );\\r\\n\\t\\t\\tuniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;\\r\\n\\r\\n\\t\\t\\tif ( material.side === BackSide ) {\\r\\n\\r\\n\\t\\t\\t\\tuniforms.clearcoatNormalScale.value.negate();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tuniforms.transparency.value = material.transparency;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction refreshUniformsMatcap( uniforms, material ) {\\r\\n\\r\\n\\t\\tif ( material.matcap ) {\\r\\n\\r\\n\\t\\t\\tuniforms.matcap.value = material.matcap;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( material.bumpMap ) {\\r\\n\\r\\n\\t\\t\\tuniforms.bumpMap.value = material.bumpMap;\\r\\n\\t\\t\\tuniforms.bumpScale.value = material.bumpScale;\\r\\n\\t\\t\\tif ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( material.normalMap ) {\\r\\n\\r\\n\\t\\t\\tuniforms.normalMap.value = material.normalMap;\\r\\n\\t\\t\\tuniforms.normalScale.value.copy( material.normalScale );\\r\\n\\t\\t\\tif ( material.side === BackSide ) uniforms.normalScale.value.negate();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( material.displacementMap ) {\\r\\n\\r\\n\\t\\t\\tuniforms.displacementMap.value = material.displacementMap;\\r\\n\\t\\t\\tuniforms.displacementScale.value = material.displacementScale;\\r\\n\\t\\t\\tuniforms.displacementBias.value = material.displacementBias;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction refreshUniformsDepth( uniforms, material ) {\\r\\n\\r\\n\\t\\tif ( material.displacementMap ) {\\r\\n\\r\\n\\t\\t\\tuniforms.displacementMap.value = material.displacementMap;\\r\\n\\t\\t\\tuniforms.displacementScale.value = material.displacementScale;\\r\\n\\t\\t\\tuniforms.displacementBias.value = material.displacementBias;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction refreshUniformsDistance( uniforms, material ) {\\r\\n\\r\\n\\t\\tif ( material.displacementMap ) {\\r\\n\\r\\n\\t\\t\\tuniforms.displacementMap.value = material.displacementMap;\\r\\n\\t\\t\\tuniforms.displacementScale.value = material.displacementScale;\\r\\n\\t\\t\\tuniforms.displacementBias.value = material.displacementBias;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tuniforms.referencePosition.value.copy( material.referencePosition );\\r\\n\\t\\tuniforms.nearDistance.value = material.nearDistance;\\r\\n\\t\\tuniforms.farDistance.value = material.farDistance;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction refreshUniformsNormal( uniforms, material ) {\\r\\n\\r\\n\\t\\tif ( material.bumpMap ) {\\r\\n\\r\\n\\t\\t\\tuniforms.bumpMap.value = material.bumpMap;\\r\\n\\t\\t\\tuniforms.bumpScale.value = material.bumpScale;\\r\\n\\t\\t\\tif ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( material.normalMap ) {\\r\\n\\r\\n\\t\\t\\tuniforms.normalMap.value = material.normalMap;\\r\\n\\t\\t\\tuniforms.normalScale.value.copy( material.normalScale );\\r\\n\\t\\t\\tif ( material.side === BackSide ) uniforms.normalScale.value.negate();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( material.displacementMap ) {\\r\\n\\r\\n\\t\\t\\tuniforms.displacementMap.value = material.displacementMap;\\r\\n\\t\\t\\tuniforms.displacementScale.value = material.displacementScale;\\r\\n\\t\\t\\tuniforms.displacementBias.value = material.displacementBias;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn {\\r\\n\\t\\trefreshFogUniforms: refreshFogUniforms,\\r\\n\\t\\trefreshMaterialUniforms: refreshMaterialUniforms\\r\\n\\t};\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * @author supereggbert / http://www.paulbrunt.co.uk/\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n * @author szimek / https://github.com/szimek/\\r\\n * @author tschw\\r\\n */\\r\\n\\r\\nfunction WebGLRenderer( parameters ) {\\r\\n\\r\\n\\tparameters = parameters || {};\\r\\n\\r\\n\\tvar _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),\\r\\n\\t\\t_context = parameters.context !== undefined ? parameters.context : null,\\r\\n\\r\\n\\t\\t_alpha = parameters.alpha !== undefined ? parameters.alpha : false,\\r\\n\\t\\t_depth = parameters.depth !== undefined ? parameters.depth : true,\\r\\n\\t\\t_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\\r\\n\\t\\t_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\\r\\n\\t\\t_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\\r\\n\\t\\t_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,\\r\\n\\t\\t_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',\\r\\n\\t\\t_failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;\\r\\n\\r\\n\\tvar currentRenderList = null;\\r\\n\\tvar currentRenderState = null;\\r\\n\\r\\n\\t// public properties\\r\\n\\r\\n\\tthis.domElement = _canvas;\\r\\n\\r\\n\\t// Debug configuration container\\r\\n\\tthis.debug = {\\r\\n\\r\\n\\t\\t/**\\r\\n\\t\\t * Enables error checking and reporting when shader programs are being compiled\\r\\n\\t\\t * @type {boolean}\\r\\n\\t\\t */\\r\\n\\t\\tcheckShaderErrors: true\\r\\n\\t};\\r\\n\\r\\n\\t// clearing\\r\\n\\r\\n\\tthis.autoClear = true;\\r\\n\\tthis.autoClearColor = true;\\r\\n\\tthis.autoClearDepth = true;\\r\\n\\tthis.autoClearStencil = true;\\r\\n\\r\\n\\t// scene graph\\r\\n\\r\\n\\tthis.sortObjects = true;\\r\\n\\r\\n\\t// user-defined clipping\\r\\n\\r\\n\\tthis.clippingPlanes = [];\\r\\n\\tthis.localClippingEnabled = false;\\r\\n\\r\\n\\t// physically based shading\\r\\n\\r\\n\\tthis.gammaFactor = 2.0;\\t// for backwards compatibility\\r\\n\\tthis.outputEncoding = LinearEncoding;\\r\\n\\r\\n\\t// physical lights\\r\\n\\r\\n\\tthis.physicallyCorrectLights = false;\\r\\n\\r\\n\\t// tone mapping\\r\\n\\r\\n\\tthis.toneMapping = NoToneMapping;\\r\\n\\tthis.toneMappingExposure = 1.0;\\r\\n\\tthis.toneMappingWhitePoint = 1.0;\\r\\n\\r\\n\\t// morphs\\r\\n\\r\\n\\tthis.maxMorphTargets = 8;\\r\\n\\tthis.maxMorphNormals = 4;\\r\\n\\r\\n\\t// internal properties\\r\\n\\r\\n\\tvar _this = this,\\r\\n\\r\\n\\t\\t_isContextLost = false,\\r\\n\\r\\n\\t\\t// internal state cache\\r\\n\\r\\n\\t\\t_framebuffer = null,\\r\\n\\r\\n\\t\\t_currentActiveCubeFace = 0,\\r\\n\\t\\t_currentActiveMipmapLevel = 0,\\r\\n\\t\\t_currentRenderTarget = null,\\r\\n\\t\\t_currentFramebuffer = null,\\r\\n\\t\\t_currentMaterialId = - 1,\\r\\n\\r\\n\\t\\t// geometry and program caching\\r\\n\\r\\n\\t\\t_currentGeometryProgram = {\\r\\n\\t\\t\\tgeometry: null,\\r\\n\\t\\t\\tprogram: null,\\r\\n\\t\\t\\twireframe: false\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\t_currentCamera = null,\\r\\n\\t\\t_currentArrayCamera = null,\\r\\n\\r\\n\\t\\t_currentViewport = new Vector4(),\\r\\n\\t\\t_currentScissor = new Vector4(),\\r\\n\\t\\t_currentScissorTest = null,\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\t_width = _canvas.width,\\r\\n\\t\\t_height = _canvas.height,\\r\\n\\r\\n\\t\\t_pixelRatio = 1,\\r\\n\\t\\t_opaqueSort = null,\\r\\n\\t\\t_transparentSort = null,\\r\\n\\r\\n\\t\\t_viewport = new Vector4( 0, 0, _width, _height ),\\r\\n\\t\\t_scissor = new Vector4( 0, 0, _width, _height ),\\r\\n\\t\\t_scissorTest = false,\\r\\n\\r\\n\\t\\t// frustum\\r\\n\\r\\n\\t\\t_frustum = new Frustum(),\\r\\n\\r\\n\\t\\t// clipping\\r\\n\\r\\n\\t\\t_clipping = new WebGLClipping(),\\r\\n\\t\\t_clippingEnabled = false,\\r\\n\\t\\t_localClippingEnabled = false,\\r\\n\\r\\n\\t\\t// camera matrices cache\\r\\n\\r\\n\\t\\t_projScreenMatrix = new Matrix4(),\\r\\n\\r\\n\\t\\t_vector3 = new Vector3();\\r\\n\\r\\n\\tfunction getTargetPixelRatio() {\\r\\n\\r\\n\\t\\treturn _currentRenderTarget === null ? _pixelRatio : 1;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// initialize\\r\\n\\r\\n\\tvar _gl;\\r\\n\\r\\n\\ttry {\\r\\n\\r\\n\\t\\tvar contextAttributes = {\\r\\n\\t\\t\\talpha: _alpha,\\r\\n\\t\\t\\tdepth: _depth,\\r\\n\\t\\t\\tstencil: _stencil,\\r\\n\\t\\t\\tantialias: _antialias,\\r\\n\\t\\t\\tpremultipliedAlpha: _premultipliedAlpha,\\r\\n\\t\\t\\tpreserveDrawingBuffer: _preserveDrawingBuffer,\\r\\n\\t\\t\\tpowerPreference: _powerPreference,\\r\\n\\t\\t\\tfailIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\t// event listeners must be registered before WebGL context is created, see #12753\\r\\n\\r\\n\\t\\t_canvas.addEventListener( 'webglcontextlost', onContextLost, false );\\r\\n\\t\\t_canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );\\r\\n\\r\\n\\t\\t_gl = _context || _canvas.getContext( 'webgl', contextAttributes ) || _canvas.getContext( 'experimental-webgl', contextAttributes );\\r\\n\\r\\n\\t\\tif ( _gl === null ) {\\r\\n\\r\\n\\t\\t\\tif ( _canvas.getContext( 'webgl' ) !== null ) {\\r\\n\\r\\n\\t\\t\\t\\tthrow new Error( 'Error creating WebGL context with your selected attributes.' );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tthrow new Error( 'Error creating WebGL context.' );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Some experimental-webgl implementations do not have getShaderPrecisionFormat\\r\\n\\r\\n\\t\\tif ( _gl.getShaderPrecisionFormat === undefined ) {\\r\\n\\r\\n\\t\\t\\t_gl.getShaderPrecisionFormat = function () {\\r\\n\\r\\n\\t\\t\\t\\treturn { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} catch ( error ) {\\r\\n\\r\\n\\t\\tconsole.error( 'THREE.WebGLRenderer: ' + error.message );\\r\\n\\t\\tthrow error;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tvar extensions, capabilities, state, info;\\r\\n\\tvar properties, textures, attributes, geometries, objects;\\r\\n\\tvar programCache, materials, renderLists, renderStates;\\r\\n\\r\\n\\tvar background, morphtargets, bufferRenderer, indexedBufferRenderer;\\r\\n\\r\\n\\tvar utils;\\r\\n\\r\\n\\tfunction initGLContext() {\\r\\n\\r\\n\\t\\textensions = new WebGLExtensions( _gl );\\r\\n\\r\\n\\t\\tcapabilities = new WebGLCapabilities( _gl, extensions, parameters );\\r\\n\\r\\n\\t\\tif ( capabilities.isWebGL2 === false ) {\\r\\n\\r\\n\\t\\t\\textensions.get( 'WEBGL_depth_texture' );\\r\\n\\t\\t\\textensions.get( 'OES_texture_float' );\\r\\n\\t\\t\\textensions.get( 'OES_texture_half_float' );\\r\\n\\t\\t\\textensions.get( 'OES_texture_half_float_linear' );\\r\\n\\t\\t\\textensions.get( 'OES_standard_derivatives' );\\r\\n\\t\\t\\textensions.get( 'OES_element_index_uint' );\\r\\n\\t\\t\\textensions.get( 'ANGLE_instanced_arrays' );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\textensions.get( 'OES_texture_float_linear' );\\r\\n\\r\\n\\t\\tutils = new WebGLUtils( _gl, extensions, capabilities );\\r\\n\\r\\n\\t\\tstate = new WebGLState( _gl, extensions, capabilities );\\r\\n\\t\\tstate.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor() );\\r\\n\\t\\tstate.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor() );\\r\\n\\r\\n\\t\\tinfo = new WebGLInfo( _gl );\\r\\n\\t\\tproperties = new WebGLProperties();\\r\\n\\t\\ttextures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info );\\r\\n\\t\\tattributes = new WebGLAttributes( _gl, capabilities );\\r\\n\\t\\tgeometries = new WebGLGeometries( _gl, attributes, info );\\r\\n\\t\\tobjects = new WebGLObjects( _gl, geometries, attributes, info );\\r\\n\\t\\tmorphtargets = new WebGLMorphtargets( _gl );\\r\\n\\t\\tprogramCache = new WebGLPrograms( _this, extensions, capabilities );\\r\\n\\t\\tmaterials = new WebGLMaterials( properties );\\r\\n\\t\\trenderLists = new WebGLRenderLists();\\r\\n\\t\\trenderStates = new WebGLRenderStates();\\r\\n\\r\\n\\t\\tbackground = new WebGLBackground( _this, state, objects, _premultipliedAlpha );\\r\\n\\r\\n\\t\\tbufferRenderer = new WebGLBufferRenderer( _gl, extensions, info, capabilities );\\r\\n\\t\\tindexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info, capabilities );\\r\\n\\r\\n\\t\\tinfo.programs = programCache.programs;\\r\\n\\r\\n\\t\\t_this.capabilities = capabilities;\\r\\n\\t\\t_this.extensions = extensions;\\r\\n\\t\\t_this.properties = properties;\\r\\n\\t\\t_this.renderLists = renderLists;\\r\\n\\t\\t_this.state = state;\\r\\n\\t\\t_this.info = info;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tinitGLContext();\\r\\n\\r\\n\\t// xr\\r\\n\\r\\n\\tvar xr = new WebXRManager( _this, _gl );\\r\\n\\r\\n\\tthis.xr = xr;\\r\\n\\r\\n\\t// shadow map\\r\\n\\r\\n\\tvar shadowMap = new WebGLShadowMap( _this, objects, capabilities.maxTextureSize );\\r\\n\\r\\n\\tthis.shadowMap = shadowMap;\\r\\n\\r\\n\\t// API\\r\\n\\r\\n\\tthis.getContext = function () {\\r\\n\\r\\n\\t\\treturn _gl;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.getContextAttributes = function () {\\r\\n\\r\\n\\t\\treturn _gl.getContextAttributes();\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.forceContextLoss = function () {\\r\\n\\r\\n\\t\\tvar extension = extensions.get( 'WEBGL_lose_context' );\\r\\n\\t\\tif ( extension ) extension.loseContext();\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.forceContextRestore = function () {\\r\\n\\r\\n\\t\\tvar extension = extensions.get( 'WEBGL_lose_context' );\\r\\n\\t\\tif ( extension ) extension.restoreContext();\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.getPixelRatio = function () {\\r\\n\\r\\n\\t\\treturn _pixelRatio;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.setPixelRatio = function ( value ) {\\r\\n\\r\\n\\t\\tif ( value === undefined ) return;\\r\\n\\r\\n\\t\\t_pixelRatio = value;\\r\\n\\r\\n\\t\\tthis.setSize( _width, _height, false );\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.getSize = function ( target ) {\\r\\n\\r\\n\\t\\tif ( target === undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'WebGLRenderer: .getsize() now requires a Vector2 as an argument' );\\r\\n\\r\\n\\t\\t\\ttarget = new Vector2();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn target.set( _width, _height );\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.setSize = function ( width, height, updateStyle ) {\\r\\n\\r\\n\\t\\tif ( xr.isPresenting ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Can\\\\'t change size while VR device is presenting.' );\\r\\n\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t_width = width;\\r\\n\\t\\t_height = height;\\r\\n\\r\\n\\t\\t_canvas.width = Math.floor( width * _pixelRatio );\\r\\n\\t\\t_canvas.height = Math.floor( height * _pixelRatio );\\r\\n\\r\\n\\t\\tif ( updateStyle !== false ) {\\r\\n\\r\\n\\t\\t\\t_canvas.style.width = width + 'px';\\r\\n\\t\\t\\t_canvas.style.height = height + 'px';\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.setViewport( 0, 0, width, height );\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.getDrawingBufferSize = function ( target ) {\\r\\n\\r\\n\\t\\tif ( target === undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument' );\\r\\n\\r\\n\\t\\t\\ttarget = new Vector2();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn target.set( _width * _pixelRatio, _height * _pixelRatio ).floor();\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.setDrawingBufferSize = function ( width, height, pixelRatio ) {\\r\\n\\r\\n\\t\\t_width = width;\\r\\n\\t\\t_height = height;\\r\\n\\r\\n\\t\\t_pixelRatio = pixelRatio;\\r\\n\\r\\n\\t\\t_canvas.width = Math.floor( width * pixelRatio );\\r\\n\\t\\t_canvas.height = Math.floor( height * pixelRatio );\\r\\n\\r\\n\\t\\tthis.setViewport( 0, 0, width, height );\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.getCurrentViewport = function ( target ) {\\r\\n\\r\\n\\t\\tif ( target === undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument' );\\r\\n\\r\\n\\t\\t\\ttarget = new Vector4();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn target.copy( _currentViewport );\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.getViewport = function ( target ) {\\r\\n\\r\\n\\t\\treturn target.copy( _viewport );\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.setViewport = function ( x, y, width, height ) {\\r\\n\\r\\n\\t\\tif ( x.isVector4 ) {\\r\\n\\r\\n\\t\\t\\t_viewport.set( x.x, x.y, x.z, x.w );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t_viewport.set( x, y, width, height );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tstate.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor() );\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.getScissor = function ( target ) {\\r\\n\\r\\n\\t\\treturn target.copy( _scissor );\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.setScissor = function ( x, y, width, height ) {\\r\\n\\r\\n\\t\\tif ( x.isVector4 ) {\\r\\n\\r\\n\\t\\t\\t_scissor.set( x.x, x.y, x.z, x.w );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t_scissor.set( x, y, width, height );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tstate.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor() );\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.getScissorTest = function () {\\r\\n\\r\\n\\t\\treturn _scissorTest;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.setScissorTest = function ( boolean ) {\\r\\n\\r\\n\\t\\tstate.setScissorTest( _scissorTest = boolean );\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.setOpaqueSort = function ( method ) {\\r\\n\\r\\n\\t\\t_opaqueSort = method;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.setTransparentSort = function ( method ) {\\r\\n\\r\\n\\t\\t_transparentSort = method;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t// Clearing\\r\\n\\r\\n\\tthis.getClearColor = function () {\\r\\n\\r\\n\\t\\treturn background.getClearColor();\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.setClearColor = function () {\\r\\n\\r\\n\\t\\tbackground.setClearColor.apply( background, arguments );\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.getClearAlpha = function () {\\r\\n\\r\\n\\t\\treturn background.getClearAlpha();\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.setClearAlpha = function () {\\r\\n\\r\\n\\t\\tbackground.setClearAlpha.apply( background, arguments );\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.clear = function ( color, depth, stencil ) {\\r\\n\\r\\n\\t\\tvar bits = 0;\\r\\n\\r\\n\\t\\tif ( color === undefined || color ) bits |= 16384;\\r\\n\\t\\tif ( depth === undefined || depth ) bits |= 256;\\r\\n\\t\\tif ( stencil === undefined || stencil ) bits |= 1024;\\r\\n\\r\\n\\t\\t_gl.clear( bits );\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.clearColor = function () {\\r\\n\\r\\n\\t\\tthis.clear( true, false, false );\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.clearDepth = function () {\\r\\n\\r\\n\\t\\tthis.clear( false, true, false );\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.clearStencil = function () {\\r\\n\\r\\n\\t\\tthis.clear( false, false, true );\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tthis.dispose = function () {\\r\\n\\r\\n\\t\\t_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );\\r\\n\\t\\t_canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );\\r\\n\\r\\n\\t\\trenderLists.dispose();\\r\\n\\t\\trenderStates.dispose();\\r\\n\\t\\tproperties.dispose();\\r\\n\\t\\tobjects.dispose();\\r\\n\\r\\n\\t\\txr.dispose();\\r\\n\\r\\n\\t\\tanimation.stop();\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t// Events\\r\\n\\r\\n\\tfunction onContextLost( event ) {\\r\\n\\r\\n\\t\\tevent.preventDefault();\\r\\n\\r\\n\\t\\tconsole.log( 'THREE.WebGLRenderer: Context Lost.' );\\r\\n\\r\\n\\t\\t_isContextLost = true;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction onContextRestore( /* event */ ) {\\r\\n\\r\\n\\t\\tconsole.log( 'THREE.WebGLRenderer: Context Restored.' );\\r\\n\\r\\n\\t\\t_isContextLost = false;\\r\\n\\r\\n\\t\\tinitGLContext();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction onMaterialDispose( event ) {\\r\\n\\r\\n\\t\\tvar material = event.target;\\r\\n\\r\\n\\t\\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\\r\\n\\r\\n\\t\\tdeallocateMaterial( material );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// Buffer deallocation\\r\\n\\r\\n\\tfunction deallocateMaterial( material ) {\\r\\n\\r\\n\\t\\treleaseMaterialProgramReference( material );\\r\\n\\r\\n\\t\\tproperties.remove( material );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\r\\n\\tfunction releaseMaterialProgramReference( material ) {\\r\\n\\r\\n\\t\\tvar programInfo = properties.get( material ).program;\\r\\n\\r\\n\\t\\tmaterial.program = undefined;\\r\\n\\r\\n\\t\\tif ( programInfo !== undefined ) {\\r\\n\\r\\n\\t\\t\\tprogramCache.releaseProgram( programInfo );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// Buffer rendering\\r\\n\\r\\n\\tfunction renderObjectImmediate( object, program ) {\\r\\n\\r\\n\\t\\tobject.render( function ( object ) {\\r\\n\\r\\n\\t\\t\\t_this.renderBufferImmediate( object, program );\\r\\n\\r\\n\\t\\t} );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tthis.renderBufferImmediate = function ( object, program ) {\\r\\n\\r\\n\\t\\tstate.initAttributes();\\r\\n\\r\\n\\t\\tvar buffers = properties.get( object );\\r\\n\\r\\n\\t\\tif ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();\\r\\n\\t\\tif ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();\\r\\n\\t\\tif ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();\\r\\n\\t\\tif ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();\\r\\n\\r\\n\\t\\tvar programAttributes = program.getAttributes();\\r\\n\\r\\n\\t\\tif ( object.hasPositions ) {\\r\\n\\r\\n\\t\\t\\t_gl.bindBuffer( 34962, buffers.position );\\r\\n\\t\\t\\t_gl.bufferData( 34962, object.positionArray, 35048 );\\r\\n\\r\\n\\t\\t\\tstate.enableAttribute( programAttributes.position );\\r\\n\\t\\t\\t_gl.vertexAttribPointer( programAttributes.position, 3, 5126, false, 0, 0 );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( object.hasNormals ) {\\r\\n\\r\\n\\t\\t\\t_gl.bindBuffer( 34962, buffers.normal );\\r\\n\\t\\t\\t_gl.bufferData( 34962, object.normalArray, 35048 );\\r\\n\\r\\n\\t\\t\\tstate.enableAttribute( programAttributes.normal );\\r\\n\\t\\t\\t_gl.vertexAttribPointer( programAttributes.normal, 3, 5126, false, 0, 0 );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( object.hasUvs ) {\\r\\n\\r\\n\\t\\t\\t_gl.bindBuffer( 34962, buffers.uv );\\r\\n\\t\\t\\t_gl.bufferData( 34962, object.uvArray, 35048 );\\r\\n\\r\\n\\t\\t\\tstate.enableAttribute( programAttributes.uv );\\r\\n\\t\\t\\t_gl.vertexAttribPointer( programAttributes.uv, 2, 5126, false, 0, 0 );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( object.hasColors ) {\\r\\n\\r\\n\\t\\t\\t_gl.bindBuffer( 34962, buffers.color );\\r\\n\\t\\t\\t_gl.bufferData( 34962, object.colorArray, 35048 );\\r\\n\\r\\n\\t\\t\\tstate.enableAttribute( programAttributes.color );\\r\\n\\t\\t\\t_gl.vertexAttribPointer( programAttributes.color, 3, 5126, false, 0, 0 );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tstate.disableUnusedAttributes();\\r\\n\\r\\n\\t\\t_gl.drawArrays( 4, 0, object.count );\\r\\n\\r\\n\\t\\tobject.count = 0;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tvar tempScene = new Scene();\\r\\n\\r\\n\\tthis.renderBufferDirect = function ( camera, scene, geometry, material, object, group ) {\\r\\n\\r\\n\\t\\tif ( scene === null ) scene = tempScene; // renderBufferDirect second parameter used to be fog (could be null)\\r\\n\\r\\n\\t\\tvar frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );\\r\\n\\r\\n\\t\\tvar program = setProgram( camera, scene, material, object );\\r\\n\\r\\n\\t\\tstate.setMaterial( material, frontFaceCW );\\r\\n\\r\\n\\t\\tvar updateBuffers = false;\\r\\n\\r\\n\\t\\tif ( _currentGeometryProgram.geometry !== geometry.id ||\\r\\n\\t\\t\\t_currentGeometryProgram.program !== program.id ||\\r\\n\\t\\t\\t_currentGeometryProgram.wireframe !== ( material.wireframe === true ) ) {\\r\\n\\r\\n\\t\\t\\t_currentGeometryProgram.geometry = geometry.id;\\r\\n\\t\\t\\t_currentGeometryProgram.program = program.id;\\r\\n\\t\\t\\t_currentGeometryProgram.wireframe = material.wireframe === true;\\r\\n\\t\\t\\tupdateBuffers = true;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( material.morphTargets || material.morphNormals ) {\\r\\n\\r\\n\\t\\t\\tmorphtargets.update( object, geometry, material, program );\\r\\n\\r\\n\\t\\t\\tupdateBuffers = true;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( object.isInstancedMesh === true ) {\\r\\n\\r\\n\\t\\t\\tupdateBuffers = true;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\tvar index = geometry.index;\\r\\n\\t\\tvar position = geometry.attributes.position;\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\tif ( index === null ) {\\r\\n\\r\\n\\t\\t\\tif ( position === undefined || position.count === 0 ) return;\\r\\n\\r\\n\\t\\t} else if ( index.count === 0 ) {\\r\\n\\r\\n\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\tvar rangeFactor = 1;\\r\\n\\r\\n\\t\\tif ( material.wireframe === true ) {\\r\\n\\r\\n\\t\\t\\tindex = geometries.getWireframeAttribute( geometry );\\r\\n\\t\\t\\trangeFactor = 2;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar attribute;\\r\\n\\t\\tvar renderer = bufferRenderer;\\r\\n\\r\\n\\t\\tif ( index !== null ) {\\r\\n\\r\\n\\t\\t\\tattribute = attributes.get( index );\\r\\n\\r\\n\\t\\t\\trenderer = indexedBufferRenderer;\\r\\n\\t\\t\\trenderer.setIndex( attribute );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( updateBuffers ) {\\r\\n\\r\\n\\t\\t\\tsetupVertexAttributes( object, geometry, material, program );\\r\\n\\r\\n\\t\\t\\tif ( index !== null ) {\\r\\n\\r\\n\\t\\t\\t\\t_gl.bindBuffer( 34963, attribute.buffer );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\tvar dataCount = ( index !== null ) ? index.count : position.count;\\r\\n\\r\\n\\t\\tvar rangeStart = geometry.drawRange.start * rangeFactor;\\r\\n\\t\\tvar rangeCount = geometry.drawRange.count * rangeFactor;\\r\\n\\r\\n\\t\\tvar groupStart = group !== null ? group.start * rangeFactor : 0;\\r\\n\\t\\tvar groupCount = group !== null ? group.count * rangeFactor : Infinity;\\r\\n\\r\\n\\t\\tvar drawStart = Math.max( rangeStart, groupStart );\\r\\n\\t\\tvar drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;\\r\\n\\r\\n\\t\\tvar drawCount = Math.max( 0, drawEnd - drawStart + 1 );\\r\\n\\r\\n\\t\\tif ( drawCount === 0 ) return;\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\tif ( object.isMesh ) {\\r\\n\\r\\n\\t\\t\\tif ( material.wireframe === true ) {\\r\\n\\r\\n\\t\\t\\t\\tstate.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );\\r\\n\\t\\t\\t\\trenderer.setMode( 1 );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\trenderer.setMode( 4 );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t} else if ( object.isLine ) {\\r\\n\\r\\n\\t\\t\\tvar lineWidth = material.linewidth;\\r\\n\\r\\n\\t\\t\\tif ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material\\r\\n\\r\\n\\t\\t\\tstate.setLineWidth( lineWidth * getTargetPixelRatio() );\\r\\n\\r\\n\\t\\t\\tif ( object.isLineSegments ) {\\r\\n\\r\\n\\t\\t\\t\\trenderer.setMode( 1 );\\r\\n\\r\\n\\t\\t\\t} else if ( object.isLineLoop ) {\\r\\n\\r\\n\\t\\t\\t\\trenderer.setMode( 2 );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\trenderer.setMode( 3 );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t} else if ( object.isPoints ) {\\r\\n\\r\\n\\t\\t\\trenderer.setMode( 0 );\\r\\n\\r\\n\\t\\t} else if ( object.isSprite ) {\\r\\n\\r\\n\\t\\t\\trenderer.setMode( 4 );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( object.isInstancedMesh ) {\\r\\n\\r\\n\\t\\t\\trenderer.renderInstances( geometry, drawStart, drawCount, object.count );\\r\\n\\r\\n\\t\\t} else if ( geometry.isInstancedBufferGeometry ) {\\r\\n\\r\\n\\t\\t\\tvar instanceCount = Math.min( geometry.instanceCount, geometry._maxInstanceCount );\\r\\n\\r\\n\\t\\t\\trenderer.renderInstances( geometry, drawStart, drawCount, instanceCount );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\trenderer.render( drawStart, drawCount );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tfunction setupVertexAttributes( object, geometry, material, program ) {\\r\\n\\r\\n\\t\\tif ( capabilities.isWebGL2 === false && ( object.isInstancedMesh || geometry.isInstancedBufferGeometry ) ) {\\r\\n\\r\\n\\t\\t\\tif ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) return;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tstate.initAttributes();\\r\\n\\r\\n\\t\\tvar geometryAttributes = geometry.attributes;\\r\\n\\r\\n\\t\\tvar programAttributes = program.getAttributes();\\r\\n\\r\\n\\t\\tvar materialDefaultAttributeValues = material.defaultAttributeValues;\\r\\n\\r\\n\\t\\tfor ( var name in programAttributes ) {\\r\\n\\r\\n\\t\\t\\tvar programAttribute = programAttributes[ name ];\\r\\n\\r\\n\\t\\t\\tif ( programAttribute >= 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tvar geometryAttribute = geometryAttributes[ name ];\\r\\n\\r\\n\\t\\t\\t\\tif ( geometryAttribute !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar normalized = geometryAttribute.normalized;\\r\\n\\t\\t\\t\\t\\tvar size = geometryAttribute.itemSize;\\r\\n\\r\\n\\t\\t\\t\\t\\tvar attribute = attributes.get( geometryAttribute );\\r\\n\\r\\n\\t\\t\\t\\t\\t// TODO Attribute may not be available on context restore\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( attribute === undefined ) continue;\\r\\n\\r\\n\\t\\t\\t\\t\\tvar buffer = attribute.buffer;\\r\\n\\t\\t\\t\\t\\tvar type = attribute.type;\\r\\n\\t\\t\\t\\t\\tvar bytesPerElement = attribute.bytesPerElement;\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( geometryAttribute.isInterleavedBufferAttribute ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar data = geometryAttribute.data;\\r\\n\\t\\t\\t\\t\\t\\tvar stride = data.stride;\\r\\n\\t\\t\\t\\t\\t\\tvar offset = geometryAttribute.offset;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( data && data.isInstancedInterleavedBuffer ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tstate.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( geometry._maxInstanceCount === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tgeometry._maxInstanceCount = data.meshPerAttribute * data.count;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tstate.enableAttribute( programAttribute );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t_gl.bindBuffer( 34962, buffer );\\r\\n\\t\\t\\t\\t\\t\\tstate.vertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement );\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( geometryAttribute.isInstancedBufferAttribute ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tstate.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( geometry._maxInstanceCount === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tgeometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tstate.enableAttribute( programAttribute );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t_gl.bindBuffer( 34962, buffer );\\r\\n\\t\\t\\t\\t\\t\\tstate.vertexAttribPointer( programAttribute, size, type, normalized, 0, 0 );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t} else if ( name === 'instanceMatrix' ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar attribute = attributes.get( object.instanceMatrix );\\r\\n\\r\\n\\t\\t\\t\\t\\t// TODO Attribute may not be available on context restore\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( attribute === undefined ) continue;\\r\\n\\r\\n\\t\\t\\t\\t\\tvar buffer = attribute.buffer;\\r\\n\\t\\t\\t\\t\\tvar type = attribute.type;\\r\\n\\r\\n\\t\\t\\t\\t\\tstate.enableAttributeAndDivisor( programAttribute + 0, 1 );\\r\\n\\t\\t\\t\\t\\tstate.enableAttributeAndDivisor( programAttribute + 1, 1 );\\r\\n\\t\\t\\t\\t\\tstate.enableAttributeAndDivisor( programAttribute + 2, 1 );\\r\\n\\t\\t\\t\\t\\tstate.enableAttributeAndDivisor( programAttribute + 3, 1 );\\r\\n\\r\\n\\t\\t\\t\\t\\t_gl.bindBuffer( 34962, buffer );\\r\\n\\r\\n\\t\\t\\t\\t\\t_gl.vertexAttribPointer( programAttribute + 0, 4, type, false, 64, 0 );\\r\\n\\t\\t\\t\\t\\t_gl.vertexAttribPointer( programAttribute + 1, 4, type, false, 64, 16 );\\r\\n\\t\\t\\t\\t\\t_gl.vertexAttribPointer( programAttribute + 2, 4, type, false, 64, 32 );\\r\\n\\t\\t\\t\\t\\t_gl.vertexAttribPointer( programAttribute + 3, 4, type, false, 64, 48 );\\r\\n\\r\\n\\t\\t\\t\\t} else if ( materialDefaultAttributeValues !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar value = materialDefaultAttributeValues[ name ];\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( value !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tswitch ( value.length ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tcase 2:\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t_gl.vertexAttrib2fv( programAttribute, value );\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tcase 3:\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t_gl.vertexAttrib3fv( programAttribute, value );\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tcase 4:\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t_gl.vertexAttrib4fv( programAttribute, value );\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tdefault:\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t_gl.vertexAttrib1fv( programAttribute, value );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tstate.disableUnusedAttributes();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// Compile\\r\\n\\r\\n\\tthis.compile = function ( scene, camera ) {\\r\\n\\r\\n\\t\\tcurrentRenderState = renderStates.get( scene, camera );\\r\\n\\t\\tcurrentRenderState.init();\\r\\n\\r\\n\\t\\tscene.traverse( function ( object ) {\\r\\n\\r\\n\\t\\t\\tif ( object.isLight ) {\\r\\n\\r\\n\\t\\t\\t\\tcurrentRenderState.pushLight( object );\\r\\n\\r\\n\\t\\t\\t\\tif ( object.castShadow ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tcurrentRenderState.pushShadow( object );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t} );\\r\\n\\r\\n\\t\\tcurrentRenderState.setupLights( camera );\\r\\n\\r\\n\\t\\tconst compiled = {};\\r\\n\\r\\n\\t\\tscene.traverse( function ( object ) {\\r\\n\\r\\n\\t\\t\\tlet material = object.material;\\r\\n\\r\\n\\t\\t\\tif ( material ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( Array.isArray( material ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( let i = 0; i < material.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tlet material2 = material[ i ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( material2.uuid in compiled === false ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tinitMaterial( material2, scene, object );\\r\\n\\t\\t\\t\\t\\t\\t\\tcompiled[ material2.uuid ] = true;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t} else if ( material.uuid in compiled === false ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tinitMaterial( material, scene, object );\\r\\n\\t\\t\\t\\t\\tcompiled[ material.uuid ] = true;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t} );\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t// Animation Loop\\r\\n\\r\\n\\tvar onAnimationFrameCallback = null;\\r\\n\\r\\n\\tfunction onAnimationFrame( time ) {\\r\\n\\r\\n\\t\\tif ( xr.isPresenting ) return;\\r\\n\\t\\tif ( onAnimationFrameCallback ) onAnimationFrameCallback( time );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tvar animation = new WebGLAnimation();\\r\\n\\tanimation.setAnimationLoop( onAnimationFrame );\\r\\n\\r\\n\\tif ( typeof window !== 'undefined' ) animation.setContext( window );\\r\\n\\r\\n\\tthis.setAnimationLoop = function ( callback ) {\\r\\n\\r\\n\\t\\tonAnimationFrameCallback = callback;\\r\\n\\t\\txr.setAnimationLoop( callback );\\r\\n\\r\\n\\t\\tanimation.start();\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t// Rendering\\r\\n\\r\\n\\tthis.render = function ( scene, camera ) {\\r\\n\\r\\n\\t\\tvar renderTarget, forceClear;\\r\\n\\r\\n\\t\\tif ( arguments[ 2 ] !== undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.' );\\r\\n\\t\\t\\trenderTarget = arguments[ 2 ];\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( arguments[ 3 ] !== undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.' );\\r\\n\\t\\t\\tforceClear = arguments[ 3 ];\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( ! ( camera && camera.isCamera ) ) {\\r\\n\\r\\n\\t\\t\\tconsole.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\\r\\n\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( _isContextLost ) return;\\r\\n\\r\\n\\t\\t// reset caching for this frame\\r\\n\\r\\n\\t\\t_currentGeometryProgram.geometry = null;\\r\\n\\t\\t_currentGeometryProgram.program = null;\\r\\n\\t\\t_currentGeometryProgram.wireframe = false;\\r\\n\\t\\t_currentMaterialId = - 1;\\r\\n\\t\\t_currentCamera = null;\\r\\n\\r\\n\\t\\t// update scene graph\\r\\n\\r\\n\\t\\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\\r\\n\\r\\n\\t\\t// update camera matrices and frustum\\r\\n\\r\\n\\t\\tif ( camera.parent === null ) camera.updateMatrixWorld();\\r\\n\\r\\n\\t\\tif ( xr.enabled && xr.isPresenting ) {\\r\\n\\r\\n\\t\\t\\tcamera = xr.getCamera( camera );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t//\\r\\n\\t\\tscene.onBeforeRender( _this, scene, camera, renderTarget || _currentRenderTarget );\\r\\n\\r\\n\\t\\tcurrentRenderState = renderStates.get( scene, camera );\\r\\n\\t\\tcurrentRenderState.init();\\r\\n\\r\\n\\t\\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\\r\\n\\t\\t_frustum.setFromProjectionMatrix( _projScreenMatrix );\\r\\n\\r\\n\\t\\t_localClippingEnabled = this.localClippingEnabled;\\r\\n\\t\\t_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );\\r\\n\\r\\n\\t\\tcurrentRenderList = renderLists.get( scene, camera );\\r\\n\\t\\tcurrentRenderList.init();\\r\\n\\r\\n\\t\\tprojectObject( scene, camera, 0, _this.sortObjects );\\r\\n\\r\\n\\t\\tcurrentRenderList.finish();\\r\\n\\r\\n\\t\\tif ( _this.sortObjects === true ) {\\r\\n\\r\\n\\t\\t\\tcurrentRenderList.sort( _opaqueSort, _transparentSort );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\tif ( _clippingEnabled ) _clipping.beginShadows();\\r\\n\\r\\n\\t\\tvar shadowsArray = currentRenderState.state.shadowsArray;\\r\\n\\r\\n\\t\\tshadowMap.render( shadowsArray, scene, camera );\\r\\n\\r\\n\\t\\tcurrentRenderState.setupLights( camera );\\r\\n\\r\\n\\t\\tif ( _clippingEnabled ) _clipping.endShadows();\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\tif ( this.info.autoReset ) this.info.reset();\\r\\n\\r\\n\\t\\tif ( renderTarget !== undefined ) {\\r\\n\\r\\n\\t\\t\\tthis.setRenderTarget( renderTarget );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\tbackground.render( currentRenderList, scene, camera, forceClear );\\r\\n\\r\\n\\t\\t// render scene\\r\\n\\r\\n\\t\\tvar opaqueObjects = currentRenderList.opaque;\\r\\n\\t\\tvar transparentObjects = currentRenderList.transparent;\\r\\n\\r\\n\\t\\tif ( scene.overrideMaterial ) {\\r\\n\\r\\n\\t\\t\\tvar overrideMaterial = scene.overrideMaterial;\\r\\n\\r\\n\\t\\t\\tif ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera, overrideMaterial );\\r\\n\\t\\t\\tif ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera, overrideMaterial );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t// opaque pass (front-to-back order)\\r\\n\\r\\n\\t\\t\\tif ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera );\\r\\n\\r\\n\\t\\t\\t// transparent pass (back-to-front order)\\r\\n\\r\\n\\t\\t\\tif ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\tscene.onAfterRender( _this, scene, camera );\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\tif ( _currentRenderTarget !== null ) {\\r\\n\\r\\n\\t\\t\\t// Generate mipmap if we're using any kind of mipmap filtering\\r\\n\\r\\n\\t\\t\\ttextures.updateRenderTargetMipmap( _currentRenderTarget );\\r\\n\\r\\n\\t\\t\\t// resolve multisample renderbuffers to a single-sample texture if necessary\\r\\n\\r\\n\\t\\t\\ttextures.updateMultisampleRenderTarget( _currentRenderTarget );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Ensure depth buffer writing is enabled so it can be cleared on next render\\r\\n\\r\\n\\t\\tstate.buffers.depth.setTest( true );\\r\\n\\t\\tstate.buffers.depth.setMask( true );\\r\\n\\t\\tstate.buffers.color.setMask( true );\\r\\n\\r\\n\\t\\tstate.setPolygonOffset( false );\\r\\n\\r\\n\\t\\t// _gl.finish();\\r\\n\\r\\n\\t\\tcurrentRenderList = null;\\r\\n\\t\\tcurrentRenderState = null;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tfunction projectObject( object, camera, groupOrder, sortObjects ) {\\r\\n\\r\\n\\t\\tif ( object.visible === false ) return;\\r\\n\\r\\n\\t\\tvar visible = object.layers.test( camera.layers );\\r\\n\\r\\n\\t\\tif ( visible ) {\\r\\n\\r\\n\\t\\t\\tif ( object.isGroup ) {\\r\\n\\r\\n\\t\\t\\t\\tgroupOrder = object.renderOrder;\\r\\n\\r\\n\\t\\t\\t} else if ( object.isLOD ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( object.autoUpdate === true ) object.update( camera );\\r\\n\\r\\n\\t\\t\\t} else if ( object.isLight ) {\\r\\n\\r\\n\\t\\t\\t\\tcurrentRenderState.pushLight( object );\\r\\n\\r\\n\\t\\t\\t\\tif ( object.castShadow ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tcurrentRenderState.pushShadow( object );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} else if ( object.isSprite ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( sortObjects ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t_vector3.setFromMatrixPosition( object.matrixWorld )\\r\\n\\t\\t\\t\\t\\t\\t\\t.applyMatrix4( _projScreenMatrix );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tvar geometry = objects.update( object );\\r\\n\\t\\t\\t\\t\\tvar material = object.material;\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( material.visible ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tcurrentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} else if ( object.isImmediateRenderObject ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( sortObjects ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t_vector3.setFromMatrixPosition( object.matrixWorld )\\r\\n\\t\\t\\t\\t\\t\\t.applyMatrix4( _projScreenMatrix );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tcurrentRenderList.push( object, null, object.material, groupOrder, _vector3.z, null );\\r\\n\\r\\n\\t\\t\\t} else if ( object.isMesh || object.isLine || object.isPoints ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( object.isSkinnedMesh ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// update skeleton only once in a frame\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( object.skeleton.frame !== info.render.frame ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tobject.skeleton.update();\\r\\n\\t\\t\\t\\t\\t\\tobject.skeleton.frame = info.render.frame;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( sortObjects ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t_vector3.setFromMatrixPosition( object.matrixWorld )\\r\\n\\t\\t\\t\\t\\t\\t\\t.applyMatrix4( _projScreenMatrix );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tvar geometry = objects.update( object );\\r\\n\\t\\t\\t\\t\\tvar material = object.material;\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( Array.isArray( material ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar groups = geometry.groups;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tvar group = groups[ i ];\\r\\n\\t\\t\\t\\t\\t\\t\\tvar groupMaterial = material[ group.materialIndex ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( groupMaterial && groupMaterial.visible ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tcurrentRenderList.push( object, geometry, groupMaterial, groupOrder, _vector3.z, group );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t} else if ( material.visible ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tcurrentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar children = object.children;\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\tprojectObject( children[ i ], camera, groupOrder, sortObjects );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction renderObjects( renderList, scene, camera, overrideMaterial ) {\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = renderList.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar renderItem = renderList[ i ];\\r\\n\\r\\n\\t\\t\\tvar object = renderItem.object;\\r\\n\\t\\t\\tvar geometry = renderItem.geometry;\\r\\n\\t\\t\\tvar material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;\\r\\n\\t\\t\\tvar group = renderItem.group;\\r\\n\\r\\n\\t\\t\\tif ( camera.isArrayCamera ) {\\r\\n\\r\\n\\t\\t\\t\\t_currentArrayCamera = camera;\\r\\n\\r\\n\\t\\t\\t\\tvar cameras = camera.cameras;\\r\\n\\r\\n\\t\\t\\t\\tfor ( var j = 0, jl = cameras.length; j < jl; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar camera2 = cameras[ j ];\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( object.layers.test( camera2.layers ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tstate.viewport( _currentViewport.copy( camera2.viewport ) );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tcurrentRenderState.setupLights( camera2 );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\trenderObject( object, scene, camera2, geometry, material, group );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t_currentArrayCamera = null;\\r\\n\\r\\n\\t\\t\\t\\trenderObject( object, scene, camera, geometry, material, group );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction renderObject( object, scene, camera, geometry, material, group ) {\\r\\n\\r\\n\\t\\tobject.onBeforeRender( _this, scene, camera, geometry, material, group );\\r\\n\\t\\tcurrentRenderState = renderStates.get( scene, _currentArrayCamera || camera );\\r\\n\\r\\n\\t\\tobject.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\\r\\n\\t\\tobject.normalMatrix.getNormalMatrix( object.modelViewMatrix );\\r\\n\\r\\n\\t\\tif ( object.isImmediateRenderObject ) {\\r\\n\\r\\n\\t\\t\\tvar program = setProgram( camera, scene, material, object );\\r\\n\\r\\n\\t\\t\\tstate.setMaterial( material );\\r\\n\\r\\n\\t\\t\\t_currentGeometryProgram.geometry = null;\\r\\n\\t\\t\\t_currentGeometryProgram.program = null;\\r\\n\\t\\t\\t_currentGeometryProgram.wireframe = false;\\r\\n\\r\\n\\t\\t\\trenderObjectImmediate( object, program );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t_this.renderBufferDirect( camera, scene, geometry, material, object, group );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tobject.onAfterRender( _this, scene, camera, geometry, material, group );\\r\\n\\t\\tcurrentRenderState = renderStates.get( scene, _currentArrayCamera || camera );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction initMaterial( material, scene, object ) {\\r\\n\\r\\n\\t\\tvar materialProperties = properties.get( material );\\r\\n\\r\\n\\t\\tvar lights = currentRenderState.state.lights;\\r\\n\\t\\tvar shadowsArray = currentRenderState.state.shadowsArray;\\r\\n\\r\\n\\t\\tvar lightsStateVersion = lights.state.version;\\r\\n\\r\\n\\t\\tvar parameters = programCache.getParameters( material, lights.state, shadowsArray, scene, _clipping.numPlanes, _clipping.numIntersection, object );\\r\\n\\t\\tvar programCacheKey = programCache.getProgramCacheKey( parameters );\\r\\n\\r\\n\\t\\tvar program = materialProperties.program;\\r\\n\\t\\tvar programChange = true;\\r\\n\\r\\n\\t\\tif ( program === undefined ) {\\r\\n\\r\\n\\t\\t\\t// new material\\r\\n\\t\\t\\tmaterial.addEventListener( 'dispose', onMaterialDispose );\\r\\n\\r\\n\\t\\t} else if ( program.cacheKey !== programCacheKey ) {\\r\\n\\r\\n\\t\\t\\t// changed glsl or parameters\\r\\n\\t\\t\\treleaseMaterialProgramReference( material );\\r\\n\\r\\n\\t\\t} else if ( materialProperties.lightsStateVersion !== lightsStateVersion ) {\\r\\n\\r\\n\\t\\t\\tmaterialProperties.lightsStateVersion = lightsStateVersion;\\r\\n\\r\\n\\t\\t\\tprogramChange = false;\\r\\n\\r\\n\\t\\t} else if ( parameters.shaderID !== undefined ) {\\r\\n\\r\\n\\t\\t\\t// same glsl and uniform list\\r\\n\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t// only rebuild uniform list\\r\\n\\t\\t\\tprogramChange = false;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( programChange ) {\\r\\n\\r\\n\\t\\t\\tprogram = programCache.acquireProgram( parameters, programCacheKey );\\r\\n\\r\\n\\t\\t\\tmaterialProperties.program = program;\\r\\n\\t\\t\\tmaterialProperties.uniforms = parameters.uniforms;\\r\\n\\t\\t\\tmaterialProperties.outputEncoding = parameters.outputEncoding;\\r\\n\\t\\t\\tmaterial.program = program;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar programAttributes = program.getAttributes();\\r\\n\\r\\n\\t\\tif ( material.morphTargets ) {\\r\\n\\r\\n\\t\\t\\tmaterial.numSupportedMorphTargets = 0;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < _this.maxMorphTargets; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( programAttributes[ 'morphTarget' + i ] >= 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tmaterial.numSupportedMorphTargets ++;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( material.morphNormals ) {\\r\\n\\r\\n\\t\\t\\tmaterial.numSupportedMorphNormals = 0;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < _this.maxMorphNormals; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( programAttributes[ 'morphNormal' + i ] >= 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tmaterial.numSupportedMorphNormals ++;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar uniforms = materialProperties.uniforms;\\r\\n\\r\\n\\t\\tif ( ! material.isShaderMaterial &&\\r\\n\\t\\t\\t! material.isRawShaderMaterial ||\\r\\n\\t\\t\\tmaterial.clipping === true ) {\\r\\n\\r\\n\\t\\t\\tmaterialProperties.numClippingPlanes = _clipping.numPlanes;\\r\\n\\t\\t\\tmaterialProperties.numIntersection = _clipping.numIntersection;\\r\\n\\t\\t\\tuniforms.clippingPlanes = _clipping.uniform;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tmaterialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;\\r\\n\\t\\tmaterialProperties.fog = scene.fog;\\r\\n\\r\\n\\t\\t// store the light setup it was created for\\r\\n\\r\\n\\t\\tmaterialProperties.needsLights = materialNeedsLights( material );\\r\\n\\t\\tmaterialProperties.lightsStateVersion = lightsStateVersion;\\r\\n\\r\\n\\t\\tif ( materialProperties.needsLights ) {\\r\\n\\r\\n\\t\\t\\t// wire up the material to this renderer's lighting state\\r\\n\\r\\n\\t\\t\\tuniforms.ambientLightColor.value = lights.state.ambient;\\r\\n\\t\\t\\tuniforms.lightProbe.value = lights.state.probe;\\r\\n\\t\\t\\tuniforms.directionalLights.value = lights.state.directional;\\r\\n\\t\\t\\tuniforms.directionalLightShadows.value = lights.state.directionalShadow;\\r\\n\\t\\t\\tuniforms.spotLights.value = lights.state.spot;\\r\\n\\t\\t\\tuniforms.spotLightShadows.value = lights.state.spotShadow;\\r\\n\\t\\t\\tuniforms.rectAreaLights.value = lights.state.rectArea;\\r\\n\\t\\t\\tuniforms.pointLights.value = lights.state.point;\\r\\n\\t\\t\\tuniforms.pointLightShadows.value = lights.state.pointShadow;\\r\\n\\t\\t\\tuniforms.hemisphereLights.value = lights.state.hemi;\\r\\n\\r\\n\\t\\t\\tuniforms.directionalShadowMap.value = lights.state.directionalShadowMap;\\r\\n\\t\\t\\tuniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;\\r\\n\\t\\t\\tuniforms.spotShadowMap.value = lights.state.spotShadowMap;\\r\\n\\t\\t\\tuniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;\\r\\n\\t\\t\\tuniforms.pointShadowMap.value = lights.state.pointShadowMap;\\r\\n\\t\\t\\tuniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;\\r\\n\\t\\t\\t// TODO (abelnation): add area lights shadow info to uniforms\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar progUniforms = materialProperties.program.getUniforms(),\\r\\n\\t\\t\\tuniformsList =\\r\\n\\t\\t\\t\\tWebGLUniforms.seqWithValue( progUniforms.seq, uniforms );\\r\\n\\r\\n\\t\\tmaterialProperties.uniformsList = uniformsList;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction setProgram( camera, scene, material, object ) {\\r\\n\\r\\n\\t\\ttextures.resetTextureUnits();\\r\\n\\r\\n\\t\\tvar fog = scene.fog;\\r\\n\\t\\tvar environment = material.isMeshStandardMaterial ? scene.environment : null;\\r\\n\\t\\tvar encoding = ( _currentRenderTarget === null ) ? _this.outputEncoding : _currentRenderTarget.texture.encoding;\\r\\n\\r\\n\\t\\tvar materialProperties = properties.get( material );\\r\\n\\t\\tvar lights = currentRenderState.state.lights;\\r\\n\\r\\n\\t\\tif ( _clippingEnabled ) {\\r\\n\\r\\n\\t\\t\\tif ( _localClippingEnabled || camera !== _currentCamera ) {\\r\\n\\r\\n\\t\\t\\t\\tvar useCache =\\r\\n\\t\\t\\t\\t\\tcamera === _currentCamera &&\\r\\n\\t\\t\\t\\t\\tmaterial.id === _currentMaterialId;\\r\\n\\r\\n\\t\\t\\t\\t// we might want to call this function with some ClippingGroup\\r\\n\\t\\t\\t\\t// object instead of the material, once it becomes feasible\\r\\n\\t\\t\\t\\t// (#8465, #8379)\\r\\n\\t\\t\\t\\t_clipping.setState(\\r\\n\\t\\t\\t\\t\\tmaterial.clippingPlanes, material.clipIntersection, material.clipShadows,\\r\\n\\t\\t\\t\\t\\tcamera, materialProperties, useCache );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( material.version === materialProperties.__version ) {\\r\\n\\r\\n\\t\\t\\tif ( materialProperties.program === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tinitMaterial( material, scene, object );\\r\\n\\r\\n\\t\\t\\t} else if ( material.fog && materialProperties.fog !== fog ) {\\r\\n\\r\\n\\t\\t\\t\\tinitMaterial( material, scene, object );\\r\\n\\r\\n\\t\\t\\t} else if ( materialProperties.environment !== environment ) {\\r\\n\\r\\n\\t\\t\\t\\tinitMaterial( material, scene, object );\\r\\n\\r\\n\\t\\t\\t} else if ( materialProperties.needsLights && ( materialProperties.lightsStateVersion !== lights.state.version ) ) {\\r\\n\\r\\n\\t\\t\\t\\tinitMaterial( material, scene, object );\\r\\n\\r\\n\\t\\t\\t} else if ( materialProperties.numClippingPlanes !== undefined &&\\r\\n\\t\\t\\t\\t( materialProperties.numClippingPlanes !== _clipping.numPlanes ||\\r\\n\\t\\t\\t\\tmaterialProperties.numIntersection !== _clipping.numIntersection ) ) {\\r\\n\\r\\n\\t\\t\\t\\tinitMaterial( material, scene, object );\\r\\n\\r\\n\\t\\t\\t} else if ( materialProperties.outputEncoding !== encoding ) {\\r\\n\\r\\n\\t\\t\\t\\tinitMaterial( material, scene, object );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tinitMaterial( material, scene, object );\\r\\n\\t\\t\\tmaterialProperties.__version = material.version;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar refreshProgram = false;\\r\\n\\t\\tvar refreshMaterial = false;\\r\\n\\t\\tvar refreshLights = false;\\r\\n\\r\\n\\t\\tvar program = materialProperties.program,\\r\\n\\t\\t\\tp_uniforms = program.getUniforms(),\\r\\n\\t\\t\\tm_uniforms = materialProperties.uniforms;\\r\\n\\r\\n\\t\\tif ( state.useProgram( program.program ) ) {\\r\\n\\r\\n\\t\\t\\trefreshProgram = true;\\r\\n\\t\\t\\trefreshMaterial = true;\\r\\n\\t\\t\\trefreshLights = true;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( material.id !== _currentMaterialId ) {\\r\\n\\r\\n\\t\\t\\t_currentMaterialId = material.id;\\r\\n\\r\\n\\t\\t\\trefreshMaterial = true;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( refreshProgram || _currentCamera !== camera ) {\\r\\n\\r\\n\\t\\t\\tp_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );\\r\\n\\r\\n\\t\\t\\tif ( capabilities.logarithmicDepthBuffer ) {\\r\\n\\r\\n\\t\\t\\t\\tp_uniforms.setValue( _gl, 'logDepthBufFC',\\r\\n\\t\\t\\t\\t\\t2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( _currentCamera !== camera ) {\\r\\n\\r\\n\\t\\t\\t\\t_currentCamera = camera;\\r\\n\\r\\n\\t\\t\\t\\t// lighting uniforms depend on the camera so enforce an update\\r\\n\\t\\t\\t\\t// now, in case this material supports lights - or later, when\\r\\n\\t\\t\\t\\t// the next material that does gets activated:\\r\\n\\r\\n\\t\\t\\t\\trefreshMaterial = true;\\t\\t// set to true on material change\\r\\n\\t\\t\\t\\trefreshLights = true;\\t\\t// remains set until update done\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// load material specific uniforms\\r\\n\\t\\t\\t// (shader material also gets them for the sake of genericity)\\r\\n\\r\\n\\t\\t\\tif ( material.isShaderMaterial ||\\r\\n\\t\\t\\t\\tmaterial.isMeshPhongMaterial ||\\r\\n\\t\\t\\t\\tmaterial.isMeshToonMaterial ||\\r\\n\\t\\t\\t\\tmaterial.isMeshStandardMaterial ||\\r\\n\\t\\t\\t\\tmaterial.envMap ) {\\r\\n\\r\\n\\t\\t\\t\\tvar uCamPos = p_uniforms.map.cameraPosition;\\r\\n\\r\\n\\t\\t\\t\\tif ( uCamPos !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tuCamPos.setValue( _gl,\\r\\n\\t\\t\\t\\t\\t\\t_vector3.setFromMatrixPosition( camera.matrixWorld ) );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( material.isMeshPhongMaterial ||\\r\\n\\t\\t\\t\\tmaterial.isMeshToonMaterial ||\\r\\n\\t\\t\\t\\tmaterial.isMeshLambertMaterial ||\\r\\n\\t\\t\\t\\tmaterial.isMeshBasicMaterial ||\\r\\n\\t\\t\\t\\tmaterial.isMeshStandardMaterial ||\\r\\n\\t\\t\\t\\tmaterial.isShaderMaterial ) {\\r\\n\\r\\n\\t\\t\\t\\tp_uniforms.setValue( _gl, 'isOrthographic', camera.isOrthographicCamera === true );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( material.isMeshPhongMaterial ||\\r\\n\\t\\t\\t\\tmaterial.isMeshToonMaterial ||\\r\\n\\t\\t\\t\\tmaterial.isMeshLambertMaterial ||\\r\\n\\t\\t\\t\\tmaterial.isMeshBasicMaterial ||\\r\\n\\t\\t\\t\\tmaterial.isMeshStandardMaterial ||\\r\\n\\t\\t\\t\\tmaterial.isShaderMaterial ||\\r\\n\\t\\t\\t\\tmaterial.skinning ) {\\r\\n\\r\\n\\t\\t\\t\\tp_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// skinning uniforms must be set even if material didn't change\\r\\n\\t\\t// auto-setting of texture unit for bone texture must go before other textures\\r\\n\\t\\t// otherwise textures used for skinning can take over texture units reserved for other material textures\\r\\n\\r\\n\\t\\tif ( material.skinning ) {\\r\\n\\r\\n\\t\\t\\tp_uniforms.setOptional( _gl, object, 'bindMatrix' );\\r\\n\\t\\t\\tp_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );\\r\\n\\r\\n\\t\\t\\tvar skeleton = object.skeleton;\\r\\n\\r\\n\\t\\t\\tif ( skeleton ) {\\r\\n\\r\\n\\t\\t\\t\\tvar bones = skeleton.bones;\\r\\n\\r\\n\\t\\t\\t\\tif ( capabilities.floatVertexTextures ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( skeleton.boneTexture === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// layout (1 matrix = 4 pixels)\\r\\n\\t\\t\\t\\t\\t\\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\\r\\n\\t\\t\\t\\t\\t\\t//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\\r\\n\\t\\t\\t\\t\\t\\t//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\\r\\n\\t\\t\\t\\t\\t\\t//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\\r\\n\\t\\t\\t\\t\\t\\t//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\\r\\n\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar size = Math.sqrt( bones.length * 4 ); // 4 pixels needed for 1 matrix\\r\\n\\t\\t\\t\\t\\t\\tsize = MathUtils.ceilPowerOfTwo( size );\\r\\n\\t\\t\\t\\t\\t\\tsize = Math.max( size, 4 );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel\\r\\n\\t\\t\\t\\t\\t\\tboneMatrices.set( skeleton.boneMatrices ); // copy current values\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tskeleton.boneMatrices = boneMatrices;\\r\\n\\t\\t\\t\\t\\t\\tskeleton.boneTexture = boneTexture;\\r\\n\\t\\t\\t\\t\\t\\tskeleton.boneTextureSize = size;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tp_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture, textures );\\r\\n\\t\\t\\t\\t\\tp_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tp_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow ) {\\r\\n\\r\\n\\t\\t\\tmaterialProperties.receiveShadow = object.receiveShadow;\\r\\n\\t\\t\\tp_uniforms.setValue( _gl, 'receiveShadow', object.receiveShadow );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( refreshMaterial ) {\\r\\n\\r\\n\\t\\t\\tp_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );\\r\\n\\t\\t\\tp_uniforms.setValue( _gl, 'toneMappingWhitePoint', _this.toneMappingWhitePoint );\\r\\n\\r\\n\\t\\t\\tif ( materialProperties.needsLights ) {\\r\\n\\r\\n\\t\\t\\t\\t// the current material requires lighting info\\r\\n\\r\\n\\t\\t\\t\\t// note: all lighting uniforms are always set correctly\\r\\n\\t\\t\\t\\t// they simply reference the renderer's state for their\\r\\n\\t\\t\\t\\t// values\\r\\n\\t\\t\\t\\t//\\r\\n\\t\\t\\t\\t// use the current material's .needsUpdate flags to set\\r\\n\\t\\t\\t\\t// the GL state when required\\r\\n\\r\\n\\t\\t\\t\\tmarkUniformsLightsNeedsUpdate( m_uniforms, refreshLights );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// refresh uniforms common to several materials\\r\\n\\r\\n\\t\\t\\tif ( fog && material.fog ) {\\r\\n\\r\\n\\t\\t\\t\\tmaterials.refreshFogUniforms( m_uniforms, fog );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tmaterials.refreshMaterialUniforms( m_uniforms, material, environment, _pixelRatio, _height );\\r\\n\\r\\n\\t\\t\\t// RectAreaLight Texture\\r\\n\\t\\t\\t// TODO (mrdoob): Find a nicer implementation\\r\\n\\r\\n\\t\\t\\tif ( m_uniforms.ltc_1 !== undefined ) m_uniforms.ltc_1.value = UniformsLib.LTC_1;\\r\\n\\t\\t\\tif ( m_uniforms.ltc_2 !== undefined ) m_uniforms.ltc_2.value = UniformsLib.LTC_2;\\r\\n\\r\\n\\t\\t\\tWebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {\\r\\n\\r\\n\\t\\t\\tWebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );\\r\\n\\t\\t\\tmaterial.uniformsNeedUpdate = false;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( material.isSpriteMaterial ) {\\r\\n\\r\\n\\t\\t\\tp_uniforms.setValue( _gl, 'center', object.center );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// common matrices\\r\\n\\r\\n\\t\\tp_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );\\r\\n\\t\\tp_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );\\r\\n\\t\\tp_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );\\r\\n\\r\\n\\t\\treturn program;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// If uniforms are marked as clean, they don't need to be loaded to the GPU.\\r\\n\\r\\n\\tfunction markUniformsLightsNeedsUpdate( uniforms, value ) {\\r\\n\\r\\n\\t\\tuniforms.ambientLightColor.needsUpdate = value;\\r\\n\\t\\tuniforms.lightProbe.needsUpdate = value;\\r\\n\\r\\n\\t\\tuniforms.directionalLights.needsUpdate = value;\\r\\n\\t\\tuniforms.directionalLightShadows.needsUpdate = value;\\r\\n\\t\\tuniforms.pointLights.needsUpdate = value;\\r\\n\\t\\tuniforms.pointLightShadows.needsUpdate = value;\\r\\n\\t\\tuniforms.spotLights.needsUpdate = value;\\r\\n\\t\\tuniforms.spotLightShadows.needsUpdate = value;\\r\\n\\t\\tuniforms.rectAreaLights.needsUpdate = value;\\r\\n\\t\\tuniforms.hemisphereLights.needsUpdate = value;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction materialNeedsLights( material ) {\\r\\n\\r\\n\\t\\treturn material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial ||\\r\\n\\t\\t\\tmaterial.isMeshStandardMaterial || material.isShadowMaterial ||\\r\\n\\t\\t\\t( material.isShaderMaterial && material.lights === true );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t//\\r\\n\\tthis.setFramebuffer = function ( value ) {\\r\\n\\r\\n\\t\\tif ( _framebuffer !== value && _currentRenderTarget === null ) _gl.bindFramebuffer( 36160, value );\\r\\n\\r\\n\\t\\t_framebuffer = value;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.getActiveCubeFace = function () {\\r\\n\\r\\n\\t\\treturn _currentActiveCubeFace;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.getActiveMipmapLevel = function () {\\r\\n\\r\\n\\t\\treturn _currentActiveMipmapLevel;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.getRenderTarget = function () {\\r\\n\\r\\n\\t\\treturn _currentRenderTarget;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.setRenderTarget = function ( renderTarget, activeCubeFace, activeMipmapLevel ) {\\r\\n\\r\\n\\t\\t_currentRenderTarget = renderTarget;\\r\\n\\t\\t_currentActiveCubeFace = activeCubeFace;\\r\\n\\t\\t_currentActiveMipmapLevel = activeMipmapLevel;\\r\\n\\r\\n\\t\\tif ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {\\r\\n\\r\\n\\t\\t\\ttextures.setupRenderTarget( renderTarget );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar framebuffer = _framebuffer;\\r\\n\\t\\tvar isCube = false;\\r\\n\\r\\n\\t\\tif ( renderTarget ) {\\r\\n\\r\\n\\t\\t\\tvar __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;\\r\\n\\r\\n\\t\\t\\tif ( renderTarget.isWebGLCubeRenderTarget ) {\\r\\n\\r\\n\\t\\t\\t\\tframebuffer = __webglFramebuffer[ activeCubeFace || 0 ];\\r\\n\\t\\t\\t\\tisCube = true;\\r\\n\\r\\n\\t\\t\\t} else if ( renderTarget.isWebGLMultisampleRenderTarget ) {\\r\\n\\r\\n\\t\\t\\t\\tframebuffer = properties.get( renderTarget ).__webglMultisampledFramebuffer;\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tframebuffer = __webglFramebuffer;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t_currentViewport.copy( renderTarget.viewport );\\r\\n\\t\\t\\t_currentScissor.copy( renderTarget.scissor );\\r\\n\\t\\t\\t_currentScissorTest = renderTarget.scissorTest;\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor();\\r\\n\\t\\t\\t_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor();\\r\\n\\t\\t\\t_currentScissorTest = _scissorTest;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( _currentFramebuffer !== framebuffer ) {\\r\\n\\r\\n\\t\\t\\t_gl.bindFramebuffer( 36160, framebuffer );\\r\\n\\t\\t\\t_currentFramebuffer = framebuffer;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tstate.viewport( _currentViewport );\\r\\n\\t\\tstate.scissor( _currentScissor );\\r\\n\\t\\tstate.setScissorTest( _currentScissorTest );\\r\\n\\r\\n\\t\\tif ( isCube ) {\\r\\n\\r\\n\\t\\t\\tvar textureProperties = properties.get( renderTarget.texture );\\r\\n\\t\\t\\t_gl.framebufferTexture2D( 36160, 36064, 34069 + ( activeCubeFace || 0 ), textureProperties.__webglTexture, activeMipmapLevel || 0 );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer, activeCubeFaceIndex ) {\\r\\n\\r\\n\\t\\tif ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {\\r\\n\\r\\n\\t\\t\\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );\\r\\n\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar framebuffer = properties.get( renderTarget ).__webglFramebuffer;\\r\\n\\r\\n\\t\\tif ( renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined ) {\\r\\n\\r\\n\\t\\t\\tframebuffer = framebuffer[ activeCubeFaceIndex ];\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( framebuffer ) {\\r\\n\\r\\n\\t\\t\\tvar restore = false;\\r\\n\\r\\n\\t\\t\\tif ( framebuffer !== _currentFramebuffer ) {\\r\\n\\r\\n\\t\\t\\t\\t_gl.bindFramebuffer( 36160, framebuffer );\\r\\n\\r\\n\\t\\t\\t\\trestore = true;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\ttry {\\r\\n\\r\\n\\t\\t\\t\\tvar texture = renderTarget.texture;\\r\\n\\t\\t\\t\\tvar textureFormat = texture.format;\\r\\n\\t\\t\\t\\tvar textureType = texture.type;\\r\\n\\r\\n\\t\\t\\t\\tif ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( 35739 ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );\\r\\n\\t\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( 35738 ) && // IE11, Edge and Chrome Mac < 52 (#9513)\\r\\n\\t\\t\\t\\t\\t! ( textureType === FloatType && ( capabilities.isWebGL2 || extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox\\r\\n\\t\\t\\t\\t\\t! ( textureType === HalfFloatType && ( capabilities.isWebGL2 ? extensions.get( 'EXT_color_buffer_float' ) : extensions.get( 'EXT_color_buffer_half_float' ) ) ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );\\r\\n\\t\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( _gl.checkFramebufferStatus( 36160 ) === 36053 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} finally {\\r\\n\\r\\n\\t\\t\\t\\tif ( restore ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t_gl.bindFramebuffer( 36160, _currentFramebuffer );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.copyFramebufferToTexture = function ( position, texture, level ) {\\r\\n\\r\\n\\t\\tif ( level === undefined ) level = 0;\\r\\n\\r\\n\\t\\tvar levelScale = Math.pow( 2, - level );\\r\\n\\t\\tvar width = Math.floor( texture.image.width * levelScale );\\r\\n\\t\\tvar height = Math.floor( texture.image.height * levelScale );\\r\\n\\t\\tvar glFormat = utils.convert( texture.format );\\r\\n\\r\\n\\t\\ttextures.setTexture2D( texture, 0 );\\r\\n\\r\\n\\t\\t_gl.copyTexImage2D( 3553, level, glFormat, position.x, position.y, width, height, 0 );\\r\\n\\r\\n\\t\\tstate.unbindTexture();\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.copyTextureToTexture = function ( position, srcTexture, dstTexture, level ) {\\r\\n\\r\\n\\t\\tif ( level === undefined ) level = 0;\\r\\n\\r\\n\\t\\tvar width = srcTexture.image.width;\\r\\n\\t\\tvar height = srcTexture.image.height;\\r\\n\\t\\tvar glFormat = utils.convert( dstTexture.format );\\r\\n\\t\\tvar glType = utils.convert( dstTexture.type );\\r\\n\\r\\n\\t\\ttextures.setTexture2D( dstTexture, 0 );\\r\\n\\r\\n\\t\\tif ( srcTexture.isDataTexture ) {\\r\\n\\r\\n\\t\\t\\t_gl.texSubImage2D( 3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tif ( srcTexture.isCompressedTexture ) {\\r\\n\\r\\n\\t\\t\\t\\t_gl.compressedTexSubImage2D( 3553, level, position.x, position.y, srcTexture.mipmaps[ 0 ].width, srcTexture.mipmaps[ 0 ].height, glFormat, srcTexture.mipmaps[ 0 ].data );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t_gl.texSubImage2D( 3553, level, position.x, position.y, glFormat, glType, srcTexture.image );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Generate mipmaps only when copying level 0\\r\\n\\t\\tif ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( 3553 );\\r\\n\\r\\n\\t\\tstate.unbindTexture();\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.initTexture = function ( texture ) {\\r\\n\\r\\n\\t\\ttextures.setTexture2D( texture, 0 );\\r\\n\\r\\n\\t\\tstate.unbindTexture();\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tif ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {\\r\\n\\r\\n\\t\\t__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) ); // eslint-disable-line no-undef\\r\\n\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n */\\r\\n\\r\\nfunction FogExp2( color, density ) {\\r\\n\\r\\n\\tthis.name = '';\\r\\n\\r\\n\\tthis.color = new Color( color );\\r\\n\\tthis.density = ( density !== undefined ) ? density : 0.00025;\\r\\n\\r\\n}\\r\\n\\r\\nObject.assign( FogExp2.prototype, {\\r\\n\\r\\n\\tisFogExp2: true,\\r\\n\\r\\n\\tclone: function () {\\r\\n\\r\\n\\t\\treturn new FogExp2( this.color, this.density );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttoJSON: function ( /* meta */ ) {\\r\\n\\r\\n\\t\\treturn {\\r\\n\\t\\t\\ttype: 'FogExp2',\\r\\n\\t\\t\\tcolor: this.color.getHex(),\\r\\n\\t\\t\\tdensity: this.density\\r\\n\\t\\t};\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n */\\r\\n\\r\\nfunction Fog( color, near, far ) {\\r\\n\\r\\n\\tthis.name = '';\\r\\n\\r\\n\\tthis.color = new Color( color );\\r\\n\\r\\n\\tthis.near = ( near !== undefined ) ? near : 1;\\r\\n\\tthis.far = ( far !== undefined ) ? far : 1000;\\r\\n\\r\\n}\\r\\n\\r\\nObject.assign( Fog.prototype, {\\r\\n\\r\\n\\tisFog: true,\\r\\n\\r\\n\\tclone: function () {\\r\\n\\r\\n\\t\\treturn new Fog( this.color, this.near, this.far );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttoJSON: function ( /* meta */ ) {\\r\\n\\r\\n\\t\\treturn {\\r\\n\\t\\t\\ttype: 'Fog',\\r\\n\\t\\t\\tcolor: this.color.getHex(),\\r\\n\\t\\t\\tnear: this.near,\\r\\n\\t\\t\\tfar: this.far\\r\\n\\t\\t};\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author benaadams / https://twitter.com/ben_a_adams\\r\\n */\\r\\n\\r\\nfunction InterleavedBuffer( array, stride ) {\\r\\n\\r\\n\\tthis.array = array;\\r\\n\\tthis.stride = stride;\\r\\n\\tthis.count = array !== undefined ? array.length / stride : 0;\\r\\n\\r\\n\\tthis.usage = StaticDrawUsage;\\r\\n\\tthis.updateRange = { offset: 0, count: - 1 };\\r\\n\\r\\n\\tthis.version = 0;\\r\\n\\r\\n}\\r\\n\\r\\nObject.defineProperty( InterleavedBuffer.prototype, 'needsUpdate', {\\r\\n\\r\\n\\tset: function ( value ) {\\r\\n\\r\\n\\t\\tif ( value === true ) this.version ++;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nObject.assign( InterleavedBuffer.prototype, {\\r\\n\\r\\n\\tisInterleavedBuffer: true,\\r\\n\\r\\n\\tonUploadCallback: function () {},\\r\\n\\r\\n\\tsetUsage: function ( value ) {\\r\\n\\r\\n\\t\\tthis.usage = value;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\tthis.array = new source.array.constructor( source.array );\\r\\n\\t\\tthis.count = source.count;\\r\\n\\t\\tthis.stride = source.stride;\\r\\n\\t\\tthis.usage = source.usage;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcopyAt: function ( index1, attribute, index2 ) {\\r\\n\\r\\n\\t\\tindex1 *= this.stride;\\r\\n\\t\\tindex2 *= attribute.stride;\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = this.stride; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tset: function ( value, offset ) {\\r\\n\\r\\n\\t\\tif ( offset === undefined ) offset = 0;\\r\\n\\r\\n\\t\\tthis.array.set( value, offset );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclone: function () {\\r\\n\\r\\n\\t\\treturn new this.constructor().copy( this );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tonUpload: function ( callback ) {\\r\\n\\r\\n\\t\\tthis.onUploadCallback = callback;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author benaadams / https://twitter.com/ben_a_adams\\r\\n */\\r\\n\\r\\nvar _vector$6 = new Vector3();\\r\\n\\r\\nfunction InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {\\r\\n\\r\\n\\tthis.name = '';\\r\\n\\r\\n\\tthis.data = interleavedBuffer;\\r\\n\\tthis.itemSize = itemSize;\\r\\n\\tthis.offset = offset;\\r\\n\\r\\n\\tthis.normalized = normalized === true;\\r\\n\\r\\n}\\r\\n\\r\\nObject.defineProperties( InterleavedBufferAttribute.prototype, {\\r\\n\\r\\n\\tcount: {\\r\\n\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\treturn this.data.count;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tarray: {\\r\\n\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\treturn this.data.array;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nObject.assign( InterleavedBufferAttribute.prototype, {\\r\\n\\r\\n\\tisInterleavedBufferAttribute: true,\\r\\n\\r\\n\\tapplyMatrix4: function ( m ) {\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = this.data.count; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t_vector$6.x = this.getX( i );\\r\\n\\t\\t\\t_vector$6.y = this.getY( i );\\r\\n\\t\\t\\t_vector$6.z = this.getZ( i );\\r\\n\\r\\n\\t\\t\\t_vector$6.applyMatrix4( m );\\r\\n\\r\\n\\t\\t\\tthis.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetX: function ( index, x ) {\\r\\n\\r\\n\\t\\tthis.data.array[ index * this.data.stride + this.offset ] = x;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetY: function ( index, y ) {\\r\\n\\r\\n\\t\\tthis.data.array[ index * this.data.stride + this.offset + 1 ] = y;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetZ: function ( index, z ) {\\r\\n\\r\\n\\t\\tthis.data.array[ index * this.data.stride + this.offset + 2 ] = z;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetW: function ( index, w ) {\\r\\n\\r\\n\\t\\tthis.data.array[ index * this.data.stride + this.offset + 3 ] = w;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetX: function ( index ) {\\r\\n\\r\\n\\t\\treturn this.data.array[ index * this.data.stride + this.offset ];\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetY: function ( index ) {\\r\\n\\r\\n\\t\\treturn this.data.array[ index * this.data.stride + this.offset + 1 ];\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetZ: function ( index ) {\\r\\n\\r\\n\\t\\treturn this.data.array[ index * this.data.stride + this.offset + 2 ];\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetW: function ( index ) {\\r\\n\\r\\n\\t\\treturn this.data.array[ index * this.data.stride + this.offset + 3 ];\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetXY: function ( index, x, y ) {\\r\\n\\r\\n\\t\\tindex = index * this.data.stride + this.offset;\\r\\n\\r\\n\\t\\tthis.data.array[ index + 0 ] = x;\\r\\n\\t\\tthis.data.array[ index + 1 ] = y;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetXYZ: function ( index, x, y, z ) {\\r\\n\\r\\n\\t\\tindex = index * this.data.stride + this.offset;\\r\\n\\r\\n\\t\\tthis.data.array[ index + 0 ] = x;\\r\\n\\t\\tthis.data.array[ index + 1 ] = y;\\r\\n\\t\\tthis.data.array[ index + 2 ] = z;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetXYZW: function ( index, x, y, z, w ) {\\r\\n\\r\\n\\t\\tindex = index * this.data.stride + this.offset;\\r\\n\\r\\n\\t\\tthis.data.array[ index + 0 ] = x;\\r\\n\\t\\tthis.data.array[ index + 1 ] = y;\\r\\n\\t\\tthis.data.array[ index + 2 ] = z;\\r\\n\\t\\tthis.data.array[ index + 3 ] = w;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclone: function () {\\r\\n\\r\\n\\t\\tconsole.log( 'THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.' );\\r\\n\\r\\n\\t\\tvar array = [];\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < this.count; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar index = i * this.data.stride + this.offset;\\r\\n\\r\\n\\t\\t\\tfor ( var j = 0; j < this.itemSize; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tarray.push( this.data.array[ index + j ] );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn new BufferAttribute( new this.array.constructor( array ), this.itemSize, this.normalized );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttoJSON: function () {\\r\\n\\r\\n\\t\\tconsole.log( 'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.' );\\r\\n\\r\\n\\t\\tvar array = [];\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < this.count; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar index = i * this.data.stride + this.offset;\\r\\n\\r\\n\\t\\t\\tfor ( var j = 0; j < this.itemSize; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tarray.push( this.data.array[ index + j ] );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// deinterleave data and save it as an ordinary buffer attribute for now\\r\\n\\r\\n\\t\\treturn {\\r\\n\\t\\t\\titemSize: this.itemSize,\\r\\n\\t\\t\\ttype: this.array.constructor.name,\\r\\n\\t\\t\\tarray: array,\\r\\n\\t\\t\\tnormalized: this.normalized\\r\\n\\t\\t};\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n *\\r\\n * parameters = {\\r\\n *  color: <hex>,\\r\\n *  map: new THREE.Texture( <Image> ),\\r\\n *  alphaMap: new THREE.Texture( <Image> ),\\r\\n *  rotation: <float>,\\r\\n *  sizeAttenuation: <bool>\\r\\n * }\\r\\n */\\r\\n\\r\\nfunction SpriteMaterial( parameters ) {\\r\\n\\r\\n\\tMaterial.call( this );\\r\\n\\r\\n\\tthis.type = 'SpriteMaterial';\\r\\n\\r\\n\\tthis.color = new Color( 0xffffff );\\r\\n\\r\\n\\tthis.map = null;\\r\\n\\r\\n\\tthis.alphaMap = null;\\r\\n\\r\\n\\tthis.rotation = 0;\\r\\n\\r\\n\\tthis.sizeAttenuation = true;\\r\\n\\r\\n\\tthis.transparent = true;\\r\\n\\r\\n\\tthis.setValues( parameters );\\r\\n\\r\\n}\\r\\n\\r\\nSpriteMaterial.prototype = Object.create( Material.prototype );\\r\\nSpriteMaterial.prototype.constructor = SpriteMaterial;\\r\\nSpriteMaterial.prototype.isSpriteMaterial = true;\\r\\n\\r\\nSpriteMaterial.prototype.copy = function ( source ) {\\r\\n\\r\\n\\tMaterial.prototype.copy.call( this, source );\\r\\n\\r\\n\\tthis.color.copy( source.color );\\r\\n\\r\\n\\tthis.map = source.map;\\r\\n\\r\\n\\tthis.alphaMap = source.alphaMap;\\r\\n\\r\\n\\tthis.rotation = source.rotation;\\r\\n\\r\\n\\tthis.sizeAttenuation = source.sizeAttenuation;\\r\\n\\r\\n\\treturn this;\\r\\n\\r\\n};\\r\\n\\r\\n/**\\r\\n * @author mikael emtinger / http://gomo.se/\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n */\\r\\n\\r\\nvar _geometry;\\r\\n\\r\\nvar _intersectPoint = new Vector3();\\r\\nvar _worldScale = new Vector3();\\r\\nvar _mvPosition = new Vector3();\\r\\n\\r\\nvar _alignedPosition = new Vector2();\\r\\nvar _rotatedPosition = new Vector2();\\r\\nvar _viewWorldMatrix = new Matrix4();\\r\\n\\r\\nvar _vA$1 = new Vector3();\\r\\nvar _vB$1 = new Vector3();\\r\\nvar _vC$1 = new Vector3();\\r\\n\\r\\nvar _uvA$1 = new Vector2();\\r\\nvar _uvB$1 = new Vector2();\\r\\nvar _uvC$1 = new Vector2();\\r\\n\\r\\nfunction Sprite( material ) {\\r\\n\\r\\n\\tObject3D.call( this );\\r\\n\\r\\n\\tthis.type = 'Sprite';\\r\\n\\r\\n\\tif ( _geometry === undefined ) {\\r\\n\\r\\n\\t\\t_geometry = new BufferGeometry();\\r\\n\\r\\n\\t\\tvar float32Array = new Float32Array( [\\r\\n\\t\\t\\t- 0.5, - 0.5, 0, 0, 0,\\r\\n\\t\\t\\t0.5, - 0.5, 0, 1, 0,\\r\\n\\t\\t\\t0.5, 0.5, 0, 1, 1,\\r\\n\\t\\t\\t- 0.5, 0.5, 0, 0, 1\\r\\n\\t\\t] );\\r\\n\\r\\n\\t\\tvar interleavedBuffer = new InterleavedBuffer( float32Array, 5 );\\r\\n\\r\\n\\t\\t_geometry.setIndex( [ 0, 1, 2,\\t0, 2, 3 ] );\\r\\n\\t\\t_geometry.setAttribute( 'position', new InterleavedBufferAttribute( interleavedBuffer, 3, 0, false ) );\\r\\n\\t\\t_geometry.setAttribute( 'uv', new InterleavedBufferAttribute( interleavedBuffer, 2, 3, false ) );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tthis.geometry = _geometry;\\r\\n\\tthis.material = ( material !== undefined ) ? material : new SpriteMaterial();\\r\\n\\r\\n\\tthis.center = new Vector2( 0.5, 0.5 );\\r\\n\\r\\n}\\r\\n\\r\\nSprite.prototype = Object.assign( Object.create( Object3D.prototype ), {\\r\\n\\r\\n\\tconstructor: Sprite,\\r\\n\\r\\n\\tisSprite: true,\\r\\n\\r\\n\\traycast: function ( raycaster, intersects ) {\\r\\n\\r\\n\\t\\tif ( raycaster.camera === null ) {\\r\\n\\r\\n\\t\\t\\tconsole.error( 'THREE.Sprite: \\\"Raycaster.camera\\\" needs to be set in order to raycast against sprites.' );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t_worldScale.setFromMatrixScale( this.matrixWorld );\\r\\n\\r\\n\\t\\t_viewWorldMatrix.copy( raycaster.camera.matrixWorld );\\r\\n\\t\\tthis.modelViewMatrix.multiplyMatrices( raycaster.camera.matrixWorldInverse, this.matrixWorld );\\r\\n\\r\\n\\t\\t_mvPosition.setFromMatrixPosition( this.modelViewMatrix );\\r\\n\\r\\n\\t\\tif ( raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false ) {\\r\\n\\r\\n\\t\\t\\t_worldScale.multiplyScalar( - _mvPosition.z );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar rotation = this.material.rotation;\\r\\n\\t\\tvar sin, cos;\\r\\n\\t\\tif ( rotation !== 0 ) {\\r\\n\\r\\n\\t\\t\\tcos = Math.cos( rotation );\\r\\n\\t\\t\\tsin = Math.sin( rotation );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar center = this.center;\\r\\n\\r\\n\\t\\ttransformVertex( _vA$1.set( - 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );\\r\\n\\t\\ttransformVertex( _vB$1.set( 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );\\r\\n\\t\\ttransformVertex( _vC$1.set( 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );\\r\\n\\r\\n\\t\\t_uvA$1.set( 0, 0 );\\r\\n\\t\\t_uvB$1.set( 1, 0 );\\r\\n\\t\\t_uvC$1.set( 1, 1 );\\r\\n\\r\\n\\t\\t// check first triangle\\r\\n\\t\\tvar intersect = raycaster.ray.intersectTriangle( _vA$1, _vB$1, _vC$1, false, _intersectPoint );\\r\\n\\r\\n\\t\\tif ( intersect === null ) {\\r\\n\\r\\n\\t\\t\\t// check second triangle\\r\\n\\t\\t\\ttransformVertex( _vB$1.set( - 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );\\r\\n\\t\\t\\t_uvB$1.set( 0, 1 );\\r\\n\\r\\n\\t\\t\\tintersect = raycaster.ray.intersectTriangle( _vA$1, _vC$1, _vB$1, false, _intersectPoint );\\r\\n\\t\\t\\tif ( intersect === null ) {\\r\\n\\r\\n\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar distance = raycaster.ray.origin.distanceTo( _intersectPoint );\\r\\n\\r\\n\\t\\tif ( distance < raycaster.near || distance > raycaster.far ) return;\\r\\n\\r\\n\\t\\tintersects.push( {\\r\\n\\r\\n\\t\\t\\tdistance: distance,\\r\\n\\t\\t\\tpoint: _intersectPoint.clone(),\\r\\n\\t\\t\\tuv: Triangle.getUV( _intersectPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2() ),\\r\\n\\t\\t\\tface: null,\\r\\n\\t\\t\\tobject: this\\r\\n\\r\\n\\t\\t} );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclone: function () {\\r\\n\\r\\n\\t\\treturn new this.constructor( this.material ).copy( this );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\tObject3D.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\tif ( source.center !== undefined ) this.center.copy( source.center );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\r\\n} );\\r\\n\\r\\nfunction transformVertex( vertexPosition, mvPosition, center, scale, sin, cos ) {\\r\\n\\r\\n\\t// compute position in camera space\\r\\n\\t_alignedPosition.subVectors( vertexPosition, center ).addScalar( 0.5 ).multiply( scale );\\r\\n\\r\\n\\t// to check if rotation is not zero\\r\\n\\tif ( sin !== undefined ) {\\r\\n\\r\\n\\t\\t_rotatedPosition.x = ( cos * _alignedPosition.x ) - ( sin * _alignedPosition.y );\\r\\n\\t\\t_rotatedPosition.y = ( sin * _alignedPosition.x ) + ( cos * _alignedPosition.y );\\r\\n\\r\\n\\t} else {\\r\\n\\r\\n\\t\\t_rotatedPosition.copy( _alignedPosition );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\r\\n\\tvertexPosition.copy( mvPosition );\\r\\n\\tvertexPosition.x += _rotatedPosition.x;\\r\\n\\tvertexPosition.y += _rotatedPosition.y;\\r\\n\\r\\n\\t// transform to world space\\r\\n\\tvertexPosition.applyMatrix4( _viewWorldMatrix );\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * @author mikael emtinger / http://gomo.se/\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nvar _v1$4 = new Vector3();\\r\\nvar _v2$2 = new Vector3();\\r\\n\\r\\nfunction LOD() {\\r\\n\\r\\n\\tObject3D.call( this );\\r\\n\\r\\n\\tthis._currentLevel = 0;\\r\\n\\r\\n\\tthis.type = 'LOD';\\r\\n\\r\\n\\tObject.defineProperties( this, {\\r\\n\\t\\tlevels: {\\r\\n\\t\\t\\tenumerable: true,\\r\\n\\t\\t\\tvalue: []\\r\\n\\t\\t}\\r\\n\\t} );\\r\\n\\r\\n\\tthis.autoUpdate = true;\\r\\n\\r\\n}\\r\\n\\r\\nLOD.prototype = Object.assign( Object.create( Object3D.prototype ), {\\r\\n\\r\\n\\tconstructor: LOD,\\r\\n\\r\\n\\tisLOD: true,\\r\\n\\r\\n\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\tObject3D.prototype.copy.call( this, source, false );\\r\\n\\r\\n\\t\\tvar levels = source.levels;\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar level = levels[ i ];\\r\\n\\r\\n\\t\\t\\tthis.addLevel( level.object.clone(), level.distance );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.autoUpdate = source.autoUpdate;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\taddLevel: function ( object, distance ) {\\r\\n\\r\\n\\t\\tif ( distance === undefined ) distance = 0;\\r\\n\\r\\n\\t\\tdistance = Math.abs( distance );\\r\\n\\r\\n\\t\\tvar levels = this.levels;\\r\\n\\r\\n\\t\\tfor ( var l = 0; l < levels.length; l ++ ) {\\r\\n\\r\\n\\t\\t\\tif ( distance < levels[ l ].distance ) {\\r\\n\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tlevels.splice( l, 0, { distance: distance, object: object } );\\r\\n\\r\\n\\t\\tthis.add( object );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetCurrentLevel: function () {\\r\\n\\r\\n\\t\\treturn this._currentLevel;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetObjectForDistance: function ( distance ) {\\r\\n\\r\\n\\t\\tvar levels = this.levels;\\r\\n\\r\\n\\t\\tif ( levels.length > 0 ) {\\r\\n\\r\\n\\t\\t\\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( distance < levels[ i ].distance ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn levels[ i - 1 ].object;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn null;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\traycast: function ( raycaster, intersects ) {\\r\\n\\r\\n\\t\\tvar levels = this.levels;\\r\\n\\r\\n\\t\\tif ( levels.length > 0 ) {\\r\\n\\r\\n\\t\\t\\t_v1$4.setFromMatrixPosition( this.matrixWorld );\\r\\n\\r\\n\\t\\t\\tvar distance = raycaster.ray.origin.distanceTo( _v1$4 );\\r\\n\\r\\n\\t\\t\\tthis.getObjectForDistance( distance ).raycast( raycaster, intersects );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tupdate: function ( camera ) {\\r\\n\\r\\n\\t\\tvar levels = this.levels;\\r\\n\\r\\n\\t\\tif ( levels.length > 1 ) {\\r\\n\\r\\n\\t\\t\\t_v1$4.setFromMatrixPosition( camera.matrixWorld );\\r\\n\\t\\t\\t_v2$2.setFromMatrixPosition( this.matrixWorld );\\r\\n\\r\\n\\t\\t\\tvar distance = _v1$4.distanceTo( _v2$2 ) / camera.zoom;\\r\\n\\r\\n\\t\\t\\tlevels[ 0 ].object.visible = true;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( distance >= levels[ i ].distance ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tlevels[ i - 1 ].object.visible = false;\\r\\n\\t\\t\\t\\t\\tlevels[ i ].object.visible = true;\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis._currentLevel = i - 1;\\r\\n\\r\\n\\t\\t\\tfor ( ; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tlevels[ i ].object.visible = false;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttoJSON: function ( meta ) {\\r\\n\\r\\n\\t\\tvar data = Object3D.prototype.toJSON.call( this, meta );\\r\\n\\r\\n\\t\\tif ( this.autoUpdate === false ) data.object.autoUpdate = false;\\r\\n\\r\\n\\t\\tdata.object.levels = [];\\r\\n\\r\\n\\t\\tvar levels = this.levels;\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar level = levels[ i ];\\r\\n\\r\\n\\t\\t\\tdata.object.levels.push( {\\r\\n\\t\\t\\t\\tobject: level.object.uuid,\\r\\n\\t\\t\\t\\tdistance: level.distance\\r\\n\\t\\t\\t} );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn data;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author mikael emtinger / http://gomo.se/\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n * @author ikerr / http://verold.com\\r\\n */\\r\\n\\r\\nfunction SkinnedMesh( geometry, material ) {\\r\\n\\r\\n\\tif ( geometry && geometry.isGeometry ) {\\r\\n\\r\\n\\t\\tconsole.error( 'THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tMesh.call( this, geometry, material );\\r\\n\\r\\n\\tthis.type = 'SkinnedMesh';\\r\\n\\r\\n\\tthis.bindMode = 'attached';\\r\\n\\tthis.bindMatrix = new Matrix4();\\r\\n\\tthis.bindMatrixInverse = new Matrix4();\\r\\n\\r\\n}\\r\\n\\r\\nSkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {\\r\\n\\r\\n\\tconstructor: SkinnedMesh,\\r\\n\\r\\n\\tisSkinnedMesh: true,\\r\\n\\r\\n\\tbind: function ( skeleton, bindMatrix ) {\\r\\n\\r\\n\\t\\tthis.skeleton = skeleton;\\r\\n\\r\\n\\t\\tif ( bindMatrix === undefined ) {\\r\\n\\r\\n\\t\\t\\tthis.updateMatrixWorld( true );\\r\\n\\r\\n\\t\\t\\tthis.skeleton.calculateInverses();\\r\\n\\r\\n\\t\\t\\tbindMatrix = this.matrixWorld;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.bindMatrix.copy( bindMatrix );\\r\\n\\t\\tthis.bindMatrixInverse.getInverse( bindMatrix );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tpose: function () {\\r\\n\\r\\n\\t\\tthis.skeleton.pose();\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tnormalizeSkinWeights: function () {\\r\\n\\r\\n\\t\\tvar vector = new Vector4();\\r\\n\\r\\n\\t\\tvar skinWeight = this.geometry.attributes.skinWeight;\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = skinWeight.count; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvector.x = skinWeight.getX( i );\\r\\n\\t\\t\\tvector.y = skinWeight.getY( i );\\r\\n\\t\\t\\tvector.z = skinWeight.getZ( i );\\r\\n\\t\\t\\tvector.w = skinWeight.getW( i );\\r\\n\\r\\n\\t\\t\\tvar scale = 1.0 / vector.manhattanLength();\\r\\n\\r\\n\\t\\t\\tif ( scale !== Infinity ) {\\r\\n\\r\\n\\t\\t\\t\\tvector.multiplyScalar( scale );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tvector.set( 1, 0, 0, 0 ); // do something reasonable\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tskinWeight.setXYZW( i, vector.x, vector.y, vector.z, vector.w );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tupdateMatrixWorld: function ( force ) {\\r\\n\\r\\n\\t\\tMesh.prototype.updateMatrixWorld.call( this, force );\\r\\n\\r\\n\\t\\tif ( this.bindMode === 'attached' ) {\\r\\n\\r\\n\\t\\t\\tthis.bindMatrixInverse.getInverse( this.matrixWorld );\\r\\n\\r\\n\\t\\t} else if ( this.bindMode === 'detached' ) {\\r\\n\\r\\n\\t\\t\\tthis.bindMatrixInverse.getInverse( this.bindMatrix );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclone: function () {\\r\\n\\r\\n\\t\\treturn new this.constructor( this.geometry, this.material ).copy( this );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tboneTransform: ( function () {\\r\\n\\r\\n\\t\\tvar basePosition = new Vector3();\\r\\n\\r\\n\\t\\tvar skinIndex = new Vector4();\\r\\n\\t\\tvar skinWeight = new Vector4();\\r\\n\\r\\n\\t\\tvar vector = new Vector3();\\r\\n\\t\\tvar matrix = new Matrix4();\\r\\n\\r\\n\\t\\treturn function ( index, target ) {\\r\\n\\r\\n\\t\\t\\tvar skeleton = this.skeleton;\\r\\n\\t\\t\\tvar geometry = this.geometry;\\r\\n\\r\\n\\t\\t\\tskinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );\\r\\n\\t\\t\\tskinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );\\r\\n\\r\\n\\t\\t\\tbasePosition.fromBufferAttribute( geometry.attributes.position, index ).applyMatrix4( this.bindMatrix );\\r\\n\\r\\n\\t\\t\\ttarget.set( 0, 0, 0 );\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < 4; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar weight = skinWeight.getComponent( i );\\r\\n\\r\\n\\t\\t\\t\\tif ( weight !== 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar boneIndex = skinIndex.getComponent( i );\\r\\n\\r\\n\\t\\t\\t\\t\\tmatrix.multiplyMatrices( skeleton.bones[ boneIndex ].matrixWorld, skeleton.boneInverses[ boneIndex ] );\\r\\n\\r\\n\\t\\t\\t\\t\\ttarget.addScaledVector( vector.copy( basePosition ).applyMatrix4( matrix ), weight );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn target.applyMatrix4( this.bindMatrixInverse );\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t}() )\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author mikael emtinger / http://gomo.se/\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n * @author michael guerrero / http://realitymeltdown.com\\r\\n * @author ikerr / http://verold.com\\r\\n */\\r\\n\\r\\nvar _offsetMatrix = new Matrix4();\\r\\nvar _identityMatrix = new Matrix4();\\r\\n\\r\\nfunction Skeleton( bones, boneInverses ) {\\r\\n\\r\\n\\t// copy the bone array\\r\\n\\r\\n\\tbones = bones || [];\\r\\n\\r\\n\\tthis.bones = bones.slice( 0 );\\r\\n\\tthis.boneMatrices = new Float32Array( this.bones.length * 16 );\\r\\n\\r\\n\\tthis.frame = - 1;\\r\\n\\r\\n\\t// use the supplied bone inverses or calculate the inverses\\r\\n\\r\\n\\tif ( boneInverses === undefined ) {\\r\\n\\r\\n\\t\\tthis.calculateInverses();\\r\\n\\r\\n\\t} else {\\r\\n\\r\\n\\t\\tif ( this.bones.length === boneInverses.length ) {\\r\\n\\r\\n\\t\\t\\tthis.boneInverses = boneInverses.slice( 0 );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Skeleton boneInverses is the wrong length.' );\\r\\n\\r\\n\\t\\t\\tthis.boneInverses = [];\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, il = this.bones.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.boneInverses.push( new Matrix4() );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\\r\\nObject.assign( Skeleton.prototype, {\\r\\n\\r\\n\\tcalculateInverses: function () {\\r\\n\\r\\n\\t\\tthis.boneInverses = [];\\r\\n\\r\\n\\t\\tfor ( var i = 0, il = this.bones.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar inverse = new Matrix4();\\r\\n\\r\\n\\t\\t\\tif ( this.bones[ i ] ) {\\r\\n\\r\\n\\t\\t\\t\\tinverse.getInverse( this.bones[ i ].matrixWorld );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.boneInverses.push( inverse );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tpose: function () {\\r\\n\\r\\n\\t\\tvar bone, i, il;\\r\\n\\r\\n\\t\\t// recover the bind-time world matrices\\r\\n\\r\\n\\t\\tfor ( i = 0, il = this.bones.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\tbone = this.bones[ i ];\\r\\n\\r\\n\\t\\t\\tif ( bone ) {\\r\\n\\r\\n\\t\\t\\t\\tbone.matrixWorld.getInverse( this.boneInverses[ i ] );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// compute the local matrices, positions, rotations and scales\\r\\n\\r\\n\\t\\tfor ( i = 0, il = this.bones.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\tbone = this.bones[ i ];\\r\\n\\r\\n\\t\\t\\tif ( bone ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( bone.parent && bone.parent.isBone ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tbone.matrix.getInverse( bone.parent.matrixWorld );\\r\\n\\t\\t\\t\\t\\tbone.matrix.multiply( bone.matrixWorld );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tbone.matrix.copy( bone.matrixWorld );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tupdate: function () {\\r\\n\\r\\n\\t\\tvar bones = this.bones;\\r\\n\\t\\tvar boneInverses = this.boneInverses;\\r\\n\\t\\tvar boneMatrices = this.boneMatrices;\\r\\n\\t\\tvar boneTexture = this.boneTexture;\\r\\n\\r\\n\\t\\t// flatten bone matrices to array\\r\\n\\r\\n\\t\\tfor ( var i = 0, il = bones.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t// compute the offset between the current and the original transform\\r\\n\\r\\n\\t\\t\\tvar matrix = bones[ i ] ? bones[ i ].matrixWorld : _identityMatrix;\\r\\n\\r\\n\\t\\t\\t_offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );\\r\\n\\t\\t\\t_offsetMatrix.toArray( boneMatrices, i * 16 );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( boneTexture !== undefined ) {\\r\\n\\r\\n\\t\\t\\tboneTexture.needsUpdate = true;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclone: function () {\\r\\n\\r\\n\\t\\treturn new Skeleton( this.bones, this.boneInverses );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetBoneByName: function ( name ) {\\r\\n\\r\\n\\t\\tfor ( var i = 0, il = this.bones.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar bone = this.bones[ i ];\\r\\n\\r\\n\\t\\t\\tif ( bone.name === name ) {\\r\\n\\r\\n\\t\\t\\t\\treturn bone;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn undefined;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tdispose: function ( ) {\\r\\n\\r\\n\\t\\tif ( this.boneTexture ) {\\r\\n\\r\\n\\t\\t\\tthis.boneTexture.dispose();\\r\\n\\r\\n\\t\\t\\tthis.boneTexture = undefined;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author mikael emtinger / http://gomo.se/\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n * @author ikerr / http://verold.com\\r\\n */\\r\\n\\r\\nfunction Bone() {\\r\\n\\r\\n\\tObject3D.call( this );\\r\\n\\r\\n\\tthis.type = 'Bone';\\r\\n\\r\\n}\\r\\n\\r\\nBone.prototype = Object.assign( Object.create( Object3D.prototype ), {\\r\\n\\r\\n\\tconstructor: Bone,\\r\\n\\r\\n\\tisBone: true\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nvar _instanceLocalMatrix = new Matrix4();\\r\\nvar _instanceWorldMatrix = new Matrix4();\\r\\n\\r\\nvar _instanceIntersects = [];\\r\\n\\r\\nvar _mesh = new Mesh();\\r\\n\\r\\nfunction InstancedMesh( geometry, material, count ) {\\r\\n\\r\\n\\tMesh.call( this, geometry, material );\\r\\n\\r\\n\\tthis.instanceMatrix = new BufferAttribute( new Float32Array( count * 16 ), 16 );\\r\\n\\r\\n\\tthis.count = count;\\r\\n\\r\\n\\tthis.frustumCulled = false;\\r\\n\\r\\n}\\r\\n\\r\\nInstancedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {\\r\\n\\r\\n\\tconstructor: InstancedMesh,\\r\\n\\r\\n\\tisInstancedMesh: true,\\r\\n\\r\\n\\tgetMatrixAt: function ( index, matrix ) {\\r\\n\\r\\n\\t\\tmatrix.fromArray( this.instanceMatrix.array, index * 16 );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\traycast: function ( raycaster, intersects ) {\\r\\n\\r\\n\\t\\tvar matrixWorld = this.matrixWorld;\\r\\n\\t\\tvar raycastTimes = this.count;\\r\\n\\r\\n\\t\\t_mesh.geometry = this.geometry;\\r\\n\\t\\t_mesh.material = this.material;\\r\\n\\r\\n\\t\\tif ( _mesh.material === undefined ) return;\\r\\n\\r\\n\\t\\tfor ( var instanceId = 0; instanceId < raycastTimes; instanceId ++ ) {\\r\\n\\r\\n\\t\\t\\t// calculate the world matrix for each instance\\r\\n\\r\\n\\t\\t\\tthis.getMatrixAt( instanceId, _instanceLocalMatrix );\\r\\n\\r\\n\\t\\t\\t_instanceWorldMatrix.multiplyMatrices( matrixWorld, _instanceLocalMatrix );\\r\\n\\r\\n\\t\\t\\t// the mesh represents this single instance\\r\\n\\r\\n\\t\\t\\t_mesh.matrixWorld = _instanceWorldMatrix;\\r\\n\\r\\n\\t\\t\\t_mesh.raycast( raycaster, _instanceIntersects );\\r\\n\\r\\n\\t\\t\\t// process the result of raycast\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = _instanceIntersects.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar intersect = _instanceIntersects[ i ];\\r\\n\\t\\t\\t\\tintersect.instanceId = instanceId;\\r\\n\\t\\t\\t\\tintersect.object = this;\\r\\n\\t\\t\\t\\tintersects.push( intersect );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t_instanceIntersects.length = 0;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetMatrixAt: function ( index, matrix ) {\\r\\n\\r\\n\\t\\tmatrix.toArray( this.instanceMatrix.array, index * 16 );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tupdateMorphTargets: function () {\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n *\\r\\n * parameters = {\\r\\n *  color: <hex>,\\r\\n *  opacity: <float>,\\r\\n *\\r\\n *  linewidth: <float>,\\r\\n *  linecap: \\\"round\\\",\\r\\n *  linejoin: \\\"round\\\"\\r\\n * }\\r\\n */\\r\\n\\r\\nfunction LineBasicMaterial( parameters ) {\\r\\n\\r\\n\\tMaterial.call( this );\\r\\n\\r\\n\\tthis.type = 'LineBasicMaterial';\\r\\n\\r\\n\\tthis.color = new Color( 0xffffff );\\r\\n\\r\\n\\tthis.linewidth = 1;\\r\\n\\tthis.linecap = 'round';\\r\\n\\tthis.linejoin = 'round';\\r\\n\\r\\n\\tthis.morphTargets = false;\\r\\n\\r\\n\\tthis.setValues( parameters );\\r\\n\\r\\n}\\r\\n\\r\\nLineBasicMaterial.prototype = Object.create( Material.prototype );\\r\\nLineBasicMaterial.prototype.constructor = LineBasicMaterial;\\r\\n\\r\\nLineBasicMaterial.prototype.isLineBasicMaterial = true;\\r\\n\\r\\nLineBasicMaterial.prototype.copy = function ( source ) {\\r\\n\\r\\n\\tMaterial.prototype.copy.call( this, source );\\r\\n\\r\\n\\tthis.color.copy( source.color );\\r\\n\\r\\n\\tthis.linewidth = source.linewidth;\\r\\n\\tthis.linecap = source.linecap;\\r\\n\\tthis.linejoin = source.linejoin;\\r\\n\\r\\n\\tthis.morphTargets = source.morphTargets;\\r\\n\\r\\n\\treturn this;\\r\\n\\r\\n};\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nvar _start = new Vector3();\\r\\nvar _end = new Vector3();\\r\\nvar _inverseMatrix$1 = new Matrix4();\\r\\nvar _ray$1 = new Ray();\\r\\nvar _sphere$2 = new Sphere();\\r\\n\\r\\nfunction Line( geometry, material, mode ) {\\r\\n\\r\\n\\tif ( mode === 1 ) {\\r\\n\\r\\n\\t\\tconsole.error( 'THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.' );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tObject3D.call( this );\\r\\n\\r\\n\\tthis.type = 'Line';\\r\\n\\r\\n\\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\\r\\n\\tthis.material = material !== undefined ? material : new LineBasicMaterial();\\r\\n\\r\\n\\tthis.updateMorphTargets();\\r\\n\\r\\n}\\r\\n\\r\\nLine.prototype = Object.assign( Object.create( Object3D.prototype ), {\\r\\n\\r\\n\\tconstructor: Line,\\r\\n\\r\\n\\tisLine: true,\\r\\n\\r\\n\\tcomputeLineDistances: function () {\\r\\n\\r\\n\\t\\tvar geometry = this.geometry;\\r\\n\\r\\n\\t\\tif ( geometry.isBufferGeometry ) {\\r\\n\\r\\n\\t\\t\\t// we assume non-indexed geometry\\r\\n\\r\\n\\t\\t\\tif ( geometry.index === null ) {\\r\\n\\r\\n\\t\\t\\t\\tvar positionAttribute = geometry.attributes.position;\\r\\n\\t\\t\\t\\tvar lineDistances = [ 0 ];\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 1, l = positionAttribute.count; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t_start.fromBufferAttribute( positionAttribute, i - 1 );\\r\\n\\t\\t\\t\\t\\t_end.fromBufferAttribute( positionAttribute, i );\\r\\n\\r\\n\\t\\t\\t\\t\\tlineDistances[ i ] = lineDistances[ i - 1 ];\\r\\n\\t\\t\\t\\t\\tlineDistances[ i ] += _start.distanceTo( _end );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tgeometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t} else if ( geometry.isGeometry ) {\\r\\n\\r\\n\\t\\t\\tvar vertices = geometry.vertices;\\r\\n\\t\\t\\tvar lineDistances = geometry.lineDistances;\\r\\n\\r\\n\\t\\t\\tlineDistances[ 0 ] = 0;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 1, l = vertices.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tlineDistances[ i ] = lineDistances[ i - 1 ];\\r\\n\\t\\t\\t\\tlineDistances[ i ] += vertices[ i - 1 ].distanceTo( vertices[ i ] );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\traycast: function ( raycaster, intersects ) {\\r\\n\\r\\n\\t\\tvar geometry = this.geometry;\\r\\n\\t\\tvar matrixWorld = this.matrixWorld;\\r\\n\\t\\tvar threshold = raycaster.params.Line.threshold;\\r\\n\\r\\n\\t\\t// Checking boundingSphere distance to ray\\r\\n\\r\\n\\t\\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\\r\\n\\r\\n\\t\\t_sphere$2.copy( geometry.boundingSphere );\\r\\n\\t\\t_sphere$2.applyMatrix4( matrixWorld );\\r\\n\\t\\t_sphere$2.radius += threshold;\\r\\n\\r\\n\\t\\tif ( raycaster.ray.intersectsSphere( _sphere$2 ) === false ) return;\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\t_inverseMatrix$1.getInverse( matrixWorld );\\r\\n\\t\\t_ray$1.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$1 );\\r\\n\\r\\n\\t\\tvar localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\\r\\n\\t\\tvar localThresholdSq = localThreshold * localThreshold;\\r\\n\\r\\n\\t\\tvar vStart = new Vector3();\\r\\n\\t\\tvar vEnd = new Vector3();\\r\\n\\t\\tvar interSegment = new Vector3();\\r\\n\\t\\tvar interRay = new Vector3();\\r\\n\\t\\tvar step = ( this && this.isLineSegments ) ? 2 : 1;\\r\\n\\r\\n\\t\\tif ( geometry.isBufferGeometry ) {\\r\\n\\r\\n\\t\\t\\tvar index = geometry.index;\\r\\n\\t\\t\\tvar attributes = geometry.attributes;\\r\\n\\t\\t\\tvar positions = attributes.position.array;\\r\\n\\r\\n\\t\\t\\tif ( index !== null ) {\\r\\n\\r\\n\\t\\t\\t\\tvar indices = index.array;\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, l = indices.length - 1; i < l; i += step ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar a = indices[ i ];\\r\\n\\t\\t\\t\\t\\tvar b = indices[ i + 1 ];\\r\\n\\r\\n\\t\\t\\t\\t\\tvStart.fromArray( positions, a * 3 );\\r\\n\\t\\t\\t\\t\\tvEnd.fromArray( positions, b * 3 );\\r\\n\\r\\n\\t\\t\\t\\t\\tvar distSq = _ray$1.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( distSq > localThresholdSq ) continue;\\r\\n\\r\\n\\t\\t\\t\\t\\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\\r\\n\\r\\n\\t\\t\\t\\t\\tvar distance = raycaster.ray.origin.distanceTo( interRay );\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\\r\\n\\r\\n\\t\\t\\t\\t\\tintersects.push( {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tdistance: distance,\\r\\n\\t\\t\\t\\t\\t\\t// What do we want? intersection point on the ray or on the segment??\\r\\n\\t\\t\\t\\t\\t\\t// point: raycaster.ray.at( distance ),\\r\\n\\t\\t\\t\\t\\t\\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\\r\\n\\t\\t\\t\\t\\t\\tindex: i,\\r\\n\\t\\t\\t\\t\\t\\tface: null,\\r\\n\\t\\t\\t\\t\\t\\tfaceIndex: null,\\r\\n\\t\\t\\t\\t\\t\\tobject: this\\r\\n\\r\\n\\t\\t\\t\\t\\t} );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvStart.fromArray( positions, 3 * i );\\r\\n\\t\\t\\t\\t\\tvEnd.fromArray( positions, 3 * i + 3 );\\r\\n\\r\\n\\t\\t\\t\\t\\tvar distSq = _ray$1.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( distSq > localThresholdSq ) continue;\\r\\n\\r\\n\\t\\t\\t\\t\\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\\r\\n\\r\\n\\t\\t\\t\\t\\tvar distance = raycaster.ray.origin.distanceTo( interRay );\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\\r\\n\\r\\n\\t\\t\\t\\t\\tintersects.push( {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tdistance: distance,\\r\\n\\t\\t\\t\\t\\t\\t// What do we want? intersection point on the ray or on the segment??\\r\\n\\t\\t\\t\\t\\t\\t// point: raycaster.ray.at( distance ),\\r\\n\\t\\t\\t\\t\\t\\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\\r\\n\\t\\t\\t\\t\\t\\tindex: i,\\r\\n\\t\\t\\t\\t\\t\\tface: null,\\r\\n\\t\\t\\t\\t\\t\\tfaceIndex: null,\\r\\n\\t\\t\\t\\t\\t\\tobject: this\\r\\n\\r\\n\\t\\t\\t\\t\\t} );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t} else if ( geometry.isGeometry ) {\\r\\n\\r\\n\\t\\t\\tvar vertices = geometry.vertices;\\r\\n\\t\\t\\tvar nbVertices = vertices.length;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < nbVertices - 1; i += step ) {\\r\\n\\r\\n\\t\\t\\t\\tvar distSq = _ray$1.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );\\r\\n\\r\\n\\t\\t\\t\\tif ( distSq > localThresholdSq ) continue;\\r\\n\\r\\n\\t\\t\\t\\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\\r\\n\\r\\n\\t\\t\\t\\tvar distance = raycaster.ray.origin.distanceTo( interRay );\\r\\n\\r\\n\\t\\t\\t\\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\\r\\n\\r\\n\\t\\t\\t\\tintersects.push( {\\r\\n\\r\\n\\t\\t\\t\\t\\tdistance: distance,\\r\\n\\t\\t\\t\\t\\t// What do we want? intersection point on the ray or on the segment??\\r\\n\\t\\t\\t\\t\\t// point: raycaster.ray.at( distance ),\\r\\n\\t\\t\\t\\t\\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\\r\\n\\t\\t\\t\\t\\tindex: i,\\r\\n\\t\\t\\t\\t\\tface: null,\\r\\n\\t\\t\\t\\t\\tfaceIndex: null,\\r\\n\\t\\t\\t\\t\\tobject: this\\r\\n\\r\\n\\t\\t\\t\\t} );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tupdateMorphTargets: function () {\\r\\n\\r\\n\\t\\tvar geometry = this.geometry;\\r\\n\\t\\tvar m, ml, name;\\r\\n\\r\\n\\t\\tif ( geometry.isBufferGeometry ) {\\r\\n\\r\\n\\t\\t\\tvar morphAttributes = geometry.morphAttributes;\\r\\n\\t\\t\\tvar keys = Object.keys( morphAttributes );\\r\\n\\r\\n\\t\\t\\tif ( keys.length > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tvar morphAttribute = morphAttributes[ keys[ 0 ] ];\\r\\n\\r\\n\\t\\t\\t\\tif ( morphAttribute !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.morphTargetInfluences = [];\\r\\n\\t\\t\\t\\t\\tthis.morphTargetDictionary = {};\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( m = 0, ml = morphAttribute.length; m < ml; m ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tname = morphAttribute[ m ].name || String( m );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tthis.morphTargetInfluences.push( 0 );\\r\\n\\t\\t\\t\\t\\t\\tthis.morphTargetDictionary[ name ] = m;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tvar morphTargets = geometry.morphTargets;\\r\\n\\r\\n\\t\\t\\tif ( morphTargets !== undefined && morphTargets.length > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.error( 'THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.' );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclone: function () {\\r\\n\\r\\n\\t\\treturn new this.constructor( this.geometry, this.material ).copy( this );\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nvar _start$1 = new Vector3();\\r\\nvar _end$1 = new Vector3();\\r\\n\\r\\nfunction LineSegments( geometry, material ) {\\r\\n\\r\\n\\tLine.call( this, geometry, material );\\r\\n\\r\\n\\tthis.type = 'LineSegments';\\r\\n\\r\\n}\\r\\n\\r\\nLineSegments.prototype = Object.assign( Object.create( Line.prototype ), {\\r\\n\\r\\n\\tconstructor: LineSegments,\\r\\n\\r\\n\\tisLineSegments: true,\\r\\n\\r\\n\\tcomputeLineDistances: function () {\\r\\n\\r\\n\\t\\tvar geometry = this.geometry;\\r\\n\\r\\n\\t\\tif ( geometry.isBufferGeometry ) {\\r\\n\\r\\n\\t\\t\\t// we assume non-indexed geometry\\r\\n\\r\\n\\t\\t\\tif ( geometry.index === null ) {\\r\\n\\r\\n\\t\\t\\t\\tvar positionAttribute = geometry.attributes.position;\\r\\n\\t\\t\\t\\tvar lineDistances = [];\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, l = positionAttribute.count; i < l; i += 2 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t_start$1.fromBufferAttribute( positionAttribute, i );\\r\\n\\t\\t\\t\\t\\t_end$1.fromBufferAttribute( positionAttribute, i + 1 );\\r\\n\\r\\n\\t\\t\\t\\t\\tlineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];\\r\\n\\t\\t\\t\\t\\tlineDistances[ i + 1 ] = lineDistances[ i ] + _start$1.distanceTo( _end$1 );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tgeometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t} else if ( geometry.isGeometry ) {\\r\\n\\r\\n\\t\\t\\tvar vertices = geometry.vertices;\\r\\n\\t\\t\\tvar lineDistances = geometry.lineDistances;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = vertices.length; i < l; i += 2 ) {\\r\\n\\r\\n\\t\\t\\t\\t_start$1.copy( vertices[ i ] );\\r\\n\\t\\t\\t\\t_end$1.copy( vertices[ i + 1 ] );\\r\\n\\r\\n\\t\\t\\t\\tlineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];\\r\\n\\t\\t\\t\\tlineDistances[ i + 1 ] = lineDistances[ i ] + _start$1.distanceTo( _end$1 );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author mgreter / http://github.com/mgreter\\r\\n */\\r\\n\\r\\nfunction LineLoop( geometry, material ) {\\r\\n\\r\\n\\tLine.call( this, geometry, material );\\r\\n\\r\\n\\tthis.type = 'LineLoop';\\r\\n\\r\\n}\\r\\n\\r\\nLineLoop.prototype = Object.assign( Object.create( Line.prototype ), {\\r\\n\\r\\n\\tconstructor: LineLoop,\\r\\n\\r\\n\\tisLineLoop: true,\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n *\\r\\n * parameters = {\\r\\n *  color: <hex>,\\r\\n *  opacity: <float>,\\r\\n *  map: new THREE.Texture( <Image> ),\\r\\n *  alphaMap: new THREE.Texture( <Image> ),\\r\\n *\\r\\n *  size: <float>,\\r\\n *  sizeAttenuation: <bool>\\r\\n *\\r\\n *  morphTargets: <bool>\\r\\n * }\\r\\n */\\r\\n\\r\\nfunction PointsMaterial( parameters ) {\\r\\n\\r\\n\\tMaterial.call( this );\\r\\n\\r\\n\\tthis.type = 'PointsMaterial';\\r\\n\\r\\n\\tthis.color = new Color( 0xffffff );\\r\\n\\r\\n\\tthis.map = null;\\r\\n\\r\\n\\tthis.alphaMap = null;\\r\\n\\r\\n\\tthis.size = 1;\\r\\n\\tthis.sizeAttenuation = true;\\r\\n\\r\\n\\tthis.morphTargets = false;\\r\\n\\r\\n\\tthis.setValues( parameters );\\r\\n\\r\\n}\\r\\n\\r\\nPointsMaterial.prototype = Object.create( Material.prototype );\\r\\nPointsMaterial.prototype.constructor = PointsMaterial;\\r\\n\\r\\nPointsMaterial.prototype.isPointsMaterial = true;\\r\\n\\r\\nPointsMaterial.prototype.copy = function ( source ) {\\r\\n\\r\\n\\tMaterial.prototype.copy.call( this, source );\\r\\n\\r\\n\\tthis.color.copy( source.color );\\r\\n\\r\\n\\tthis.map = source.map;\\r\\n\\r\\n\\tthis.alphaMap = source.alphaMap;\\r\\n\\r\\n\\tthis.size = source.size;\\r\\n\\tthis.sizeAttenuation = source.sizeAttenuation;\\r\\n\\r\\n\\tthis.morphTargets = source.morphTargets;\\r\\n\\r\\n\\treturn this;\\r\\n\\r\\n};\\r\\n\\r\\n/**\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n */\\r\\n\\r\\nvar _inverseMatrix$2 = new Matrix4();\\r\\nvar _ray$2 = new Ray();\\r\\nvar _sphere$3 = new Sphere();\\r\\nvar _position$1 = new Vector3();\\r\\n\\r\\nfunction Points( geometry, material ) {\\r\\n\\r\\n\\tObject3D.call( this );\\r\\n\\r\\n\\tthis.type = 'Points';\\r\\n\\r\\n\\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\\r\\n\\tthis.material = material !== undefined ? material : new PointsMaterial();\\r\\n\\r\\n\\tthis.updateMorphTargets();\\r\\n\\r\\n}\\r\\n\\r\\nPoints.prototype = Object.assign( Object.create( Object3D.prototype ), {\\r\\n\\r\\n\\tconstructor: Points,\\r\\n\\r\\n\\tisPoints: true,\\r\\n\\r\\n\\traycast: function ( raycaster, intersects ) {\\r\\n\\r\\n\\t\\tvar geometry = this.geometry;\\r\\n\\t\\tvar matrixWorld = this.matrixWorld;\\r\\n\\t\\tvar threshold = raycaster.params.Points.threshold;\\r\\n\\r\\n\\t\\t// Checking boundingSphere distance to ray\\r\\n\\r\\n\\t\\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\\r\\n\\r\\n\\t\\t_sphere$3.copy( geometry.boundingSphere );\\r\\n\\t\\t_sphere$3.applyMatrix4( matrixWorld );\\r\\n\\t\\t_sphere$3.radius += threshold;\\r\\n\\r\\n\\t\\tif ( raycaster.ray.intersectsSphere( _sphere$3 ) === false ) return;\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\t_inverseMatrix$2.getInverse( matrixWorld );\\r\\n\\t\\t_ray$2.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$2 );\\r\\n\\r\\n\\t\\tvar localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\\r\\n\\t\\tvar localThresholdSq = localThreshold * localThreshold;\\r\\n\\r\\n\\t\\tif ( geometry.isBufferGeometry ) {\\r\\n\\r\\n\\t\\t\\tvar index = geometry.index;\\r\\n\\t\\t\\tvar attributes = geometry.attributes;\\r\\n\\t\\t\\tvar positions = attributes.position.array;\\r\\n\\r\\n\\t\\t\\tif ( index !== null ) {\\r\\n\\r\\n\\t\\t\\t\\tvar indices = index.array;\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, il = indices.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar a = indices[ i ];\\r\\n\\r\\n\\t\\t\\t\\t\\t_position$1.fromArray( positions, a * 3 );\\r\\n\\r\\n\\t\\t\\t\\t\\ttestPoint( _position$1, a, localThresholdSq, matrixWorld, raycaster, intersects, this );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, l = positions.length / 3; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t_position$1.fromArray( positions, i * 3 );\\r\\n\\r\\n\\t\\t\\t\\t\\ttestPoint( _position$1, i, localThresholdSq, matrixWorld, raycaster, intersects, this );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tvar vertices = geometry.vertices;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = vertices.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\ttestPoint( vertices[ i ], i, localThresholdSq, matrixWorld, raycaster, intersects, this );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tupdateMorphTargets: function () {\\r\\n\\r\\n\\t\\tvar geometry = this.geometry;\\r\\n\\t\\tvar m, ml, name;\\r\\n\\r\\n\\t\\tif ( geometry.isBufferGeometry ) {\\r\\n\\r\\n\\t\\t\\tvar morphAttributes = geometry.morphAttributes;\\r\\n\\t\\t\\tvar keys = Object.keys( morphAttributes );\\r\\n\\r\\n\\t\\t\\tif ( keys.length > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tvar morphAttribute = morphAttributes[ keys[ 0 ] ];\\r\\n\\r\\n\\t\\t\\t\\tif ( morphAttribute !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.morphTargetInfluences = [];\\r\\n\\t\\t\\t\\t\\tthis.morphTargetDictionary = {};\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( m = 0, ml = morphAttribute.length; m < ml; m ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tname = morphAttribute[ m ].name || String( m );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tthis.morphTargetInfluences.push( 0 );\\r\\n\\t\\t\\t\\t\\t\\tthis.morphTargetDictionary[ name ] = m;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tvar morphTargets = geometry.morphTargets;\\r\\n\\r\\n\\t\\t\\tif ( morphTargets !== undefined && morphTargets.length > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.error( 'THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.' );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclone: function () {\\r\\n\\r\\n\\t\\treturn new this.constructor( this.geometry, this.material ).copy( this );\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nfunction testPoint( point, index, localThresholdSq, matrixWorld, raycaster, intersects, object ) {\\r\\n\\r\\n\\tvar rayPointDistanceSq = _ray$2.distanceSqToPoint( point );\\r\\n\\r\\n\\tif ( rayPointDistanceSq < localThresholdSq ) {\\r\\n\\r\\n\\t\\tvar intersectPoint = new Vector3();\\r\\n\\r\\n\\t\\t_ray$2.closestPointToPoint( point, intersectPoint );\\r\\n\\t\\tintersectPoint.applyMatrix4( matrixWorld );\\r\\n\\r\\n\\t\\tvar distance = raycaster.ray.origin.distanceTo( intersectPoint );\\r\\n\\r\\n\\t\\tif ( distance < raycaster.near || distance > raycaster.far ) return;\\r\\n\\r\\n\\t\\tintersects.push( {\\r\\n\\r\\n\\t\\t\\tdistance: distance,\\r\\n\\t\\t\\tdistanceToRay: Math.sqrt( rayPointDistanceSq ),\\r\\n\\t\\t\\tpoint: intersectPoint,\\r\\n\\t\\t\\tindex: index,\\r\\n\\t\\t\\tface: null,\\r\\n\\t\\t\\tobject: object\\r\\n\\r\\n\\t\\t} );\\r\\n\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nfunction VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\\r\\n\\r\\n\\tTexture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\\r\\n\\r\\n\\tthis.format = format !== undefined ? format : RGBFormat;\\r\\n\\r\\n\\tthis.minFilter = minFilter !== undefined ? minFilter : LinearFilter;\\r\\n\\tthis.magFilter = magFilter !== undefined ? magFilter : LinearFilter;\\r\\n\\r\\n\\tthis.generateMipmaps = false;\\r\\n\\r\\n}\\r\\n\\r\\nVideoTexture.prototype = Object.assign( Object.create( Texture.prototype ), {\\r\\n\\r\\n\\tconstructor: VideoTexture,\\r\\n\\r\\n\\tisVideoTexture: true,\\r\\n\\r\\n\\tupdate: function () {\\r\\n\\r\\n\\t\\tvar video = this.image;\\r\\n\\r\\n\\t\\tif ( video.readyState >= video.HAVE_CURRENT_DATA ) {\\r\\n\\r\\n\\t\\t\\tthis.needsUpdate = true;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n */\\r\\n\\r\\nfunction CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\\r\\n\\r\\n\\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\\r\\n\\r\\n\\tthis.image = { width: width, height: height };\\r\\n\\tthis.mipmaps = mipmaps;\\r\\n\\r\\n\\t// no flipping for cube textures\\r\\n\\t// (also flipping doesn't work for compressed textures )\\r\\n\\r\\n\\tthis.flipY = false;\\r\\n\\r\\n\\t// can't generate mipmaps for compressed textures\\r\\n\\t// mips must be embedded in DDS files\\r\\n\\r\\n\\tthis.generateMipmaps = false;\\r\\n\\r\\n}\\r\\n\\r\\nCompressedTexture.prototype = Object.create( Texture.prototype );\\r\\nCompressedTexture.prototype.constructor = CompressedTexture;\\r\\n\\r\\nCompressedTexture.prototype.isCompressedTexture = true;\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nfunction CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\\r\\n\\r\\n\\tTexture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\\r\\n\\r\\n\\tthis.needsUpdate = true;\\r\\n\\r\\n}\\r\\n\\r\\nCanvasTexture.prototype = Object.create( Texture.prototype );\\r\\nCanvasTexture.prototype.constructor = CanvasTexture;\\r\\nCanvasTexture.prototype.isCanvasTexture = true;\\r\\n\\r\\n/**\\r\\n * @author Matt DesLauriers / @mattdesl\\r\\n * @author atix / arthursilber.de\\r\\n */\\r\\n\\r\\nfunction DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {\\r\\n\\r\\n\\tformat = format !== undefined ? format : DepthFormat;\\r\\n\\r\\n\\tif ( format !== DepthFormat && format !== DepthStencilFormat ) {\\r\\n\\r\\n\\t\\tthrow new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tif ( type === undefined && format === DepthFormat ) type = UnsignedShortType;\\r\\n\\tif ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;\\r\\n\\r\\n\\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\\r\\n\\r\\n\\tthis.image = { width: width, height: height };\\r\\n\\r\\n\\tthis.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\\r\\n\\tthis.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\\r\\n\\r\\n\\tthis.flipY = false;\\r\\n\\tthis.generateMipmaps\\t= false;\\r\\n\\r\\n}\\r\\n\\r\\nDepthTexture.prototype = Object.create( Texture.prototype );\\r\\nDepthTexture.prototype.constructor = DepthTexture;\\r\\nDepthTexture.prototype.isDepthTexture = true;\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n * @author Mugen87 / https://github.com/Mugen87\\r\\n */\\r\\n\\r\\nfunction WireframeGeometry( geometry ) {\\r\\n\\r\\n\\tBufferGeometry.call( this );\\r\\n\\r\\n\\tthis.type = 'WireframeGeometry';\\r\\n\\r\\n\\t// buffer\\r\\n\\r\\n\\tvar vertices = [];\\r\\n\\r\\n\\t// helper variables\\r\\n\\r\\n\\tvar i, j, l, o, ol;\\r\\n\\tvar edge = [ 0, 0 ], edges = {}, e, edge1, edge2;\\r\\n\\tvar key, keys = [ 'a', 'b', 'c' ];\\r\\n\\tvar vertex;\\r\\n\\r\\n\\t// different logic for Geometry and BufferGeometry\\r\\n\\r\\n\\tif ( geometry && geometry.isGeometry ) {\\r\\n\\r\\n\\t\\t// create a data structure that contains all edges without duplicates\\r\\n\\r\\n\\t\\tvar faces = geometry.faces;\\r\\n\\r\\n\\t\\tfor ( i = 0, l = faces.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar face = faces[ i ];\\r\\n\\r\\n\\t\\t\\tfor ( j = 0; j < 3; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tedge1 = face[ keys[ j ] ];\\r\\n\\t\\t\\t\\tedge2 = face[ keys[ ( j + 1 ) % 3 ] ];\\r\\n\\t\\t\\t\\tedge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates\\r\\n\\t\\t\\t\\tedge[ 1 ] = Math.max( edge1, edge2 );\\r\\n\\r\\n\\t\\t\\t\\tkey = edge[ 0 ] + ',' + edge[ 1 ];\\r\\n\\r\\n\\t\\t\\t\\tif ( edges[ key ] === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tedges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// generate vertices\\r\\n\\r\\n\\t\\tfor ( key in edges ) {\\r\\n\\r\\n\\t\\t\\te = edges[ key ];\\r\\n\\r\\n\\t\\t\\tvertex = geometry.vertices[ e.index1 ];\\r\\n\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\r\\n\\r\\n\\t\\t\\tvertex = geometry.vertices[ e.index2 ];\\r\\n\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} else if ( geometry && geometry.isBufferGeometry ) {\\r\\n\\r\\n\\t\\tvar position, indices, groups;\\r\\n\\t\\tvar group, start, count;\\r\\n\\t\\tvar index1, index2;\\r\\n\\r\\n\\t\\tvertex = new Vector3();\\r\\n\\r\\n\\t\\tif ( geometry.index !== null ) {\\r\\n\\r\\n\\t\\t\\t// indexed BufferGeometry\\r\\n\\r\\n\\t\\t\\tposition = geometry.attributes.position;\\r\\n\\t\\t\\tindices = geometry.index;\\r\\n\\t\\t\\tgroups = geometry.groups;\\r\\n\\r\\n\\t\\t\\tif ( groups.length === 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tgroups = [ { start: 0, count: indices.count, materialIndex: 0 } ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// create a data structure that contains all eges without duplicates\\r\\n\\r\\n\\t\\t\\tfor ( o = 0, ol = groups.length; o < ol; ++ o ) {\\r\\n\\r\\n\\t\\t\\t\\tgroup = groups[ o ];\\r\\n\\r\\n\\t\\t\\t\\tstart = group.start;\\r\\n\\t\\t\\t\\tcount = group.count;\\r\\n\\r\\n\\t\\t\\t\\tfor ( i = start, l = ( start + count ); i < l; i += 3 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( j = 0; j < 3; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tedge1 = indices.getX( i + j );\\r\\n\\t\\t\\t\\t\\t\\tedge2 = indices.getX( i + ( j + 1 ) % 3 );\\r\\n\\t\\t\\t\\t\\t\\tedge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates\\r\\n\\t\\t\\t\\t\\t\\tedge[ 1 ] = Math.max( edge1, edge2 );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tkey = edge[ 0 ] + ',' + edge[ 1 ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( edges[ key ] === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tedges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// generate vertices\\r\\n\\r\\n\\t\\t\\tfor ( key in edges ) {\\r\\n\\r\\n\\t\\t\\t\\te = edges[ key ];\\r\\n\\r\\n\\t\\t\\t\\tvertex.fromBufferAttribute( position, e.index1 );\\r\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\r\\n\\r\\n\\t\\t\\t\\tvertex.fromBufferAttribute( position, e.index2 );\\r\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t// non-indexed BufferGeometry\\r\\n\\r\\n\\t\\t\\tposition = geometry.attributes.position;\\r\\n\\r\\n\\t\\t\\tfor ( i = 0, l = ( position.count / 3 ); i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tfor ( j = 0; j < 3; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// three edges per triangle, an edge is represented as (index1, index2)\\r\\n\\t\\t\\t\\t\\t// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)\\r\\n\\r\\n\\t\\t\\t\\t\\tindex1 = 3 * i + j;\\r\\n\\t\\t\\t\\t\\tvertex.fromBufferAttribute( position, index1 );\\r\\n\\t\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\r\\n\\r\\n\\t\\t\\t\\t\\tindex2 = 3 * i + ( ( j + 1 ) % 3 );\\r\\n\\t\\t\\t\\t\\tvertex.fromBufferAttribute( position, index2 );\\r\\n\\t\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// build geometry\\r\\n\\r\\n\\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\r\\n\\r\\n}\\r\\n\\r\\nWireframeGeometry.prototype = Object.create( BufferGeometry.prototype );\\r\\nWireframeGeometry.prototype.constructor = WireframeGeometry;\\r\\n\\r\\n/**\\r\\n * @author zz85 / https://github.com/zz85\\r\\n * @author Mugen87 / https://github.com/Mugen87\\r\\n *\\r\\n * Parametric Surfaces Geometry\\r\\n * based on the brilliant article by @prideout https://prideout.net/blog/old/blog/index.html@p=44.html\\r\\n */\\r\\n\\r\\n// ParametricGeometry\\r\\n\\r\\nfunction ParametricGeometry( func, slices, stacks ) {\\r\\n\\r\\n\\tGeometry.call( this );\\r\\n\\r\\n\\tthis.type = 'ParametricGeometry';\\r\\n\\r\\n\\tthis.parameters = {\\r\\n\\t\\tfunc: func,\\r\\n\\t\\tslices: slices,\\r\\n\\t\\tstacks: stacks\\r\\n\\t};\\r\\n\\r\\n\\tthis.fromBufferGeometry( new ParametricBufferGeometry( func, slices, stacks ) );\\r\\n\\tthis.mergeVertices();\\r\\n\\r\\n}\\r\\n\\r\\nParametricGeometry.prototype = Object.create( Geometry.prototype );\\r\\nParametricGeometry.prototype.constructor = ParametricGeometry;\\r\\n\\r\\n// ParametricBufferGeometry\\r\\n\\r\\nfunction ParametricBufferGeometry( func, slices, stacks ) {\\r\\n\\r\\n\\tBufferGeometry.call( this );\\r\\n\\r\\n\\tthis.type = 'ParametricBufferGeometry';\\r\\n\\r\\n\\tthis.parameters = {\\r\\n\\t\\tfunc: func,\\r\\n\\t\\tslices: slices,\\r\\n\\t\\tstacks: stacks\\r\\n\\t};\\r\\n\\r\\n\\t// buffers\\r\\n\\r\\n\\tvar indices = [];\\r\\n\\tvar vertices = [];\\r\\n\\tvar normals = [];\\r\\n\\tvar uvs = [];\\r\\n\\r\\n\\tvar EPS = 0.00001;\\r\\n\\r\\n\\tvar normal = new Vector3();\\r\\n\\r\\n\\tvar p0 = new Vector3(), p1 = new Vector3();\\r\\n\\tvar pu = new Vector3(), pv = new Vector3();\\r\\n\\r\\n\\tvar i, j;\\r\\n\\r\\n\\tif ( func.length < 3 ) {\\r\\n\\r\\n\\t\\tconsole.error( 'THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.' );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// generate vertices, normals and uvs\\r\\n\\r\\n\\tvar sliceCount = slices + 1;\\r\\n\\r\\n\\tfor ( i = 0; i <= stacks; i ++ ) {\\r\\n\\r\\n\\t\\tvar v = i / stacks;\\r\\n\\r\\n\\t\\tfor ( j = 0; j <= slices; j ++ ) {\\r\\n\\r\\n\\t\\t\\tvar u = j / slices;\\r\\n\\r\\n\\t\\t\\t// vertex\\r\\n\\r\\n\\t\\t\\tfunc( u, v, p0 );\\r\\n\\t\\t\\tvertices.push( p0.x, p0.y, p0.z );\\r\\n\\r\\n\\t\\t\\t// normal\\r\\n\\r\\n\\t\\t\\t// approximate tangent vectors via finite differences\\r\\n\\r\\n\\t\\t\\tif ( u - EPS >= 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tfunc( u - EPS, v, p1 );\\r\\n\\t\\t\\t\\tpu.subVectors( p0, p1 );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tfunc( u + EPS, v, p1 );\\r\\n\\t\\t\\t\\tpu.subVectors( p1, p0 );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( v - EPS >= 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tfunc( u, v - EPS, p1 );\\r\\n\\t\\t\\t\\tpv.subVectors( p0, p1 );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tfunc( u, v + EPS, p1 );\\r\\n\\t\\t\\t\\tpv.subVectors( p1, p0 );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// cross product of tangent vectors returns surface normal\\r\\n\\r\\n\\t\\t\\tnormal.crossVectors( pu, pv ).normalize();\\r\\n\\t\\t\\tnormals.push( normal.x, normal.y, normal.z );\\r\\n\\r\\n\\t\\t\\t// uv\\r\\n\\r\\n\\t\\t\\tuvs.push( u, v );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// generate indices\\r\\n\\r\\n\\tfor ( i = 0; i < stacks; i ++ ) {\\r\\n\\r\\n\\t\\tfor ( j = 0; j < slices; j ++ ) {\\r\\n\\r\\n\\t\\t\\tvar a = i * sliceCount + j;\\r\\n\\t\\t\\tvar b = i * sliceCount + j + 1;\\r\\n\\t\\t\\tvar c = ( i + 1 ) * sliceCount + j + 1;\\r\\n\\t\\t\\tvar d = ( i + 1 ) * sliceCount + j;\\r\\n\\r\\n\\t\\t\\t// faces one and two\\r\\n\\r\\n\\t\\t\\tindices.push( a, b, d );\\r\\n\\t\\t\\tindices.push( b, c, d );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// build geometry\\r\\n\\r\\n\\tthis.setIndex( indices );\\r\\n\\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\r\\n\\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\r\\n\\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\r\\n\\r\\n}\\r\\n\\r\\nParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\r\\nParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;\\r\\n\\r\\n/**\\r\\n * @author clockworkgeek / https://github.com/clockworkgeek\\r\\n * @author timothypratley / https://github.com/timothypratley\\r\\n * @author WestLangley / http://github.com/WestLangley\\r\\n * @author Mugen87 / https://github.com/Mugen87\\r\\n */\\r\\n\\r\\n// PolyhedronGeometry\\r\\n\\r\\nfunction PolyhedronGeometry( vertices, indices, radius, detail ) {\\r\\n\\r\\n\\tGeometry.call( this );\\r\\n\\r\\n\\tthis.type = 'PolyhedronGeometry';\\r\\n\\r\\n\\tthis.parameters = {\\r\\n\\t\\tvertices: vertices,\\r\\n\\t\\tindices: indices,\\r\\n\\t\\tradius: radius,\\r\\n\\t\\tdetail: detail\\r\\n\\t};\\r\\n\\r\\n\\tthis.fromBufferGeometry( new PolyhedronBufferGeometry( vertices, indices, radius, detail ) );\\r\\n\\tthis.mergeVertices();\\r\\n\\r\\n}\\r\\n\\r\\nPolyhedronGeometry.prototype = Object.create( Geometry.prototype );\\r\\nPolyhedronGeometry.prototype.constructor = PolyhedronGeometry;\\r\\n\\r\\n// PolyhedronBufferGeometry\\r\\n\\r\\nfunction PolyhedronBufferGeometry( vertices, indices, radius, detail ) {\\r\\n\\r\\n\\tBufferGeometry.call( this );\\r\\n\\r\\n\\tthis.type = 'PolyhedronBufferGeometry';\\r\\n\\r\\n\\tthis.parameters = {\\r\\n\\t\\tvertices: vertices,\\r\\n\\t\\tindices: indices,\\r\\n\\t\\tradius: radius,\\r\\n\\t\\tdetail: detail\\r\\n\\t};\\r\\n\\r\\n\\tradius = radius || 1;\\r\\n\\tdetail = detail || 0;\\r\\n\\r\\n\\t// default buffer data\\r\\n\\r\\n\\tvar vertexBuffer = [];\\r\\n\\tvar uvBuffer = [];\\r\\n\\r\\n\\t// the subdivision creates the vertex buffer data\\r\\n\\r\\n\\tsubdivide( detail );\\r\\n\\r\\n\\t// all vertices should lie on a conceptual sphere with a given radius\\r\\n\\r\\n\\tapplyRadius( radius );\\r\\n\\r\\n\\t// finally, create the uv data\\r\\n\\r\\n\\tgenerateUVs();\\r\\n\\r\\n\\t// build non-indexed geometry\\r\\n\\r\\n\\tthis.setAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );\\r\\n\\tthis.setAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );\\r\\n\\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );\\r\\n\\r\\n\\tif ( detail === 0 ) {\\r\\n\\r\\n\\t\\tthis.computeVertexNormals(); // flat normals\\r\\n\\r\\n\\t} else {\\r\\n\\r\\n\\t\\tthis.normalizeNormals(); // smooth normals\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// helper functions\\r\\n\\r\\n\\tfunction subdivide( detail ) {\\r\\n\\r\\n\\t\\tvar a = new Vector3();\\r\\n\\t\\tvar b = new Vector3();\\r\\n\\t\\tvar c = new Vector3();\\r\\n\\r\\n\\t\\t// iterate over all faces and apply a subdivison with the given detail value\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < indices.length; i += 3 ) {\\r\\n\\r\\n\\t\\t\\t// get the vertices of the face\\r\\n\\r\\n\\t\\t\\tgetVertexByIndex( indices[ i + 0 ], a );\\r\\n\\t\\t\\tgetVertexByIndex( indices[ i + 1 ], b );\\r\\n\\t\\t\\tgetVertexByIndex( indices[ i + 2 ], c );\\r\\n\\r\\n\\t\\t\\t// perform subdivision\\r\\n\\r\\n\\t\\t\\tsubdivideFace( a, b, c, detail );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction subdivideFace( a, b, c, detail ) {\\r\\n\\r\\n\\t\\tvar cols = Math.pow( 2, detail );\\r\\n\\r\\n\\t\\t// we use this multidimensional array as a data structure for creating the subdivision\\r\\n\\r\\n\\t\\tvar v = [];\\r\\n\\r\\n\\t\\tvar i, j;\\r\\n\\r\\n\\t\\t// construct all of the vertices for this subdivision\\r\\n\\r\\n\\t\\tfor ( i = 0; i <= cols; i ++ ) {\\r\\n\\r\\n\\t\\t\\tv[ i ] = [];\\r\\n\\r\\n\\t\\t\\tvar aj = a.clone().lerp( c, i / cols );\\r\\n\\t\\t\\tvar bj = b.clone().lerp( c, i / cols );\\r\\n\\r\\n\\t\\t\\tvar rows = cols - i;\\r\\n\\r\\n\\t\\t\\tfor ( j = 0; j <= rows; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( j === 0 && i === cols ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tv[ i ][ j ] = aj;\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tv[ i ][ j ] = aj.clone().lerp( bj, j / rows );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// construct all of the faces\\r\\n\\r\\n\\t\\tfor ( i = 0; i < cols; i ++ ) {\\r\\n\\r\\n\\t\\t\\tfor ( j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar k = Math.floor( j / 2 );\\r\\n\\r\\n\\t\\t\\t\\tif ( j % 2 === 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tpushVertex( v[ i ][ k + 1 ] );\\r\\n\\t\\t\\t\\t\\tpushVertex( v[ i + 1 ][ k ] );\\r\\n\\t\\t\\t\\t\\tpushVertex( v[ i ][ k ] );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tpushVertex( v[ i ][ k + 1 ] );\\r\\n\\t\\t\\t\\t\\tpushVertex( v[ i + 1 ][ k + 1 ] );\\r\\n\\t\\t\\t\\t\\tpushVertex( v[ i + 1 ][ k ] );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction applyRadius( radius ) {\\r\\n\\r\\n\\t\\tvar vertex = new Vector3();\\r\\n\\r\\n\\t\\t// iterate over the entire buffer and apply the radius to each vertex\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < vertexBuffer.length; i += 3 ) {\\r\\n\\r\\n\\t\\t\\tvertex.x = vertexBuffer[ i + 0 ];\\r\\n\\t\\t\\tvertex.y = vertexBuffer[ i + 1 ];\\r\\n\\t\\t\\tvertex.z = vertexBuffer[ i + 2 ];\\r\\n\\r\\n\\t\\t\\tvertex.normalize().multiplyScalar( radius );\\r\\n\\r\\n\\t\\t\\tvertexBuffer[ i + 0 ] = vertex.x;\\r\\n\\t\\t\\tvertexBuffer[ i + 1 ] = vertex.y;\\r\\n\\t\\t\\tvertexBuffer[ i + 2 ] = vertex.z;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction generateUVs() {\\r\\n\\r\\n\\t\\tvar vertex = new Vector3();\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < vertexBuffer.length; i += 3 ) {\\r\\n\\r\\n\\t\\t\\tvertex.x = vertexBuffer[ i + 0 ];\\r\\n\\t\\t\\tvertex.y = vertexBuffer[ i + 1 ];\\r\\n\\t\\t\\tvertex.z = vertexBuffer[ i + 2 ];\\r\\n\\r\\n\\t\\t\\tvar u = azimuth( vertex ) / 2 / Math.PI + 0.5;\\r\\n\\t\\t\\tvar v = inclination( vertex ) / Math.PI + 0.5;\\r\\n\\t\\t\\tuvBuffer.push( u, 1 - v );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tcorrectUVs();\\r\\n\\r\\n\\t\\tcorrectSeam();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction correctSeam() {\\r\\n\\r\\n\\t\\t// handle case when face straddles the seam, see #3269\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < uvBuffer.length; i += 6 ) {\\r\\n\\r\\n\\t\\t\\t// uv data of a single face\\r\\n\\r\\n\\t\\t\\tvar x0 = uvBuffer[ i + 0 ];\\r\\n\\t\\t\\tvar x1 = uvBuffer[ i + 2 ];\\r\\n\\t\\t\\tvar x2 = uvBuffer[ i + 4 ];\\r\\n\\r\\n\\t\\t\\tvar max = Math.max( x0, x1, x2 );\\r\\n\\t\\t\\tvar min = Math.min( x0, x1, x2 );\\r\\n\\r\\n\\t\\t\\t// 0.9 is somewhat arbitrary\\r\\n\\r\\n\\t\\t\\tif ( max > 0.9 && min < 0.1 ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;\\r\\n\\t\\t\\t\\tif ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;\\r\\n\\t\\t\\t\\tif ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction pushVertex( vertex ) {\\r\\n\\r\\n\\t\\tvertexBuffer.push( vertex.x, vertex.y, vertex.z );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction getVertexByIndex( index, vertex ) {\\r\\n\\r\\n\\t\\tvar stride = index * 3;\\r\\n\\r\\n\\t\\tvertex.x = vertices[ stride + 0 ];\\r\\n\\t\\tvertex.y = vertices[ stride + 1 ];\\r\\n\\t\\tvertex.z = vertices[ stride + 2 ];\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction correctUVs() {\\r\\n\\r\\n\\t\\tvar a = new Vector3();\\r\\n\\t\\tvar b = new Vector3();\\r\\n\\t\\tvar c = new Vector3();\\r\\n\\r\\n\\t\\tvar centroid = new Vector3();\\r\\n\\r\\n\\t\\tvar uvA = new Vector2();\\r\\n\\t\\tvar uvB = new Vector2();\\r\\n\\t\\tvar uvC = new Vector2();\\r\\n\\r\\n\\t\\tfor ( var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {\\r\\n\\r\\n\\t\\t\\ta.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );\\r\\n\\t\\t\\tb.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );\\r\\n\\t\\t\\tc.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );\\r\\n\\r\\n\\t\\t\\tuvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );\\r\\n\\t\\t\\tuvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );\\r\\n\\t\\t\\tuvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );\\r\\n\\r\\n\\t\\t\\tcentroid.copy( a ).add( b ).add( c ).divideScalar( 3 );\\r\\n\\r\\n\\t\\t\\tvar azi = azimuth( centroid );\\r\\n\\r\\n\\t\\t\\tcorrectUV( uvA, j + 0, a, azi );\\r\\n\\t\\t\\tcorrectUV( uvB, j + 2, b, azi );\\r\\n\\t\\t\\tcorrectUV( uvC, j + 4, c, azi );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction correctUV( uv, stride, vector, azimuth ) {\\r\\n\\r\\n\\t\\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {\\r\\n\\r\\n\\t\\t\\tuvBuffer[ stride ] = uv.x - 1;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {\\r\\n\\r\\n\\t\\t\\tuvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// Angle around the Y axis, counter-clockwise when looking from above.\\r\\n\\r\\n\\tfunction azimuth( vector ) {\\r\\n\\r\\n\\t\\treturn Math.atan2( vector.z, - vector.x );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\r\\n\\t// Angle above the XZ plane.\\r\\n\\r\\n\\tfunction inclination( vector ) {\\r\\n\\r\\n\\t\\treturn Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\\r\\n\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\\r\\nPolyhedronBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\r\\nPolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;\\r\\n\\r\\n/**\\r\\n * @author timothypratley / https://github.com/timothypratley\\r\\n * @author Mugen87 / https://github.com/Mugen87\\r\\n */\\r\\n\\r\\n// TetrahedronGeometry\\r\\n\\r\\nfunction TetrahedronGeometry( radius, detail ) {\\r\\n\\r\\n\\tGeometry.call( this );\\r\\n\\r\\n\\tthis.type = 'TetrahedronGeometry';\\r\\n\\r\\n\\tthis.parameters = {\\r\\n\\t\\tradius: radius,\\r\\n\\t\\tdetail: detail\\r\\n\\t};\\r\\n\\r\\n\\tthis.fromBufferGeometry( new TetrahedronBufferGeometry( radius, detail ) );\\r\\n\\tthis.mergeVertices();\\r\\n\\r\\n}\\r\\n\\r\\nTetrahedronGeometry.prototype = Object.create( Geometry.prototype );\\r\\nTetrahedronGeometry.prototype.constructor = TetrahedronGeometry;\\r\\n\\r\\n// TetrahedronBufferGeometry\\r\\n\\r\\nfunction TetrahedronBufferGeometry( radius, detail ) {\\r\\n\\r\\n\\tvar vertices = [\\r\\n\\t\\t1, 1, 1, \\t- 1, - 1, 1, \\t- 1, 1, - 1, \\t1, - 1, - 1\\r\\n\\t];\\r\\n\\r\\n\\tvar indices = [\\r\\n\\t\\t2, 1, 0, \\t0, 3, 2,\\t1, 3, 0,\\t2, 3, 1\\r\\n\\t];\\r\\n\\r\\n\\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\\r\\n\\r\\n\\tthis.type = 'TetrahedronBufferGeometry';\\r\\n\\r\\n\\tthis.parameters = {\\r\\n\\t\\tradius: radius,\\r\\n\\t\\tdetail: detail\\r\\n\\t};\\r\\n\\r\\n}\\r\\n\\r\\nTetrahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\\r\\nTetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;\\r\\n\\r\\n/**\\r\\n * @author timothypratley / https://github.com/timothypratley\\r\\n * @author Mugen87 / https://github.com/Mugen87\\r\\n */\\r\\n\\r\\n// OctahedronGeometry\\r\\n\\r\\nfunction OctahedronGeometry( radius, detail ) {\\r\\n\\r\\n\\tGeometry.call( this );\\r\\n\\r\\n\\tthis.type = 'OctahedronGeometry';\\r\\n\\r\\n\\tthis.parameters = {\\r\\n\\t\\tradius: radius,\\r\\n\\t\\tdetail: detail\\r\\n\\t};\\r\\n\\r\\n\\tthis.fromBufferGeometry( new OctahedronBufferGeometry( radius, detail ) );\\r\\n\\tthis.mergeVertices();\\r\\n\\r\\n}\\r\\n\\r\\nOctahedronGeometry.prototype = Object.create( Geometry.prototype );\\r\\nOctahedronGeometry.prototype.constructor = OctahedronGeometry;\\r\\n\\r\\n// OctahedronBufferGeometry\\r\\n\\r\\nfunction OctahedronBufferGeometry( radius, detail ) {\\r\\n\\r\\n\\tvar vertices = [\\r\\n\\t\\t1, 0, 0, \\t- 1, 0, 0,\\t0, 1, 0,\\r\\n\\t\\t0, - 1, 0, \\t0, 0, 1,\\t0, 0, - 1\\r\\n\\t];\\r\\n\\r\\n\\tvar indices = [\\r\\n\\t\\t0, 2, 4,\\t0, 4, 3,\\t0, 3, 5,\\r\\n\\t\\t0, 5, 2,\\t1, 2, 5,\\t1, 5, 3,\\r\\n\\t\\t1, 3, 4,\\t1, 4, 2\\r\\n\\t];\\r\\n\\r\\n\\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\\r\\n\\r\\n\\tthis.type = 'OctahedronBufferGeometry';\\r\\n\\r\\n\\tthis.parameters = {\\r\\n\\t\\tradius: radius,\\r\\n\\t\\tdetail: detail\\r\\n\\t};\\r\\n\\r\\n}\\r\\n\\r\\nOctahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\\r\\nOctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;\\r\\n\\r\\n/**\\r\\n * @author timothypratley / https://github.com/timothypratley\\r\\n * @author Mugen87 / https://github.com/Mugen87\\r\\n */\\r\\n\\r\\n// IcosahedronGeometry\\r\\n\\r\\nfunction IcosahedronGeometry( radius, detail ) {\\r\\n\\r\\n\\tGeometry.call( this );\\r\\n\\r\\n\\tthis.type = 'IcosahedronGeometry';\\r\\n\\r\\n\\tthis.parameters = {\\r\\n\\t\\tradius: radius,\\r\\n\\t\\tdetail: detail\\r\\n\\t};\\r\\n\\r\\n\\tthis.fromBufferGeometry( new IcosahedronBufferGeometry( radius, detail ) );\\r\\n\\tthis.mergeVertices();\\r\\n\\r\\n}\\r\\n\\r\\nIcosahedronGeometry.prototype = Object.create( Geometry.prototype );\\r\\nIcosahedronGeometry.prototype.constructor = IcosahedronGeometry;\\r\\n\\r\\n// IcosahedronBufferGeometry\\r\\n\\r\\nfunction IcosahedronBufferGeometry( radius, detail ) {\\r\\n\\r\\n\\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\\r\\n\\r\\n\\tvar vertices = [\\r\\n\\t\\t- 1, t, 0, \\t1, t, 0, \\t- 1, - t, 0, \\t1, - t, 0,\\r\\n\\t\\t 0, - 1, t, \\t0, 1, t,\\t0, - 1, - t, \\t0, 1, - t,\\r\\n\\t\\t t, 0, - 1, \\tt, 0, 1, \\t- t, 0, - 1, \\t- t, 0, 1\\r\\n\\t];\\r\\n\\r\\n\\tvar indices = [\\r\\n\\t\\t 0, 11, 5, \\t0, 5, 1, \\t0, 1, 7, \\t0, 7, 10, \\t0, 10, 11,\\r\\n\\t\\t 1, 5, 9, \\t5, 11, 4,\\t11, 10, 2,\\t10, 7, 6,\\t7, 1, 8,\\r\\n\\t\\t 3, 9, 4, \\t3, 4, 2,\\t3, 2, 6,\\t3, 6, 8,\\t3, 8, 9,\\r\\n\\t\\t 4, 9, 5, \\t2, 4, 11,\\t6, 2, 10,\\t8, 6, 7,\\t9, 8, 1\\r\\n\\t];\\r\\n\\r\\n\\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\\r\\n\\r\\n\\tthis.type = 'IcosahedronBufferGeometry';\\r\\n\\r\\n\\tthis.parameters = {\\r\\n\\t\\tradius: radius,\\r\\n\\t\\tdetail: detail\\r\\n\\t};\\r\\n\\r\\n}\\r\\n\\r\\nIcosahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\\r\\nIcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;\\r\\n\\r\\n/**\\r\\n * @author Abe Pazos / https://hamoid.com\\r\\n * @author Mugen87 / https://github.com/Mugen87\\r\\n */\\r\\n\\r\\n// DodecahedronGeometry\\r\\n\\r\\nfunction DodecahedronGeometry( radius, detail ) {\\r\\n\\r\\n\\tGeometry.call( this );\\r\\n\\r\\n\\tthis.type = 'DodecahedronGeometry';\\r\\n\\r\\n\\tthis.parameters = {\\r\\n\\t\\tradius: radius,\\r\\n\\t\\tdetail: detail\\r\\n\\t};\\r\\n\\r\\n\\tthis.fromBufferGeometry( new DodecahedronBufferGeometry( radius, detail ) );\\r\\n\\tthis.mergeVertices();\\r\\n\\r\\n}\\r\\n\\r\\nDodecahedronGeometry.prototype = Object.create( Geometry.prototype );\\r\\nDodecahedronGeometry.prototype.constructor = DodecahedronGeometry;\\r\\n\\r\\n// DodecahedronBufferGeometry\\r\\n\\r\\nfunction DodecahedronBufferGeometry( radius, detail ) {\\r\\n\\r\\n\\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\\r\\n\\tvar r = 1 / t;\\r\\n\\r\\n\\tvar vertices = [\\r\\n\\r\\n\\t\\t// (1, 1, 1)\\r\\n\\t\\t- 1, - 1, - 1,\\t- 1, - 1, 1,\\r\\n\\t\\t- 1, 1, - 1, - 1, 1, 1,\\r\\n\\t\\t1, - 1, - 1, 1, - 1, 1,\\r\\n\\t\\t1, 1, - 1, 1, 1, 1,\\r\\n\\r\\n\\t\\t// (0, 1/, )\\r\\n\\t\\t 0, - r, - t, 0, - r, t,\\r\\n\\t\\t 0, r, - t, 0, r, t,\\r\\n\\r\\n\\t\\t// (1/, , 0)\\r\\n\\t\\t- r, - t, 0, - r, t, 0,\\r\\n\\t\\t r, - t, 0, r, t, 0,\\r\\n\\r\\n\\t\\t// (, 0, 1/)\\r\\n\\t\\t- t, 0, - r, t, 0, - r,\\r\\n\\t\\t- t, 0, r, t, 0, r\\r\\n\\t];\\r\\n\\r\\n\\tvar indices = [\\r\\n\\t\\t3, 11, 7, \\t3, 7, 15, \\t3, 15, 13,\\r\\n\\t\\t7, 19, 17, \\t7, 17, 6, \\t7, 6, 15,\\r\\n\\t\\t17, 4, 8, \\t17, 8, 10, \\t17, 10, 6,\\r\\n\\t\\t8, 0, 16, \\t8, 16, 2, \\t8, 2, 10,\\r\\n\\t\\t0, 12, 1, \\t0, 1, 18, \\t0, 18, 16,\\r\\n\\t\\t6, 10, 2, \\t6, 2, 13, \\t6, 13, 15,\\r\\n\\t\\t2, 16, 18, \\t2, 18, 3, \\t2, 3, 13,\\r\\n\\t\\t18, 1, 9, \\t18, 9, 11, \\t18, 11, 3,\\r\\n\\t\\t4, 14, 12, \\t4, 12, 0, \\t4, 0, 8,\\r\\n\\t\\t11, 9, 5, \\t11, 5, 19, \\t11, 19, 7,\\r\\n\\t\\t19, 5, 14, \\t19, 14, 4, \\t19, 4, 17,\\r\\n\\t\\t1, 12, 14, \\t1, 14, 5, \\t1, 5, 9\\r\\n\\t];\\r\\n\\r\\n\\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\\r\\n\\r\\n\\tthis.type = 'DodecahedronBufferGeometry';\\r\\n\\r\\n\\tthis.parameters = {\\r\\n\\t\\tradius: radius,\\r\\n\\t\\tdetail: detail\\r\\n\\t};\\r\\n\\r\\n}\\r\\n\\r\\nDodecahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\\r\\nDodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;\\r\\n\\r\\n/**\\r\\n * @author oosmoxiecode / https://github.com/oosmoxiecode\\r\\n * @author WestLangley / https://github.com/WestLangley\\r\\n * @author zz85 / https://github.com/zz85\\r\\n * @author miningold / https://github.com/miningold\\r\\n * @author jonobr1 / https://github.com/jonobr1\\r\\n * @author Mugen87 / https://github.com/Mugen87\\r\\n *\\r\\n */\\r\\n\\r\\n// TubeGeometry\\r\\n\\r\\nfunction TubeGeometry( path, tubularSegments, radius, radialSegments, closed, taper ) {\\r\\n\\r\\n\\tGeometry.call( this );\\r\\n\\r\\n\\tthis.type = 'TubeGeometry';\\r\\n\\r\\n\\tthis.parameters = {\\r\\n\\t\\tpath: path,\\r\\n\\t\\ttubularSegments: tubularSegments,\\r\\n\\t\\tradius: radius,\\r\\n\\t\\tradialSegments: radialSegments,\\r\\n\\t\\tclosed: closed\\r\\n\\t};\\r\\n\\r\\n\\tif ( taper !== undefined ) console.warn( 'THREE.TubeGeometry: taper has been removed.' );\\r\\n\\r\\n\\tvar bufferGeometry = new TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed );\\r\\n\\r\\n\\t// expose internals\\r\\n\\r\\n\\tthis.tangents = bufferGeometry.tangents;\\r\\n\\tthis.normals = bufferGeometry.normals;\\r\\n\\tthis.binormals = bufferGeometry.binormals;\\r\\n\\r\\n\\t// create geometry\\r\\n\\r\\n\\tthis.fromBufferGeometry( bufferGeometry );\\r\\n\\tthis.mergeVertices();\\r\\n\\r\\n}\\r\\n\\r\\nTubeGeometry.prototype = Object.create( Geometry.prototype );\\r\\nTubeGeometry.prototype.constructor = TubeGeometry;\\r\\n\\r\\n// TubeBufferGeometry\\r\\n\\r\\nfunction TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed ) {\\r\\n\\r\\n\\tBufferGeometry.call( this );\\r\\n\\r\\n\\tthis.type = 'TubeBufferGeometry';\\r\\n\\r\\n\\tthis.parameters = {\\r\\n\\t\\tpath: path,\\r\\n\\t\\ttubularSegments: tubularSegments,\\r\\n\\t\\tradius: radius,\\r\\n\\t\\tradialSegments: radialSegments,\\r\\n\\t\\tclosed: closed\\r\\n\\t};\\r\\n\\r\\n\\ttubularSegments = tubularSegments || 64;\\r\\n\\tradius = radius || 1;\\r\\n\\tradialSegments = radialSegments || 8;\\r\\n\\tclosed = closed || false;\\r\\n\\r\\n\\tvar frames = path.computeFrenetFrames( tubularSegments, closed );\\r\\n\\r\\n\\t// expose internals\\r\\n\\r\\n\\tthis.tangents = frames.tangents;\\r\\n\\tthis.normals = frames.normals;\\r\\n\\tthis.binormals = frames.binormals;\\r\\n\\r\\n\\t// helper variables\\r\\n\\r\\n\\tvar vertex = new Vector3();\\r\\n\\tvar normal = new Vector3();\\r\\n\\tvar uv = new Vector2();\\r\\n\\tvar P = new Vector3();\\r\\n\\r\\n\\tvar i, j;\\r\\n\\r\\n\\t// buffer\\r\\n\\r\\n\\tvar vertices = [];\\r\\n\\tvar normals = [];\\r\\n\\tvar uvs = [];\\r\\n\\tvar indices = [];\\r\\n\\r\\n\\t// create buffer data\\r\\n\\r\\n\\tgenerateBufferData();\\r\\n\\r\\n\\t// build geometry\\r\\n\\r\\n\\tthis.setIndex( indices );\\r\\n\\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\r\\n\\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\r\\n\\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\r\\n\\r\\n\\t// functions\\r\\n\\r\\n\\tfunction generateBufferData() {\\r\\n\\r\\n\\t\\tfor ( i = 0; i < tubularSegments; i ++ ) {\\r\\n\\r\\n\\t\\t\\tgenerateSegment( i );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// if the geometry is not closed, generate the last row of vertices and normals\\r\\n\\t\\t// at the regular position on the given path\\r\\n\\t\\t//\\r\\n\\t\\t// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)\\r\\n\\r\\n\\t\\tgenerateSegment( ( closed === false ) ? tubularSegments : 0 );\\r\\n\\r\\n\\t\\t// uvs are generated in a separate function.\\r\\n\\t\\t// this makes it easy compute correct values for closed geometries\\r\\n\\r\\n\\t\\tgenerateUVs();\\r\\n\\r\\n\\t\\t// finally create faces\\r\\n\\r\\n\\t\\tgenerateIndices();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction generateSegment( i ) {\\r\\n\\r\\n\\t\\t// we use getPointAt to sample evenly distributed points from the given path\\r\\n\\r\\n\\t\\tP = path.getPointAt( i / tubularSegments, P );\\r\\n\\r\\n\\t\\t// retrieve corresponding normal and binormal\\r\\n\\r\\n\\t\\tvar N = frames.normals[ i ];\\r\\n\\t\\tvar B = frames.binormals[ i ];\\r\\n\\r\\n\\t\\t// generate normals and vertices for the current segment\\r\\n\\r\\n\\t\\tfor ( j = 0; j <= radialSegments; j ++ ) {\\r\\n\\r\\n\\t\\t\\tvar v = j / radialSegments * Math.PI * 2;\\r\\n\\r\\n\\t\\t\\tvar sin = Math.sin( v );\\r\\n\\t\\t\\tvar cos = - Math.cos( v );\\r\\n\\r\\n\\t\\t\\t// normal\\r\\n\\r\\n\\t\\t\\tnormal.x = ( cos * N.x + sin * B.x );\\r\\n\\t\\t\\tnormal.y = ( cos * N.y + sin * B.y );\\r\\n\\t\\t\\tnormal.z = ( cos * N.z + sin * B.z );\\r\\n\\t\\t\\tnormal.normalize();\\r\\n\\r\\n\\t\\t\\tnormals.push( normal.x, normal.y, normal.z );\\r\\n\\r\\n\\t\\t\\t// vertex\\r\\n\\r\\n\\t\\t\\tvertex.x = P.x + radius * normal.x;\\r\\n\\t\\t\\tvertex.y = P.y + radius * normal.y;\\r\\n\\t\\t\\tvertex.z = P.z + radius * normal.z;\\r\\n\\r\\n\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction generateIndices() {\\r\\n\\r\\n\\t\\tfor ( j = 1; j <= tubularSegments; j ++ ) {\\r\\n\\r\\n\\t\\t\\tfor ( i = 1; i <= radialSegments; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\\r\\n\\t\\t\\t\\tvar b = ( radialSegments + 1 ) * j + ( i - 1 );\\r\\n\\t\\t\\t\\tvar c = ( radialSegments + 1 ) * j + i;\\r\\n\\t\\t\\t\\tvar d = ( radialSegments + 1 ) * ( j - 1 ) + i;\\r\\n\\r\\n\\t\\t\\t\\t// faces\\r\\n\\r\\n\\t\\t\\t\\tindices.push( a, b, d );\\r\\n\\t\\t\\t\\tindices.push( b, c, d );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction generateUVs() {\\r\\n\\r\\n\\t\\tfor ( i = 0; i <= tubularSegments; i ++ ) {\\r\\n\\r\\n\\t\\t\\tfor ( j = 0; j <= radialSegments; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tuv.x = i / tubularSegments;\\r\\n\\t\\t\\t\\tuv.y = j / radialSegments;\\r\\n\\r\\n\\t\\t\\t\\tuvs.push( uv.x, uv.y );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\\r\\nTubeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\r\\nTubeBufferGeometry.prototype.constructor = TubeBufferGeometry;\\r\\n\\r\\nTubeBufferGeometry.prototype.toJSON = function () {\\r\\n\\r\\n\\tvar data = BufferGeometry.prototype.toJSON.call( this );\\r\\n\\r\\n\\tdata.path = this.parameters.path.toJSON();\\r\\n\\r\\n\\treturn data;\\r\\n\\r\\n};\\r\\n\\r\\n/**\\r\\n * @author oosmoxiecode\\r\\n * @author Mugen87 / https://github.com/Mugen87\\r\\n *\\r\\n * based on http://www.blackpawn.com/texts/pqtorus/\\r\\n */\\r\\n\\r\\n// TorusKnotGeometry\\r\\n\\r\\nfunction TorusKnotGeometry( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {\\r\\n\\r\\n\\tGeometry.call( this );\\r\\n\\r\\n\\tthis.type = 'TorusKnotGeometry';\\r\\n\\r\\n\\tthis.parameters = {\\r\\n\\t\\tradius: radius,\\r\\n\\t\\ttube: tube,\\r\\n\\t\\ttubularSegments: tubularSegments,\\r\\n\\t\\tradialSegments: radialSegments,\\r\\n\\t\\tp: p,\\r\\n\\t\\tq: q\\r\\n\\t};\\r\\n\\r\\n\\tif ( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );\\r\\n\\r\\n\\tthis.fromBufferGeometry( new TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );\\r\\n\\tthis.mergeVertices();\\r\\n\\r\\n}\\r\\n\\r\\nTorusKnotGeometry.prototype = Object.create( Geometry.prototype );\\r\\nTorusKnotGeometry.prototype.constructor = TorusKnotGeometry;\\r\\n\\r\\n// TorusKnotBufferGeometry\\r\\n\\r\\nfunction TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) {\\r\\n\\r\\n\\tBufferGeometry.call( this );\\r\\n\\r\\n\\tthis.type = 'TorusKnotBufferGeometry';\\r\\n\\r\\n\\tthis.parameters = {\\r\\n\\t\\tradius: radius,\\r\\n\\t\\ttube: tube,\\r\\n\\t\\ttubularSegments: tubularSegments,\\r\\n\\t\\tradialSegments: radialSegments,\\r\\n\\t\\tp: p,\\r\\n\\t\\tq: q\\r\\n\\t};\\r\\n\\r\\n\\tradius = radius || 1;\\r\\n\\ttube = tube || 0.4;\\r\\n\\ttubularSegments = Math.floor( tubularSegments ) || 64;\\r\\n\\tradialSegments = Math.floor( radialSegments ) || 8;\\r\\n\\tp = p || 2;\\r\\n\\tq = q || 3;\\r\\n\\r\\n\\t// buffers\\r\\n\\r\\n\\tvar indices = [];\\r\\n\\tvar vertices = [];\\r\\n\\tvar normals = [];\\r\\n\\tvar uvs = [];\\r\\n\\r\\n\\t// helper variables\\r\\n\\r\\n\\tvar i, j;\\r\\n\\r\\n\\tvar vertex = new Vector3();\\r\\n\\tvar normal = new Vector3();\\r\\n\\r\\n\\tvar P1 = new Vector3();\\r\\n\\tvar P2 = new Vector3();\\r\\n\\r\\n\\tvar B = new Vector3();\\r\\n\\tvar T = new Vector3();\\r\\n\\tvar N = new Vector3();\\r\\n\\r\\n\\t// generate vertices, normals and uvs\\r\\n\\r\\n\\tfor ( i = 0; i <= tubularSegments; ++ i ) {\\r\\n\\r\\n\\t\\t// the radian \\\"u\\\" is used to calculate the position on the torus curve of the current tubular segement\\r\\n\\r\\n\\t\\tvar u = i / tubularSegments * p * Math.PI * 2;\\r\\n\\r\\n\\t\\t// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\\r\\n\\t\\t// these points are used to create a special \\\"coordinate space\\\", which is necessary to calculate the correct vertex positions\\r\\n\\r\\n\\t\\tcalculatePositionOnCurve( u, p, q, radius, P1 );\\r\\n\\t\\tcalculatePositionOnCurve( u + 0.01, p, q, radius, P2 );\\r\\n\\r\\n\\t\\t// calculate orthonormal basis\\r\\n\\r\\n\\t\\tT.subVectors( P2, P1 );\\r\\n\\t\\tN.addVectors( P2, P1 );\\r\\n\\t\\tB.crossVectors( T, N );\\r\\n\\t\\tN.crossVectors( B, T );\\r\\n\\r\\n\\t\\t// normalize B, N. T can be ignored, we don't use it\\r\\n\\r\\n\\t\\tB.normalize();\\r\\n\\t\\tN.normalize();\\r\\n\\r\\n\\t\\tfor ( j = 0; j <= radialSegments; ++ j ) {\\r\\n\\r\\n\\t\\t\\t// now calculate the vertices. they are nothing more than an extrusion of the torus curve.\\r\\n\\t\\t\\t// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\\r\\n\\r\\n\\t\\t\\tvar v = j / radialSegments * Math.PI * 2;\\r\\n\\t\\t\\tvar cx = - tube * Math.cos( v );\\r\\n\\t\\t\\tvar cy = tube * Math.sin( v );\\r\\n\\r\\n\\t\\t\\t// now calculate the final vertex position.\\r\\n\\t\\t\\t// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve\\r\\n\\r\\n\\t\\t\\tvertex.x = P1.x + ( cx * N.x + cy * B.x );\\r\\n\\t\\t\\tvertex.y = P1.y + ( cx * N.y + cy * B.y );\\r\\n\\t\\t\\tvertex.z = P1.z + ( cx * N.z + cy * B.z );\\r\\n\\r\\n\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\r\\n\\r\\n\\t\\t\\t// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\\r\\n\\r\\n\\t\\t\\tnormal.subVectors( vertex, P1 ).normalize();\\r\\n\\r\\n\\t\\t\\tnormals.push( normal.x, normal.y, normal.z );\\r\\n\\r\\n\\t\\t\\t// uv\\r\\n\\r\\n\\t\\t\\tuvs.push( i / tubularSegments );\\r\\n\\t\\t\\tuvs.push( j / radialSegments );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// generate indices\\r\\n\\r\\n\\tfor ( j = 1; j <= tubularSegments; j ++ ) {\\r\\n\\r\\n\\t\\tfor ( i = 1; i <= radialSegments; i ++ ) {\\r\\n\\r\\n\\t\\t\\t// indices\\r\\n\\r\\n\\t\\t\\tvar a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\\r\\n\\t\\t\\tvar b = ( radialSegments + 1 ) * j + ( i - 1 );\\r\\n\\t\\t\\tvar c = ( radialSegments + 1 ) * j + i;\\r\\n\\t\\t\\tvar d = ( radialSegments + 1 ) * ( j - 1 ) + i;\\r\\n\\r\\n\\t\\t\\t// faces\\r\\n\\r\\n\\t\\t\\tindices.push( a, b, d );\\r\\n\\t\\t\\tindices.push( b, c, d );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// build geometry\\r\\n\\r\\n\\tthis.setIndex( indices );\\r\\n\\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\r\\n\\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\r\\n\\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\r\\n\\r\\n\\t// this function calculates the current position on the torus curve\\r\\n\\r\\n\\tfunction calculatePositionOnCurve( u, p, q, radius, position ) {\\r\\n\\r\\n\\t\\tvar cu = Math.cos( u );\\r\\n\\t\\tvar su = Math.sin( u );\\r\\n\\t\\tvar quOverP = q / p * u;\\r\\n\\t\\tvar cs = Math.cos( quOverP );\\r\\n\\r\\n\\t\\tposition.x = radius * ( 2 + cs ) * 0.5 * cu;\\r\\n\\t\\tposition.y = radius * ( 2 + cs ) * su * 0.5;\\r\\n\\t\\tposition.z = radius * Math.sin( quOverP ) * 0.5;\\r\\n\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\\r\\nTorusKnotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\r\\nTorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;\\r\\n\\r\\n/**\\r\\n * @author oosmoxiecode\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n * @author Mugen87 / https://github.com/Mugen87\\r\\n */\\r\\n\\r\\n// TorusGeometry\\r\\n\\r\\nfunction TorusGeometry( radius, tube, radialSegments, tubularSegments, arc ) {\\r\\n\\r\\n\\tGeometry.call( this );\\r\\n\\r\\n\\tthis.type = 'TorusGeometry';\\r\\n\\r\\n\\tthis.parameters = {\\r\\n\\t\\tradius: radius,\\r\\n\\t\\ttube: tube,\\r\\n\\t\\tradialSegments: radialSegments,\\r\\n\\t\\ttubularSegments: tubularSegments,\\r\\n\\t\\tarc: arc\\r\\n\\t};\\r\\n\\r\\n\\tthis.fromBufferGeometry( new TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );\\r\\n\\tthis.mergeVertices();\\r\\n\\r\\n}\\r\\n\\r\\nTorusGeometry.prototype = Object.create( Geometry.prototype );\\r\\nTorusGeometry.prototype.constructor = TorusGeometry;\\r\\n\\r\\n// TorusBufferGeometry\\r\\n\\r\\nfunction TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) {\\r\\n\\r\\n\\tBufferGeometry.call( this );\\r\\n\\r\\n\\tthis.type = 'TorusBufferGeometry';\\r\\n\\r\\n\\tthis.parameters = {\\r\\n\\t\\tradius: radius,\\r\\n\\t\\ttube: tube,\\r\\n\\t\\tradialSegments: radialSegments,\\r\\n\\t\\ttubularSegments: tubularSegments,\\r\\n\\t\\tarc: arc\\r\\n\\t};\\r\\n\\r\\n\\tradius = radius || 1;\\r\\n\\ttube = tube || 0.4;\\r\\n\\tradialSegments = Math.floor( radialSegments ) || 8;\\r\\n\\ttubularSegments = Math.floor( tubularSegments ) || 6;\\r\\n\\tarc = arc || Math.PI * 2;\\r\\n\\r\\n\\t// buffers\\r\\n\\r\\n\\tvar indices = [];\\r\\n\\tvar vertices = [];\\r\\n\\tvar normals = [];\\r\\n\\tvar uvs = [];\\r\\n\\r\\n\\t// helper variables\\r\\n\\r\\n\\tvar center = new Vector3();\\r\\n\\tvar vertex = new Vector3();\\r\\n\\tvar normal = new Vector3();\\r\\n\\r\\n\\tvar j, i;\\r\\n\\r\\n\\t// generate vertices, normals and uvs\\r\\n\\r\\n\\tfor ( j = 0; j <= radialSegments; j ++ ) {\\r\\n\\r\\n\\t\\tfor ( i = 0; i <= tubularSegments; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar u = i / tubularSegments * arc;\\r\\n\\t\\t\\tvar v = j / radialSegments * Math.PI * 2;\\r\\n\\r\\n\\t\\t\\t// vertex\\r\\n\\r\\n\\t\\t\\tvertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );\\r\\n\\t\\t\\tvertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );\\r\\n\\t\\t\\tvertex.z = tube * Math.sin( v );\\r\\n\\r\\n\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\r\\n\\r\\n\\t\\t\\t// normal\\r\\n\\r\\n\\t\\t\\tcenter.x = radius * Math.cos( u );\\r\\n\\t\\t\\tcenter.y = radius * Math.sin( u );\\r\\n\\t\\t\\tnormal.subVectors( vertex, center ).normalize();\\r\\n\\r\\n\\t\\t\\tnormals.push( normal.x, normal.y, normal.z );\\r\\n\\r\\n\\t\\t\\t// uv\\r\\n\\r\\n\\t\\t\\tuvs.push( i / tubularSegments );\\r\\n\\t\\t\\tuvs.push( j / radialSegments );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// generate indices\\r\\n\\r\\n\\tfor ( j = 1; j <= radialSegments; j ++ ) {\\r\\n\\r\\n\\t\\tfor ( i = 1; i <= tubularSegments; i ++ ) {\\r\\n\\r\\n\\t\\t\\t// indices\\r\\n\\r\\n\\t\\t\\tvar a = ( tubularSegments + 1 ) * j + i - 1;\\r\\n\\t\\t\\tvar b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;\\r\\n\\t\\t\\tvar c = ( tubularSegments + 1 ) * ( j - 1 ) + i;\\r\\n\\t\\t\\tvar d = ( tubularSegments + 1 ) * j + i;\\r\\n\\r\\n\\t\\t\\t// faces\\r\\n\\r\\n\\t\\t\\tindices.push( a, b, d );\\r\\n\\t\\t\\tindices.push( b, c, d );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// build geometry\\r\\n\\r\\n\\tthis.setIndex( indices );\\r\\n\\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\r\\n\\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\r\\n\\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\r\\n\\r\\n}\\r\\n\\r\\nTorusBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\r\\nTorusBufferGeometry.prototype.constructor = TorusBufferGeometry;\\r\\n\\r\\n/**\\r\\n * @author Mugen87 / https://github.com/Mugen87\\r\\n * Port from https://github.com/mapbox/earcut (v2.2.2)\\r\\n */\\r\\n\\r\\nvar Earcut = {\\r\\n\\r\\n\\ttriangulate: function ( data, holeIndices, dim ) {\\r\\n\\r\\n\\t\\tdim = dim || 2;\\r\\n\\r\\n\\t\\tvar hasHoles = holeIndices && holeIndices.length,\\r\\n\\t\\t\\touterLen = hasHoles ? holeIndices[ 0 ] * dim : data.length,\\r\\n\\t\\t\\touterNode = linkedList( data, 0, outerLen, dim, true ),\\r\\n\\t\\t\\ttriangles = [];\\r\\n\\r\\n\\t\\tif ( ! outerNode || outerNode.next === outerNode.prev ) return triangles;\\r\\n\\r\\n\\t\\tvar minX, minY, maxX, maxY, x, y, invSize;\\r\\n\\r\\n\\t\\tif ( hasHoles ) outerNode = eliminateHoles( data, holeIndices, outerNode, dim );\\r\\n\\r\\n\\t\\t// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\\r\\n\\t\\tif ( data.length > 80 * dim ) {\\r\\n\\r\\n\\t\\t\\tminX = maxX = data[ 0 ];\\r\\n\\t\\t\\tminY = maxY = data[ 1 ];\\r\\n\\r\\n\\t\\t\\tfor ( var i = dim; i < outerLen; i += dim ) {\\r\\n\\r\\n\\t\\t\\t\\tx = data[ i ];\\r\\n\\t\\t\\t\\ty = data[ i + 1 ];\\r\\n\\t\\t\\t\\tif ( x < minX ) minX = x;\\r\\n\\t\\t\\t\\tif ( y < minY ) minY = y;\\r\\n\\t\\t\\t\\tif ( x > maxX ) maxX = x;\\r\\n\\t\\t\\t\\tif ( y > maxY ) maxY = y;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// minX, minY and invSize are later used to transform coords into integers for z-order calculation\\r\\n\\t\\t\\tinvSize = Math.max( maxX - minX, maxY - minY );\\r\\n\\t\\t\\tinvSize = invSize !== 0 ? 1 / invSize : 0;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tearcutLinked( outerNode, triangles, dim, minX, minY, invSize );\\r\\n\\r\\n\\t\\treturn triangles;\\r\\n\\r\\n\\t}\\r\\n\\r\\n};\\r\\n\\r\\n// create a circular doubly linked list from polygon points in the specified winding order\\r\\nfunction linkedList( data, start, end, dim, clockwise ) {\\r\\n\\r\\n\\tvar i, last;\\r\\n\\r\\n\\tif ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) {\\r\\n\\r\\n\\t\\tfor ( i = start; i < end; i += dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );\\r\\n\\r\\n\\t} else {\\r\\n\\r\\n\\t\\tfor ( i = end - dim; i >= start; i -= dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tif ( last && equals( last, last.next ) ) {\\r\\n\\r\\n\\t\\tremoveNode( last );\\r\\n\\t\\tlast = last.next;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn last;\\r\\n\\r\\n}\\r\\n\\r\\n// eliminate colinear or duplicate points\\r\\nfunction filterPoints( start, end ) {\\r\\n\\r\\n\\tif ( ! start ) return start;\\r\\n\\tif ( ! end ) end = start;\\r\\n\\r\\n\\tvar p = start,\\r\\n\\t\\tagain;\\r\\n\\tdo {\\r\\n\\r\\n\\t\\tagain = false;\\r\\n\\r\\n\\t\\tif ( ! p.steiner && ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) {\\r\\n\\r\\n\\t\\t\\tremoveNode( p );\\r\\n\\t\\t\\tp = end = p.prev;\\r\\n\\t\\t\\tif ( p === p.next ) break;\\r\\n\\t\\t\\tagain = true;\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tp = p.next;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} while ( again || p !== end );\\r\\n\\r\\n\\treturn end;\\r\\n\\r\\n}\\r\\n\\r\\n// main ear slicing loop which triangulates a polygon (given as a linked list)\\r\\nfunction earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {\\r\\n\\r\\n\\tif ( ! ear ) return;\\r\\n\\r\\n\\t// interlink polygon nodes in z-order\\r\\n\\tif ( ! pass && invSize ) indexCurve( ear, minX, minY, invSize );\\r\\n\\r\\n\\tvar stop = ear,\\r\\n\\t\\tprev, next;\\r\\n\\r\\n\\t// iterate through ears, slicing them one by one\\r\\n\\twhile ( ear.prev !== ear.next ) {\\r\\n\\r\\n\\t\\tprev = ear.prev;\\r\\n\\t\\tnext = ear.next;\\r\\n\\r\\n\\t\\tif ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {\\r\\n\\r\\n\\t\\t\\t// cut off the triangle\\r\\n\\t\\t\\ttriangles.push( prev.i / dim );\\r\\n\\t\\t\\ttriangles.push( ear.i / dim );\\r\\n\\t\\t\\ttriangles.push( next.i / dim );\\r\\n\\r\\n\\t\\t\\tremoveNode( ear );\\r\\n\\r\\n\\t\\t\\t// skipping the next vertex leads to less sliver triangles\\r\\n\\t\\t\\tear = next.next;\\r\\n\\t\\t\\tstop = next.next;\\r\\n\\r\\n\\t\\t\\tcontinue;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tear = next;\\r\\n\\r\\n\\t\\t// if we looped through the whole remaining polygon and can't find any more ears\\r\\n\\t\\tif ( ear === stop ) {\\r\\n\\r\\n\\t\\t\\t// try filtering points and slicing again\\r\\n\\t\\t\\tif ( ! pass ) {\\r\\n\\r\\n\\t\\t\\t\\tearcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );\\r\\n\\r\\n\\t\\t\\t\\t// if this didn't work, try curing all small self-intersections locally\\r\\n\\r\\n\\t\\t\\t} else if ( pass === 1 ) {\\r\\n\\r\\n\\t\\t\\t\\tear = cureLocalIntersections( filterPoints( ear ), triangles, dim );\\r\\n\\t\\t\\t\\tearcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );\\r\\n\\r\\n\\t\\t\\t\\t// as a last resort, try splitting the remaining polygon into two\\r\\n\\r\\n\\t\\t\\t} else if ( pass === 2 ) {\\r\\n\\r\\n\\t\\t\\t\\tsplitEarcut( ear, triangles, dim, minX, minY, invSize );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\\r\\n// check whether a polygon node forms a valid ear with adjacent nodes\\r\\nfunction isEar( ear ) {\\r\\n\\r\\n\\tvar a = ear.prev,\\r\\n\\t\\tb = ear,\\r\\n\\t\\tc = ear.next;\\r\\n\\r\\n\\tif ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear\\r\\n\\r\\n\\t// now make sure we don't have other points inside the potential ear\\r\\n\\tvar p = ear.next.next;\\r\\n\\r\\n\\twhile ( p !== ear.prev ) {\\r\\n\\r\\n\\t\\tif ( pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&\\r\\n\\t\\t\\tarea( p.prev, p, p.next ) >= 0 ) return false;\\r\\n\\t\\tp = p.next;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn true;\\r\\n\\r\\n}\\r\\n\\r\\nfunction isEarHashed( ear, minX, minY, invSize ) {\\r\\n\\r\\n\\tvar a = ear.prev,\\r\\n\\t\\tb = ear,\\r\\n\\t\\tc = ear.next;\\r\\n\\r\\n\\tif ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear\\r\\n\\r\\n\\t// triangle bbox; min & max are calculated like this for speed\\r\\n\\tvar minTX = a.x < b.x ? ( a.x < c.x ? a.x : c.x ) : ( b.x < c.x ? b.x : c.x ),\\r\\n\\t\\tminTY = a.y < b.y ? ( a.y < c.y ? a.y : c.y ) : ( b.y < c.y ? b.y : c.y ),\\r\\n\\t\\tmaxTX = a.x > b.x ? ( a.x > c.x ? a.x : c.x ) : ( b.x > c.x ? b.x : c.x ),\\r\\n\\t\\tmaxTY = a.y > b.y ? ( a.y > c.y ? a.y : c.y ) : ( b.y > c.y ? b.y : c.y );\\r\\n\\r\\n\\t// z-order range for the current triangle bbox;\\r\\n\\tvar minZ = zOrder( minTX, minTY, minX, minY, invSize ),\\r\\n\\t\\tmaxZ = zOrder( maxTX, maxTY, minX, minY, invSize );\\r\\n\\r\\n\\tvar p = ear.prevZ,\\r\\n\\t\\tn = ear.nextZ;\\r\\n\\r\\n\\t// look for points inside the triangle in both directions\\r\\n\\twhile ( p && p.z >= minZ && n && n.z <= maxZ ) {\\r\\n\\r\\n\\t\\tif ( p !== ear.prev && p !== ear.next &&\\r\\n\\t\\t\\tpointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&\\r\\n\\t\\t\\tarea( p.prev, p, p.next ) >= 0 ) return false;\\r\\n\\t\\tp = p.prevZ;\\r\\n\\r\\n\\t\\tif ( n !== ear.prev && n !== ear.next &&\\r\\n\\t\\t\\tpointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y ) &&\\r\\n\\t\\t\\tarea( n.prev, n, n.next ) >= 0 ) return false;\\r\\n\\t\\tn = n.nextZ;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// look for remaining points in decreasing z-order\\r\\n\\twhile ( p && p.z >= minZ ) {\\r\\n\\r\\n\\t\\tif ( p !== ear.prev && p !== ear.next &&\\r\\n\\t\\t\\tpointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&\\r\\n\\t\\t\\tarea( p.prev, p, p.next ) >= 0 ) return false;\\r\\n\\t\\tp = p.prevZ;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// look for remaining points in increasing z-order\\r\\n\\twhile ( n && n.z <= maxZ ) {\\r\\n\\r\\n\\t\\tif ( n !== ear.prev && n !== ear.next &&\\r\\n\\t\\t\\tpointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y ) &&\\r\\n\\t\\t\\tarea( n.prev, n, n.next ) >= 0 ) return false;\\r\\n\\t\\tn = n.nextZ;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn true;\\r\\n\\r\\n}\\r\\n\\r\\n// go through all polygon nodes and cure small local self-intersections\\r\\nfunction cureLocalIntersections( start, triangles, dim ) {\\r\\n\\r\\n\\tvar p = start;\\r\\n\\tdo {\\r\\n\\r\\n\\t\\tvar a = p.prev,\\r\\n\\t\\t\\tb = p.next.next;\\r\\n\\r\\n\\t\\tif ( ! equals( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) {\\r\\n\\r\\n\\t\\t\\ttriangles.push( a.i / dim );\\r\\n\\t\\t\\ttriangles.push( p.i / dim );\\r\\n\\t\\t\\ttriangles.push( b.i / dim );\\r\\n\\r\\n\\t\\t\\t// remove two nodes involved\\r\\n\\t\\t\\tremoveNode( p );\\r\\n\\t\\t\\tremoveNode( p.next );\\r\\n\\r\\n\\t\\t\\tp = start = b;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tp = p.next;\\r\\n\\r\\n\\t} while ( p !== start );\\r\\n\\r\\n\\treturn filterPoints( p );\\r\\n\\r\\n}\\r\\n\\r\\n// try splitting polygon into two and triangulate them independently\\r\\nfunction splitEarcut( start, triangles, dim, minX, minY, invSize ) {\\r\\n\\r\\n\\t// look for a valid diagonal that divides the polygon into two\\r\\n\\tvar a = start;\\r\\n\\tdo {\\r\\n\\r\\n\\t\\tvar b = a.next.next;\\r\\n\\t\\twhile ( b !== a.prev ) {\\r\\n\\r\\n\\t\\t\\tif ( a.i !== b.i && isValidDiagonal( a, b ) ) {\\r\\n\\r\\n\\t\\t\\t\\t// split the polygon in two by the diagonal\\r\\n\\t\\t\\t\\tvar c = splitPolygon( a, b );\\r\\n\\r\\n\\t\\t\\t\\t// filter colinear points around the cuts\\r\\n\\t\\t\\t\\ta = filterPoints( a, a.next );\\r\\n\\t\\t\\t\\tc = filterPoints( c, c.next );\\r\\n\\r\\n\\t\\t\\t\\t// run earcut on each half\\r\\n\\t\\t\\t\\tearcutLinked( a, triangles, dim, minX, minY, invSize );\\r\\n\\t\\t\\t\\tearcutLinked( c, triangles, dim, minX, minY, invSize );\\r\\n\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tb = b.next;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\ta = a.next;\\r\\n\\r\\n\\t} while ( a !== start );\\r\\n\\r\\n}\\r\\n\\r\\n// link every hole into the outer loop, producing a single-ring polygon without holes\\r\\nfunction eliminateHoles( data, holeIndices, outerNode, dim ) {\\r\\n\\r\\n\\tvar queue = [],\\r\\n\\t\\ti, len, start, end, list;\\r\\n\\r\\n\\tfor ( i = 0, len = holeIndices.length; i < len; i ++ ) {\\r\\n\\r\\n\\t\\tstart = holeIndices[ i ] * dim;\\r\\n\\t\\tend = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;\\r\\n\\t\\tlist = linkedList( data, start, end, dim, false );\\r\\n\\t\\tif ( list === list.next ) list.steiner = true;\\r\\n\\t\\tqueue.push( getLeftmost( list ) );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tqueue.sort( compareX );\\r\\n\\r\\n\\t// process holes from left to right\\r\\n\\tfor ( i = 0; i < queue.length; i ++ ) {\\r\\n\\r\\n\\t\\teliminateHole( queue[ i ], outerNode );\\r\\n\\t\\touterNode = filterPoints( outerNode, outerNode.next );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn outerNode;\\r\\n\\r\\n}\\r\\n\\r\\nfunction compareX( a, b ) {\\r\\n\\r\\n\\treturn a.x - b.x;\\r\\n\\r\\n}\\r\\n\\r\\n// find a bridge between vertices that connects hole with an outer ring and and link it\\r\\nfunction eliminateHole( hole, outerNode ) {\\r\\n\\r\\n\\touterNode = findHoleBridge( hole, outerNode );\\r\\n\\tif ( outerNode ) {\\r\\n\\r\\n\\t\\tvar b = splitPolygon( outerNode, hole );\\r\\n\\r\\n\\t\\t// filter collinear points around the cuts\\r\\n\\t\\tfilterPoints( outerNode, outerNode.next );\\r\\n\\t\\tfilterPoints( b, b.next );\\r\\n\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\\r\\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\\r\\nfunction findHoleBridge( hole, outerNode ) {\\r\\n\\r\\n\\tvar p = outerNode,\\r\\n\\t\\thx = hole.x,\\r\\n\\t\\thy = hole.y,\\r\\n\\t\\tqx = - Infinity,\\r\\n\\t\\tm;\\r\\n\\r\\n\\t// find a segment intersected by a ray from the hole's leftmost point to the left;\\r\\n\\t// segment's endpoint with lesser x will be potential connection point\\r\\n\\tdo {\\r\\n\\r\\n\\t\\tif ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {\\r\\n\\r\\n\\t\\t\\tvar x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );\\r\\n\\t\\t\\tif ( x <= hx && x > qx ) {\\r\\n\\r\\n\\t\\t\\t\\tqx = x;\\r\\n\\t\\t\\t\\tif ( x === hx ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( hy === p.y ) return p;\\r\\n\\t\\t\\t\\t\\tif ( hy === p.next.y ) return p.next;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tm = p.x < p.next.x ? p : p.next;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tp = p.next;\\r\\n\\r\\n\\t} while ( p !== outerNode );\\r\\n\\r\\n\\tif ( ! m ) return null;\\r\\n\\r\\n\\tif ( hx === qx ) return m; // hole touches outer segment; pick leftmost endpoint\\r\\n\\r\\n\\t// look for points inside the triangle of hole point, segment intersection and endpoint;\\r\\n\\t// if there are no points found, we have a valid connection;\\r\\n\\t// otherwise choose the point of the minimum angle with the ray as connection point\\r\\n\\r\\n\\tvar stop = m,\\r\\n\\t\\tmx = m.x,\\r\\n\\t\\tmy = m.y,\\r\\n\\t\\ttanMin = Infinity,\\r\\n\\t\\ttan;\\r\\n\\r\\n\\tp = m;\\r\\n\\r\\n\\tdo {\\r\\n\\r\\n\\t\\tif ( hx >= p.x && p.x >= mx && hx !== p.x &&\\r\\n\\t\\t\\t\\tpointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {\\r\\n\\r\\n\\t\\t\\ttan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential\\r\\n\\r\\n\\t\\t\\tif ( locallyInside( p, hole ) && ( tan < tanMin || ( tan === tanMin && ( p.x > m.x || ( p.x === m.x && sectorContainsSector( m, p ) ) ) ) ) ) {\\r\\n\\r\\n\\t\\t\\t\\tm = p;\\r\\n\\t\\t\\t\\ttanMin = tan;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tp = p.next;\\r\\n\\r\\n\\t} while ( p !== stop );\\r\\n\\r\\n\\treturn m;\\r\\n\\r\\n}\\r\\n\\r\\n// whether sector in vertex m contains sector in vertex p in the same coordinates\\r\\nfunction sectorContainsSector( m, p ) {\\r\\n\\r\\n\\treturn area( m.prev, m, p.prev ) < 0 && area( p.next, m, m.next ) < 0;\\r\\n\\r\\n}\\r\\n\\r\\n// interlink polygon nodes in z-order\\r\\nfunction indexCurve( start, minX, minY, invSize ) {\\r\\n\\r\\n\\tvar p = start;\\r\\n\\tdo {\\r\\n\\r\\n\\t\\tif ( p.z === null ) p.z = zOrder( p.x, p.y, minX, minY, invSize );\\r\\n\\t\\tp.prevZ = p.prev;\\r\\n\\t\\tp.nextZ = p.next;\\r\\n\\t\\tp = p.next;\\r\\n\\r\\n\\t} while ( p !== start );\\r\\n\\r\\n\\tp.prevZ.nextZ = null;\\r\\n\\tp.prevZ = null;\\r\\n\\r\\n\\tsortLinked( p );\\r\\n\\r\\n}\\r\\n\\r\\n// Simon Tatham's linked list merge sort algorithm\\r\\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\\r\\nfunction sortLinked( list ) {\\r\\n\\r\\n\\tvar i, p, q, e, tail, numMerges, pSize, qSize,\\r\\n\\t\\tinSize = 1;\\r\\n\\r\\n\\tdo {\\r\\n\\r\\n\\t\\tp = list;\\r\\n\\t\\tlist = null;\\r\\n\\t\\ttail = null;\\r\\n\\t\\tnumMerges = 0;\\r\\n\\r\\n\\t\\twhile ( p ) {\\r\\n\\r\\n\\t\\t\\tnumMerges ++;\\r\\n\\t\\t\\tq = p;\\r\\n\\t\\t\\tpSize = 0;\\r\\n\\t\\t\\tfor ( i = 0; i < inSize; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tpSize ++;\\r\\n\\t\\t\\t\\tq = q.nextZ;\\r\\n\\t\\t\\t\\tif ( ! q ) break;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tqSize = inSize;\\r\\n\\r\\n\\t\\t\\twhile ( pSize > 0 || ( qSize > 0 && q ) ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\te = p;\\r\\n\\t\\t\\t\\t\\tp = p.nextZ;\\r\\n\\t\\t\\t\\t\\tpSize --;\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\te = q;\\r\\n\\t\\t\\t\\t\\tq = q.nextZ;\\r\\n\\t\\t\\t\\t\\tqSize --;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( tail ) tail.nextZ = e;\\r\\n\\t\\t\\t\\telse list = e;\\r\\n\\r\\n\\t\\t\\t\\te.prevZ = tail;\\r\\n\\t\\t\\t\\ttail = e;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tp = q;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\ttail.nextZ = null;\\r\\n\\t\\tinSize *= 2;\\r\\n\\r\\n\\t} while ( numMerges > 1 );\\r\\n\\r\\n\\treturn list;\\r\\n\\r\\n}\\r\\n\\r\\n// z-order of a point given coords and inverse of the longer side of data bbox\\r\\nfunction zOrder( x, y, minX, minY, invSize ) {\\r\\n\\r\\n\\t// coords are transformed into non-negative 15-bit integer range\\r\\n\\tx = 32767 * ( x - minX ) * invSize;\\r\\n\\ty = 32767 * ( y - minY ) * invSize;\\r\\n\\r\\n\\tx = ( x | ( x << 8 ) ) & 0x00FF00FF;\\r\\n\\tx = ( x | ( x << 4 ) ) & 0x0F0F0F0F;\\r\\n\\tx = ( x | ( x << 2 ) ) & 0x33333333;\\r\\n\\tx = ( x | ( x << 1 ) ) & 0x55555555;\\r\\n\\r\\n\\ty = ( y | ( y << 8 ) ) & 0x00FF00FF;\\r\\n\\ty = ( y | ( y << 4 ) ) & 0x0F0F0F0F;\\r\\n\\ty = ( y | ( y << 2 ) ) & 0x33333333;\\r\\n\\ty = ( y | ( y << 1 ) ) & 0x55555555;\\r\\n\\r\\n\\treturn x | ( y << 1 );\\r\\n\\r\\n}\\r\\n\\r\\n// find the leftmost node of a polygon ring\\r\\nfunction getLeftmost( start ) {\\r\\n\\r\\n\\tvar p = start,\\r\\n\\t\\tleftmost = start;\\r\\n\\tdo {\\r\\n\\r\\n\\t\\tif ( p.x < leftmost.x || ( p.x === leftmost.x && p.y < leftmost.y ) ) leftmost = p;\\r\\n\\t\\tp = p.next;\\r\\n\\r\\n\\t} while ( p !== start );\\r\\n\\r\\n\\treturn leftmost;\\r\\n\\r\\n}\\r\\n\\r\\n// check if a point lies within a convex triangle\\r\\nfunction pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {\\r\\n\\r\\n\\treturn ( cx - px ) * ( ay - py ) - ( ax - px ) * ( cy - py ) >= 0 &&\\r\\n\\t\\t\\t( ax - px ) * ( by - py ) - ( bx - px ) * ( ay - py ) >= 0 &&\\r\\n\\t\\t\\t( bx - px ) * ( cy - py ) - ( cx - px ) * ( by - py ) >= 0;\\r\\n\\r\\n}\\r\\n\\r\\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\\r\\nfunction isValidDiagonal( a, b ) {\\r\\n\\r\\n\\treturn a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon( a, b ) && // dones't intersect other edges\\r\\n\\t\\t( locallyInside( a, b ) && locallyInside( b, a ) && middleInside( a, b ) && // locally visible\\r\\n\\t\\t( area( a.prev, a, b.prev ) || area( a, b.prev, b ) ) || // does not create opposite-facing sectors\\r\\n\\t\\tequals( a, b ) && area( a.prev, a, a.next ) > 0 && area( b.prev, b, b.next ) > 0 ); // special zero-length case\\r\\n\\r\\n}\\r\\n\\r\\n// signed area of a triangle\\r\\nfunction area( p, q, r ) {\\r\\n\\r\\n\\treturn ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );\\r\\n\\r\\n}\\r\\n\\r\\n// check if two points are equal\\r\\nfunction equals( p1, p2 ) {\\r\\n\\r\\n\\treturn p1.x === p2.x && p1.y === p2.y;\\r\\n\\r\\n}\\r\\n\\r\\n// check if two segments intersect\\r\\nfunction intersects( p1, q1, p2, q2 ) {\\r\\n\\r\\n\\tvar o1 = sign( area( p1, q1, p2 ) );\\r\\n\\tvar o2 = sign( area( p1, q1, q2 ) );\\r\\n\\tvar o3 = sign( area( p2, q2, p1 ) );\\r\\n\\tvar o4 = sign( area( p2, q2, q1 ) );\\r\\n\\r\\n\\tif ( o1 !== o2 && o3 !== o4 ) return true; // general case\\r\\n\\r\\n\\tif ( o1 === 0 && onSegment( p1, p2, q1 ) ) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\\r\\n\\tif ( o2 === 0 && onSegment( p1, q2, q1 ) ) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\\r\\n\\tif ( o3 === 0 && onSegment( p2, p1, q2 ) ) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\\r\\n\\tif ( o4 === 0 && onSegment( p2, q1, q2 ) ) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\\r\\n\\r\\n\\treturn false;\\r\\n\\r\\n}\\r\\n\\r\\n// for collinear points p, q, r, check if point q lies on segment pr\\r\\nfunction onSegment( p, q, r ) {\\r\\n\\r\\n\\treturn q.x <= Math.max( p.x, r.x ) && q.x >= Math.min( p.x, r.x ) && q.y <= Math.max( p.y, r.y ) && q.y >= Math.min( p.y, r.y );\\r\\n\\r\\n}\\r\\n\\r\\nfunction sign( num ) {\\r\\n\\r\\n\\treturn num > 0 ? 1 : num < 0 ? - 1 : 0;\\r\\n\\r\\n}\\r\\n\\r\\n// check if a polygon diagonal intersects any polygon segments\\r\\nfunction intersectsPolygon( a, b ) {\\r\\n\\r\\n\\tvar p = a;\\r\\n\\tdo {\\r\\n\\r\\n\\t\\tif ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\\r\\n\\t\\t\\t\\tintersects( p, p.next, a, b ) ) return true;\\r\\n\\t\\tp = p.next;\\r\\n\\r\\n\\t} while ( p !== a );\\r\\n\\r\\n\\treturn false;\\r\\n\\r\\n}\\r\\n\\r\\n// check if a polygon diagonal is locally inside the polygon\\r\\nfunction locallyInside( a, b ) {\\r\\n\\r\\n\\treturn area( a.prev, a, a.next ) < 0 ?\\r\\n\\t\\tarea( a, b, a.next ) >= 0 && area( a, a.prev, b ) >= 0 :\\r\\n\\t\\tarea( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0;\\r\\n\\r\\n}\\r\\n\\r\\n// check if the middle point of a polygon diagonal is inside the polygon\\r\\nfunction middleInside( a, b ) {\\r\\n\\r\\n\\tvar p = a,\\r\\n\\t\\tinside = false,\\r\\n\\t\\tpx = ( a.x + b.x ) / 2,\\r\\n\\t\\tpy = ( a.y + b.y ) / 2;\\r\\n\\tdo {\\r\\n\\r\\n\\t\\tif ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&\\r\\n\\t\\t\\t\\t( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) )\\r\\n\\t\\t\\tinside = ! inside;\\r\\n\\t\\tp = p.next;\\r\\n\\r\\n\\t} while ( p !== a );\\r\\n\\r\\n\\treturn inside;\\r\\n\\r\\n}\\r\\n\\r\\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\\r\\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\\r\\nfunction splitPolygon( a, b ) {\\r\\n\\r\\n\\tvar a2 = new Node( a.i, a.x, a.y ),\\r\\n\\t\\tb2 = new Node( b.i, b.x, b.y ),\\r\\n\\t\\tan = a.next,\\r\\n\\t\\tbp = b.prev;\\r\\n\\r\\n\\ta.next = b;\\r\\n\\tb.prev = a;\\r\\n\\r\\n\\ta2.next = an;\\r\\n\\tan.prev = a2;\\r\\n\\r\\n\\tb2.next = a2;\\r\\n\\ta2.prev = b2;\\r\\n\\r\\n\\tbp.next = b2;\\r\\n\\tb2.prev = bp;\\r\\n\\r\\n\\treturn b2;\\r\\n\\r\\n}\\r\\n\\r\\n// create a node and optionally link it with previous one (in a circular doubly linked list)\\r\\nfunction insertNode( i, x, y, last ) {\\r\\n\\r\\n\\tvar p = new Node( i, x, y );\\r\\n\\r\\n\\tif ( ! last ) {\\r\\n\\r\\n\\t\\tp.prev = p;\\r\\n\\t\\tp.next = p;\\r\\n\\r\\n\\t} else {\\r\\n\\r\\n\\t\\tp.next = last.next;\\r\\n\\t\\tp.prev = last;\\r\\n\\t\\tlast.next.prev = p;\\r\\n\\t\\tlast.next = p;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn p;\\r\\n\\r\\n}\\r\\n\\r\\nfunction removeNode( p ) {\\r\\n\\r\\n\\tp.next.prev = p.prev;\\r\\n\\tp.prev.next = p.next;\\r\\n\\r\\n\\tif ( p.prevZ ) p.prevZ.nextZ = p.nextZ;\\r\\n\\tif ( p.nextZ ) p.nextZ.prevZ = p.prevZ;\\r\\n\\r\\n}\\r\\n\\r\\nfunction Node( i, x, y ) {\\r\\n\\r\\n\\t// vertex index in coordinates array\\r\\n\\tthis.i = i;\\r\\n\\r\\n\\t// vertex coordinates\\r\\n\\tthis.x = x;\\r\\n\\tthis.y = y;\\r\\n\\r\\n\\t// previous and next vertex nodes in a polygon ring\\r\\n\\tthis.prev = null;\\r\\n\\tthis.next = null;\\r\\n\\r\\n\\t// z-order curve value\\r\\n\\tthis.z = null;\\r\\n\\r\\n\\t// previous and next nodes in z-order\\r\\n\\tthis.prevZ = null;\\r\\n\\tthis.nextZ = null;\\r\\n\\r\\n\\t// indicates whether this is a steiner point\\r\\n\\tthis.steiner = false;\\r\\n\\r\\n}\\r\\n\\r\\nfunction signedArea( data, start, end, dim ) {\\r\\n\\r\\n\\tvar sum = 0;\\r\\n\\tfor ( var i = start, j = end - dim; i < end; i += dim ) {\\r\\n\\r\\n\\t\\tsum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );\\r\\n\\t\\tj = i;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn sum;\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * @author zz85 / http://www.lab4games.net/zz85/blog\\r\\n */\\r\\n\\r\\nvar ShapeUtils = {\\r\\n\\r\\n\\t// calculate area of the contour polygon\\r\\n\\r\\n\\tarea: function ( contour ) {\\r\\n\\r\\n\\t\\tvar n = contour.length;\\r\\n\\t\\tvar a = 0.0;\\r\\n\\r\\n\\t\\tfor ( var p = n - 1, q = 0; q < n; p = q ++ ) {\\r\\n\\r\\n\\t\\t\\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn a * 0.5;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tisClockWise: function ( pts ) {\\r\\n\\r\\n\\t\\treturn ShapeUtils.area( pts ) < 0;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttriangulateShape: function ( contour, holes ) {\\r\\n\\r\\n\\t\\tvar vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]\\r\\n\\t\\tvar holeIndices = []; // array of hole indices\\r\\n\\t\\tvar faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]\\r\\n\\r\\n\\t\\tremoveDupEndPts( contour );\\r\\n\\t\\taddContour( vertices, contour );\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\tvar holeIndex = contour.length;\\r\\n\\r\\n\\t\\tholes.forEach( removeDupEndPts );\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < holes.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\tholeIndices.push( holeIndex );\\r\\n\\t\\t\\tholeIndex += holes[ i ].length;\\r\\n\\t\\t\\taddContour( vertices, holes[ i ] );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\tvar triangles = Earcut.triangulate( vertices, holeIndices );\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < triangles.length; i += 3 ) {\\r\\n\\r\\n\\t\\t\\tfaces.push( triangles.slice( i, i + 3 ) );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn faces;\\r\\n\\r\\n\\t}\\r\\n\\r\\n};\\r\\n\\r\\nfunction removeDupEndPts( points ) {\\r\\n\\r\\n\\tvar l = points.length;\\r\\n\\r\\n\\tif ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {\\r\\n\\r\\n\\t\\tpoints.pop();\\r\\n\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\\r\\nfunction addContour( vertices, contour ) {\\r\\n\\r\\n\\tfor ( var i = 0; i < contour.length; i ++ ) {\\r\\n\\r\\n\\t\\tvertices.push( contour[ i ].x );\\r\\n\\t\\tvertices.push( contour[ i ].y );\\r\\n\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * @author zz85 / http://www.lab4games.net/zz85/blog\\r\\n *\\r\\n * Creates extruded geometry from a path shape.\\r\\n *\\r\\n * parameters = {\\r\\n *\\r\\n *  curveSegments: <int>, // number of points on the curves\\r\\n *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\\r\\n *  depth: <float>, // Depth to extrude the shape\\r\\n *\\r\\n *  bevelEnabled: <bool>, // turn on bevel\\r\\n *  bevelThickness: <float>, // how deep into the original shape bevel goes\\r\\n *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel\\r\\n *  bevelOffset: <float>, // how far from shape outline does bevel start\\r\\n *  bevelSegments: <int>, // number of bevel layers\\r\\n *\\r\\n *  extrudePath: <THREE.Curve> // curve to extrude shape along\\r\\n *\\r\\n *  UVGenerator: <Object> // object that provides UV generator functions\\r\\n *\\r\\n * }\\r\\n */\\r\\n\\r\\n// ExtrudeGeometry\\r\\n\\r\\nfunction ExtrudeGeometry( shapes, options ) {\\r\\n\\r\\n\\tGeometry.call( this );\\r\\n\\r\\n\\tthis.type = 'ExtrudeGeometry';\\r\\n\\r\\n\\tthis.parameters = {\\r\\n\\t\\tshapes: shapes,\\r\\n\\t\\toptions: options\\r\\n\\t};\\r\\n\\r\\n\\tthis.fromBufferGeometry( new ExtrudeBufferGeometry( shapes, options ) );\\r\\n\\tthis.mergeVertices();\\r\\n\\r\\n}\\r\\n\\r\\nExtrudeGeometry.prototype = Object.create( Geometry.prototype );\\r\\nExtrudeGeometry.prototype.constructor = ExtrudeGeometry;\\r\\n\\r\\nExtrudeGeometry.prototype.toJSON = function () {\\r\\n\\r\\n\\tvar data = Geometry.prototype.toJSON.call( this );\\r\\n\\r\\n\\tvar shapes = this.parameters.shapes;\\r\\n\\tvar options = this.parameters.options;\\r\\n\\r\\n\\treturn toJSON( shapes, options, data );\\r\\n\\r\\n};\\r\\n\\r\\n// ExtrudeBufferGeometry\\r\\n\\r\\nfunction ExtrudeBufferGeometry( shapes, options ) {\\r\\n\\r\\n\\tBufferGeometry.call( this );\\r\\n\\r\\n\\tthis.type = 'ExtrudeBufferGeometry';\\r\\n\\r\\n\\tthis.parameters = {\\r\\n\\t\\tshapes: shapes,\\r\\n\\t\\toptions: options\\r\\n\\t};\\r\\n\\r\\n\\tshapes = Array.isArray( shapes ) ? shapes : [ shapes ];\\r\\n\\r\\n\\tvar scope = this;\\r\\n\\r\\n\\tvar verticesArray = [];\\r\\n\\tvar uvArray = [];\\r\\n\\r\\n\\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\tvar shape = shapes[ i ];\\r\\n\\t\\taddShape( shape );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// build geometry\\r\\n\\r\\n\\tthis.setAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );\\r\\n\\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );\\r\\n\\r\\n\\tthis.computeVertexNormals();\\r\\n\\r\\n\\t// functions\\r\\n\\r\\n\\tfunction addShape( shape ) {\\r\\n\\r\\n\\t\\tvar placeholder = [];\\r\\n\\r\\n\\t\\t// options\\r\\n\\r\\n\\t\\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\\r\\n\\t\\tvar steps = options.steps !== undefined ? options.steps : 1;\\r\\n\\t\\tvar depth = options.depth !== undefined ? options.depth : 100;\\r\\n\\r\\n\\t\\tvar bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;\\r\\n\\t\\tvar bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;\\r\\n\\t\\tvar bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;\\r\\n\\t\\tvar bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;\\r\\n\\t\\tvar bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\\r\\n\\r\\n\\t\\tvar extrudePath = options.extrudePath;\\r\\n\\r\\n\\t\\tvar uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;\\r\\n\\r\\n\\t\\t// deprecated options\\r\\n\\r\\n\\t\\tif ( options.amount !== undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.ExtrudeBufferGeometry: amount has been renamed to depth.' );\\r\\n\\t\\t\\tdepth = options.amount;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t//\\r\\n\\r\\n\\t\\tvar extrudePts, extrudeByPath = false;\\r\\n\\t\\tvar splineTube, binormal, normal, position2;\\r\\n\\r\\n\\t\\tif ( extrudePath ) {\\r\\n\\r\\n\\t\\t\\textrudePts = extrudePath.getSpacedPoints( steps );\\r\\n\\r\\n\\t\\t\\textrudeByPath = true;\\r\\n\\t\\t\\tbevelEnabled = false; // bevels not supported for path extrusion\\r\\n\\r\\n\\t\\t\\t// SETUP TNB variables\\r\\n\\r\\n\\t\\t\\t// TODO1 - have a .isClosed in spline?\\r\\n\\r\\n\\t\\t\\tsplineTube = extrudePath.computeFrenetFrames( steps, false );\\r\\n\\r\\n\\t\\t\\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\\r\\n\\r\\n\\t\\t\\tbinormal = new Vector3();\\r\\n\\t\\t\\tnormal = new Vector3();\\r\\n\\t\\t\\tposition2 = new Vector3();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Safeguards if bevels are not enabled\\r\\n\\r\\n\\t\\tif ( ! bevelEnabled ) {\\r\\n\\r\\n\\t\\t\\tbevelSegments = 0;\\r\\n\\t\\t\\tbevelThickness = 0;\\r\\n\\t\\t\\tbevelSize = 0;\\r\\n\\t\\t\\tbevelOffset = 0;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Variables initialization\\r\\n\\r\\n\\t\\tvar ahole, h, hl; // looping of holes\\r\\n\\r\\n\\t\\tvar shapePoints = shape.extractPoints( curveSegments );\\r\\n\\r\\n\\t\\tvar vertices = shapePoints.shape;\\r\\n\\t\\tvar holes = shapePoints.holes;\\r\\n\\r\\n\\t\\tvar reverse = ! ShapeUtils.isClockWise( vertices );\\r\\n\\r\\n\\t\\tif ( reverse ) {\\r\\n\\r\\n\\t\\t\\tvertices = vertices.reverse();\\r\\n\\r\\n\\t\\t\\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\\r\\n\\r\\n\\t\\t\\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tahole = holes[ h ];\\r\\n\\r\\n\\t\\t\\t\\tif ( ShapeUtils.isClockWise( ahole ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tholes[ h ] = ahole.reverse();\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\r\\n\\t\\tvar faces = ShapeUtils.triangulateShape( vertices, holes );\\r\\n\\r\\n\\t\\t/* Vertices */\\r\\n\\r\\n\\t\\tvar contour = vertices; // vertices has all points but contour has only points of circumference\\r\\n\\r\\n\\t\\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\\r\\n\\r\\n\\t\\t\\tahole = holes[ h ];\\r\\n\\r\\n\\t\\t\\tvertices = vertices.concat( ahole );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\r\\n\\t\\tfunction scalePt2( pt, vec, size ) {\\r\\n\\r\\n\\t\\t\\tif ( ! vec ) console.error( \\\"THREE.ExtrudeGeometry: vec does not exist\\\" );\\r\\n\\r\\n\\t\\t\\treturn vec.clone().multiplyScalar( size ).add( pt );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar b, bs, t, z,\\r\\n\\t\\t\\tvert, vlen = vertices.length,\\r\\n\\t\\t\\tface, flen = faces.length;\\r\\n\\r\\n\\r\\n\\t\\t// Find directions for point movement\\r\\n\\r\\n\\r\\n\\t\\tfunction getBevelVec( inPt, inPrev, inNext ) {\\r\\n\\r\\n\\t\\t\\t// computes for inPt the corresponding point inPt' on a new contour\\r\\n\\t\\t\\t//   shifted by 1 unit (length of normalized vector) to the left\\r\\n\\t\\t\\t// if we walk along contour clockwise, this new contour is outside the old one\\r\\n\\t\\t\\t//\\r\\n\\t\\t\\t// inPt' is the intersection of the two lines parallel to the two\\r\\n\\t\\t\\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\\r\\n\\r\\n\\t\\t\\tvar v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt\\r\\n\\r\\n\\t\\t\\t// good reading for geometry algorithms (here: line-line intersection)\\r\\n\\t\\t\\t// http://geomalgorithms.com/a05-_intersect-1.html\\r\\n\\r\\n\\t\\t\\tvar v_prev_x = inPt.x - inPrev.x,\\r\\n\\t\\t\\t\\tv_prev_y = inPt.y - inPrev.y;\\r\\n\\t\\t\\tvar v_next_x = inNext.x - inPt.x,\\r\\n\\t\\t\\t\\tv_next_y = inNext.y - inPt.y;\\r\\n\\r\\n\\t\\t\\tvar v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\\r\\n\\r\\n\\t\\t\\t// check for collinear edges\\r\\n\\t\\t\\tvar collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\\r\\n\\r\\n\\t\\t\\tif ( Math.abs( collinear0 ) > Number.EPSILON ) {\\r\\n\\r\\n\\t\\t\\t\\t// not collinear\\r\\n\\r\\n\\t\\t\\t\\t// length of vectors for normalizing\\r\\n\\r\\n\\t\\t\\t\\tvar v_prev_len = Math.sqrt( v_prev_lensq );\\r\\n\\t\\t\\t\\tvar v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\\r\\n\\r\\n\\t\\t\\t\\t// shift adjacent points by unit vectors to the left\\r\\n\\r\\n\\t\\t\\t\\tvar ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\\r\\n\\t\\t\\t\\tvar ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\\r\\n\\r\\n\\t\\t\\t\\tvar ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\\r\\n\\t\\t\\t\\tvar ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\\r\\n\\r\\n\\t\\t\\t\\t// scaling factor for v_prev to intersection point\\r\\n\\r\\n\\t\\t\\t\\tvar sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\\r\\n\\t\\t\\t\\t\\t\\t( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /\\r\\n\\t\\t\\t\\t\\t( v_prev_x * v_next_y - v_prev_y * v_next_x );\\r\\n\\r\\n\\t\\t\\t\\t// vector from inPt to intersection point\\r\\n\\r\\n\\t\\t\\t\\tv_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\\r\\n\\t\\t\\t\\tv_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\\r\\n\\r\\n\\t\\t\\t\\t// Don't normalize!, otherwise sharp corners become ugly\\r\\n\\t\\t\\t\\t//  but prevent crazy spikes\\r\\n\\t\\t\\t\\tvar v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );\\r\\n\\t\\t\\t\\tif ( v_trans_lensq <= 2 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\treturn new Vector2( v_trans_x, v_trans_y );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tshrink_by = Math.sqrt( v_trans_lensq / 2 );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t// handle special case of collinear edges\\r\\n\\r\\n\\t\\t\\t\\tvar direction_eq = false; // assumes: opposite\\r\\n\\t\\t\\t\\tif ( v_prev_x > Number.EPSILON ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( v_next_x > Number.EPSILON ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tdirection_eq = true;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( v_prev_x < - Number.EPSILON ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( v_next_x < - Number.EPSILON ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tdirection_eq = true;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tdirection_eq = true;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( direction_eq ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// console.log(\\\"Warning: lines are a straight sequence\\\");\\r\\n\\t\\t\\t\\t\\tv_trans_x = - v_prev_y;\\r\\n\\t\\t\\t\\t\\tv_trans_y = v_prev_x;\\r\\n\\t\\t\\t\\t\\tshrink_by = Math.sqrt( v_prev_lensq );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t// console.log(\\\"Warning: lines are a straight spike\\\");\\r\\n\\t\\t\\t\\t\\tv_trans_x = v_prev_x;\\r\\n\\t\\t\\t\\t\\tv_trans_y = v_prev_y;\\r\\n\\t\\t\\t\\t\\tshrink_by = Math.sqrt( v_prev_lensq / 2 );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\r\\n\\t\\tvar contourMovements = [];\\r\\n\\r\\n\\t\\tfor ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\\r\\n\\r\\n\\t\\t\\tif ( j === il ) j = 0;\\r\\n\\t\\t\\tif ( k === il ) k = 0;\\r\\n\\r\\n\\t\\t\\t//  (j)---(i)---(k)\\r\\n\\t\\t\\t// console.log('i,j,k', i, j , k)\\r\\n\\r\\n\\t\\t\\tcontourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar holesMovements = [],\\r\\n\\t\\t\\toneHoleMovements, verticesMovements = contourMovements.concat();\\r\\n\\r\\n\\t\\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\\r\\n\\r\\n\\t\\t\\tahole = holes[ h ];\\r\\n\\r\\n\\t\\t\\toneHoleMovements = [];\\r\\n\\r\\n\\t\\t\\tfor ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( j === il ) j = 0;\\r\\n\\t\\t\\t\\tif ( k === il ) k = 0;\\r\\n\\r\\n\\t\\t\\t\\t//  (j)---(i)---(k)\\r\\n\\t\\t\\t\\toneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tholesMovements.push( oneHoleMovements );\\r\\n\\t\\t\\tverticesMovements = verticesMovements.concat( oneHoleMovements );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\r\\n\\t\\t// Loop bevelSegments, 1 for the front, 1 for the back\\r\\n\\r\\n\\t\\tfor ( b = 0; b < bevelSegments; b ++ ) {\\r\\n\\r\\n\\t\\t\\t//for ( b = bevelSegments; b > 0; b -- ) {\\r\\n\\r\\n\\t\\t\\tt = b / bevelSegments;\\r\\n\\t\\t\\tz = bevelThickness * Math.cos( t * Math.PI / 2 );\\r\\n\\t\\t\\tbs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;\\r\\n\\r\\n\\t\\t\\t// contract shape\\r\\n\\r\\n\\t\\t\\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\\r\\n\\r\\n\\t\\t\\t\\tv( vert.x, vert.y, - z );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// expand holes\\r\\n\\r\\n\\t\\t\\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tahole = holes[ h ];\\r\\n\\t\\t\\t\\toneHoleMovements = holesMovements[ h ];\\r\\n\\r\\n\\t\\t\\t\\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\\r\\n\\r\\n\\t\\t\\t\\t\\tv( vert.x, vert.y, - z );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tbs = bevelSize + bevelOffset;\\r\\n\\r\\n\\t\\t// Back facing vertices\\r\\n\\r\\n\\t\\tfor ( i = 0; i < vlen; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\\r\\n\\r\\n\\t\\t\\tif ( ! extrudeByPath ) {\\r\\n\\r\\n\\t\\t\\t\\tv( vert.x, vert.y, 0 );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\\r\\n\\r\\n\\t\\t\\t\\tnormal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );\\r\\n\\t\\t\\t\\tbinormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );\\r\\n\\r\\n\\t\\t\\t\\tposition2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );\\r\\n\\r\\n\\t\\t\\t\\tv( position2.x, position2.y, position2.z );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Add stepped vertices...\\r\\n\\t\\t// Including front facing vertices\\r\\n\\r\\n\\t\\tvar s;\\r\\n\\r\\n\\t\\tfor ( s = 1; s <= steps; s ++ ) {\\r\\n\\r\\n\\t\\t\\tfor ( i = 0; i < vlen; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\\r\\n\\r\\n\\t\\t\\t\\tif ( ! extrudeByPath ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tv( vert.x, vert.y, depth / steps * s );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\\r\\n\\r\\n\\t\\t\\t\\t\\tnormal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );\\r\\n\\t\\t\\t\\t\\tbinormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );\\r\\n\\r\\n\\t\\t\\t\\t\\tposition2.copy( extrudePts[ s ] ).add( normal ).add( binormal );\\r\\n\\r\\n\\t\\t\\t\\t\\tv( position2.x, position2.y, position2.z );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\r\\n\\t\\t// Add bevel segments planes\\r\\n\\r\\n\\t\\t//for ( b = 1; b <= bevelSegments; b ++ ) {\\r\\n\\t\\tfor ( b = bevelSegments - 1; b >= 0; b -- ) {\\r\\n\\r\\n\\t\\t\\tt = b / bevelSegments;\\r\\n\\t\\t\\tz = bevelThickness * Math.cos( t * Math.PI / 2 );\\r\\n\\t\\t\\tbs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;\\r\\n\\r\\n\\t\\t\\t// contract shape\\r\\n\\r\\n\\t\\t\\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\\r\\n\\t\\t\\t\\tv( vert.x, vert.y, depth + z );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// expand holes\\r\\n\\r\\n\\t\\t\\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tahole = holes[ h ];\\r\\n\\t\\t\\t\\toneHoleMovements = holesMovements[ h ];\\r\\n\\r\\n\\t\\t\\t\\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( ! extrudeByPath ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tv( vert.x, vert.y, depth + z );\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t/* Faces */\\r\\n\\r\\n\\t\\t// Top and bottom faces\\r\\n\\r\\n\\t\\tbuildLidFaces();\\r\\n\\r\\n\\t\\t// Sides faces\\r\\n\\r\\n\\t\\tbuildSideFaces();\\r\\n\\r\\n\\r\\n\\t\\t/////  Internal functions\\r\\n\\r\\n\\t\\tfunction buildLidFaces() {\\r\\n\\r\\n\\t\\t\\tvar start = verticesArray.length / 3;\\r\\n\\r\\n\\t\\t\\tif ( bevelEnabled ) {\\r\\n\\r\\n\\t\\t\\t\\tvar layer = 0; // steps + 1\\r\\n\\t\\t\\t\\tvar offset = vlen * layer;\\r\\n\\r\\n\\t\\t\\t\\t// Bottom faces\\r\\n\\r\\n\\t\\t\\t\\tfor ( i = 0; i < flen; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tface = faces[ i ];\\r\\n\\t\\t\\t\\t\\tf3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tlayer = steps + bevelSegments * 2;\\r\\n\\t\\t\\t\\toffset = vlen * layer;\\r\\n\\r\\n\\t\\t\\t\\t// Top faces\\r\\n\\r\\n\\t\\t\\t\\tfor ( i = 0; i < flen; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tface = faces[ i ];\\r\\n\\t\\t\\t\\t\\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t// Bottom faces\\r\\n\\r\\n\\t\\t\\t\\tfor ( i = 0; i < flen; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tface = faces[ i ];\\r\\n\\t\\t\\t\\t\\tf3( face[ 2 ], face[ 1 ], face[ 0 ] );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t// Top faces\\r\\n\\r\\n\\t\\t\\t\\tfor ( i = 0; i < flen; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tface = faces[ i ];\\r\\n\\t\\t\\t\\t\\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tscope.addGroup( start, verticesArray.length / 3 - start, 0 );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Create faces for the z-sides of the shape\\r\\n\\r\\n\\t\\tfunction buildSideFaces() {\\r\\n\\r\\n\\t\\t\\tvar start = verticesArray.length / 3;\\r\\n\\t\\t\\tvar layeroffset = 0;\\r\\n\\t\\t\\tsidewalls( contour, layeroffset );\\r\\n\\t\\t\\tlayeroffset += contour.length;\\r\\n\\r\\n\\t\\t\\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tahole = holes[ h ];\\r\\n\\t\\t\\t\\tsidewalls( ahole, layeroffset );\\r\\n\\r\\n\\t\\t\\t\\t//, true\\r\\n\\t\\t\\t\\tlayeroffset += ahole.length;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\r\\n\\t\\t\\tscope.addGroup( start, verticesArray.length / 3 - start, 1 );\\r\\n\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction sidewalls( contour, layeroffset ) {\\r\\n\\r\\n\\t\\t\\tvar j, k;\\r\\n\\t\\t\\ti = contour.length;\\r\\n\\r\\n\\t\\t\\twhile ( -- i >= 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tj = i;\\r\\n\\t\\t\\t\\tk = i - 1;\\r\\n\\t\\t\\t\\tif ( k < 0 ) k = contour.length - 1;\\r\\n\\r\\n\\t\\t\\t\\t//console.log('b', i,j, i-1, k,vertices.length);\\r\\n\\r\\n\\t\\t\\t\\tvar s = 0,\\r\\n\\t\\t\\t\\t\\tsl = steps + bevelSegments * 2;\\r\\n\\r\\n\\t\\t\\t\\tfor ( s = 0; s < sl; s ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar slen1 = vlen * s;\\r\\n\\t\\t\\t\\t\\tvar slen2 = vlen * ( s + 1 );\\r\\n\\r\\n\\t\\t\\t\\t\\tvar a = layeroffset + j + slen1,\\r\\n\\t\\t\\t\\t\\t\\tb = layeroffset + k + slen1,\\r\\n\\t\\t\\t\\t\\t\\tc = layeroffset + k + slen2,\\r\\n\\t\\t\\t\\t\\t\\td = layeroffset + j + slen2;\\r\\n\\r\\n\\t\\t\\t\\t\\tf4( a, b, c, d );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction v( x, y, z ) {\\r\\n\\r\\n\\t\\t\\tplaceholder.push( x );\\r\\n\\t\\t\\tplaceholder.push( y );\\r\\n\\t\\t\\tplaceholder.push( z );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\r\\n\\t\\tfunction f3( a, b, c ) {\\r\\n\\r\\n\\t\\t\\taddVertex( a );\\r\\n\\t\\t\\taddVertex( b );\\r\\n\\t\\t\\taddVertex( c );\\r\\n\\r\\n\\t\\t\\tvar nextIndex = verticesArray.length / 3;\\r\\n\\t\\t\\tvar uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );\\r\\n\\r\\n\\t\\t\\taddUV( uvs[ 0 ] );\\r\\n\\t\\t\\taddUV( uvs[ 1 ] );\\r\\n\\t\\t\\taddUV( uvs[ 2 ] );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction f4( a, b, c, d ) {\\r\\n\\r\\n\\t\\t\\taddVertex( a );\\r\\n\\t\\t\\taddVertex( b );\\r\\n\\t\\t\\taddVertex( d );\\r\\n\\r\\n\\t\\t\\taddVertex( b );\\r\\n\\t\\t\\taddVertex( c );\\r\\n\\t\\t\\taddVertex( d );\\r\\n\\r\\n\\r\\n\\t\\t\\tvar nextIndex = verticesArray.length / 3;\\r\\n\\t\\t\\tvar uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );\\r\\n\\r\\n\\t\\t\\taddUV( uvs[ 0 ] );\\r\\n\\t\\t\\taddUV( uvs[ 1 ] );\\r\\n\\t\\t\\taddUV( uvs[ 3 ] );\\r\\n\\r\\n\\t\\t\\taddUV( uvs[ 1 ] );\\r\\n\\t\\t\\taddUV( uvs[ 2 ] );\\r\\n\\t\\t\\taddUV( uvs[ 3 ] );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction addVertex( index ) {\\r\\n\\r\\n\\t\\t\\tverticesArray.push( placeholder[ index * 3 + 0 ] );\\r\\n\\t\\t\\tverticesArray.push( placeholder[ index * 3 + 1 ] );\\r\\n\\t\\t\\tverticesArray.push( placeholder[ index * 3 + 2 ] );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\r\\n\\t\\tfunction addUV( vector2 ) {\\r\\n\\r\\n\\t\\t\\tuvArray.push( vector2.x );\\r\\n\\t\\t\\tuvArray.push( vector2.y );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\\r\\nExtrudeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\r\\nExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;\\r\\n\\r\\nExtrudeBufferGeometry.prototype.toJSON = function () {\\r\\n\\r\\n\\tvar data = BufferGeometry.prototype.toJSON.call( this );\\r\\n\\r\\n\\tvar shapes = this.parameters.shapes;\\r\\n\\tvar options = this.parameters.options;\\r\\n\\r\\n\\treturn toJSON( shapes, options, data );\\r\\n\\r\\n};\\r\\n\\r\\n//\\r\\n\\r\\nvar WorldUVGenerator = {\\r\\n\\r\\n\\tgenerateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {\\r\\n\\r\\n\\t\\tvar a_x = vertices[ indexA * 3 ];\\r\\n\\t\\tvar a_y = vertices[ indexA * 3 + 1 ];\\r\\n\\t\\tvar b_x = vertices[ indexB * 3 ];\\r\\n\\t\\tvar b_y = vertices[ indexB * 3 + 1 ];\\r\\n\\t\\tvar c_x = vertices[ indexC * 3 ];\\r\\n\\t\\tvar c_y = vertices[ indexC * 3 + 1 ];\\r\\n\\r\\n\\t\\treturn [\\r\\n\\t\\t\\tnew Vector2( a_x, a_y ),\\r\\n\\t\\t\\tnew Vector2( b_x, b_y ),\\r\\n\\t\\t\\tnew Vector2( c_x, c_y )\\r\\n\\t\\t];\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgenerateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {\\r\\n\\r\\n\\t\\tvar a_x = vertices[ indexA * 3 ];\\r\\n\\t\\tvar a_y = vertices[ indexA * 3 + 1 ];\\r\\n\\t\\tvar a_z = vertices[ indexA * 3 + 2 ];\\r\\n\\t\\tvar b_x = vertices[ indexB * 3 ];\\r\\n\\t\\tvar b_y = vertices[ indexB * 3 + 1 ];\\r\\n\\t\\tvar b_z = vertices[ indexB * 3 + 2 ];\\r\\n\\t\\tvar c_x = vertices[ indexC * 3 ];\\r\\n\\t\\tvar c_y = vertices[ indexC * 3 + 1 ];\\r\\n\\t\\tvar c_z = vertices[ indexC * 3 + 2 ];\\r\\n\\t\\tvar d_x = vertices[ indexD * 3 ];\\r\\n\\t\\tvar d_y = vertices[ indexD * 3 + 1 ];\\r\\n\\t\\tvar d_z = vertices[ indexD * 3 + 2 ];\\r\\n\\r\\n\\t\\tif ( Math.abs( a_y - b_y ) < 0.01 ) {\\r\\n\\r\\n\\t\\t\\treturn [\\r\\n\\t\\t\\t\\tnew Vector2( a_x, 1 - a_z ),\\r\\n\\t\\t\\t\\tnew Vector2( b_x, 1 - b_z ),\\r\\n\\t\\t\\t\\tnew Vector2( c_x, 1 - c_z ),\\r\\n\\t\\t\\t\\tnew Vector2( d_x, 1 - d_z )\\r\\n\\t\\t\\t];\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\treturn [\\r\\n\\t\\t\\t\\tnew Vector2( a_y, 1 - a_z ),\\r\\n\\t\\t\\t\\tnew Vector2( b_y, 1 - b_z ),\\r\\n\\t\\t\\t\\tnew Vector2( c_y, 1 - c_z ),\\r\\n\\t\\t\\t\\tnew Vector2( d_y, 1 - d_z )\\r\\n\\t\\t\\t];\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n};\\r\\n\\r\\nfunction toJSON( shapes, options, data ) {\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tdata.shapes = [];\\r\\n\\r\\n\\tif ( Array.isArray( shapes ) ) {\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar shape = shapes[ i ];\\r\\n\\r\\n\\t\\t\\tdata.shapes.push( shape.uuid );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} else {\\r\\n\\r\\n\\t\\tdata.shapes.push( shapes.uuid );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tif ( options.extrudePath !== undefined ) data.options.extrudePath = options.extrudePath.toJSON();\\r\\n\\r\\n\\treturn data;\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * @author zz85 / http://www.lab4games.net/zz85/blog\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n *\\r\\n * Text = 3D Text\\r\\n *\\r\\n * parameters = {\\r\\n *  font: <THREE.Font>, // font\\r\\n *\\r\\n *  size: <float>, // size of the text\\r\\n *  height: <float>, // thickness to extrude text\\r\\n *  curveSegments: <int>, // number of points on the curves\\r\\n *\\r\\n *  bevelEnabled: <bool>, // turn on bevel\\r\\n *  bevelThickness: <float>, // how deep into text bevel goes\\r\\n *  bevelSize: <float>, // how far from text outline (including bevelOffset) is bevel\\r\\n *  bevelOffset: <float> // how far from text outline does bevel start\\r\\n * }\\r\\n */\\r\\n\\r\\n// TextGeometry\\r\\n\\r\\nfunction TextGeometry( text, parameters ) {\\r\\n\\r\\n\\tGeometry.call( this );\\r\\n\\r\\n\\tthis.type = 'TextGeometry';\\r\\n\\r\\n\\tthis.parameters = {\\r\\n\\t\\ttext: text,\\r\\n\\t\\tparameters: parameters\\r\\n\\t};\\r\\n\\r\\n\\tthis.fromBufferGeometry( new TextBufferGeometry( text, parameters ) );\\r\\n\\tthis.mergeVertices();\\r\\n\\r\\n}\\r\\n\\r\\nTextGeometry.prototype = Object.create( Geometry.prototype );\\r\\nTextGeometry.prototype.constructor = TextGeometry;\\r\\n\\r\\n// TextBufferGeometry\\r\\n\\r\\nfunction TextBufferGeometry( text, parameters ) {\\r\\n\\r\\n\\tparameters = parameters || {};\\r\\n\\r\\n\\tvar font = parameters.font;\\r\\n\\r\\n\\tif ( ! ( font && font.isFont ) ) {\\r\\n\\r\\n\\t\\tconsole.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );\\r\\n\\t\\treturn new Geometry();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tvar shapes = font.generateShapes( text, parameters.size );\\r\\n\\r\\n\\t// translate parameters to ExtrudeGeometry API\\r\\n\\r\\n\\tparameters.depth = parameters.height !== undefined ? parameters.height : 50;\\r\\n\\r\\n\\t// defaults\\r\\n\\r\\n\\tif ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;\\r\\n\\tif ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;\\r\\n\\tif ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;\\r\\n\\r\\n\\tExtrudeBufferGeometry.call( this, shapes, parameters );\\r\\n\\r\\n\\tthis.type = 'TextBufferGeometry';\\r\\n\\r\\n}\\r\\n\\r\\nTextBufferGeometry.prototype = Object.create( ExtrudeBufferGeometry.prototype );\\r\\nTextBufferGeometry.prototype.constructor = TextBufferGeometry;\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n * @author benaadams / https://twitter.com/ben_a_adams\\r\\n * @author Mugen87 / https://github.com/Mugen87\\r\\n */\\r\\n\\r\\n// SphereGeometry\\r\\n\\r\\nfunction SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\\r\\n\\r\\n\\tGeometry.call( this );\\r\\n\\r\\n\\tthis.type = 'SphereGeometry';\\r\\n\\r\\n\\tthis.parameters = {\\r\\n\\t\\tradius: radius,\\r\\n\\t\\twidthSegments: widthSegments,\\r\\n\\t\\theightSegments: heightSegments,\\r\\n\\t\\tphiStart: phiStart,\\r\\n\\t\\tphiLength: phiLength,\\r\\n\\t\\tthetaStart: thetaStart,\\r\\n\\t\\tthetaLength: thetaLength\\r\\n\\t};\\r\\n\\r\\n\\tthis.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );\\r\\n\\tthis.mergeVertices();\\r\\n\\r\\n}\\r\\n\\r\\nSphereGeometry.prototype = Object.create( Geometry.prototype );\\r\\nSphereGeometry.prototype.constructor = SphereGeometry;\\r\\n\\r\\n// SphereBufferGeometry\\r\\n\\r\\nfunction SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\\r\\n\\r\\n\\tBufferGeometry.call( this );\\r\\n\\r\\n\\tthis.type = 'SphereBufferGeometry';\\r\\n\\r\\n\\tthis.parameters = {\\r\\n\\t\\tradius: radius,\\r\\n\\t\\twidthSegments: widthSegments,\\r\\n\\t\\theightSegments: heightSegments,\\r\\n\\t\\tphiStart: phiStart,\\r\\n\\t\\tphiLength: phiLength,\\r\\n\\t\\tthetaStart: thetaStart,\\r\\n\\t\\tthetaLength: thetaLength\\r\\n\\t};\\r\\n\\r\\n\\tradius = radius || 1;\\r\\n\\r\\n\\twidthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );\\r\\n\\theightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );\\r\\n\\r\\n\\tphiStart = phiStart !== undefined ? phiStart : 0;\\r\\n\\tphiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\\r\\n\\r\\n\\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\\r\\n\\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\\r\\n\\r\\n\\tvar thetaEnd = Math.min( thetaStart + thetaLength, Math.PI );\\r\\n\\r\\n\\tvar ix, iy;\\r\\n\\r\\n\\tvar index = 0;\\r\\n\\tvar grid = [];\\r\\n\\r\\n\\tvar vertex = new Vector3();\\r\\n\\tvar normal = new Vector3();\\r\\n\\r\\n\\t// buffers\\r\\n\\r\\n\\tvar indices = [];\\r\\n\\tvar vertices = [];\\r\\n\\tvar normals = [];\\r\\n\\tvar uvs = [];\\r\\n\\r\\n\\t// generate vertices, normals and uvs\\r\\n\\r\\n\\tfor ( iy = 0; iy <= heightSegments; iy ++ ) {\\r\\n\\r\\n\\t\\tvar verticesRow = [];\\r\\n\\r\\n\\t\\tvar v = iy / heightSegments;\\r\\n\\r\\n\\t\\t// special case for the poles\\r\\n\\r\\n\\t\\tvar uOffset = 0;\\r\\n\\r\\n\\t\\tif ( iy == 0 && thetaStart == 0 ) {\\r\\n\\r\\n\\t\\t\\tuOffset = 0.5 / widthSegments;\\r\\n\\r\\n\\t\\t} else if ( iy == heightSegments && thetaEnd == Math.PI ) {\\r\\n\\r\\n\\t\\t\\tuOffset = - 0.5 / widthSegments;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfor ( ix = 0; ix <= widthSegments; ix ++ ) {\\r\\n\\r\\n\\t\\t\\tvar u = ix / widthSegments;\\r\\n\\r\\n\\t\\t\\t// vertex\\r\\n\\r\\n\\t\\t\\tvertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\\r\\n\\t\\t\\tvertex.y = radius * Math.cos( thetaStart + v * thetaLength );\\r\\n\\t\\t\\tvertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\\r\\n\\r\\n\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\r\\n\\r\\n\\t\\t\\t// normal\\r\\n\\r\\n\\t\\t\\tnormal.copy( vertex ).normalize();\\r\\n\\t\\t\\tnormals.push( normal.x, normal.y, normal.z );\\r\\n\\r\\n\\t\\t\\t// uv\\r\\n\\r\\n\\t\\t\\tuvs.push( u + uOffset, 1 - v );\\r\\n\\r\\n\\t\\t\\tverticesRow.push( index ++ );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tgrid.push( verticesRow );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// indices\\r\\n\\r\\n\\tfor ( iy = 0; iy < heightSegments; iy ++ ) {\\r\\n\\r\\n\\t\\tfor ( ix = 0; ix < widthSegments; ix ++ ) {\\r\\n\\r\\n\\t\\t\\tvar a = grid[ iy ][ ix + 1 ];\\r\\n\\t\\t\\tvar b = grid[ iy ][ ix ];\\r\\n\\t\\t\\tvar c = grid[ iy + 1 ][ ix ];\\r\\n\\t\\t\\tvar d = grid[ iy + 1 ][ ix + 1 ];\\r\\n\\r\\n\\t\\t\\tif ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );\\r\\n\\t\\t\\tif ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// build geometry\\r\\n\\r\\n\\tthis.setIndex( indices );\\r\\n\\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\r\\n\\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\r\\n\\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\r\\n\\r\\n}\\r\\n\\r\\nSphereBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\r\\nSphereBufferGeometry.prototype.constructor = SphereBufferGeometry;\\r\\n\\r\\n/**\\r\\n * @author Kaleb Murphy\\r\\n * @author Mugen87 / https://github.com/Mugen87\\r\\n */\\r\\n\\r\\n// RingGeometry\\r\\n\\r\\nfunction RingGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\\r\\n\\r\\n\\tGeometry.call( this );\\r\\n\\r\\n\\tthis.type = 'RingGeometry';\\r\\n\\r\\n\\tthis.parameters = {\\r\\n\\t\\tinnerRadius: innerRadius,\\r\\n\\t\\touterRadius: outerRadius,\\r\\n\\t\\tthetaSegments: thetaSegments,\\r\\n\\t\\tphiSegments: phiSegments,\\r\\n\\t\\tthetaStart: thetaStart,\\r\\n\\t\\tthetaLength: thetaLength\\r\\n\\t};\\r\\n\\r\\n\\tthis.fromBufferGeometry( new RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );\\r\\n\\tthis.mergeVertices();\\r\\n\\r\\n}\\r\\n\\r\\nRingGeometry.prototype = Object.create( Geometry.prototype );\\r\\nRingGeometry.prototype.constructor = RingGeometry;\\r\\n\\r\\n// RingBufferGeometry\\r\\n\\r\\nfunction RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\\r\\n\\r\\n\\tBufferGeometry.call( this );\\r\\n\\r\\n\\tthis.type = 'RingBufferGeometry';\\r\\n\\r\\n\\tthis.parameters = {\\r\\n\\t\\tinnerRadius: innerRadius,\\r\\n\\t\\touterRadius: outerRadius,\\r\\n\\t\\tthetaSegments: thetaSegments,\\r\\n\\t\\tphiSegments: phiSegments,\\r\\n\\t\\tthetaStart: thetaStart,\\r\\n\\t\\tthetaLength: thetaLength\\r\\n\\t};\\r\\n\\r\\n\\tinnerRadius = innerRadius || 0.5;\\r\\n\\touterRadius = outerRadius || 1;\\r\\n\\r\\n\\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\\r\\n\\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\\r\\n\\r\\n\\tthetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;\\r\\n\\tphiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;\\r\\n\\r\\n\\t// buffers\\r\\n\\r\\n\\tvar indices = [];\\r\\n\\tvar vertices = [];\\r\\n\\tvar normals = [];\\r\\n\\tvar uvs = [];\\r\\n\\r\\n\\t// some helper variables\\r\\n\\r\\n\\tvar segment;\\r\\n\\tvar radius = innerRadius;\\r\\n\\tvar radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\\r\\n\\tvar vertex = new Vector3();\\r\\n\\tvar uv = new Vector2();\\r\\n\\tvar j, i;\\r\\n\\r\\n\\t// generate vertices, normals and uvs\\r\\n\\r\\n\\tfor ( j = 0; j <= phiSegments; j ++ ) {\\r\\n\\r\\n\\t\\tfor ( i = 0; i <= thetaSegments; i ++ ) {\\r\\n\\r\\n\\t\\t\\t// values are generate from the inside of the ring to the outside\\r\\n\\r\\n\\t\\t\\tsegment = thetaStart + i / thetaSegments * thetaLength;\\r\\n\\r\\n\\t\\t\\t// vertex\\r\\n\\r\\n\\t\\t\\tvertex.x = radius * Math.cos( segment );\\r\\n\\t\\t\\tvertex.y = radius * Math.sin( segment );\\r\\n\\r\\n\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\r\\n\\r\\n\\t\\t\\t// normal\\r\\n\\r\\n\\t\\t\\tnormals.push( 0, 0, 1 );\\r\\n\\r\\n\\t\\t\\t// uv\\r\\n\\r\\n\\t\\t\\tuv.x = ( vertex.x / outerRadius + 1 ) / 2;\\r\\n\\t\\t\\tuv.y = ( vertex.y / outerRadius + 1 ) / 2;\\r\\n\\r\\n\\t\\t\\tuvs.push( uv.x, uv.y );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// increase the radius for next row of vertices\\r\\n\\r\\n\\t\\tradius += radiusStep;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// indices\\r\\n\\r\\n\\tfor ( j = 0; j < phiSegments; j ++ ) {\\r\\n\\r\\n\\t\\tvar thetaSegmentLevel = j * ( thetaSegments + 1 );\\r\\n\\r\\n\\t\\tfor ( i = 0; i < thetaSegments; i ++ ) {\\r\\n\\r\\n\\t\\t\\tsegment = i + thetaSegmentLevel;\\r\\n\\r\\n\\t\\t\\tvar a = segment;\\r\\n\\t\\t\\tvar b = segment + thetaSegments + 1;\\r\\n\\t\\t\\tvar c = segment + thetaSegments + 2;\\r\\n\\t\\t\\tvar d = segment + 1;\\r\\n\\r\\n\\t\\t\\t// faces\\r\\n\\r\\n\\t\\t\\tindices.push( a, b, d );\\r\\n\\t\\t\\tindices.push( b, c, d );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// build geometry\\r\\n\\r\\n\\tthis.setIndex( indices );\\r\\n\\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\r\\n\\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\r\\n\\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\r\\n\\r\\n}\\r\\n\\r\\nRingBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\r\\nRingBufferGeometry.prototype.constructor = RingBufferGeometry;\\r\\n\\r\\n/**\\r\\n * @author zz85 / https://github.com/zz85\\r\\n * @author bhouston / http://clara.io\\r\\n * @author Mugen87 / https://github.com/Mugen87\\r\\n */\\r\\n\\r\\n// LatheGeometry\\r\\n\\r\\nfunction LatheGeometry( points, segments, phiStart, phiLength ) {\\r\\n\\r\\n\\tGeometry.call( this );\\r\\n\\r\\n\\tthis.type = 'LatheGeometry';\\r\\n\\r\\n\\tthis.parameters = {\\r\\n\\t\\tpoints: points,\\r\\n\\t\\tsegments: segments,\\r\\n\\t\\tphiStart: phiStart,\\r\\n\\t\\tphiLength: phiLength\\r\\n\\t};\\r\\n\\r\\n\\tthis.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );\\r\\n\\tthis.mergeVertices();\\r\\n\\r\\n}\\r\\n\\r\\nLatheGeometry.prototype = Object.create( Geometry.prototype );\\r\\nLatheGeometry.prototype.constructor = LatheGeometry;\\r\\n\\r\\n// LatheBufferGeometry\\r\\n\\r\\nfunction LatheBufferGeometry( points, segments, phiStart, phiLength ) {\\r\\n\\r\\n\\tBufferGeometry.call( this );\\r\\n\\r\\n\\tthis.type = 'LatheBufferGeometry';\\r\\n\\r\\n\\tthis.parameters = {\\r\\n\\t\\tpoints: points,\\r\\n\\t\\tsegments: segments,\\r\\n\\t\\tphiStart: phiStart,\\r\\n\\t\\tphiLength: phiLength\\r\\n\\t};\\r\\n\\r\\n\\tsegments = Math.floor( segments ) || 12;\\r\\n\\tphiStart = phiStart || 0;\\r\\n\\tphiLength = phiLength || Math.PI * 2;\\r\\n\\r\\n\\t// clamp phiLength so it's in range of [ 0, 2PI ]\\r\\n\\r\\n\\tphiLength = MathUtils.clamp( phiLength, 0, Math.PI * 2 );\\r\\n\\r\\n\\r\\n\\t// buffers\\r\\n\\r\\n\\tvar indices = [];\\r\\n\\tvar vertices = [];\\r\\n\\tvar uvs = [];\\r\\n\\r\\n\\t// helper variables\\r\\n\\r\\n\\tvar base;\\r\\n\\tvar inverseSegments = 1.0 / segments;\\r\\n\\tvar vertex = new Vector3();\\r\\n\\tvar uv = new Vector2();\\r\\n\\tvar i, j;\\r\\n\\r\\n\\t// generate vertices and uvs\\r\\n\\r\\n\\tfor ( i = 0; i <= segments; i ++ ) {\\r\\n\\r\\n\\t\\tvar phi = phiStart + i * inverseSegments * phiLength;\\r\\n\\r\\n\\t\\tvar sin = Math.sin( phi );\\r\\n\\t\\tvar cos = Math.cos( phi );\\r\\n\\r\\n\\t\\tfor ( j = 0; j <= ( points.length - 1 ); j ++ ) {\\r\\n\\r\\n\\t\\t\\t// vertex\\r\\n\\r\\n\\t\\t\\tvertex.x = points[ j ].x * sin;\\r\\n\\t\\t\\tvertex.y = points[ j ].y;\\r\\n\\t\\t\\tvertex.z = points[ j ].x * cos;\\r\\n\\r\\n\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\r\\n\\r\\n\\t\\t\\t// uv\\r\\n\\r\\n\\t\\t\\tuv.x = i / segments;\\r\\n\\t\\t\\tuv.y = j / ( points.length - 1 );\\r\\n\\r\\n\\t\\t\\tuvs.push( uv.x, uv.y );\\r\\n\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// indices\\r\\n\\r\\n\\tfor ( i = 0; i < segments; i ++ ) {\\r\\n\\r\\n\\t\\tfor ( j = 0; j < ( points.length - 1 ); j ++ ) {\\r\\n\\r\\n\\t\\t\\tbase = j + i * points.length;\\r\\n\\r\\n\\t\\t\\tvar a = base;\\r\\n\\t\\t\\tvar b = base + points.length;\\r\\n\\t\\t\\tvar c = base + points.length + 1;\\r\\n\\t\\t\\tvar d = base + 1;\\r\\n\\r\\n\\t\\t\\t// faces\\r\\n\\r\\n\\t\\t\\tindices.push( a, b, d );\\r\\n\\t\\t\\tindices.push( b, c, d );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// build geometry\\r\\n\\r\\n\\tthis.setIndex( indices );\\r\\n\\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\r\\n\\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\r\\n\\r\\n\\t// generate normals\\r\\n\\r\\n\\tthis.computeVertexNormals();\\r\\n\\r\\n\\t// if the geometry is closed, we need to average the normals along the seam.\\r\\n\\t// because the corresponding vertices are identical (but still have different UVs).\\r\\n\\r\\n\\tif ( phiLength === Math.PI * 2 ) {\\r\\n\\r\\n\\t\\tvar normals = this.attributes.normal.array;\\r\\n\\t\\tvar n1 = new Vector3();\\r\\n\\t\\tvar n2 = new Vector3();\\r\\n\\t\\tvar n = new Vector3();\\r\\n\\r\\n\\t\\t// this is the buffer offset for the last line of vertices\\r\\n\\r\\n\\t\\tbase = segments * points.length * 3;\\r\\n\\r\\n\\t\\tfor ( i = 0, j = 0; i < points.length; i ++, j += 3 ) {\\r\\n\\r\\n\\t\\t\\t// select the normal of the vertex in the first line\\r\\n\\r\\n\\t\\t\\tn1.x = normals[ j + 0 ];\\r\\n\\t\\t\\tn1.y = normals[ j + 1 ];\\r\\n\\t\\t\\tn1.z = normals[ j + 2 ];\\r\\n\\r\\n\\t\\t\\t// select the normal of the vertex in the last line\\r\\n\\r\\n\\t\\t\\tn2.x = normals[ base + j + 0 ];\\r\\n\\t\\t\\tn2.y = normals[ base + j + 1 ];\\r\\n\\t\\t\\tn2.z = normals[ base + j + 2 ];\\r\\n\\r\\n\\t\\t\\t// average normals\\r\\n\\r\\n\\t\\t\\tn.addVectors( n1, n2 ).normalize();\\r\\n\\r\\n\\t\\t\\t// assign the new values to both normals\\r\\n\\r\\n\\t\\t\\tnormals[ j + 0 ] = normals[ base + j + 0 ] = n.x;\\r\\n\\t\\t\\tnormals[ j + 1 ] = normals[ base + j + 1 ] = n.y;\\r\\n\\t\\t\\tnormals[ j + 2 ] = normals[ base + j + 2 ] = n.z;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\\r\\nLatheBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\r\\nLatheBufferGeometry.prototype.constructor = LatheBufferGeometry;\\r\\n\\r\\n/**\\r\\n * @author jonobr1 / http://jonobr1.com\\r\\n * @author Mugen87 / https://github.com/Mugen87\\r\\n */\\r\\n\\r\\n// ShapeGeometry\\r\\n\\r\\nfunction ShapeGeometry( shapes, curveSegments ) {\\r\\n\\r\\n\\tGeometry.call( this );\\r\\n\\r\\n\\tthis.type = 'ShapeGeometry';\\r\\n\\r\\n\\tif ( typeof curveSegments === 'object' ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.ShapeGeometry: Options parameter has been removed.' );\\r\\n\\r\\n\\t\\tcurveSegments = curveSegments.curveSegments;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tthis.parameters = {\\r\\n\\t\\tshapes: shapes,\\r\\n\\t\\tcurveSegments: curveSegments\\r\\n\\t};\\r\\n\\r\\n\\tthis.fromBufferGeometry( new ShapeBufferGeometry( shapes, curveSegments ) );\\r\\n\\tthis.mergeVertices();\\r\\n\\r\\n}\\r\\n\\r\\nShapeGeometry.prototype = Object.create( Geometry.prototype );\\r\\nShapeGeometry.prototype.constructor = ShapeGeometry;\\r\\n\\r\\nShapeGeometry.prototype.toJSON = function () {\\r\\n\\r\\n\\tvar data = Geometry.prototype.toJSON.call( this );\\r\\n\\r\\n\\tvar shapes = this.parameters.shapes;\\r\\n\\r\\n\\treturn toJSON$1( shapes, data );\\r\\n\\r\\n};\\r\\n\\r\\n// ShapeBufferGeometry\\r\\n\\r\\nfunction ShapeBufferGeometry( shapes, curveSegments ) {\\r\\n\\r\\n\\tBufferGeometry.call( this );\\r\\n\\r\\n\\tthis.type = 'ShapeBufferGeometry';\\r\\n\\r\\n\\tthis.parameters = {\\r\\n\\t\\tshapes: shapes,\\r\\n\\t\\tcurveSegments: curveSegments\\r\\n\\t};\\r\\n\\r\\n\\tcurveSegments = curveSegments || 12;\\r\\n\\r\\n\\t// buffers\\r\\n\\r\\n\\tvar indices = [];\\r\\n\\tvar vertices = [];\\r\\n\\tvar normals = [];\\r\\n\\tvar uvs = [];\\r\\n\\r\\n\\t// helper variables\\r\\n\\r\\n\\tvar groupStart = 0;\\r\\n\\tvar groupCount = 0;\\r\\n\\r\\n\\t// allow single and array values for \\\"shapes\\\" parameter\\r\\n\\r\\n\\tif ( Array.isArray( shapes ) === false ) {\\r\\n\\r\\n\\t\\taddShape( shapes );\\r\\n\\r\\n\\t} else {\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < shapes.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\taddShape( shapes[ i ] );\\r\\n\\r\\n\\t\\t\\tthis.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support\\r\\n\\r\\n\\t\\t\\tgroupStart += groupCount;\\r\\n\\t\\t\\tgroupCount = 0;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// build geometry\\r\\n\\r\\n\\tthis.setIndex( indices );\\r\\n\\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\r\\n\\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\r\\n\\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\r\\n\\r\\n\\r\\n\\t// helper functions\\r\\n\\r\\n\\tfunction addShape( shape ) {\\r\\n\\r\\n\\t\\tvar i, l, shapeHole;\\r\\n\\r\\n\\t\\tvar indexOffset = vertices.length / 3;\\r\\n\\t\\tvar points = shape.extractPoints( curveSegments );\\r\\n\\r\\n\\t\\tvar shapeVertices = points.shape;\\r\\n\\t\\tvar shapeHoles = points.holes;\\r\\n\\r\\n\\t\\t// check direction of vertices\\r\\n\\r\\n\\t\\tif ( ShapeUtils.isClockWise( shapeVertices ) === false ) {\\r\\n\\r\\n\\t\\t\\tshapeVertices = shapeVertices.reverse();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfor ( i = 0, l = shapeHoles.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\tshapeHole = shapeHoles[ i ];\\r\\n\\r\\n\\t\\t\\tif ( ShapeUtils.isClockWise( shapeHole ) === true ) {\\r\\n\\r\\n\\t\\t\\t\\tshapeHoles[ i ] = shapeHole.reverse();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );\\r\\n\\r\\n\\t\\t// join vertices of inner and outer paths to a single array\\r\\n\\r\\n\\t\\tfor ( i = 0, l = shapeHoles.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\tshapeHole = shapeHoles[ i ];\\r\\n\\t\\t\\tshapeVertices = shapeVertices.concat( shapeHole );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// vertices, normals, uvs\\r\\n\\r\\n\\t\\tfor ( i = 0, l = shapeVertices.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar vertex = shapeVertices[ i ];\\r\\n\\r\\n\\t\\t\\tvertices.push( vertex.x, vertex.y, 0 );\\r\\n\\t\\t\\tnormals.push( 0, 0, 1 );\\r\\n\\t\\t\\tuvs.push( vertex.x, vertex.y ); // world uvs\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// incides\\r\\n\\r\\n\\t\\tfor ( i = 0, l = faces.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar face = faces[ i ];\\r\\n\\r\\n\\t\\t\\tvar a = face[ 0 ] + indexOffset;\\r\\n\\t\\t\\tvar b = face[ 1 ] + indexOffset;\\r\\n\\t\\t\\tvar c = face[ 2 ] + indexOffset;\\r\\n\\r\\n\\t\\t\\tindices.push( a, b, c );\\r\\n\\t\\t\\tgroupCount += 3;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\\r\\nShapeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\r\\nShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;\\r\\n\\r\\nShapeBufferGeometry.prototype.toJSON = function () {\\r\\n\\r\\n\\tvar data = BufferGeometry.prototype.toJSON.call( this );\\r\\n\\r\\n\\tvar shapes = this.parameters.shapes;\\r\\n\\r\\n\\treturn toJSON$1( shapes, data );\\r\\n\\r\\n};\\r\\n\\r\\n//\\r\\n\\r\\nfunction toJSON$1( shapes, data ) {\\r\\n\\r\\n\\tdata.shapes = [];\\r\\n\\r\\n\\tif ( Array.isArray( shapes ) ) {\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar shape = shapes[ i ];\\r\\n\\r\\n\\t\\t\\tdata.shapes.push( shape.uuid );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t} else {\\r\\n\\r\\n\\t\\tdata.shapes.push( shapes.uuid );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn data;\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * @author WestLangley / http://github.com/WestLangley\\r\\n * @author Mugen87 / https://github.com/Mugen87\\r\\n */\\r\\n\\r\\nfunction EdgesGeometry( geometry, thresholdAngle ) {\\r\\n\\r\\n\\tBufferGeometry.call( this );\\r\\n\\r\\n\\tthis.type = 'EdgesGeometry';\\r\\n\\r\\n\\tthis.parameters = {\\r\\n\\t\\tthresholdAngle: thresholdAngle\\r\\n\\t};\\r\\n\\r\\n\\tthresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;\\r\\n\\r\\n\\t// buffer\\r\\n\\r\\n\\tvar vertices = [];\\r\\n\\r\\n\\t// helper variables\\r\\n\\r\\n\\tvar thresholdDot = Math.cos( MathUtils.DEG2RAD * thresholdAngle );\\r\\n\\tvar edge = [ 0, 0 ], edges = {}, edge1, edge2;\\r\\n\\tvar key, keys = [ 'a', 'b', 'c' ];\\r\\n\\r\\n\\t// prepare source geometry\\r\\n\\r\\n\\tvar geometry2;\\r\\n\\r\\n\\tif ( geometry.isBufferGeometry ) {\\r\\n\\r\\n\\t\\tgeometry2 = new Geometry();\\r\\n\\t\\tgeometry2.fromBufferGeometry( geometry );\\r\\n\\r\\n\\t} else {\\r\\n\\r\\n\\t\\tgeometry2 = geometry.clone();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tgeometry2.mergeVertices();\\r\\n\\tgeometry2.computeFaceNormals();\\r\\n\\r\\n\\tvar sourceVertices = geometry2.vertices;\\r\\n\\tvar faces = geometry2.faces;\\r\\n\\r\\n\\t// now create a data structure where each entry represents an edge with its adjoining faces\\r\\n\\r\\n\\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\tvar face = faces[ i ];\\r\\n\\r\\n\\t\\tfor ( var j = 0; j < 3; j ++ ) {\\r\\n\\r\\n\\t\\t\\tedge1 = face[ keys[ j ] ];\\r\\n\\t\\t\\tedge2 = face[ keys[ ( j + 1 ) % 3 ] ];\\r\\n\\t\\t\\tedge[ 0 ] = Math.min( edge1, edge2 );\\r\\n\\t\\t\\tedge[ 1 ] = Math.max( edge1, edge2 );\\r\\n\\r\\n\\t\\t\\tkey = edge[ 0 ] + ',' + edge[ 1 ];\\r\\n\\r\\n\\t\\t\\tif ( edges[ key ] === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tedges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ], face1: i, face2: undefined };\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tedges[ key ].face2 = i;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// generate vertices\\r\\n\\r\\n\\tfor ( key in edges ) {\\r\\n\\r\\n\\t\\tvar e = edges[ key ];\\r\\n\\r\\n\\t\\t// an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.\\r\\n\\r\\n\\t\\tif ( e.face2 === undefined || faces[ e.face1 ].normal.dot( faces[ e.face2 ].normal ) <= thresholdDot ) {\\r\\n\\r\\n\\t\\t\\tvar vertex = sourceVertices[ e.index1 ];\\r\\n\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\r\\n\\r\\n\\t\\t\\tvertex = sourceVertices[ e.index2 ];\\r\\n\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// build geometry\\r\\n\\r\\n\\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\r\\n\\r\\n}\\r\\n\\r\\nEdgesGeometry.prototype = Object.create( BufferGeometry.prototype );\\r\\nEdgesGeometry.prototype.constructor = EdgesGeometry;\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n * @author Mugen87 / https://github.com/Mugen87\\r\\n */\\r\\n\\r\\n// CylinderGeometry\\r\\n\\r\\nfunction CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\\r\\n\\r\\n\\tGeometry.call( this );\\r\\n\\r\\n\\tthis.type = 'CylinderGeometry';\\r\\n\\r\\n\\tthis.parameters = {\\r\\n\\t\\tradiusTop: radiusTop,\\r\\n\\t\\tradiusBottom: radiusBottom,\\r\\n\\t\\theight: height,\\r\\n\\t\\tradialSegments: radialSegments,\\r\\n\\t\\theightSegments: heightSegments,\\r\\n\\t\\topenEnded: openEnded,\\r\\n\\t\\tthetaStart: thetaStart,\\r\\n\\t\\tthetaLength: thetaLength\\r\\n\\t};\\r\\n\\r\\n\\tthis.fromBufferGeometry( new CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );\\r\\n\\tthis.mergeVertices();\\r\\n\\r\\n}\\r\\n\\r\\nCylinderGeometry.prototype = Object.create( Geometry.prototype );\\r\\nCylinderGeometry.prototype.constructor = CylinderGeometry;\\r\\n\\r\\n// CylinderBufferGeometry\\r\\n\\r\\nfunction CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\\r\\n\\r\\n\\tBufferGeometry.call( this );\\r\\n\\r\\n\\tthis.type = 'CylinderBufferGeometry';\\r\\n\\r\\n\\tthis.parameters = {\\r\\n\\t\\tradiusTop: radiusTop,\\r\\n\\t\\tradiusBottom: radiusBottom,\\r\\n\\t\\theight: height,\\r\\n\\t\\tradialSegments: radialSegments,\\r\\n\\t\\theightSegments: heightSegments,\\r\\n\\t\\topenEnded: openEnded,\\r\\n\\t\\tthetaStart: thetaStart,\\r\\n\\t\\tthetaLength: thetaLength\\r\\n\\t};\\r\\n\\r\\n\\tvar scope = this;\\r\\n\\r\\n\\tradiusTop = radiusTop !== undefined ? radiusTop : 1;\\r\\n\\tradiusBottom = radiusBottom !== undefined ? radiusBottom : 1;\\r\\n\\theight = height || 1;\\r\\n\\r\\n\\tradialSegments = Math.floor( radialSegments ) || 8;\\r\\n\\theightSegments = Math.floor( heightSegments ) || 1;\\r\\n\\r\\n\\topenEnded = openEnded !== undefined ? openEnded : false;\\r\\n\\tthetaStart = thetaStart !== undefined ? thetaStart : 0.0;\\r\\n\\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\\r\\n\\r\\n\\t// buffers\\r\\n\\r\\n\\tvar indices = [];\\r\\n\\tvar vertices = [];\\r\\n\\tvar normals = [];\\r\\n\\tvar uvs = [];\\r\\n\\r\\n\\t// helper variables\\r\\n\\r\\n\\tvar index = 0;\\r\\n\\tvar indexArray = [];\\r\\n\\tvar halfHeight = height / 2;\\r\\n\\tvar groupStart = 0;\\r\\n\\r\\n\\t// generate geometry\\r\\n\\r\\n\\tgenerateTorso();\\r\\n\\r\\n\\tif ( openEnded === false ) {\\r\\n\\r\\n\\t\\tif ( radiusTop > 0 ) generateCap( true );\\r\\n\\t\\tif ( radiusBottom > 0 ) generateCap( false );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// build geometry\\r\\n\\r\\n\\tthis.setIndex( indices );\\r\\n\\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\r\\n\\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\r\\n\\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\r\\n\\r\\n\\tfunction generateTorso() {\\r\\n\\r\\n\\t\\tvar x, y;\\r\\n\\t\\tvar normal = new Vector3();\\r\\n\\t\\tvar vertex = new Vector3();\\r\\n\\r\\n\\t\\tvar groupCount = 0;\\r\\n\\r\\n\\t\\t// this will be used to calculate the normal\\r\\n\\t\\tvar slope = ( radiusBottom - radiusTop ) / height;\\r\\n\\r\\n\\t\\t// generate vertices, normals and uvs\\r\\n\\r\\n\\t\\tfor ( y = 0; y <= heightSegments; y ++ ) {\\r\\n\\r\\n\\t\\t\\tvar indexRow = [];\\r\\n\\r\\n\\t\\t\\tvar v = y / heightSegments;\\r\\n\\r\\n\\t\\t\\t// calculate the radius of the current row\\r\\n\\r\\n\\t\\t\\tvar radius = v * ( radiusBottom - radiusTop ) + radiusTop;\\r\\n\\r\\n\\t\\t\\tfor ( x = 0; x <= radialSegments; x ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar u = x / radialSegments;\\r\\n\\r\\n\\t\\t\\t\\tvar theta = u * thetaLength + thetaStart;\\r\\n\\r\\n\\t\\t\\t\\tvar sinTheta = Math.sin( theta );\\r\\n\\t\\t\\t\\tvar cosTheta = Math.cos( theta );\\r\\n\\r\\n\\t\\t\\t\\t// vertex\\r\\n\\r\\n\\t\\t\\t\\tvertex.x = radius * sinTheta;\\r\\n\\t\\t\\t\\tvertex.y = - v * height + halfHeight;\\r\\n\\t\\t\\t\\tvertex.z = radius * cosTheta;\\r\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\r\\n\\r\\n\\t\\t\\t\\t// normal\\r\\n\\r\\n\\t\\t\\t\\tnormal.set( sinTheta, slope, cosTheta ).normalize();\\r\\n\\t\\t\\t\\tnormals.push( normal.x, normal.y, normal.z );\\r\\n\\r\\n\\t\\t\\t\\t// uv\\r\\n\\r\\n\\t\\t\\t\\tuvs.push( u, 1 - v );\\r\\n\\r\\n\\t\\t\\t\\t// save index of vertex in respective row\\r\\n\\r\\n\\t\\t\\t\\tindexRow.push( index ++ );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// now save vertices of the row in our index array\\r\\n\\r\\n\\t\\t\\tindexArray.push( indexRow );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// generate indices\\r\\n\\r\\n\\t\\tfor ( x = 0; x < radialSegments; x ++ ) {\\r\\n\\r\\n\\t\\t\\tfor ( y = 0; y < heightSegments; y ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t// we use the index array to access the correct indices\\r\\n\\r\\n\\t\\t\\t\\tvar a = indexArray[ y ][ x ];\\r\\n\\t\\t\\t\\tvar b = indexArray[ y + 1 ][ x ];\\r\\n\\t\\t\\t\\tvar c = indexArray[ y + 1 ][ x + 1 ];\\r\\n\\t\\t\\t\\tvar d = indexArray[ y ][ x + 1 ];\\r\\n\\r\\n\\t\\t\\t\\t// faces\\r\\n\\r\\n\\t\\t\\t\\tindices.push( a, b, d );\\r\\n\\t\\t\\t\\tindices.push( b, c, d );\\r\\n\\r\\n\\t\\t\\t\\t// update group counter\\r\\n\\r\\n\\t\\t\\t\\tgroupCount += 6;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// add a group to the geometry. this will ensure multi material support\\r\\n\\r\\n\\t\\tscope.addGroup( groupStart, groupCount, 0 );\\r\\n\\r\\n\\t\\t// calculate new start value for groups\\r\\n\\r\\n\\t\\tgroupStart += groupCount;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction generateCap( top ) {\\r\\n\\r\\n\\t\\tvar x, centerIndexStart, centerIndexEnd;\\r\\n\\r\\n\\t\\tvar uv = new Vector2();\\r\\n\\t\\tvar vertex = new Vector3();\\r\\n\\r\\n\\t\\tvar groupCount = 0;\\r\\n\\r\\n\\t\\tvar radius = ( top === true ) ? radiusTop : radiusBottom;\\r\\n\\t\\tvar sign = ( top === true ) ? 1 : - 1;\\r\\n\\r\\n\\t\\t// save the index of the first center vertex\\r\\n\\t\\tcenterIndexStart = index;\\r\\n\\r\\n\\t\\t// first we generate the center vertex data of the cap.\\r\\n\\t\\t// because the geometry needs one set of uvs per face,\\r\\n\\t\\t// we must generate a center vertex per face/segment\\r\\n\\r\\n\\t\\tfor ( x = 1; x <= radialSegments; x ++ ) {\\r\\n\\r\\n\\t\\t\\t// vertex\\r\\n\\r\\n\\t\\t\\tvertices.push( 0, halfHeight * sign, 0 );\\r\\n\\r\\n\\t\\t\\t// normal\\r\\n\\r\\n\\t\\t\\tnormals.push( 0, sign, 0 );\\r\\n\\r\\n\\t\\t\\t// uv\\r\\n\\r\\n\\t\\t\\tuvs.push( 0.5, 0.5 );\\r\\n\\r\\n\\t\\t\\t// increase index\\r\\n\\r\\n\\t\\t\\tindex ++;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// save the index of the last center vertex\\r\\n\\r\\n\\t\\tcenterIndexEnd = index;\\r\\n\\r\\n\\t\\t// now we generate the surrounding vertices, normals and uvs\\r\\n\\r\\n\\t\\tfor ( x = 0; x <= radialSegments; x ++ ) {\\r\\n\\r\\n\\t\\t\\tvar u = x / radialSegments;\\r\\n\\t\\t\\tvar theta = u * thetaLength + thetaStart;\\r\\n\\r\\n\\t\\t\\tvar cosTheta = Math.cos( theta );\\r\\n\\t\\t\\tvar sinTheta = Math.sin( theta );\\r\\n\\r\\n\\t\\t\\t// vertex\\r\\n\\r\\n\\t\\t\\tvertex.x = radius * sinTheta;\\r\\n\\t\\t\\tvertex.y = halfHeight * sign;\\r\\n\\t\\t\\tvertex.z = radius * cosTheta;\\r\\n\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\r\\n\\r\\n\\t\\t\\t// normal\\r\\n\\r\\n\\t\\t\\tnormals.push( 0, sign, 0 );\\r\\n\\r\\n\\t\\t\\t// uv\\r\\n\\r\\n\\t\\t\\tuv.x = ( cosTheta * 0.5 ) + 0.5;\\r\\n\\t\\t\\tuv.y = ( sinTheta * 0.5 * sign ) + 0.5;\\r\\n\\t\\t\\tuvs.push( uv.x, uv.y );\\r\\n\\r\\n\\t\\t\\t// increase index\\r\\n\\r\\n\\t\\t\\tindex ++;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// generate indices\\r\\n\\r\\n\\t\\tfor ( x = 0; x < radialSegments; x ++ ) {\\r\\n\\r\\n\\t\\t\\tvar c = centerIndexStart + x;\\r\\n\\t\\t\\tvar i = centerIndexEnd + x;\\r\\n\\r\\n\\t\\t\\tif ( top === true ) {\\r\\n\\r\\n\\t\\t\\t\\t// face top\\r\\n\\r\\n\\t\\t\\t\\tindices.push( i, i + 1, c );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t// face bottom\\r\\n\\r\\n\\t\\t\\t\\tindices.push( i + 1, i, c );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tgroupCount += 3;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// add a group to the geometry. this will ensure multi material support\\r\\n\\r\\n\\t\\tscope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );\\r\\n\\r\\n\\t\\t// calculate new start value for groups\\r\\n\\r\\n\\t\\tgroupStart += groupCount;\\r\\n\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\\r\\nCylinderBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\r\\nCylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;\\r\\n\\r\\n/**\\r\\n * @author abelnation / http://github.com/abelnation\\r\\n */\\r\\n\\r\\n// ConeGeometry\\r\\n\\r\\nfunction ConeGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\\r\\n\\r\\n\\tCylinderGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );\\r\\n\\r\\n\\tthis.type = 'ConeGeometry';\\r\\n\\r\\n\\tthis.parameters = {\\r\\n\\t\\tradius: radius,\\r\\n\\t\\theight: height,\\r\\n\\t\\tradialSegments: radialSegments,\\r\\n\\t\\theightSegments: heightSegments,\\r\\n\\t\\topenEnded: openEnded,\\r\\n\\t\\tthetaStart: thetaStart,\\r\\n\\t\\tthetaLength: thetaLength\\r\\n\\t};\\r\\n\\r\\n}\\r\\n\\r\\nConeGeometry.prototype = Object.create( CylinderGeometry.prototype );\\r\\nConeGeometry.prototype.constructor = ConeGeometry;\\r\\n\\r\\n// ConeBufferGeometry\\r\\n\\r\\nfunction ConeBufferGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\\r\\n\\r\\n\\tCylinderBufferGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );\\r\\n\\r\\n\\tthis.type = 'ConeBufferGeometry';\\r\\n\\r\\n\\tthis.parameters = {\\r\\n\\t\\tradius: radius,\\r\\n\\t\\theight: height,\\r\\n\\t\\tradialSegments: radialSegments,\\r\\n\\t\\theightSegments: heightSegments,\\r\\n\\t\\topenEnded: openEnded,\\r\\n\\t\\tthetaStart: thetaStart,\\r\\n\\t\\tthetaLength: thetaLength\\r\\n\\t};\\r\\n\\r\\n}\\r\\n\\r\\nConeBufferGeometry.prototype = Object.create( CylinderBufferGeometry.prototype );\\r\\nConeBufferGeometry.prototype.constructor = ConeBufferGeometry;\\r\\n\\r\\n/**\\r\\n * @author benaadams / https://twitter.com/ben_a_adams\\r\\n * @author Mugen87 / https://github.com/Mugen87\\r\\n * @author hughes\\r\\n */\\r\\n\\r\\n// CircleGeometry\\r\\n\\r\\nfunction CircleGeometry( radius, segments, thetaStart, thetaLength ) {\\r\\n\\r\\n\\tGeometry.call( this );\\r\\n\\r\\n\\tthis.type = 'CircleGeometry';\\r\\n\\r\\n\\tthis.parameters = {\\r\\n\\t\\tradius: radius,\\r\\n\\t\\tsegments: segments,\\r\\n\\t\\tthetaStart: thetaStart,\\r\\n\\t\\tthetaLength: thetaLength\\r\\n\\t};\\r\\n\\r\\n\\tthis.fromBufferGeometry( new CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );\\r\\n\\tthis.mergeVertices();\\r\\n\\r\\n}\\r\\n\\r\\nCircleGeometry.prototype = Object.create( Geometry.prototype );\\r\\nCircleGeometry.prototype.constructor = CircleGeometry;\\r\\n\\r\\n// CircleBufferGeometry\\r\\n\\r\\nfunction CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) {\\r\\n\\r\\n\\tBufferGeometry.call( this );\\r\\n\\r\\n\\tthis.type = 'CircleBufferGeometry';\\r\\n\\r\\n\\tthis.parameters = {\\r\\n\\t\\tradius: radius,\\r\\n\\t\\tsegments: segments,\\r\\n\\t\\tthetaStart: thetaStart,\\r\\n\\t\\tthetaLength: thetaLength\\r\\n\\t};\\r\\n\\r\\n\\tradius = radius || 1;\\r\\n\\tsegments = segments !== undefined ? Math.max( 3, segments ) : 8;\\r\\n\\r\\n\\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\\r\\n\\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\\r\\n\\r\\n\\t// buffers\\r\\n\\r\\n\\tvar indices = [];\\r\\n\\tvar vertices = [];\\r\\n\\tvar normals = [];\\r\\n\\tvar uvs = [];\\r\\n\\r\\n\\t// helper variables\\r\\n\\r\\n\\tvar i, s;\\r\\n\\tvar vertex = new Vector3();\\r\\n\\tvar uv = new Vector2();\\r\\n\\r\\n\\t// center point\\r\\n\\r\\n\\tvertices.push( 0, 0, 0 );\\r\\n\\tnormals.push( 0, 0, 1 );\\r\\n\\tuvs.push( 0.5, 0.5 );\\r\\n\\r\\n\\tfor ( s = 0, i = 3; s <= segments; s ++, i += 3 ) {\\r\\n\\r\\n\\t\\tvar segment = thetaStart + s / segments * thetaLength;\\r\\n\\r\\n\\t\\t// vertex\\r\\n\\r\\n\\t\\tvertex.x = radius * Math.cos( segment );\\r\\n\\t\\tvertex.y = radius * Math.sin( segment );\\r\\n\\r\\n\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\r\\n\\r\\n\\t\\t// normal\\r\\n\\r\\n\\t\\tnormals.push( 0, 0, 1 );\\r\\n\\r\\n\\t\\t// uvs\\r\\n\\r\\n\\t\\tuv.x = ( vertices[ i ] / radius + 1 ) / 2;\\r\\n\\t\\tuv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;\\r\\n\\r\\n\\t\\tuvs.push( uv.x, uv.y );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// indices\\r\\n\\r\\n\\tfor ( i = 1; i <= segments; i ++ ) {\\r\\n\\r\\n\\t\\tindices.push( i, i + 1, 0 );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// build geometry\\r\\n\\r\\n\\tthis.setIndex( indices );\\r\\n\\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\r\\n\\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\r\\n\\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\r\\n\\r\\n}\\r\\n\\r\\nCircleBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\r\\nCircleBufferGeometry.prototype.constructor = CircleBufferGeometry;\\r\\n\\r\\nvar Geometries = /*#__PURE__*/Object.freeze({\\r\\n\\t__proto__: null,\\r\\n\\tWireframeGeometry: WireframeGeometry,\\r\\n\\tParametricGeometry: ParametricGeometry,\\r\\n\\tParametricBufferGeometry: ParametricBufferGeometry,\\r\\n\\tTetrahedronGeometry: TetrahedronGeometry,\\r\\n\\tTetrahedronBufferGeometry: TetrahedronBufferGeometry,\\r\\n\\tOctahedronGeometry: OctahedronGeometry,\\r\\n\\tOctahedronBufferGeometry: OctahedronBufferGeometry,\\r\\n\\tIcosahedronGeometry: IcosahedronGeometry,\\r\\n\\tIcosahedronBufferGeometry: IcosahedronBufferGeometry,\\r\\n\\tDodecahedronGeometry: DodecahedronGeometry,\\r\\n\\tDodecahedronBufferGeometry: DodecahedronBufferGeometry,\\r\\n\\tPolyhedronGeometry: PolyhedronGeometry,\\r\\n\\tPolyhedronBufferGeometry: PolyhedronBufferGeometry,\\r\\n\\tTubeGeometry: TubeGeometry,\\r\\n\\tTubeBufferGeometry: TubeBufferGeometry,\\r\\n\\tTorusKnotGeometry: TorusKnotGeometry,\\r\\n\\tTorusKnotBufferGeometry: TorusKnotBufferGeometry,\\r\\n\\tTorusGeometry: TorusGeometry,\\r\\n\\tTorusBufferGeometry: TorusBufferGeometry,\\r\\n\\tTextGeometry: TextGeometry,\\r\\n\\tTextBufferGeometry: TextBufferGeometry,\\r\\n\\tSphereGeometry: SphereGeometry,\\r\\n\\tSphereBufferGeometry: SphereBufferGeometry,\\r\\n\\tRingGeometry: RingGeometry,\\r\\n\\tRingBufferGeometry: RingBufferGeometry,\\r\\n\\tPlaneGeometry: PlaneGeometry,\\r\\n\\tPlaneBufferGeometry: PlaneBufferGeometry,\\r\\n\\tLatheGeometry: LatheGeometry,\\r\\n\\tLatheBufferGeometry: LatheBufferGeometry,\\r\\n\\tShapeGeometry: ShapeGeometry,\\r\\n\\tShapeBufferGeometry: ShapeBufferGeometry,\\r\\n\\tExtrudeGeometry: ExtrudeGeometry,\\r\\n\\tExtrudeBufferGeometry: ExtrudeBufferGeometry,\\r\\n\\tEdgesGeometry: EdgesGeometry,\\r\\n\\tConeGeometry: ConeGeometry,\\r\\n\\tConeBufferGeometry: ConeBufferGeometry,\\r\\n\\tCylinderGeometry: CylinderGeometry,\\r\\n\\tCylinderBufferGeometry: CylinderBufferGeometry,\\r\\n\\tCircleGeometry: CircleGeometry,\\r\\n\\tCircleBufferGeometry: CircleBufferGeometry,\\r\\n\\tBoxGeometry: BoxGeometry,\\r\\n\\tBoxBufferGeometry: BoxBufferGeometry\\r\\n});\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n *\\r\\n * parameters = {\\r\\n *  color: <THREE.Color>\\r\\n * }\\r\\n */\\r\\n\\r\\nfunction ShadowMaterial( parameters ) {\\r\\n\\r\\n\\tMaterial.call( this );\\r\\n\\r\\n\\tthis.type = 'ShadowMaterial';\\r\\n\\r\\n\\tthis.color = new Color( 0x000000 );\\r\\n\\tthis.transparent = true;\\r\\n\\r\\n\\tthis.setValues( parameters );\\r\\n\\r\\n}\\r\\n\\r\\nShadowMaterial.prototype = Object.create( Material.prototype );\\r\\nShadowMaterial.prototype.constructor = ShadowMaterial;\\r\\n\\r\\nShadowMaterial.prototype.isShadowMaterial = true;\\r\\n\\r\\nShadowMaterial.prototype.copy = function ( source ) {\\r\\n\\r\\n\\tMaterial.prototype.copy.call( this, source );\\r\\n\\r\\n\\tthis.color.copy( source.color );\\r\\n\\r\\n\\treturn this;\\r\\n\\r\\n};\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nfunction RawShaderMaterial( parameters ) {\\r\\n\\r\\n\\tShaderMaterial.call( this, parameters );\\r\\n\\r\\n\\tthis.type = 'RawShaderMaterial';\\r\\n\\r\\n}\\r\\n\\r\\nRawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype );\\r\\nRawShaderMaterial.prototype.constructor = RawShaderMaterial;\\r\\n\\r\\nRawShaderMaterial.prototype.isRawShaderMaterial = true;\\r\\n\\r\\n/**\\r\\n * @author WestLangley / http://github.com/WestLangley\\r\\n *\\r\\n * parameters = {\\r\\n *  color: <hex>,\\r\\n *  roughness: <float>,\\r\\n *  metalness: <float>,\\r\\n *  opacity: <float>,\\r\\n *\\r\\n *  map: new THREE.Texture( <Image> ),\\r\\n *\\r\\n *  lightMap: new THREE.Texture( <Image> ),\\r\\n *  lightMapIntensity: <float>\\r\\n *\\r\\n *  aoMap: new THREE.Texture( <Image> ),\\r\\n *  aoMapIntensity: <float>\\r\\n *\\r\\n *  emissive: <hex>,\\r\\n *  emissiveIntensity: <float>\\r\\n *  emissiveMap: new THREE.Texture( <Image> ),\\r\\n *\\r\\n *  bumpMap: new THREE.Texture( <Image> ),\\r\\n *  bumpScale: <float>,\\r\\n *\\r\\n *  normalMap: new THREE.Texture( <Image> ),\\r\\n *  normalMapType: THREE.TangentSpaceNormalMap,\\r\\n *  normalScale: <Vector2>,\\r\\n *\\r\\n *  displacementMap: new THREE.Texture( <Image> ),\\r\\n *  displacementScale: <float>,\\r\\n *  displacementBias: <float>,\\r\\n *\\r\\n *  roughnessMap: new THREE.Texture( <Image> ),\\r\\n *\\r\\n *  metalnessMap: new THREE.Texture( <Image> ),\\r\\n *\\r\\n *  alphaMap: new THREE.Texture( <Image> ),\\r\\n *\\r\\n *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\\r\\n *  envMapIntensity: <float>\\r\\n *\\r\\n *  refractionRatio: <float>,\\r\\n *\\r\\n *  wireframe: <boolean>,\\r\\n *  wireframeLinewidth: <float>,\\r\\n *\\r\\n *  skinning: <bool>,\\r\\n *  morphTargets: <bool>,\\r\\n *  morphNormals: <bool>\\r\\n * }\\r\\n */\\r\\n\\r\\nfunction MeshStandardMaterial( parameters ) {\\r\\n\\r\\n\\tMaterial.call( this );\\r\\n\\r\\n\\tthis.defines = { 'STANDARD': '' };\\r\\n\\r\\n\\tthis.type = 'MeshStandardMaterial';\\r\\n\\r\\n\\tthis.color = new Color( 0xffffff ); // diffuse\\r\\n\\tthis.roughness = 1.0;\\r\\n\\tthis.metalness = 0.0;\\r\\n\\r\\n\\tthis.map = null;\\r\\n\\r\\n\\tthis.lightMap = null;\\r\\n\\tthis.lightMapIntensity = 1.0;\\r\\n\\r\\n\\tthis.aoMap = null;\\r\\n\\tthis.aoMapIntensity = 1.0;\\r\\n\\r\\n\\tthis.emissive = new Color( 0x000000 );\\r\\n\\tthis.emissiveIntensity = 1.0;\\r\\n\\tthis.emissiveMap = null;\\r\\n\\r\\n\\tthis.bumpMap = null;\\r\\n\\tthis.bumpScale = 1;\\r\\n\\r\\n\\tthis.normalMap = null;\\r\\n\\tthis.normalMapType = TangentSpaceNormalMap;\\r\\n\\tthis.normalScale = new Vector2( 1, 1 );\\r\\n\\r\\n\\tthis.displacementMap = null;\\r\\n\\tthis.displacementScale = 1;\\r\\n\\tthis.displacementBias = 0;\\r\\n\\r\\n\\tthis.roughnessMap = null;\\r\\n\\r\\n\\tthis.metalnessMap = null;\\r\\n\\r\\n\\tthis.alphaMap = null;\\r\\n\\r\\n\\tthis.envMap = null;\\r\\n\\tthis.envMapIntensity = 1.0;\\r\\n\\r\\n\\tthis.refractionRatio = 0.98;\\r\\n\\r\\n\\tthis.wireframe = false;\\r\\n\\tthis.wireframeLinewidth = 1;\\r\\n\\tthis.wireframeLinecap = 'round';\\r\\n\\tthis.wireframeLinejoin = 'round';\\r\\n\\r\\n\\tthis.skinning = false;\\r\\n\\tthis.morphTargets = false;\\r\\n\\tthis.morphNormals = false;\\r\\n\\r\\n\\tthis.vertexTangents = false;\\r\\n\\r\\n\\tthis.setValues( parameters );\\r\\n\\r\\n}\\r\\n\\r\\nMeshStandardMaterial.prototype = Object.create( Material.prototype );\\r\\nMeshStandardMaterial.prototype.constructor = MeshStandardMaterial;\\r\\n\\r\\nMeshStandardMaterial.prototype.isMeshStandardMaterial = true;\\r\\n\\r\\nMeshStandardMaterial.prototype.copy = function ( source ) {\\r\\n\\r\\n\\tMaterial.prototype.copy.call( this, source );\\r\\n\\r\\n\\tthis.defines = { 'STANDARD': '' };\\r\\n\\r\\n\\tthis.color.copy( source.color );\\r\\n\\tthis.roughness = source.roughness;\\r\\n\\tthis.metalness = source.metalness;\\r\\n\\r\\n\\tthis.map = source.map;\\r\\n\\r\\n\\tthis.lightMap = source.lightMap;\\r\\n\\tthis.lightMapIntensity = source.lightMapIntensity;\\r\\n\\r\\n\\tthis.aoMap = source.aoMap;\\r\\n\\tthis.aoMapIntensity = source.aoMapIntensity;\\r\\n\\r\\n\\tthis.emissive.copy( source.emissive );\\r\\n\\tthis.emissiveMap = source.emissiveMap;\\r\\n\\tthis.emissiveIntensity = source.emissiveIntensity;\\r\\n\\r\\n\\tthis.bumpMap = source.bumpMap;\\r\\n\\tthis.bumpScale = source.bumpScale;\\r\\n\\r\\n\\tthis.normalMap = source.normalMap;\\r\\n\\tthis.normalMapType = source.normalMapType;\\r\\n\\tthis.normalScale.copy( source.normalScale );\\r\\n\\r\\n\\tthis.displacementMap = source.displacementMap;\\r\\n\\tthis.displacementScale = source.displacementScale;\\r\\n\\tthis.displacementBias = source.displacementBias;\\r\\n\\r\\n\\tthis.roughnessMap = source.roughnessMap;\\r\\n\\r\\n\\tthis.metalnessMap = source.metalnessMap;\\r\\n\\r\\n\\tthis.alphaMap = source.alphaMap;\\r\\n\\r\\n\\tthis.envMap = source.envMap;\\r\\n\\tthis.envMapIntensity = source.envMapIntensity;\\r\\n\\r\\n\\tthis.refractionRatio = source.refractionRatio;\\r\\n\\r\\n\\tthis.wireframe = source.wireframe;\\r\\n\\tthis.wireframeLinewidth = source.wireframeLinewidth;\\r\\n\\tthis.wireframeLinecap = source.wireframeLinecap;\\r\\n\\tthis.wireframeLinejoin = source.wireframeLinejoin;\\r\\n\\r\\n\\tthis.skinning = source.skinning;\\r\\n\\tthis.morphTargets = source.morphTargets;\\r\\n\\tthis.morphNormals = source.morphNormals;\\r\\n\\r\\n\\tthis.vertexTangents = source.vertexTangents;\\r\\n\\r\\n\\treturn this;\\r\\n\\r\\n};\\r\\n\\r\\n/**\\r\\n * @author WestLangley / http://github.com/WestLangley\\r\\n *\\r\\n * parameters = {\\r\\n *  clearcoat: <float>,\\r\\n *  clearcoatMap: new THREE.Texture( <Image> ),\\r\\n *  clearcoatRoughness: <float>,\\r\\n *  clearcoatRoughnessMap: new THREE.Texture( <Image> ),\\r\\n *  clearcoatNormalScale: <Vector2>,\\r\\n *  clearcoatNormalMap: new THREE.Texture( <Image> ),\\r\\n *\\r\\n *  reflectivity: <float>,\\r\\n *\\r\\n *  sheen: <Color>,\\r\\n *\\r\\n *  transparency: <float>\\r\\n * }\\r\\n */\\r\\n\\r\\nfunction MeshPhysicalMaterial( parameters ) {\\r\\n\\r\\n\\tMeshStandardMaterial.call( this );\\r\\n\\r\\n\\tthis.defines = {\\r\\n\\r\\n\\t\\t'STANDARD': '',\\r\\n\\t\\t'PHYSICAL': ''\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.type = 'MeshPhysicalMaterial';\\r\\n\\r\\n\\tthis.clearcoat = 0.0;\\r\\n\\tthis.clearcoatMap = null;\\r\\n\\tthis.clearcoatRoughness = 0.0;\\r\\n\\tthis.clearcoatRoughnessMap = null;\\r\\n\\tthis.clearcoatNormalScale = new Vector2( 1, 1 );\\r\\n\\tthis.clearcoatNormalMap = null;\\r\\n\\r\\n\\tthis.reflectivity = 0.5; // maps to F0 = 0.04\\r\\n\\r\\n\\tthis.sheen = null; // null will disable sheen bsdf\\r\\n\\r\\n\\tthis.transparency = 0.0;\\r\\n\\r\\n\\tthis.setValues( parameters );\\r\\n\\r\\n}\\r\\n\\r\\nMeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );\\r\\nMeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;\\r\\n\\r\\nMeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;\\r\\n\\r\\nMeshPhysicalMaterial.prototype.copy = function ( source ) {\\r\\n\\r\\n\\tMeshStandardMaterial.prototype.copy.call( this, source );\\r\\n\\r\\n\\tthis.defines = {\\r\\n\\r\\n\\t\\t'STANDARD': '',\\r\\n\\t\\t'PHYSICAL': ''\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.clearcoat = source.clearcoat;\\r\\n\\tthis.clearcoatMap = source.clearcoatMap;\\r\\n\\tthis.clearcoatRoughness = source.clearcoatRoughness;\\r\\n\\tthis.clearcoatRoughnessMap = source.clearcoatRoughnessMap;\\r\\n\\tthis.clearcoatNormalMap = source.clearcoatNormalMap;\\r\\n\\tthis.clearcoatNormalScale.copy( source.clearcoatNormalScale );\\r\\n\\r\\n\\tthis.reflectivity = source.reflectivity;\\r\\n\\r\\n\\tif ( source.sheen ) {\\r\\n\\r\\n\\t\\tthis.sheen = ( this.sheen || new Color() ).copy( source.sheen );\\r\\n\\r\\n\\t} else {\\r\\n\\r\\n\\t\\tthis.sheen = null;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tthis.transparency = source.transparency;\\r\\n\\r\\n\\treturn this;\\r\\n\\r\\n};\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n *\\r\\n * parameters = {\\r\\n *  color: <hex>,\\r\\n *  specular: <hex>,\\r\\n *  shininess: <float>,\\r\\n *  opacity: <float>,\\r\\n *\\r\\n *  map: new THREE.Texture( <Image> ),\\r\\n *\\r\\n *  lightMap: new THREE.Texture( <Image> ),\\r\\n *  lightMapIntensity: <float>\\r\\n *\\r\\n *  aoMap: new THREE.Texture( <Image> ),\\r\\n *  aoMapIntensity: <float>\\r\\n *\\r\\n *  emissive: <hex>,\\r\\n *  emissiveIntensity: <float>\\r\\n *  emissiveMap: new THREE.Texture( <Image> ),\\r\\n *\\r\\n *  bumpMap: new THREE.Texture( <Image> ),\\r\\n *  bumpScale: <float>,\\r\\n *\\r\\n *  normalMap: new THREE.Texture( <Image> ),\\r\\n *  normalMapType: THREE.TangentSpaceNormalMap,\\r\\n *  normalScale: <Vector2>,\\r\\n *\\r\\n *  displacementMap: new THREE.Texture( <Image> ),\\r\\n *  displacementScale: <float>,\\r\\n *  displacementBias: <float>,\\r\\n *\\r\\n *  specularMap: new THREE.Texture( <Image> ),\\r\\n *\\r\\n *  alphaMap: new THREE.Texture( <Image> ),\\r\\n *\\r\\n *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\\r\\n *  combine: THREE.MultiplyOperation,\\r\\n *  reflectivity: <float>,\\r\\n *  refractionRatio: <float>,\\r\\n *\\r\\n *  wireframe: <boolean>,\\r\\n *  wireframeLinewidth: <float>,\\r\\n *\\r\\n *  skinning: <bool>,\\r\\n *  morphTargets: <bool>,\\r\\n *  morphNormals: <bool>\\r\\n * }\\r\\n */\\r\\n\\r\\nfunction MeshPhongMaterial( parameters ) {\\r\\n\\r\\n\\tMaterial.call( this );\\r\\n\\r\\n\\tthis.type = 'MeshPhongMaterial';\\r\\n\\r\\n\\tthis.color = new Color( 0xffffff ); // diffuse\\r\\n\\tthis.specular = new Color( 0x111111 );\\r\\n\\tthis.shininess = 30;\\r\\n\\r\\n\\tthis.map = null;\\r\\n\\r\\n\\tthis.lightMap = null;\\r\\n\\tthis.lightMapIntensity = 1.0;\\r\\n\\r\\n\\tthis.aoMap = null;\\r\\n\\tthis.aoMapIntensity = 1.0;\\r\\n\\r\\n\\tthis.emissive = new Color( 0x000000 );\\r\\n\\tthis.emissiveIntensity = 1.0;\\r\\n\\tthis.emissiveMap = null;\\r\\n\\r\\n\\tthis.bumpMap = null;\\r\\n\\tthis.bumpScale = 1;\\r\\n\\r\\n\\tthis.normalMap = null;\\r\\n\\tthis.normalMapType = TangentSpaceNormalMap;\\r\\n\\tthis.normalScale = new Vector2( 1, 1 );\\r\\n\\r\\n\\tthis.displacementMap = null;\\r\\n\\tthis.displacementScale = 1;\\r\\n\\tthis.displacementBias = 0;\\r\\n\\r\\n\\tthis.specularMap = null;\\r\\n\\r\\n\\tthis.alphaMap = null;\\r\\n\\r\\n\\tthis.envMap = null;\\r\\n\\tthis.combine = MultiplyOperation;\\r\\n\\tthis.reflectivity = 1;\\r\\n\\tthis.refractionRatio = 0.98;\\r\\n\\r\\n\\tthis.wireframe = false;\\r\\n\\tthis.wireframeLinewidth = 1;\\r\\n\\tthis.wireframeLinecap = 'round';\\r\\n\\tthis.wireframeLinejoin = 'round';\\r\\n\\r\\n\\tthis.skinning = false;\\r\\n\\tthis.morphTargets = false;\\r\\n\\tthis.morphNormals = false;\\r\\n\\r\\n\\tthis.setValues( parameters );\\r\\n\\r\\n}\\r\\n\\r\\nMeshPhongMaterial.prototype = Object.create( Material.prototype );\\r\\nMeshPhongMaterial.prototype.constructor = MeshPhongMaterial;\\r\\n\\r\\nMeshPhongMaterial.prototype.isMeshPhongMaterial = true;\\r\\n\\r\\nMeshPhongMaterial.prototype.copy = function ( source ) {\\r\\n\\r\\n\\tMaterial.prototype.copy.call( this, source );\\r\\n\\r\\n\\tthis.color.copy( source.color );\\r\\n\\tthis.specular.copy( source.specular );\\r\\n\\tthis.shininess = source.shininess;\\r\\n\\r\\n\\tthis.map = source.map;\\r\\n\\r\\n\\tthis.lightMap = source.lightMap;\\r\\n\\tthis.lightMapIntensity = source.lightMapIntensity;\\r\\n\\r\\n\\tthis.aoMap = source.aoMap;\\r\\n\\tthis.aoMapIntensity = source.aoMapIntensity;\\r\\n\\r\\n\\tthis.emissive.copy( source.emissive );\\r\\n\\tthis.emissiveMap = source.emissiveMap;\\r\\n\\tthis.emissiveIntensity = source.emissiveIntensity;\\r\\n\\r\\n\\tthis.bumpMap = source.bumpMap;\\r\\n\\tthis.bumpScale = source.bumpScale;\\r\\n\\r\\n\\tthis.normalMap = source.normalMap;\\r\\n\\tthis.normalMapType = source.normalMapType;\\r\\n\\tthis.normalScale.copy( source.normalScale );\\r\\n\\r\\n\\tthis.displacementMap = source.displacementMap;\\r\\n\\tthis.displacementScale = source.displacementScale;\\r\\n\\tthis.displacementBias = source.displacementBias;\\r\\n\\r\\n\\tthis.specularMap = source.specularMap;\\r\\n\\r\\n\\tthis.alphaMap = source.alphaMap;\\r\\n\\r\\n\\tthis.envMap = source.envMap;\\r\\n\\tthis.combine = source.combine;\\r\\n\\tthis.reflectivity = source.reflectivity;\\r\\n\\tthis.refractionRatio = source.refractionRatio;\\r\\n\\r\\n\\tthis.wireframe = source.wireframe;\\r\\n\\tthis.wireframeLinewidth = source.wireframeLinewidth;\\r\\n\\tthis.wireframeLinecap = source.wireframeLinecap;\\r\\n\\tthis.wireframeLinejoin = source.wireframeLinejoin;\\r\\n\\r\\n\\tthis.skinning = source.skinning;\\r\\n\\tthis.morphTargets = source.morphTargets;\\r\\n\\tthis.morphNormals = source.morphNormals;\\r\\n\\r\\n\\treturn this;\\r\\n\\r\\n};\\r\\n\\r\\n/**\\r\\n * @author takahirox / http://github.com/takahirox\\r\\n *\\r\\n * parameters = {\\r\\n *  color: <hex>,\\r\\n *  specular: <hex>,\\r\\n *  shininess: <float>,\\r\\n *\\r\\n *  map: new THREE.Texture( <Image> ),\\r\\n *  gradientMap: new THREE.Texture( <Image> ),\\r\\n *\\r\\n *  lightMap: new THREE.Texture( <Image> ),\\r\\n *  lightMapIntensity: <float>\\r\\n *\\r\\n *  aoMap: new THREE.Texture( <Image> ),\\r\\n *  aoMapIntensity: <float>\\r\\n *\\r\\n *  emissive: <hex>,\\r\\n *  emissiveIntensity: <float>\\r\\n *  emissiveMap: new THREE.Texture( <Image> ),\\r\\n *\\r\\n *  bumpMap: new THREE.Texture( <Image> ),\\r\\n *  bumpScale: <float>,\\r\\n *\\r\\n *  normalMap: new THREE.Texture( <Image> ),\\r\\n *  normalMapType: THREE.TangentSpaceNormalMap,\\r\\n *  normalScale: <Vector2>,\\r\\n *\\r\\n *  displacementMap: new THREE.Texture( <Image> ),\\r\\n *  displacementScale: <float>,\\r\\n *  displacementBias: <float>,\\r\\n *\\r\\n *  specularMap: new THREE.Texture( <Image> ),\\r\\n *\\r\\n *  alphaMap: new THREE.Texture( <Image> ),\\r\\n *\\r\\n *  wireframe: <boolean>,\\r\\n *  wireframeLinewidth: <float>,\\r\\n *\\r\\n *  skinning: <bool>,\\r\\n *  morphTargets: <bool>,\\r\\n *  morphNormals: <bool>\\r\\n * }\\r\\n */\\r\\n\\r\\nfunction MeshToonMaterial( parameters ) {\\r\\n\\r\\n\\tMaterial.call( this );\\r\\n\\r\\n\\tthis.defines = { 'TOON': '' };\\r\\n\\r\\n\\tthis.type = 'MeshToonMaterial';\\r\\n\\r\\n\\tthis.color = new Color( 0xffffff );\\r\\n\\tthis.specular = new Color( 0x111111 );\\r\\n\\tthis.shininess = 30;\\r\\n\\r\\n\\tthis.map = null;\\r\\n\\tthis.gradientMap = null;\\r\\n\\r\\n\\tthis.lightMap = null;\\r\\n\\tthis.lightMapIntensity = 1.0;\\r\\n\\r\\n\\tthis.aoMap = null;\\r\\n\\tthis.aoMapIntensity = 1.0;\\r\\n\\r\\n\\tthis.emissive = new Color( 0x000000 );\\r\\n\\tthis.emissiveIntensity = 1.0;\\r\\n\\tthis.emissiveMap = null;\\r\\n\\r\\n\\tthis.bumpMap = null;\\r\\n\\tthis.bumpScale = 1;\\r\\n\\r\\n\\tthis.normalMap = null;\\r\\n\\tthis.normalMapType = TangentSpaceNormalMap;\\r\\n\\tthis.normalScale = new Vector2( 1, 1 );\\r\\n\\r\\n\\tthis.displacementMap = null;\\r\\n\\tthis.displacementScale = 1;\\r\\n\\tthis.displacementBias = 0;\\r\\n\\r\\n\\tthis.specularMap = null;\\r\\n\\r\\n\\tthis.alphaMap = null;\\r\\n\\r\\n\\tthis.wireframe = false;\\r\\n\\tthis.wireframeLinewidth = 1;\\r\\n\\tthis.wireframeLinecap = 'round';\\r\\n\\tthis.wireframeLinejoin = 'round';\\r\\n\\r\\n\\tthis.skinning = false;\\r\\n\\tthis.morphTargets = false;\\r\\n\\tthis.morphNormals = false;\\r\\n\\r\\n\\tthis.setValues( parameters );\\r\\n\\r\\n}\\r\\n\\r\\nMeshToonMaterial.prototype = Object.create( Material.prototype );\\r\\nMeshToonMaterial.prototype.constructor = MeshToonMaterial;\\r\\n\\r\\nMeshToonMaterial.prototype.isMeshToonMaterial = true;\\r\\n\\r\\nMeshToonMaterial.prototype.copy = function ( source ) {\\r\\n\\r\\n\\tMaterial.prototype.copy.call( this, source );\\r\\n\\r\\n\\tthis.color.copy( source.color );\\r\\n\\tthis.specular.copy( source.specular );\\r\\n\\tthis.shininess = source.shininess;\\r\\n\\r\\n\\tthis.map = source.map;\\r\\n\\tthis.gradientMap = source.gradientMap;\\r\\n\\r\\n\\tthis.lightMap = source.lightMap;\\r\\n\\tthis.lightMapIntensity = source.lightMapIntensity;\\r\\n\\r\\n\\tthis.aoMap = source.aoMap;\\r\\n\\tthis.aoMapIntensity = source.aoMapIntensity;\\r\\n\\r\\n\\tthis.emissive.copy( source.emissive );\\r\\n\\tthis.emissiveMap = source.emissiveMap;\\r\\n\\tthis.emissiveIntensity = source.emissiveIntensity;\\r\\n\\r\\n\\tthis.bumpMap = source.bumpMap;\\r\\n\\tthis.bumpScale = source.bumpScale;\\r\\n\\r\\n\\tthis.normalMap = source.normalMap;\\r\\n\\tthis.normalMapType = source.normalMapType;\\r\\n\\tthis.normalScale.copy( source.normalScale );\\r\\n\\r\\n\\tthis.displacementMap = source.displacementMap;\\r\\n\\tthis.displacementScale = source.displacementScale;\\r\\n\\tthis.displacementBias = source.displacementBias;\\r\\n\\r\\n\\tthis.specularMap = source.specularMap;\\r\\n\\r\\n\\tthis.alphaMap = source.alphaMap;\\r\\n\\r\\n\\tthis.wireframe = source.wireframe;\\r\\n\\tthis.wireframeLinewidth = source.wireframeLinewidth;\\r\\n\\tthis.wireframeLinecap = source.wireframeLinecap;\\r\\n\\tthis.wireframeLinejoin = source.wireframeLinejoin;\\r\\n\\r\\n\\tthis.skinning = source.skinning;\\r\\n\\tthis.morphTargets = source.morphTargets;\\r\\n\\tthis.morphNormals = source.morphNormals;\\r\\n\\r\\n\\treturn this;\\r\\n\\r\\n};\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n * @author WestLangley / http://github.com/WestLangley\\r\\n *\\r\\n * parameters = {\\r\\n *  opacity: <float>,\\r\\n *\\r\\n *  bumpMap: new THREE.Texture( <Image> ),\\r\\n *  bumpScale: <float>,\\r\\n *\\r\\n *  normalMap: new THREE.Texture( <Image> ),\\r\\n *  normalMapType: THREE.TangentSpaceNormalMap,\\r\\n *  normalScale: <Vector2>,\\r\\n *\\r\\n *  displacementMap: new THREE.Texture( <Image> ),\\r\\n *  displacementScale: <float>,\\r\\n *  displacementBias: <float>,\\r\\n *\\r\\n *  wireframe: <boolean>,\\r\\n *  wireframeLinewidth: <float>\\r\\n *\\r\\n *  skinning: <bool>,\\r\\n *  morphTargets: <bool>,\\r\\n *  morphNormals: <bool>\\r\\n * }\\r\\n */\\r\\n\\r\\nfunction MeshNormalMaterial( parameters ) {\\r\\n\\r\\n\\tMaterial.call( this );\\r\\n\\r\\n\\tthis.type = 'MeshNormalMaterial';\\r\\n\\r\\n\\tthis.bumpMap = null;\\r\\n\\tthis.bumpScale = 1;\\r\\n\\r\\n\\tthis.normalMap = null;\\r\\n\\tthis.normalMapType = TangentSpaceNormalMap;\\r\\n\\tthis.normalScale = new Vector2( 1, 1 );\\r\\n\\r\\n\\tthis.displacementMap = null;\\r\\n\\tthis.displacementScale = 1;\\r\\n\\tthis.displacementBias = 0;\\r\\n\\r\\n\\tthis.wireframe = false;\\r\\n\\tthis.wireframeLinewidth = 1;\\r\\n\\r\\n\\tthis.fog = false;\\r\\n\\r\\n\\tthis.skinning = false;\\r\\n\\tthis.morphTargets = false;\\r\\n\\tthis.morphNormals = false;\\r\\n\\r\\n\\tthis.setValues( parameters );\\r\\n\\r\\n}\\r\\n\\r\\nMeshNormalMaterial.prototype = Object.create( Material.prototype );\\r\\nMeshNormalMaterial.prototype.constructor = MeshNormalMaterial;\\r\\n\\r\\nMeshNormalMaterial.prototype.isMeshNormalMaterial = true;\\r\\n\\r\\nMeshNormalMaterial.prototype.copy = function ( source ) {\\r\\n\\r\\n\\tMaterial.prototype.copy.call( this, source );\\r\\n\\r\\n\\tthis.bumpMap = source.bumpMap;\\r\\n\\tthis.bumpScale = source.bumpScale;\\r\\n\\r\\n\\tthis.normalMap = source.normalMap;\\r\\n\\tthis.normalMapType = source.normalMapType;\\r\\n\\tthis.normalScale.copy( source.normalScale );\\r\\n\\r\\n\\tthis.displacementMap = source.displacementMap;\\r\\n\\tthis.displacementScale = source.displacementScale;\\r\\n\\tthis.displacementBias = source.displacementBias;\\r\\n\\r\\n\\tthis.wireframe = source.wireframe;\\r\\n\\tthis.wireframeLinewidth = source.wireframeLinewidth;\\r\\n\\r\\n\\tthis.skinning = source.skinning;\\r\\n\\tthis.morphTargets = source.morphTargets;\\r\\n\\tthis.morphNormals = source.morphNormals;\\r\\n\\r\\n\\treturn this;\\r\\n\\r\\n};\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n *\\r\\n * parameters = {\\r\\n *  color: <hex>,\\r\\n *  opacity: <float>,\\r\\n *\\r\\n *  map: new THREE.Texture( <Image> ),\\r\\n *\\r\\n *  lightMap: new THREE.Texture( <Image> ),\\r\\n *  lightMapIntensity: <float>\\r\\n *\\r\\n *  aoMap: new THREE.Texture( <Image> ),\\r\\n *  aoMapIntensity: <float>\\r\\n *\\r\\n *  emissive: <hex>,\\r\\n *  emissiveIntensity: <float>\\r\\n *  emissiveMap: new THREE.Texture( <Image> ),\\r\\n *\\r\\n *  specularMap: new THREE.Texture( <Image> ),\\r\\n *\\r\\n *  alphaMap: new THREE.Texture( <Image> ),\\r\\n *\\r\\n *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\\r\\n *  combine: THREE.Multiply,\\r\\n *  reflectivity: <float>,\\r\\n *  refractionRatio: <float>,\\r\\n *\\r\\n *  wireframe: <boolean>,\\r\\n *  wireframeLinewidth: <float>,\\r\\n *\\r\\n *  skinning: <bool>,\\r\\n *  morphTargets: <bool>,\\r\\n *  morphNormals: <bool>\\r\\n * }\\r\\n */\\r\\n\\r\\nfunction MeshLambertMaterial( parameters ) {\\r\\n\\r\\n\\tMaterial.call( this );\\r\\n\\r\\n\\tthis.type = 'MeshLambertMaterial';\\r\\n\\r\\n\\tthis.color = new Color( 0xffffff ); // diffuse\\r\\n\\r\\n\\tthis.map = null;\\r\\n\\r\\n\\tthis.lightMap = null;\\r\\n\\tthis.lightMapIntensity = 1.0;\\r\\n\\r\\n\\tthis.aoMap = null;\\r\\n\\tthis.aoMapIntensity = 1.0;\\r\\n\\r\\n\\tthis.emissive = new Color( 0x000000 );\\r\\n\\tthis.emissiveIntensity = 1.0;\\r\\n\\tthis.emissiveMap = null;\\r\\n\\r\\n\\tthis.specularMap = null;\\r\\n\\r\\n\\tthis.alphaMap = null;\\r\\n\\r\\n\\tthis.envMap = null;\\r\\n\\tthis.combine = MultiplyOperation;\\r\\n\\tthis.reflectivity = 1;\\r\\n\\tthis.refractionRatio = 0.98;\\r\\n\\r\\n\\tthis.wireframe = false;\\r\\n\\tthis.wireframeLinewidth = 1;\\r\\n\\tthis.wireframeLinecap = 'round';\\r\\n\\tthis.wireframeLinejoin = 'round';\\r\\n\\r\\n\\tthis.skinning = false;\\r\\n\\tthis.morphTargets = false;\\r\\n\\tthis.morphNormals = false;\\r\\n\\r\\n\\tthis.setValues( parameters );\\r\\n\\r\\n}\\r\\n\\r\\nMeshLambertMaterial.prototype = Object.create( Material.prototype );\\r\\nMeshLambertMaterial.prototype.constructor = MeshLambertMaterial;\\r\\n\\r\\nMeshLambertMaterial.prototype.isMeshLambertMaterial = true;\\r\\n\\r\\nMeshLambertMaterial.prototype.copy = function ( source ) {\\r\\n\\r\\n\\tMaterial.prototype.copy.call( this, source );\\r\\n\\r\\n\\tthis.color.copy( source.color );\\r\\n\\r\\n\\tthis.map = source.map;\\r\\n\\r\\n\\tthis.lightMap = source.lightMap;\\r\\n\\tthis.lightMapIntensity = source.lightMapIntensity;\\r\\n\\r\\n\\tthis.aoMap = source.aoMap;\\r\\n\\tthis.aoMapIntensity = source.aoMapIntensity;\\r\\n\\r\\n\\tthis.emissive.copy( source.emissive );\\r\\n\\tthis.emissiveMap = source.emissiveMap;\\r\\n\\tthis.emissiveIntensity = source.emissiveIntensity;\\r\\n\\r\\n\\tthis.specularMap = source.specularMap;\\r\\n\\r\\n\\tthis.alphaMap = source.alphaMap;\\r\\n\\r\\n\\tthis.envMap = source.envMap;\\r\\n\\tthis.combine = source.combine;\\r\\n\\tthis.reflectivity = source.reflectivity;\\r\\n\\tthis.refractionRatio = source.refractionRatio;\\r\\n\\r\\n\\tthis.wireframe = source.wireframe;\\r\\n\\tthis.wireframeLinewidth = source.wireframeLinewidth;\\r\\n\\tthis.wireframeLinecap = source.wireframeLinecap;\\r\\n\\tthis.wireframeLinejoin = source.wireframeLinejoin;\\r\\n\\r\\n\\tthis.skinning = source.skinning;\\r\\n\\tthis.morphTargets = source.morphTargets;\\r\\n\\tthis.morphNormals = source.morphNormals;\\r\\n\\r\\n\\treturn this;\\r\\n\\r\\n};\\r\\n\\r\\n/**\\r\\n * @author WestLangley / http://github.com/WestLangley\\r\\n *\\r\\n * parameters = {\\r\\n *  color: <hex>,\\r\\n *  opacity: <float>,\\r\\n *\\r\\n *  matcap: new THREE.Texture( <Image> ),\\r\\n *\\r\\n *  map: new THREE.Texture( <Image> ),\\r\\n *\\r\\n *  bumpMap: new THREE.Texture( <Image> ),\\r\\n *  bumpScale: <float>,\\r\\n *\\r\\n *  normalMap: new THREE.Texture( <Image> ),\\r\\n *  normalMapType: THREE.TangentSpaceNormalMap,\\r\\n *  normalScale: <Vector2>,\\r\\n *\\r\\n *  displacementMap: new THREE.Texture( <Image> ),\\r\\n *  displacementScale: <float>,\\r\\n *  displacementBias: <float>,\\r\\n *\\r\\n *  alphaMap: new THREE.Texture( <Image> ),\\r\\n *\\r\\n *  skinning: <bool>,\\r\\n *  morphTargets: <bool>,\\r\\n *  morphNormals: <bool>\\r\\n * }\\r\\n */\\r\\n\\r\\nfunction MeshMatcapMaterial( parameters ) {\\r\\n\\r\\n\\tMaterial.call( this );\\r\\n\\r\\n\\tthis.defines = { 'MATCAP': '' };\\r\\n\\r\\n\\tthis.type = 'MeshMatcapMaterial';\\r\\n\\r\\n\\tthis.color = new Color( 0xffffff ); // diffuse\\r\\n\\r\\n\\tthis.matcap = null;\\r\\n\\r\\n\\tthis.map = null;\\r\\n\\r\\n\\tthis.bumpMap = null;\\r\\n\\tthis.bumpScale = 1;\\r\\n\\r\\n\\tthis.normalMap = null;\\r\\n\\tthis.normalMapType = TangentSpaceNormalMap;\\r\\n\\tthis.normalScale = new Vector2( 1, 1 );\\r\\n\\r\\n\\tthis.displacementMap = null;\\r\\n\\tthis.displacementScale = 1;\\r\\n\\tthis.displacementBias = 0;\\r\\n\\r\\n\\tthis.alphaMap = null;\\r\\n\\r\\n\\tthis.skinning = false;\\r\\n\\tthis.morphTargets = false;\\r\\n\\tthis.morphNormals = false;\\r\\n\\r\\n\\tthis.setValues( parameters );\\r\\n\\r\\n}\\r\\n\\r\\nMeshMatcapMaterial.prototype = Object.create( Material.prototype );\\r\\nMeshMatcapMaterial.prototype.constructor = MeshMatcapMaterial;\\r\\n\\r\\nMeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;\\r\\n\\r\\nMeshMatcapMaterial.prototype.copy = function ( source ) {\\r\\n\\r\\n\\tMaterial.prototype.copy.call( this, source );\\r\\n\\r\\n\\tthis.defines = { 'MATCAP': '' };\\r\\n\\r\\n\\tthis.color.copy( source.color );\\r\\n\\r\\n\\tthis.matcap = source.matcap;\\r\\n\\r\\n\\tthis.map = source.map;\\r\\n\\r\\n\\tthis.bumpMap = source.bumpMap;\\r\\n\\tthis.bumpScale = source.bumpScale;\\r\\n\\r\\n\\tthis.normalMap = source.normalMap;\\r\\n\\tthis.normalMapType = source.normalMapType;\\r\\n\\tthis.normalScale.copy( source.normalScale );\\r\\n\\r\\n\\tthis.displacementMap = source.displacementMap;\\r\\n\\tthis.displacementScale = source.displacementScale;\\r\\n\\tthis.displacementBias = source.displacementBias;\\r\\n\\r\\n\\tthis.alphaMap = source.alphaMap;\\r\\n\\r\\n\\tthis.skinning = source.skinning;\\r\\n\\tthis.morphTargets = source.morphTargets;\\r\\n\\tthis.morphNormals = source.morphNormals;\\r\\n\\r\\n\\treturn this;\\r\\n\\r\\n};\\r\\n\\r\\n/**\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n *\\r\\n * parameters = {\\r\\n *  color: <hex>,\\r\\n *  opacity: <float>,\\r\\n *\\r\\n *  linewidth: <float>,\\r\\n *\\r\\n *  scale: <float>,\\r\\n *  dashSize: <float>,\\r\\n *  gapSize: <float>\\r\\n * }\\r\\n */\\r\\n\\r\\nfunction LineDashedMaterial( parameters ) {\\r\\n\\r\\n\\tLineBasicMaterial.call( this );\\r\\n\\r\\n\\tthis.type = 'LineDashedMaterial';\\r\\n\\r\\n\\tthis.scale = 1;\\r\\n\\tthis.dashSize = 3;\\r\\n\\tthis.gapSize = 1;\\r\\n\\r\\n\\tthis.setValues( parameters );\\r\\n\\r\\n}\\r\\n\\r\\nLineDashedMaterial.prototype = Object.create( LineBasicMaterial.prototype );\\r\\nLineDashedMaterial.prototype.constructor = LineDashedMaterial;\\r\\n\\r\\nLineDashedMaterial.prototype.isLineDashedMaterial = true;\\r\\n\\r\\nLineDashedMaterial.prototype.copy = function ( source ) {\\r\\n\\r\\n\\tLineBasicMaterial.prototype.copy.call( this, source );\\r\\n\\r\\n\\tthis.scale = source.scale;\\r\\n\\tthis.dashSize = source.dashSize;\\r\\n\\tthis.gapSize = source.gapSize;\\r\\n\\r\\n\\treturn this;\\r\\n\\r\\n};\\r\\n\\r\\nvar Materials = /*#__PURE__*/Object.freeze({\\r\\n\\t__proto__: null,\\r\\n\\tShadowMaterial: ShadowMaterial,\\r\\n\\tSpriteMaterial: SpriteMaterial,\\r\\n\\tRawShaderMaterial: RawShaderMaterial,\\r\\n\\tShaderMaterial: ShaderMaterial,\\r\\n\\tPointsMaterial: PointsMaterial,\\r\\n\\tMeshPhysicalMaterial: MeshPhysicalMaterial,\\r\\n\\tMeshStandardMaterial: MeshStandardMaterial,\\r\\n\\tMeshPhongMaterial: MeshPhongMaterial,\\r\\n\\tMeshToonMaterial: MeshToonMaterial,\\r\\n\\tMeshNormalMaterial: MeshNormalMaterial,\\r\\n\\tMeshLambertMaterial: MeshLambertMaterial,\\r\\n\\tMeshDepthMaterial: MeshDepthMaterial,\\r\\n\\tMeshDistanceMaterial: MeshDistanceMaterial,\\r\\n\\tMeshBasicMaterial: MeshBasicMaterial,\\r\\n\\tMeshMatcapMaterial: MeshMatcapMaterial,\\r\\n\\tLineDashedMaterial: LineDashedMaterial,\\r\\n\\tLineBasicMaterial: LineBasicMaterial,\\r\\n\\tMaterial: Material\\r\\n});\\r\\n\\r\\n/**\\r\\n * @author tschw\\r\\n * @author Ben Houston / http://clara.io/\\r\\n * @author David Sarno / http://lighthaus.us/\\r\\n */\\r\\n\\r\\nvar AnimationUtils = {\\r\\n\\r\\n\\t// same as Array.prototype.slice, but also works on typed arrays\\r\\n\\tarraySlice: function ( array, from, to ) {\\r\\n\\r\\n\\t\\tif ( AnimationUtils.isTypedArray( array ) ) {\\r\\n\\r\\n\\t\\t\\t// in ios9 array.subarray(from, undefined) will return empty array\\r\\n\\t\\t\\t// but array.subarray(from) or array.subarray(from, len) is correct\\r\\n\\t\\t\\treturn new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn array.slice( from, to );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// converts an array to a specific type\\r\\n\\tconvertArray: function ( array, type, forceClone ) {\\r\\n\\r\\n\\t\\tif ( ! array || // let 'undefined' and 'null' pass\\r\\n\\t\\t\\t! forceClone && array.constructor === type ) return array;\\r\\n\\r\\n\\t\\tif ( typeof type.BYTES_PER_ELEMENT === 'number' ) {\\r\\n\\r\\n\\t\\t\\treturn new type( array ); // create typed array\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn Array.prototype.slice.call( array ); // create Array\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tisTypedArray: function ( object ) {\\r\\n\\r\\n\\t\\treturn ArrayBuffer.isView( object ) &&\\r\\n\\t\\t\\t! ( object instanceof DataView );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// returns an array by which times and values can be sorted\\r\\n\\tgetKeyframeOrder: function ( times ) {\\r\\n\\r\\n\\t\\tfunction compareTime( i, j ) {\\r\\n\\r\\n\\t\\t\\treturn times[ i ] - times[ j ];\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar n = times.length;\\r\\n\\t\\tvar result = new Array( n );\\r\\n\\t\\tfor ( var i = 0; i !== n; ++ i ) result[ i ] = i;\\r\\n\\r\\n\\t\\tresult.sort( compareTime );\\r\\n\\r\\n\\t\\treturn result;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// uses the array previously returned by 'getKeyframeOrder' to sort data\\r\\n\\tsortedArray: function ( values, stride, order ) {\\r\\n\\r\\n\\t\\tvar nValues = values.length;\\r\\n\\t\\tvar result = new values.constructor( nValues );\\r\\n\\r\\n\\t\\tfor ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {\\r\\n\\r\\n\\t\\t\\tvar srcOffset = order[ i ] * stride;\\r\\n\\r\\n\\t\\t\\tfor ( var j = 0; j !== stride; ++ j ) {\\r\\n\\r\\n\\t\\t\\t\\tresult[ dstOffset ++ ] = values[ srcOffset + j ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn result;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// function for parsing AOS keyframe formats\\r\\n\\tflattenJSON: function ( jsonKeys, times, values, valuePropertyName ) {\\r\\n\\r\\n\\t\\tvar i = 1, key = jsonKeys[ 0 ];\\r\\n\\r\\n\\t\\twhile ( key !== undefined && key[ valuePropertyName ] === undefined ) {\\r\\n\\r\\n\\t\\t\\tkey = jsonKeys[ i ++ ];\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( key === undefined ) return; // no data\\r\\n\\r\\n\\t\\tvar value = key[ valuePropertyName ];\\r\\n\\t\\tif ( value === undefined ) return; // no data\\r\\n\\r\\n\\t\\tif ( Array.isArray( value ) ) {\\r\\n\\r\\n\\t\\t\\tdo {\\r\\n\\r\\n\\t\\t\\t\\tvalue = key[ valuePropertyName ];\\r\\n\\r\\n\\t\\t\\t\\tif ( value !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\ttimes.push( key.time );\\r\\n\\t\\t\\t\\t\\tvalues.push.apply( values, value ); // push all elements\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tkey = jsonKeys[ i ++ ];\\r\\n\\r\\n\\t\\t\\t} while ( key !== undefined );\\r\\n\\r\\n\\t\\t} else if ( value.toArray !== undefined ) {\\r\\n\\r\\n\\t\\t\\t// ...assume THREE.Math-ish\\r\\n\\r\\n\\t\\t\\tdo {\\r\\n\\r\\n\\t\\t\\t\\tvalue = key[ valuePropertyName ];\\r\\n\\r\\n\\t\\t\\t\\tif ( value !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\ttimes.push( key.time );\\r\\n\\t\\t\\t\\t\\tvalue.toArray( values, values.length );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tkey = jsonKeys[ i ++ ];\\r\\n\\r\\n\\t\\t\\t} while ( key !== undefined );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t// otherwise push as-is\\r\\n\\r\\n\\t\\t\\tdo {\\r\\n\\r\\n\\t\\t\\t\\tvalue = key[ valuePropertyName ];\\r\\n\\r\\n\\t\\t\\t\\tif ( value !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\ttimes.push( key.time );\\r\\n\\t\\t\\t\\t\\tvalues.push( value );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tkey = jsonKeys[ i ++ ];\\r\\n\\r\\n\\t\\t\\t} while ( key !== undefined );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsubclip: function ( sourceClip, name, startFrame, endFrame, fps ) {\\r\\n\\r\\n\\t\\tfps = fps || 30;\\r\\n\\r\\n\\t\\tvar clip = sourceClip.clone();\\r\\n\\r\\n\\t\\tclip.name = name;\\r\\n\\r\\n\\t\\tvar tracks = [];\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < clip.tracks.length; ++ i ) {\\r\\n\\r\\n\\t\\t\\tvar track = clip.tracks[ i ];\\r\\n\\t\\t\\tvar valueSize = track.getValueSize();\\r\\n\\r\\n\\t\\t\\tvar times = [];\\r\\n\\t\\t\\tvar values = [];\\r\\n\\r\\n\\t\\t\\tfor ( var j = 0; j < track.times.length; ++ j ) {\\r\\n\\r\\n\\t\\t\\t\\tvar frame = track.times[ j ] * fps;\\r\\n\\r\\n\\t\\t\\t\\tif ( frame < startFrame || frame >= endFrame ) continue;\\r\\n\\r\\n\\t\\t\\t\\ttimes.push( track.times[ j ] );\\r\\n\\r\\n\\t\\t\\t\\tfor ( var k = 0; k < valueSize; ++ k ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvalues.push( track.values[ j * valueSize + k ] );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( times.length === 0 ) continue;\\r\\n\\r\\n\\t\\t\\ttrack.times = AnimationUtils.convertArray( times, track.times.constructor );\\r\\n\\t\\t\\ttrack.values = AnimationUtils.convertArray( values, track.values.constructor );\\r\\n\\r\\n\\t\\t\\ttracks.push( track );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tclip.tracks = tracks;\\r\\n\\r\\n\\t\\t// find minimum .times value across all tracks in the trimmed clip\\r\\n\\r\\n\\t\\tvar minStartTime = Infinity;\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < clip.tracks.length; ++ i ) {\\r\\n\\r\\n\\t\\t\\tif ( minStartTime > clip.tracks[ i ].times[ 0 ] ) {\\r\\n\\r\\n\\t\\t\\t\\tminStartTime = clip.tracks[ i ].times[ 0 ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// shift all tracks such that clip begins at t=0\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < clip.tracks.length; ++ i ) {\\r\\n\\r\\n\\t\\t\\tclip.tracks[ i ].shift( - 1 * minStartTime );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tclip.resetDuration();\\r\\n\\r\\n\\t\\treturn clip;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tmakeClipAdditive: function ( targetClip, referenceFrame, referenceClip, fps ) {\\r\\n\\r\\n\\t\\tif ( referenceFrame === undefined ) referenceFrame = 0;\\r\\n\\t\\tif ( referenceClip === undefined ) referenceClip = targetClip;\\r\\n\\t\\tif ( fps === undefined || fps <= 0 ) fps = 30;\\r\\n\\r\\n\\t\\tvar numTracks = targetClip.tracks.length;\\r\\n\\t\\tvar referenceTime = referenceFrame / fps;\\r\\n\\r\\n\\t\\t// Make each track's values relative to the values at the reference frame\\r\\n\\t\\tfor ( var i = 0; i < numTracks; ++ i ) {\\r\\n\\r\\n\\t\\t\\tvar referenceTrack = referenceClip.tracks[ i ];\\r\\n\\t\\t\\tvar referenceTrackType = referenceTrack.ValueTypeName;\\r\\n\\r\\n\\t\\t\\t// Skip this track if it's non-numeric\\r\\n\\t\\t\\tif ( referenceTrackType === 'bool' || referenceTrackType === 'string' ) continue;\\r\\n\\r\\n\\t\\t\\t// Find the track in the target clip whose name and type matches the reference track\\r\\n\\t\\t\\tvar targetTrack = targetClip.tracks.find( function ( track ) {\\r\\n\\r\\n\\t\\t\\t\\treturn track.name === referenceTrack.name\\r\\n\\t\\t\\t\\t&& track.ValueTypeName === referenceTrackType;\\r\\n\\r\\n\\t\\t\\t} );\\r\\n\\r\\n\\t\\t\\tif ( targetTrack === undefined ) continue;\\r\\n\\r\\n\\t\\t\\tvar valueSize = referenceTrack.getValueSize();\\r\\n\\t\\t\\tvar lastIndex = referenceTrack.times.length - 1;\\r\\n\\t\\t\\tvar referenceValue;\\r\\n\\r\\n\\t\\t\\t// Find the value to subtract out of the track\\r\\n\\t\\t\\tif ( referenceTime <= referenceTrack.times[ 0 ] ) {\\r\\n\\r\\n\\t\\t\\t\\t// Reference frame is earlier than the first keyframe, so just use the first keyframe\\r\\n\\t\\t\\t\\treferenceValue = AnimationUtils.arraySlice( referenceTrack.values, 0, referenceTrack.valueSize );\\r\\n\\r\\n\\t\\t\\t} else if ( referenceTime >= referenceTrack.times[ lastIndex ] ) {\\r\\n\\r\\n\\t\\t\\t\\t// Reference frame is after the last keyframe, so just use the last keyframe\\r\\n\\t\\t\\t\\tvar startIndex = lastIndex * valueSize;\\r\\n\\t\\t\\t\\treferenceValue = AnimationUtils.arraySlice( referenceTrack.values, startIndex );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t// Interpolate to the reference value\\r\\n\\t\\t\\t\\tvar interpolant = referenceTrack.createInterpolant();\\r\\n\\t\\t\\t\\tinterpolant.evaluate( referenceTime );\\r\\n\\t\\t\\t\\treferenceValue = interpolant.resultBuffer;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// Conjugate the quaternion\\r\\n\\t\\t\\tif ( referenceTrackType === 'quaternion' ) {\\r\\n\\r\\n\\t\\t\\t\\tvar referenceQuat = new Quaternion(\\r\\n\\t\\t\\t\\t\\treferenceValue[ 0 ],\\r\\n\\t\\t\\t\\t\\treferenceValue[ 1 ],\\r\\n\\t\\t\\t\\t\\treferenceValue[ 2 ],\\r\\n\\t\\t\\t\\t\\treferenceValue[ 3 ]\\r\\n\\t\\t\\t\\t).normalize().conjugate();\\r\\n\\t\\t\\t\\treferenceQuat.toArray( referenceValue );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// Subtract the reference value from all of the track values\\r\\n\\r\\n\\t\\t\\tvar numTimes = targetTrack.times.length;\\r\\n\\t\\t\\tfor ( var j = 0; j < numTimes; ++ j ) {\\r\\n\\r\\n\\t\\t\\t\\tvar valueStart = j * valueSize;\\r\\n\\r\\n\\t\\t\\t\\tif ( referenceTrackType === 'quaternion' ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// Multiply the conjugate for quaternion track types\\r\\n\\t\\t\\t\\t\\tQuaternion.multiplyQuaternionsFlat(\\r\\n\\t\\t\\t\\t\\t\\ttargetTrack.values,\\r\\n\\t\\t\\t\\t\\t\\tvalueStart,\\r\\n\\t\\t\\t\\t\\t\\treferenceValue,\\r\\n\\t\\t\\t\\t\\t\\t0,\\r\\n\\t\\t\\t\\t\\t\\ttargetTrack.values,\\r\\n\\t\\t\\t\\t\\t\\tvalueStart\\r\\n\\t\\t\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t// Subtract each value for all other numeric track types\\r\\n\\t\\t\\t\\t\\tfor ( var k = 0; k < valueSize; ++ k ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\ttargetTrack.values[ valueStart + k ] -= referenceValue[ k ];\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\ttargetClip.blendMode = AdditiveAnimationBlendMode;\\r\\n\\r\\n\\t\\treturn targetClip;\\r\\n\\r\\n\\t}\\r\\n\\r\\n};\\r\\n\\r\\n/**\\r\\n * Abstract base class of interpolants over parametric samples.\\r\\n *\\r\\n * The parameter domain is one dimensional, typically the time or a path\\r\\n * along a curve defined by the data.\\r\\n *\\r\\n * The sample values can have any dimensionality and derived classes may\\r\\n * apply special interpretations to the data.\\r\\n *\\r\\n * This class provides the interval seek in a Template Method, deferring\\r\\n * the actual interpolation to derived classes.\\r\\n *\\r\\n * Time complexity is O(1) for linear access crossing at most two points\\r\\n * and O(log N) for random access, where N is the number of positions.\\r\\n *\\r\\n * References:\\r\\n *\\r\\n * \\t\\thttp://www.oodesign.com/template-method-pattern.html\\r\\n *\\r\\n * @author tschw\\r\\n */\\r\\n\\r\\nfunction Interpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\\r\\n\\r\\n\\tthis.parameterPositions = parameterPositions;\\r\\n\\tthis._cachedIndex = 0;\\r\\n\\r\\n\\tthis.resultBuffer = resultBuffer !== undefined ?\\r\\n\\t\\tresultBuffer : new sampleValues.constructor( sampleSize );\\r\\n\\tthis.sampleValues = sampleValues;\\r\\n\\tthis.valueSize = sampleSize;\\r\\n\\r\\n}\\r\\n\\r\\nObject.assign( Interpolant.prototype, {\\r\\n\\r\\n\\tevaluate: function ( t ) {\\r\\n\\r\\n\\t\\tvar pp = this.parameterPositions,\\r\\n\\t\\t\\ti1 = this._cachedIndex,\\r\\n\\r\\n\\t\\t\\tt1 = pp[ i1 ],\\r\\n\\t\\t\\tt0 = pp[ i1 - 1 ];\\r\\n\\r\\n\\t\\tvalidate_interval: {\\r\\n\\r\\n\\t\\t\\tseek: {\\r\\n\\r\\n\\t\\t\\t\\tvar right;\\r\\n\\r\\n\\t\\t\\t\\tlinear_scan: {\\r\\n\\r\\n\\t\\t\\t\\t\\t//- See http://jsperf.com/comparison-to-undefined/3\\r\\n\\t\\t\\t\\t\\t//- slower code:\\r\\n\\t\\t\\t\\t\\t//-\\r\\n\\t\\t\\t\\t\\t//- \\t\\t\\t\\tif ( t >= t1 || t1 === undefined ) {\\r\\n\\t\\t\\t\\t\\tforward_scan: if ( ! ( t < t1 ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tfor ( var giveUpAt = i1 + 2; ; ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( t1 === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( t < t0 ) break forward_scan;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t// after end\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\ti1 = pp.length;\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tthis._cachedIndex = i1;\\r\\n\\t\\t\\t\\t\\t\\t\\t\\treturn this.afterEnd_( i1 - 1, t, t0 );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( i1 === giveUpAt ) break; // this loop\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tt0 = t1;\\r\\n\\t\\t\\t\\t\\t\\t\\tt1 = pp[ ++ i1 ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( t < t1 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t// we have arrived at the sought interval\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak seek;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// prepare binary search on the right side of the index\\r\\n\\t\\t\\t\\t\\t\\tright = pp.length;\\r\\n\\t\\t\\t\\t\\t\\tbreak linear_scan;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t//- slower code:\\r\\n\\t\\t\\t\\t\\t//-\\t\\t\\t\\t\\tif ( t < t0 || t0 === undefined ) {\\r\\n\\t\\t\\t\\t\\tif ( ! ( t >= t0 ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// looping?\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar t1global = pp[ 1 ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( t < t1global ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\ti1 = 2; // + 1, using the scan for the details\\r\\n\\t\\t\\t\\t\\t\\t\\tt0 = t1global;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// linear reverse scan\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tfor ( var giveUpAt = i1 - 2; ; ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( t0 === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t// before start\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tthis._cachedIndex = 0;\\r\\n\\t\\t\\t\\t\\t\\t\\t\\treturn this.beforeStart_( 0, t, t1 );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( i1 === giveUpAt ) break; // this loop\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tt1 = t0;\\r\\n\\t\\t\\t\\t\\t\\t\\tt0 = pp[ -- i1 - 1 ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( t >= t0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t// we have arrived at the sought interval\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak seek;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// prepare binary search on the left side of the index\\r\\n\\t\\t\\t\\t\\t\\tright = i1;\\r\\n\\t\\t\\t\\t\\t\\ti1 = 0;\\r\\n\\t\\t\\t\\t\\t\\tbreak linear_scan;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t// the interval is valid\\r\\n\\r\\n\\t\\t\\t\\t\\tbreak validate_interval;\\r\\n\\r\\n\\t\\t\\t\\t} // linear scan\\r\\n\\r\\n\\t\\t\\t\\t// binary search\\r\\n\\r\\n\\t\\t\\t\\twhile ( i1 < right ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar mid = ( i1 + right ) >>> 1;\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( t < pp[ mid ] ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tright = mid;\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\ti1 = mid + 1;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tt1 = pp[ i1 ];\\r\\n\\t\\t\\t\\tt0 = pp[ i1 - 1 ];\\r\\n\\r\\n\\t\\t\\t\\t// check boundary cases, again\\r\\n\\r\\n\\t\\t\\t\\tif ( t0 === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis._cachedIndex = 0;\\r\\n\\t\\t\\t\\t\\treturn this.beforeStart_( 0, t, t1 );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( t1 === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\ti1 = pp.length;\\r\\n\\t\\t\\t\\t\\tthis._cachedIndex = i1;\\r\\n\\t\\t\\t\\t\\treturn this.afterEnd_( i1 - 1, t0, t );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} // seek\\r\\n\\r\\n\\t\\t\\tthis._cachedIndex = i1;\\r\\n\\r\\n\\t\\t\\tthis.intervalChanged_( i1, t0, t1 );\\r\\n\\r\\n\\t\\t} // validate_interval\\r\\n\\r\\n\\t\\treturn this.interpolate_( i1, t0, t, t1 );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsettings: null, // optional, subclass-specific settings structure\\r\\n\\t// Note: The indirection allows central control of many interpolants.\\r\\n\\r\\n\\t// --- Protected interface\\r\\n\\r\\n\\tDefaultSettings_: {},\\r\\n\\r\\n\\tgetSettings_: function () {\\r\\n\\r\\n\\t\\treturn this.settings || this.DefaultSettings_;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcopySampleValue_: function ( index ) {\\r\\n\\r\\n\\t\\t// copies a sample value to the result buffer\\r\\n\\r\\n\\t\\tvar result = this.resultBuffer,\\r\\n\\t\\t\\tvalues = this.sampleValues,\\r\\n\\t\\t\\tstride = this.valueSize,\\r\\n\\t\\t\\toffset = index * stride;\\r\\n\\r\\n\\t\\tfor ( var i = 0; i !== stride; ++ i ) {\\r\\n\\r\\n\\t\\t\\tresult[ i ] = values[ offset + i ];\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn result;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// Template methods for derived classes:\\r\\n\\r\\n\\tinterpolate_: function ( /* i1, t0, t, t1 */ ) {\\r\\n\\r\\n\\t\\tthrow new Error( 'call to abstract method' );\\r\\n\\t\\t// implementations shall return this.resultBuffer\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tintervalChanged_: function ( /* i1, t0, t1 */ ) {\\r\\n\\r\\n\\t\\t// empty\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n// DECLARE ALIAS AFTER assign prototype\\r\\nObject.assign( Interpolant.prototype, {\\r\\n\\r\\n\\t//( 0, t, t0 ), returns this.resultBuffer\\r\\n\\tbeforeStart_: Interpolant.prototype.copySampleValue_,\\r\\n\\r\\n\\t//( N-1, tN-1, t ), returns this.resultBuffer\\r\\n\\tafterEnd_: Interpolant.prototype.copySampleValue_,\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * Fast and simple cubic spline interpolant.\\r\\n *\\r\\n * It was derived from a Hermitian construction setting the first derivative\\r\\n * at each sample position to the linear slope between neighboring positions\\r\\n * over their parameter interval.\\r\\n *\\r\\n * @author tschw\\r\\n */\\r\\n\\r\\nfunction CubicInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\\r\\n\\r\\n\\tInterpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\\r\\n\\r\\n\\tthis._weightPrev = - 0;\\r\\n\\tthis._offsetPrev = - 0;\\r\\n\\tthis._weightNext = - 0;\\r\\n\\tthis._offsetNext = - 0;\\r\\n\\r\\n}\\r\\n\\r\\nCubicInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\\r\\n\\r\\n\\tconstructor: CubicInterpolant,\\r\\n\\r\\n\\tDefaultSettings_: {\\r\\n\\r\\n\\t\\tendingStart: ZeroCurvatureEnding,\\r\\n\\t\\tendingEnd: ZeroCurvatureEnding\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tintervalChanged_: function ( i1, t0, t1 ) {\\r\\n\\r\\n\\t\\tvar pp = this.parameterPositions,\\r\\n\\t\\t\\tiPrev = i1 - 2,\\r\\n\\t\\t\\tiNext = i1 + 1,\\r\\n\\r\\n\\t\\t\\ttPrev = pp[ iPrev ],\\r\\n\\t\\t\\ttNext = pp[ iNext ];\\r\\n\\r\\n\\t\\tif ( tPrev === undefined ) {\\r\\n\\r\\n\\t\\t\\tswitch ( this.getSettings_().endingStart ) {\\r\\n\\r\\n\\t\\t\\t\\tcase ZeroSlopeEnding:\\r\\n\\r\\n\\t\\t\\t\\t\\t// f'(t0) = 0\\r\\n\\t\\t\\t\\t\\tiPrev = i1;\\r\\n\\t\\t\\t\\t\\ttPrev = 2 * t0 - t1;\\r\\n\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\tcase WrapAroundEnding:\\r\\n\\r\\n\\t\\t\\t\\t\\t// use the other end of the curve\\r\\n\\t\\t\\t\\t\\tiPrev = pp.length - 2;\\r\\n\\t\\t\\t\\t\\ttPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];\\r\\n\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\tdefault: // ZeroCurvatureEnding\\r\\n\\r\\n\\t\\t\\t\\t\\t// f''(t0) = 0 a.k.a. Natural Spline\\r\\n\\t\\t\\t\\t\\tiPrev = i1;\\r\\n\\t\\t\\t\\t\\ttPrev = t1;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( tNext === undefined ) {\\r\\n\\r\\n\\t\\t\\tswitch ( this.getSettings_().endingEnd ) {\\r\\n\\r\\n\\t\\t\\t\\tcase ZeroSlopeEnding:\\r\\n\\r\\n\\t\\t\\t\\t\\t// f'(tN) = 0\\r\\n\\t\\t\\t\\t\\tiNext = i1;\\r\\n\\t\\t\\t\\t\\ttNext = 2 * t1 - t0;\\r\\n\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\tcase WrapAroundEnding:\\r\\n\\r\\n\\t\\t\\t\\t\\t// use the other end of the curve\\r\\n\\t\\t\\t\\t\\tiNext = 1;\\r\\n\\t\\t\\t\\t\\ttNext = t1 + pp[ 1 ] - pp[ 0 ];\\r\\n\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\tdefault: // ZeroCurvatureEnding\\r\\n\\r\\n\\t\\t\\t\\t\\t// f''(tN) = 0, a.k.a. Natural Spline\\r\\n\\t\\t\\t\\t\\tiNext = i1 - 1;\\r\\n\\t\\t\\t\\t\\ttNext = t0;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar halfDt = ( t1 - t0 ) * 0.5,\\r\\n\\t\\t\\tstride = this.valueSize;\\r\\n\\r\\n\\t\\tthis._weightPrev = halfDt / ( t0 - tPrev );\\r\\n\\t\\tthis._weightNext = halfDt / ( tNext - t1 );\\r\\n\\t\\tthis._offsetPrev = iPrev * stride;\\r\\n\\t\\tthis._offsetNext = iNext * stride;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tinterpolate_: function ( i1, t0, t, t1 ) {\\r\\n\\r\\n\\t\\tvar result = this.resultBuffer,\\r\\n\\t\\t\\tvalues = this.sampleValues,\\r\\n\\t\\t\\tstride = this.valueSize,\\r\\n\\r\\n\\t\\t\\to1 = i1 * stride,\\t\\to0 = o1 - stride,\\r\\n\\t\\t\\toP = this._offsetPrev, \\toN = this._offsetNext,\\r\\n\\t\\t\\twP = this._weightPrev,\\twN = this._weightNext,\\r\\n\\r\\n\\t\\t\\tp = ( t - t0 ) / ( t1 - t0 ),\\r\\n\\t\\t\\tpp = p * p,\\r\\n\\t\\t\\tppp = pp * p;\\r\\n\\r\\n\\t\\t// evaluate polynomials\\r\\n\\r\\n\\t\\tvar sP = - wP * ppp + 2 * wP * pp - wP * p;\\r\\n\\t\\tvar s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;\\r\\n\\t\\tvar s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;\\r\\n\\t\\tvar sN = wN * ppp - wN * pp;\\r\\n\\r\\n\\t\\t// combine data linearly\\r\\n\\r\\n\\t\\tfor ( var i = 0; i !== stride; ++ i ) {\\r\\n\\r\\n\\t\\t\\tresult[ i ] =\\r\\n\\t\\t\\t\\t\\tsP * values[ oP + i ] +\\r\\n\\t\\t\\t\\t\\ts0 * values[ o0 + i ] +\\r\\n\\t\\t\\t\\t\\ts1 * values[ o1 + i ] +\\r\\n\\t\\t\\t\\t\\tsN * values[ oN + i ];\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn result;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author tschw\\r\\n */\\r\\n\\r\\nfunction LinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\\r\\n\\r\\n\\tInterpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\\r\\n\\r\\n}\\r\\n\\r\\nLinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\\r\\n\\r\\n\\tconstructor: LinearInterpolant,\\r\\n\\r\\n\\tinterpolate_: function ( i1, t0, t, t1 ) {\\r\\n\\r\\n\\t\\tvar result = this.resultBuffer,\\r\\n\\t\\t\\tvalues = this.sampleValues,\\r\\n\\t\\t\\tstride = this.valueSize,\\r\\n\\r\\n\\t\\t\\toffset1 = i1 * stride,\\r\\n\\t\\t\\toffset0 = offset1 - stride,\\r\\n\\r\\n\\t\\t\\tweight1 = ( t - t0 ) / ( t1 - t0 ),\\r\\n\\t\\t\\tweight0 = 1 - weight1;\\r\\n\\r\\n\\t\\tfor ( var i = 0; i !== stride; ++ i ) {\\r\\n\\r\\n\\t\\t\\tresult[ i ] =\\r\\n\\t\\t\\t\\t\\tvalues[ offset0 + i ] * weight0 +\\r\\n\\t\\t\\t\\t\\tvalues[ offset1 + i ] * weight1;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn result;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n *\\r\\n * Interpolant that evaluates to the sample value at the position preceeding\\r\\n * the parameter.\\r\\n *\\r\\n * @author tschw\\r\\n */\\r\\n\\r\\nfunction DiscreteInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\\r\\n\\r\\n\\tInterpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\\r\\n\\r\\n}\\r\\n\\r\\nDiscreteInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\\r\\n\\r\\n\\tconstructor: DiscreteInterpolant,\\r\\n\\r\\n\\tinterpolate_: function ( i1 /*, t0, t, t1 */ ) {\\r\\n\\r\\n\\t\\treturn this.copySampleValue_( i1 - 1 );\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n *\\r\\n * A timed sequence of keyframes for a specific property.\\r\\n *\\r\\n *\\r\\n * @author Ben Houston / http://clara.io/\\r\\n * @author David Sarno / http://lighthaus.us/\\r\\n * @author tschw\\r\\n */\\r\\n\\r\\nfunction KeyframeTrack( name, times, values, interpolation ) {\\r\\n\\r\\n\\tif ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );\\r\\n\\tif ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );\\r\\n\\r\\n\\tthis.name = name;\\r\\n\\r\\n\\tthis.times = AnimationUtils.convertArray( times, this.TimeBufferType );\\r\\n\\tthis.values = AnimationUtils.convertArray( values, this.ValueBufferType );\\r\\n\\r\\n\\tthis.setInterpolation( interpolation || this.DefaultInterpolation );\\r\\n\\r\\n}\\r\\n\\r\\n// Static methods\\r\\n\\r\\nObject.assign( KeyframeTrack, {\\r\\n\\r\\n\\t// Serialization (in static context, because of constructor invocation\\r\\n\\t// and automatic invocation of .toJSON):\\r\\n\\r\\n\\ttoJSON: function ( track ) {\\r\\n\\r\\n\\t\\tvar trackType = track.constructor;\\r\\n\\r\\n\\t\\tvar json;\\r\\n\\r\\n\\t\\t// derived classes can define a static toJSON method\\r\\n\\t\\tif ( trackType.toJSON !== undefined ) {\\r\\n\\r\\n\\t\\t\\tjson = trackType.toJSON( track );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t// by default, we assume the data can be serialized as-is\\r\\n\\t\\t\\tjson = {\\r\\n\\r\\n\\t\\t\\t\\t'name': track.name,\\r\\n\\t\\t\\t\\t'times': AnimationUtils.convertArray( track.times, Array ),\\r\\n\\t\\t\\t\\t'values': AnimationUtils.convertArray( track.values, Array )\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\tvar interpolation = track.getInterpolation();\\r\\n\\r\\n\\t\\t\\tif ( interpolation !== track.DefaultInterpolation ) {\\r\\n\\r\\n\\t\\t\\t\\tjson.interpolation = interpolation;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tjson.type = track.ValueTypeName; // mandatory\\r\\n\\r\\n\\t\\treturn json;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nObject.assign( KeyframeTrack.prototype, {\\r\\n\\r\\n\\tconstructor: KeyframeTrack,\\r\\n\\r\\n\\tTimeBufferType: Float32Array,\\r\\n\\r\\n\\tValueBufferType: Float32Array,\\r\\n\\r\\n\\tDefaultInterpolation: InterpolateLinear,\\r\\n\\r\\n\\tInterpolantFactoryMethodDiscrete: function ( result ) {\\r\\n\\r\\n\\t\\treturn new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tInterpolantFactoryMethodLinear: function ( result ) {\\r\\n\\r\\n\\t\\treturn new LinearInterpolant( this.times, this.values, this.getValueSize(), result );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tInterpolantFactoryMethodSmooth: function ( result ) {\\r\\n\\r\\n\\t\\treturn new CubicInterpolant( this.times, this.values, this.getValueSize(), result );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetInterpolation: function ( interpolation ) {\\r\\n\\r\\n\\t\\tvar factoryMethod;\\r\\n\\r\\n\\t\\tswitch ( interpolation ) {\\r\\n\\r\\n\\t\\t\\tcase InterpolateDiscrete:\\r\\n\\r\\n\\t\\t\\t\\tfactoryMethod = this.InterpolantFactoryMethodDiscrete;\\r\\n\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tcase InterpolateLinear:\\r\\n\\r\\n\\t\\t\\t\\tfactoryMethod = this.InterpolantFactoryMethodLinear;\\r\\n\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tcase InterpolateSmooth:\\r\\n\\r\\n\\t\\t\\t\\tfactoryMethod = this.InterpolantFactoryMethodSmooth;\\r\\n\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( factoryMethod === undefined ) {\\r\\n\\r\\n\\t\\t\\tvar message = \\\"unsupported interpolation for \\\" +\\r\\n\\t\\t\\t\\tthis.ValueTypeName + \\\" keyframe track named \\\" + this.name;\\r\\n\\r\\n\\t\\t\\tif ( this.createInterpolant === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t// fall back to default, unless the default itself is messed up\\r\\n\\t\\t\\t\\tif ( interpolation !== this.DefaultInterpolation ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.setInterpolation( this.DefaultInterpolation );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tthrow new Error( message ); // fatal, in this case\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.KeyframeTrack:', message );\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.createInterpolant = factoryMethod;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetInterpolation: function () {\\r\\n\\r\\n\\t\\tswitch ( this.createInterpolant ) {\\r\\n\\r\\n\\t\\t\\tcase this.InterpolantFactoryMethodDiscrete:\\r\\n\\r\\n\\t\\t\\t\\treturn InterpolateDiscrete;\\r\\n\\r\\n\\t\\t\\tcase this.InterpolantFactoryMethodLinear:\\r\\n\\r\\n\\t\\t\\t\\treturn InterpolateLinear;\\r\\n\\r\\n\\t\\t\\tcase this.InterpolantFactoryMethodSmooth:\\r\\n\\r\\n\\t\\t\\t\\treturn InterpolateSmooth;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetValueSize: function () {\\r\\n\\r\\n\\t\\treturn this.values.length / this.times.length;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// move all keyframes either forwards or backwards in time\\r\\n\\tshift: function ( timeOffset ) {\\r\\n\\r\\n\\t\\tif ( timeOffset !== 0.0 ) {\\r\\n\\r\\n\\t\\t\\tvar times = this.times;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, n = times.length; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\ttimes[ i ] += timeOffset;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// scale all keyframe times by a factor (useful for frame <-> seconds conversions)\\r\\n\\tscale: function ( timeScale ) {\\r\\n\\r\\n\\t\\tif ( timeScale !== 1.0 ) {\\r\\n\\r\\n\\t\\t\\tvar times = this.times;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, n = times.length; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\ttimes[ i ] *= timeScale;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// removes keyframes before and after animation without changing any values within the range [startTime, endTime].\\r\\n\\t// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\\r\\n\\ttrim: function ( startTime, endTime ) {\\r\\n\\r\\n\\t\\tvar times = this.times,\\r\\n\\t\\t\\tnKeys = times.length,\\r\\n\\t\\t\\tfrom = 0,\\r\\n\\t\\t\\tto = nKeys - 1;\\r\\n\\r\\n\\t\\twhile ( from !== nKeys && times[ from ] < startTime ) {\\r\\n\\r\\n\\t\\t\\t++ from;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\twhile ( to !== - 1 && times[ to ] > endTime ) {\\r\\n\\r\\n\\t\\t\\t-- to;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t++ to; // inclusive -> exclusive bound\\r\\n\\r\\n\\t\\tif ( from !== 0 || to !== nKeys ) {\\r\\n\\r\\n\\t\\t\\t// empty tracks are forbidden, so keep at least one keyframe\\r\\n\\t\\t\\tif ( from >= to ) {\\r\\n\\r\\n\\t\\t\\t\\tto = Math.max( to, 1 );\\r\\n\\t\\t\\t\\tfrom = to - 1;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar stride = this.getValueSize();\\r\\n\\t\\t\\tthis.times = AnimationUtils.arraySlice( times, from, to );\\r\\n\\t\\t\\tthis.values = AnimationUtils.arraySlice( this.values, from * stride, to * stride );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\\r\\n\\tvalidate: function () {\\r\\n\\r\\n\\t\\tvar valid = true;\\r\\n\\r\\n\\t\\tvar valueSize = this.getValueSize();\\r\\n\\t\\tif ( valueSize - Math.floor( valueSize ) !== 0 ) {\\r\\n\\r\\n\\t\\t\\tconsole.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );\\r\\n\\t\\t\\tvalid = false;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar times = this.times,\\r\\n\\t\\t\\tvalues = this.values,\\r\\n\\r\\n\\t\\t\\tnKeys = times.length;\\r\\n\\r\\n\\t\\tif ( nKeys === 0 ) {\\r\\n\\r\\n\\t\\t\\tconsole.error( 'THREE.KeyframeTrack: Track is empty.', this );\\r\\n\\t\\t\\tvalid = false;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar prevTime = null;\\r\\n\\r\\n\\t\\tfor ( var i = 0; i !== nKeys; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar currTime = times[ i ];\\r\\n\\r\\n\\t\\t\\tif ( typeof currTime === 'number' && isNaN( currTime ) ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );\\r\\n\\t\\t\\t\\tvalid = false;\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( prevTime !== null && prevTime > currTime ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );\\r\\n\\t\\t\\t\\tvalid = false;\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tprevTime = currTime;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( values !== undefined ) {\\r\\n\\r\\n\\t\\t\\tif ( AnimationUtils.isTypedArray( values ) ) {\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, n = values.length; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar value = values[ i ];\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( isNaN( value ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );\\r\\n\\t\\t\\t\\t\\t\\tvalid = false;\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn valid;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// removes equivalent sequential keys as common in morph target sequences\\r\\n\\t// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\\r\\n\\toptimize: function () {\\r\\n\\r\\n\\t\\t// times or values may be shared with other tracks, so overwriting is unsafe\\r\\n\\t\\tvar times = AnimationUtils.arraySlice( this.times ),\\r\\n\\t\\t\\tvalues = AnimationUtils.arraySlice( this.values ),\\r\\n\\t\\t\\tstride = this.getValueSize(),\\r\\n\\r\\n\\t\\t\\tsmoothInterpolation = this.getInterpolation() === InterpolateSmooth,\\r\\n\\r\\n\\t\\t\\twriteIndex = 1,\\r\\n\\t\\t\\tlastIndex = times.length - 1;\\r\\n\\r\\n\\t\\tfor ( var i = 1; i < lastIndex; ++ i ) {\\r\\n\\r\\n\\t\\t\\tvar keep = false;\\r\\n\\r\\n\\t\\t\\tvar time = times[ i ];\\r\\n\\t\\t\\tvar timeNext = times[ i + 1 ];\\r\\n\\r\\n\\t\\t\\t// remove adjacent keyframes scheduled at the same time\\r\\n\\r\\n\\t\\t\\tif ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( ! smoothInterpolation ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// remove unnecessary keyframes same as their neighbors\\r\\n\\r\\n\\t\\t\\t\\t\\tvar offset = i * stride,\\r\\n\\t\\t\\t\\t\\t\\toffsetP = offset - stride,\\r\\n\\t\\t\\t\\t\\t\\toffsetN = offset + stride;\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var j = 0; j !== stride; ++ j ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar value = values[ offset + j ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( value !== values[ offsetP + j ] ||\\r\\n\\t\\t\\t\\t\\t\\t\\tvalue !== values[ offsetN + j ] ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tkeep = true;\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tkeep = true;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// in-place compaction\\r\\n\\r\\n\\t\\t\\tif ( keep ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( i !== writeIndex ) {\\r\\n\\r\\n\\t\\t\\t\\t\\ttimes[ writeIndex ] = times[ i ];\\r\\n\\r\\n\\t\\t\\t\\t\\tvar readOffset = i * stride,\\r\\n\\t\\t\\t\\t\\t\\twriteOffset = writeIndex * stride;\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var j = 0; j !== stride; ++ j ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvalues[ writeOffset + j ] = values[ readOffset + j ];\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t++ writeIndex;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// flush last keyframe (compaction looks ahead)\\r\\n\\r\\n\\t\\tif ( lastIndex > 0 ) {\\r\\n\\r\\n\\t\\t\\ttimes[ writeIndex ] = times[ lastIndex ];\\r\\n\\r\\n\\t\\t\\tfor ( var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {\\r\\n\\r\\n\\t\\t\\t\\tvalues[ writeOffset + j ] = values[ readOffset + j ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t++ writeIndex;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( writeIndex !== times.length ) {\\r\\n\\r\\n\\t\\t\\tthis.times = AnimationUtils.arraySlice( times, 0, writeIndex );\\r\\n\\t\\t\\tthis.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tthis.times = times;\\r\\n\\t\\t\\tthis.values = values;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclone: function () {\\r\\n\\r\\n\\t\\tvar times = AnimationUtils.arraySlice( this.times, 0 );\\r\\n\\t\\tvar values = AnimationUtils.arraySlice( this.values, 0 );\\r\\n\\r\\n\\t\\tvar TypedKeyframeTrack = this.constructor;\\r\\n\\t\\tvar track = new TypedKeyframeTrack( this.name, times, values );\\r\\n\\r\\n\\t\\t// Interpolant argument to constructor is not saved, so copy the factory method directly.\\r\\n\\t\\ttrack.createInterpolant = this.createInterpolant;\\r\\n\\r\\n\\t\\treturn track;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n *\\r\\n * A Track of Boolean keyframe values.\\r\\n *\\r\\n *\\r\\n * @author Ben Houston / http://clara.io/\\r\\n * @author David Sarno / http://lighthaus.us/\\r\\n * @author tschw\\r\\n */\\r\\n\\r\\nfunction BooleanKeyframeTrack( name, times, values ) {\\r\\n\\r\\n\\tKeyframeTrack.call( this, name, times, values );\\r\\n\\r\\n}\\r\\n\\r\\nBooleanKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\\r\\n\\r\\n\\tconstructor: BooleanKeyframeTrack,\\r\\n\\r\\n\\tValueTypeName: 'bool',\\r\\n\\tValueBufferType: Array,\\r\\n\\r\\n\\tDefaultInterpolation: InterpolateDiscrete,\\r\\n\\r\\n\\tInterpolantFactoryMethodLinear: undefined,\\r\\n\\tInterpolantFactoryMethodSmooth: undefined\\r\\n\\r\\n\\t// Note: Actually this track could have a optimized / compressed\\r\\n\\t// representation of a single value and a custom interpolant that\\r\\n\\t// computes \\\"firstValue ^ isOdd( index )\\\".\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n *\\r\\n * A Track of keyframe values that represent color.\\r\\n *\\r\\n *\\r\\n * @author Ben Houston / http://clara.io/\\r\\n * @author David Sarno / http://lighthaus.us/\\r\\n * @author tschw\\r\\n */\\r\\n\\r\\nfunction ColorKeyframeTrack( name, times, values, interpolation ) {\\r\\n\\r\\n\\tKeyframeTrack.call( this, name, times, values, interpolation );\\r\\n\\r\\n}\\r\\n\\r\\nColorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\\r\\n\\r\\n\\tconstructor: ColorKeyframeTrack,\\r\\n\\r\\n\\tValueTypeName: 'color'\\r\\n\\r\\n\\t// ValueBufferType is inherited\\r\\n\\r\\n\\t// DefaultInterpolation is inherited\\r\\n\\r\\n\\t// Note: Very basic implementation and nothing special yet.\\r\\n\\t// However, this is the place for color space parameterization.\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n *\\r\\n * A Track of numeric keyframe values.\\r\\n *\\r\\n * @author Ben Houston / http://clara.io/\\r\\n * @author David Sarno / http://lighthaus.us/\\r\\n * @author tschw\\r\\n */\\r\\n\\r\\nfunction NumberKeyframeTrack( name, times, values, interpolation ) {\\r\\n\\r\\n\\tKeyframeTrack.call( this, name, times, values, interpolation );\\r\\n\\r\\n}\\r\\n\\r\\nNumberKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\\r\\n\\r\\n\\tconstructor: NumberKeyframeTrack,\\r\\n\\r\\n\\tValueTypeName: 'number'\\r\\n\\r\\n\\t// ValueBufferType is inherited\\r\\n\\r\\n\\t// DefaultInterpolation is inherited\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * Spherical linear unit quaternion interpolant.\\r\\n *\\r\\n * @author tschw\\r\\n */\\r\\n\\r\\nfunction QuaternionLinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\\r\\n\\r\\n\\tInterpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\\r\\n\\r\\n}\\r\\n\\r\\nQuaternionLinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\\r\\n\\r\\n\\tconstructor: QuaternionLinearInterpolant,\\r\\n\\r\\n\\tinterpolate_: function ( i1, t0, t, t1 ) {\\r\\n\\r\\n\\t\\tvar result = this.resultBuffer,\\r\\n\\t\\t\\tvalues = this.sampleValues,\\r\\n\\t\\t\\tstride = this.valueSize,\\r\\n\\r\\n\\t\\t\\toffset = i1 * stride,\\r\\n\\r\\n\\t\\t\\talpha = ( t - t0 ) / ( t1 - t0 );\\r\\n\\r\\n\\t\\tfor ( var end = offset + stride; offset !== end; offset += 4 ) {\\r\\n\\r\\n\\t\\t\\tQuaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn result;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n *\\r\\n * A Track of quaternion keyframe values.\\r\\n *\\r\\n * @author Ben Houston / http://clara.io/\\r\\n * @author David Sarno / http://lighthaus.us/\\r\\n * @author tschw\\r\\n */\\r\\n\\r\\nfunction QuaternionKeyframeTrack( name, times, values, interpolation ) {\\r\\n\\r\\n\\tKeyframeTrack.call( this, name, times, values, interpolation );\\r\\n\\r\\n}\\r\\n\\r\\nQuaternionKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\\r\\n\\r\\n\\tconstructor: QuaternionKeyframeTrack,\\r\\n\\r\\n\\tValueTypeName: 'quaternion',\\r\\n\\r\\n\\t// ValueBufferType is inherited\\r\\n\\r\\n\\tDefaultInterpolation: InterpolateLinear,\\r\\n\\r\\n\\tInterpolantFactoryMethodLinear: function ( result ) {\\r\\n\\r\\n\\t\\treturn new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tInterpolantFactoryMethodSmooth: undefined // not yet implemented\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n *\\r\\n * A Track that interpolates Strings\\r\\n *\\r\\n *\\r\\n * @author Ben Houston / http://clara.io/\\r\\n * @author David Sarno / http://lighthaus.us/\\r\\n * @author tschw\\r\\n */\\r\\n\\r\\nfunction StringKeyframeTrack( name, times, values, interpolation ) {\\r\\n\\r\\n\\tKeyframeTrack.call( this, name, times, values, interpolation );\\r\\n\\r\\n}\\r\\n\\r\\nStringKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\\r\\n\\r\\n\\tconstructor: StringKeyframeTrack,\\r\\n\\r\\n\\tValueTypeName: 'string',\\r\\n\\tValueBufferType: Array,\\r\\n\\r\\n\\tDefaultInterpolation: InterpolateDiscrete,\\r\\n\\r\\n\\tInterpolantFactoryMethodLinear: undefined,\\r\\n\\r\\n\\tInterpolantFactoryMethodSmooth: undefined\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n *\\r\\n * A Track of vectored keyframe values.\\r\\n *\\r\\n *\\r\\n * @author Ben Houston / http://clara.io/\\r\\n * @author David Sarno / http://lighthaus.us/\\r\\n * @author tschw\\r\\n */\\r\\n\\r\\nfunction VectorKeyframeTrack( name, times, values, interpolation ) {\\r\\n\\r\\n\\tKeyframeTrack.call( this, name, times, values, interpolation );\\r\\n\\r\\n}\\r\\n\\r\\nVectorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\\r\\n\\r\\n\\tconstructor: VectorKeyframeTrack,\\r\\n\\r\\n\\tValueTypeName: 'vector'\\r\\n\\r\\n\\t// ValueBufferType is inherited\\r\\n\\r\\n\\t// DefaultInterpolation is inherited\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n *\\r\\n * Reusable set of Tracks that represent an animation.\\r\\n *\\r\\n * @author Ben Houston / http://clara.io/\\r\\n * @author David Sarno / http://lighthaus.us/\\r\\n */\\r\\n\\r\\nfunction AnimationClip( name, duration, tracks, blendMode ) {\\r\\n\\r\\n\\tthis.name = name;\\r\\n\\tthis.tracks = tracks;\\r\\n\\tthis.duration = ( duration !== undefined ) ? duration : - 1;\\r\\n\\tthis.blendMode = ( blendMode !== undefined ) ? blendMode : NormalAnimationBlendMode;\\r\\n\\r\\n\\tthis.uuid = MathUtils.generateUUID();\\r\\n\\r\\n\\t// this means it should figure out its duration by scanning the tracks\\r\\n\\tif ( this.duration < 0 ) {\\r\\n\\r\\n\\t\\tthis.resetDuration();\\r\\n\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\\r\\nfunction getTrackTypeForValueTypeName( typeName ) {\\r\\n\\r\\n\\tswitch ( typeName.toLowerCase() ) {\\r\\n\\r\\n\\t\\tcase 'scalar':\\r\\n\\t\\tcase 'double':\\r\\n\\t\\tcase 'float':\\r\\n\\t\\tcase 'number':\\r\\n\\t\\tcase 'integer':\\r\\n\\r\\n\\t\\t\\treturn NumberKeyframeTrack;\\r\\n\\r\\n\\t\\tcase 'vector':\\r\\n\\t\\tcase 'vector2':\\r\\n\\t\\tcase 'vector3':\\r\\n\\t\\tcase 'vector4':\\r\\n\\r\\n\\t\\t\\treturn VectorKeyframeTrack;\\r\\n\\r\\n\\t\\tcase 'color':\\r\\n\\r\\n\\t\\t\\treturn ColorKeyframeTrack;\\r\\n\\r\\n\\t\\tcase 'quaternion':\\r\\n\\r\\n\\t\\t\\treturn QuaternionKeyframeTrack;\\r\\n\\r\\n\\t\\tcase 'bool':\\r\\n\\t\\tcase 'boolean':\\r\\n\\r\\n\\t\\t\\treturn BooleanKeyframeTrack;\\r\\n\\r\\n\\t\\tcase 'string':\\r\\n\\r\\n\\t\\t\\treturn StringKeyframeTrack;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tthrow new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );\\r\\n\\r\\n}\\r\\n\\r\\nfunction parseKeyframeTrack( json ) {\\r\\n\\r\\n\\tif ( json.type === undefined ) {\\r\\n\\r\\n\\t\\tthrow new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tvar trackType = getTrackTypeForValueTypeName( json.type );\\r\\n\\r\\n\\tif ( json.times === undefined ) {\\r\\n\\r\\n\\t\\tvar times = [], values = [];\\r\\n\\r\\n\\t\\tAnimationUtils.flattenJSON( json.keys, times, values, 'value' );\\r\\n\\r\\n\\t\\tjson.times = times;\\r\\n\\t\\tjson.values = values;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// derived classes can define a static parse method\\r\\n\\tif ( trackType.parse !== undefined ) {\\r\\n\\r\\n\\t\\treturn trackType.parse( json );\\r\\n\\r\\n\\t} else {\\r\\n\\r\\n\\t\\t// by default, we assume a constructor compatible with the base\\r\\n\\t\\treturn new trackType( json.name, json.times, json.values, json.interpolation );\\r\\n\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\\r\\nObject.assign( AnimationClip, {\\r\\n\\r\\n\\tparse: function ( json ) {\\r\\n\\r\\n\\t\\tvar tracks = [],\\r\\n\\t\\t\\tjsonTracks = json.tracks,\\r\\n\\t\\t\\tframeTime = 1.0 / ( json.fps || 1.0 );\\r\\n\\r\\n\\t\\tfor ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\t\\ttracks.push( parseKeyframeTrack( jsonTracks[ i ] ).scale( frameTime ) );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn new AnimationClip( json.name, json.duration, tracks, json.blendMode );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttoJSON: function ( clip ) {\\r\\n\\r\\n\\t\\tvar tracks = [],\\r\\n\\t\\t\\tclipTracks = clip.tracks;\\r\\n\\r\\n\\t\\tvar json = {\\r\\n\\r\\n\\t\\t\\t'name': clip.name,\\r\\n\\t\\t\\t'duration': clip.duration,\\r\\n\\t\\t\\t'tracks': tracks,\\r\\n\\t\\t\\t'uuid': clip.uuid,\\r\\n\\t\\t\\t'blendMode': clip.blendMode\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tfor ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\t\\ttracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn json;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tCreateFromMorphTargetSequence: function ( name, morphTargetSequence, fps, noLoop ) {\\r\\n\\r\\n\\t\\tvar numMorphTargets = morphTargetSequence.length;\\r\\n\\t\\tvar tracks = [];\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < numMorphTargets; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar times = [];\\r\\n\\t\\t\\tvar values = [];\\r\\n\\r\\n\\t\\t\\ttimes.push(\\r\\n\\t\\t\\t\\t( i + numMorphTargets - 1 ) % numMorphTargets,\\r\\n\\t\\t\\t\\ti,\\r\\n\\t\\t\\t\\t( i + 1 ) % numMorphTargets );\\r\\n\\r\\n\\t\\t\\tvalues.push( 0, 1, 0 );\\r\\n\\r\\n\\t\\t\\tvar order = AnimationUtils.getKeyframeOrder( times );\\r\\n\\t\\t\\ttimes = AnimationUtils.sortedArray( times, 1, order );\\r\\n\\t\\t\\tvalues = AnimationUtils.sortedArray( values, 1, order );\\r\\n\\r\\n\\t\\t\\t// if there is a key at the first frame, duplicate it as the\\r\\n\\t\\t\\t// last frame as well for perfect loop.\\r\\n\\t\\t\\tif ( ! noLoop && times[ 0 ] === 0 ) {\\r\\n\\r\\n\\t\\t\\t\\ttimes.push( numMorphTargets );\\r\\n\\t\\t\\t\\tvalues.push( values[ 0 ] );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\ttracks.push(\\r\\n\\t\\t\\t\\tnew NumberKeyframeTrack(\\r\\n\\t\\t\\t\\t\\t'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',\\r\\n\\t\\t\\t\\t\\ttimes, values\\r\\n\\t\\t\\t\\t).scale( 1.0 / fps ) );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn new AnimationClip( name, - 1, tracks );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tfindByName: function ( objectOrClipArray, name ) {\\r\\n\\r\\n\\t\\tvar clipArray = objectOrClipArray;\\r\\n\\r\\n\\t\\tif ( ! Array.isArray( objectOrClipArray ) ) {\\r\\n\\r\\n\\t\\t\\tvar o = objectOrClipArray;\\r\\n\\t\\t\\tclipArray = o.geometry && o.geometry.animations || o.animations;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < clipArray.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\tif ( clipArray[ i ].name === name ) {\\r\\n\\r\\n\\t\\t\\t\\treturn clipArray[ i ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn null;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tCreateClipsFromMorphTargetSequences: function ( morphTargets, fps, noLoop ) {\\r\\n\\r\\n\\t\\tvar animationToMorphTargets = {};\\r\\n\\r\\n\\t\\t// tested with https://regex101.com/ on trick sequences\\r\\n\\t\\t// such flamingo_flyA_003, flamingo_run1_003, crdeath0059\\r\\n\\t\\tvar pattern = /^([\\\\w-]*?)([\\\\d]+)$/;\\r\\n\\r\\n\\t\\t// sort morph target names into animation groups based\\r\\n\\t\\t// patterns like Walk_001, Walk_002, Run_001, Run_002\\r\\n\\t\\tfor ( var i = 0, il = morphTargets.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar morphTarget = morphTargets[ i ];\\r\\n\\t\\t\\tvar parts = morphTarget.name.match( pattern );\\r\\n\\r\\n\\t\\t\\tif ( parts && parts.length > 1 ) {\\r\\n\\r\\n\\t\\t\\t\\tvar name = parts[ 1 ];\\r\\n\\r\\n\\t\\t\\t\\tvar animationMorphTargets = animationToMorphTargets[ name ];\\r\\n\\t\\t\\t\\tif ( ! animationMorphTargets ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tanimationToMorphTargets[ name ] = animationMorphTargets = [];\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tanimationMorphTargets.push( morphTarget );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar clips = [];\\r\\n\\r\\n\\t\\tfor ( var name in animationToMorphTargets ) {\\r\\n\\r\\n\\t\\t\\tclips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn clips;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// parse the animation.hierarchy format\\r\\n\\tparseAnimation: function ( animation, bones ) {\\r\\n\\r\\n\\t\\tif ( ! animation ) {\\r\\n\\r\\n\\t\\t\\tconsole.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );\\r\\n\\t\\t\\treturn null;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {\\r\\n\\r\\n\\t\\t\\t// only return track if there are actually keys.\\r\\n\\t\\t\\tif ( animationKeys.length !== 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tvar times = [];\\r\\n\\t\\t\\t\\tvar values = [];\\r\\n\\r\\n\\t\\t\\t\\tAnimationUtils.flattenJSON( animationKeys, times, values, propertyName );\\r\\n\\r\\n\\t\\t\\t\\t// empty keys are filtered out, so check again\\r\\n\\t\\t\\t\\tif ( times.length !== 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tdestTracks.push( new trackType( trackName, times, values ) );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tvar tracks = [];\\r\\n\\r\\n\\t\\tvar clipName = animation.name || 'default';\\r\\n\\t\\t// automatic length determination in AnimationClip.\\r\\n\\t\\tvar duration = animation.length || - 1;\\r\\n\\t\\tvar fps = animation.fps || 30;\\r\\n\\t\\tvar blendMode = animation.blendMode;\\r\\n\\r\\n\\t\\tvar hierarchyTracks = animation.hierarchy || [];\\r\\n\\r\\n\\t\\tfor ( var h = 0; h < hierarchyTracks.length; h ++ ) {\\r\\n\\r\\n\\t\\t\\tvar animationKeys = hierarchyTracks[ h ].keys;\\r\\n\\r\\n\\t\\t\\t// skip empty tracks\\r\\n\\t\\t\\tif ( ! animationKeys || animationKeys.length === 0 ) continue;\\r\\n\\r\\n\\t\\t\\t// process morph targets\\r\\n\\t\\t\\tif ( animationKeys[ 0 ].morphTargets ) {\\r\\n\\r\\n\\t\\t\\t\\t// figure out all morph targets used in this track\\r\\n\\t\\t\\t\\tvar morphTargetNames = {};\\r\\n\\r\\n\\t\\t\\t\\tfor ( var k = 0; k < animationKeys.length; k ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( animationKeys[ k ].morphTargets ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tfor ( var m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tmorphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t// create a track for each morph target with all zero\\r\\n\\t\\t\\t\\t// morphTargetInfluences except for the keys in which\\r\\n\\t\\t\\t\\t// the morphTarget is named.\\r\\n\\t\\t\\t\\tfor ( var morphTargetName in morphTargetNames ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar times = [];\\r\\n\\t\\t\\t\\t\\tvar values = [];\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar animationKey = animationKeys[ k ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\ttimes.push( animationKey.time );\\r\\n\\t\\t\\t\\t\\t\\tvalues.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\ttracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tduration = morphTargetNames.length * ( fps || 1.0 );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t// ...assume skeletal animation\\r\\n\\r\\n\\t\\t\\t\\tvar boneName = '.bones[' + bones[ h ].name + ']';\\r\\n\\r\\n\\t\\t\\t\\taddNonemptyTrack(\\r\\n\\t\\t\\t\\t\\tVectorKeyframeTrack, boneName + '.position',\\r\\n\\t\\t\\t\\t\\tanimationKeys, 'pos', tracks );\\r\\n\\r\\n\\t\\t\\t\\taddNonemptyTrack(\\r\\n\\t\\t\\t\\t\\tQuaternionKeyframeTrack, boneName + '.quaternion',\\r\\n\\t\\t\\t\\t\\tanimationKeys, 'rot', tracks );\\r\\n\\r\\n\\t\\t\\t\\taddNonemptyTrack(\\r\\n\\t\\t\\t\\t\\tVectorKeyframeTrack, boneName + '.scale',\\r\\n\\t\\t\\t\\t\\tanimationKeys, 'scl', tracks );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( tracks.length === 0 ) {\\r\\n\\r\\n\\t\\t\\treturn null;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar clip = new AnimationClip( clipName, duration, tracks, blendMode );\\r\\n\\r\\n\\t\\treturn clip;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nObject.assign( AnimationClip.prototype, {\\r\\n\\r\\n\\tresetDuration: function () {\\r\\n\\r\\n\\t\\tvar tracks = this.tracks, duration = 0;\\r\\n\\r\\n\\t\\tfor ( var i = 0, n = tracks.length; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\t\\tvar track = this.tracks[ i ];\\r\\n\\r\\n\\t\\t\\tduration = Math.max( duration, track.times[ track.times.length - 1 ] );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.duration = duration;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttrim: function () {\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\tthis.tracks[ i ].trim( 0, this.duration );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tvalidate: function () {\\r\\n\\r\\n\\t\\tvar valid = true;\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvalid = valid && this.tracks[ i ].validate();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn valid;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\toptimize: function () {\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\tthis.tracks[ i ].optimize();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclone: function () {\\r\\n\\r\\n\\t\\tvar tracks = [];\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\ttracks.push( this.tracks[ i ].clone() );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn new AnimationClip( this.name, this.duration, tracks, this.blendMode );\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nvar Cache = {\\r\\n\\r\\n\\tenabled: false,\\r\\n\\r\\n\\tfiles: {},\\r\\n\\r\\n\\tadd: function ( key, file ) {\\r\\n\\r\\n\\t\\tif ( this.enabled === false ) return;\\r\\n\\r\\n\\t\\t// console.log( 'THREE.Cache', 'Adding key:', key );\\r\\n\\r\\n\\t\\tthis.files[ key ] = file;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tget: function ( key ) {\\r\\n\\r\\n\\t\\tif ( this.enabled === false ) return;\\r\\n\\r\\n\\t\\t// console.log( 'THREE.Cache', 'Checking key:', key );\\r\\n\\r\\n\\t\\treturn this.files[ key ];\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tremove: function ( key ) {\\r\\n\\r\\n\\t\\tdelete this.files[ key ];\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclear: function () {\\r\\n\\r\\n\\t\\tthis.files = {};\\r\\n\\r\\n\\t}\\r\\n\\r\\n};\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nfunction LoadingManager( onLoad, onProgress, onError ) {\\r\\n\\r\\n\\tvar scope = this;\\r\\n\\r\\n\\tvar isLoading = false;\\r\\n\\tvar itemsLoaded = 0;\\r\\n\\tvar itemsTotal = 0;\\r\\n\\tvar urlModifier = undefined;\\r\\n\\tvar handlers = [];\\r\\n\\r\\n\\t// Refer to #5689 for the reason why we don't set .onStart\\r\\n\\t// in the constructor\\r\\n\\r\\n\\tthis.onStart = undefined;\\r\\n\\tthis.onLoad = onLoad;\\r\\n\\tthis.onProgress = onProgress;\\r\\n\\tthis.onError = onError;\\r\\n\\r\\n\\tthis.itemStart = function ( url ) {\\r\\n\\r\\n\\t\\titemsTotal ++;\\r\\n\\r\\n\\t\\tif ( isLoading === false ) {\\r\\n\\r\\n\\t\\t\\tif ( scope.onStart !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tscope.onStart( url, itemsLoaded, itemsTotal );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tisLoading = true;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.itemEnd = function ( url ) {\\r\\n\\r\\n\\t\\titemsLoaded ++;\\r\\n\\r\\n\\t\\tif ( scope.onProgress !== undefined ) {\\r\\n\\r\\n\\t\\t\\tscope.onProgress( url, itemsLoaded, itemsTotal );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( itemsLoaded === itemsTotal ) {\\r\\n\\r\\n\\t\\t\\tisLoading = false;\\r\\n\\r\\n\\t\\t\\tif ( scope.onLoad !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tscope.onLoad();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.itemError = function ( url ) {\\r\\n\\r\\n\\t\\tif ( scope.onError !== undefined ) {\\r\\n\\r\\n\\t\\t\\tscope.onError( url );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.resolveURL = function ( url ) {\\r\\n\\r\\n\\t\\tif ( urlModifier ) {\\r\\n\\r\\n\\t\\t\\treturn urlModifier( url );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn url;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.setURLModifier = function ( transform ) {\\r\\n\\r\\n\\t\\turlModifier = transform;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.addHandler = function ( regex, loader ) {\\r\\n\\r\\n\\t\\thandlers.push( regex, loader );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.removeHandler = function ( regex ) {\\r\\n\\r\\n\\t\\tvar index = handlers.indexOf( regex );\\r\\n\\r\\n\\t\\tif ( index !== - 1 ) {\\r\\n\\r\\n\\t\\t\\thandlers.splice( index, 2 );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.getHandler = function ( file ) {\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = handlers.length; i < l; i += 2 ) {\\r\\n\\r\\n\\t\\t\\tvar regex = handlers[ i ];\\r\\n\\t\\t\\tvar loader = handlers[ i + 1 ];\\r\\n\\r\\n\\t\\t\\tif ( regex.global ) regex.lastIndex = 0; // see #17920\\r\\n\\r\\n\\t\\t\\tif ( regex.test( file ) ) {\\r\\n\\r\\n\\t\\t\\t\\treturn loader;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn null;\\r\\n\\r\\n\\t};\\r\\n\\r\\n}\\r\\n\\r\\nvar DefaultLoadingManager = new LoadingManager();\\r\\n\\r\\n/**\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n */\\r\\n\\r\\nfunction Loader( manager ) {\\r\\n\\r\\n\\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\\r\\n\\r\\n\\tthis.crossOrigin = 'anonymous';\\r\\n\\tthis.path = '';\\r\\n\\tthis.resourcePath = '';\\r\\n\\tthis.requestHeader = {};\\r\\n\\r\\n}\\r\\n\\r\\nObject.assign( Loader.prototype, {\\r\\n\\r\\n\\tload: function ( /* url, onLoad, onProgress, onError */ ) {},\\r\\n\\r\\n\\tloadAsync: function ( url, onProgress ) {\\r\\n\\r\\n\\t\\tvar scope = this;\\r\\n\\r\\n\\t\\treturn new Promise( function ( resolve, reject ) {\\r\\n\\r\\n\\t\\t\\tscope.load( url, resolve, onProgress, reject );\\r\\n\\r\\n\\t\\t} );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tparse: function ( /* data */ ) {},\\r\\n\\r\\n\\tsetCrossOrigin: function ( crossOrigin ) {\\r\\n\\r\\n\\t\\tthis.crossOrigin = crossOrigin;\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetPath: function ( path ) {\\r\\n\\r\\n\\t\\tthis.path = path;\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetResourcePath: function ( resourcePath ) {\\r\\n\\r\\n\\t\\tthis.resourcePath = resourcePath;\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetRequestHeader: function ( requestHeader ) {\\r\\n\\r\\n\\t\\tthis.requestHeader = requestHeader;\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nvar loading = {};\\r\\n\\r\\nfunction FileLoader( manager ) {\\r\\n\\r\\n\\tLoader.call( this, manager );\\r\\n\\r\\n}\\r\\n\\r\\nFileLoader.prototype = Object.assign( Object.create( Loader.prototype ), {\\r\\n\\r\\n\\tconstructor: FileLoader,\\r\\n\\r\\n\\tload: function ( url, onLoad, onProgress, onError ) {\\r\\n\\r\\n\\t\\tif ( url === undefined ) url = '';\\r\\n\\r\\n\\t\\tif ( this.path !== undefined ) url = this.path + url;\\r\\n\\r\\n\\t\\turl = this.manager.resolveURL( url );\\r\\n\\r\\n\\t\\tvar scope = this;\\r\\n\\r\\n\\t\\tvar cached = Cache.get( url );\\r\\n\\r\\n\\t\\tif ( cached !== undefined ) {\\r\\n\\r\\n\\t\\t\\tscope.manager.itemStart( url );\\r\\n\\r\\n\\t\\t\\tsetTimeout( function () {\\r\\n\\r\\n\\t\\t\\t\\tif ( onLoad ) onLoad( cached );\\r\\n\\r\\n\\t\\t\\t\\tscope.manager.itemEnd( url );\\r\\n\\r\\n\\t\\t\\t}, 0 );\\r\\n\\r\\n\\t\\t\\treturn cached;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Check if request is duplicate\\r\\n\\r\\n\\t\\tif ( loading[ url ] !== undefined ) {\\r\\n\\r\\n\\t\\t\\tloading[ url ].push( {\\r\\n\\r\\n\\t\\t\\t\\tonLoad: onLoad,\\r\\n\\t\\t\\t\\tonProgress: onProgress,\\r\\n\\t\\t\\t\\tonError: onError\\r\\n\\r\\n\\t\\t\\t} );\\r\\n\\r\\n\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Check for data: URI\\r\\n\\t\\tvar dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;\\r\\n\\t\\tvar dataUriRegexResult = url.match( dataUriRegex );\\r\\n\\r\\n\\t\\t// Safari can not handle Data URIs through XMLHttpRequest so process manually\\r\\n\\t\\tif ( dataUriRegexResult ) {\\r\\n\\r\\n\\t\\t\\tvar mimeType = dataUriRegexResult[ 1 ];\\r\\n\\t\\t\\tvar isBase64 = !! dataUriRegexResult[ 2 ];\\r\\n\\t\\t\\tvar data = dataUriRegexResult[ 3 ];\\r\\n\\r\\n\\t\\t\\tdata = decodeURIComponent( data );\\r\\n\\r\\n\\t\\t\\tif ( isBase64 ) data = atob( data );\\r\\n\\r\\n\\t\\t\\ttry {\\r\\n\\r\\n\\t\\t\\t\\tvar response;\\r\\n\\t\\t\\t\\tvar responseType = ( this.responseType || '' ).toLowerCase();\\r\\n\\r\\n\\t\\t\\t\\tswitch ( responseType ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'arraybuffer':\\r\\n\\t\\t\\t\\t\\tcase 'blob':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar view = new Uint8Array( data.length );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0; i < data.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tview[ i ] = data.charCodeAt( i );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( responseType === 'blob' ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tresponse = new Blob( [ view.buffer ], { type: mimeType } );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tresponse = view.buffer;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'document':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar parser = new DOMParser();\\r\\n\\t\\t\\t\\t\\t\\tresponse = parser.parseFromString( data, mimeType );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'json':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tresponse = JSON.parse( data );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tdefault: // 'text' or other\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tresponse = data;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t// Wait for next browser tick like standard XMLHttpRequest event dispatching does\\r\\n\\t\\t\\t\\tsetTimeout( function () {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( onLoad ) onLoad( response );\\r\\n\\r\\n\\t\\t\\t\\t\\tscope.manager.itemEnd( url );\\r\\n\\r\\n\\t\\t\\t\\t}, 0 );\\r\\n\\r\\n\\t\\t\\t} catch ( error ) {\\r\\n\\r\\n\\t\\t\\t\\t// Wait for next browser tick like standard XMLHttpRequest event dispatching does\\r\\n\\t\\t\\t\\tsetTimeout( function () {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( onError ) onError( error );\\r\\n\\r\\n\\t\\t\\t\\t\\tscope.manager.itemError( url );\\r\\n\\t\\t\\t\\t\\tscope.manager.itemEnd( url );\\r\\n\\r\\n\\t\\t\\t\\t}, 0 );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t// Initialise array for duplicate requests\\r\\n\\r\\n\\t\\t\\tloading[ url ] = [];\\r\\n\\r\\n\\t\\t\\tloading[ url ].push( {\\r\\n\\r\\n\\t\\t\\t\\tonLoad: onLoad,\\r\\n\\t\\t\\t\\tonProgress: onProgress,\\r\\n\\t\\t\\t\\tonError: onError\\r\\n\\r\\n\\t\\t\\t} );\\r\\n\\r\\n\\t\\t\\tvar request = new XMLHttpRequest();\\r\\n\\r\\n\\t\\t\\trequest.open( 'GET', url, true );\\r\\n\\r\\n\\t\\t\\trequest.addEventListener( 'load', function ( event ) {\\r\\n\\r\\n\\t\\t\\t\\tvar response = this.response;\\r\\n\\r\\n\\t\\t\\t\\tvar callbacks = loading[ url ];\\r\\n\\r\\n\\t\\t\\t\\tdelete loading[ url ];\\r\\n\\r\\n\\t\\t\\t\\tif ( this.status === 200 || this.status === 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// Some browsers return HTTP Status 0 when using non-http protocol\\r\\n\\t\\t\\t\\t\\t// e.g. 'file://' or 'data://'. Handle as success.\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( this.status === 0 ) console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );\\r\\n\\r\\n\\t\\t\\t\\t\\t// Add to cache only on HTTP success, so that we do not cache\\r\\n\\t\\t\\t\\t\\t// error response bodies as proper responses to requests.\\r\\n\\t\\t\\t\\t\\tCache.add( url, response );\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var i = 0, il = callbacks.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar callback = callbacks[ i ];\\r\\n\\t\\t\\t\\t\\t\\tif ( callback.onLoad ) callback.onLoad( response );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tscope.manager.itemEnd( url );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var i = 0, il = callbacks.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar callback = callbacks[ i ];\\r\\n\\t\\t\\t\\t\\t\\tif ( callback.onError ) callback.onError( event );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tscope.manager.itemError( url );\\r\\n\\t\\t\\t\\t\\tscope.manager.itemEnd( url );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}, false );\\r\\n\\r\\n\\t\\t\\trequest.addEventListener( 'progress', function ( event ) {\\r\\n\\r\\n\\t\\t\\t\\tvar callbacks = loading[ url ];\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, il = callbacks.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar callback = callbacks[ i ];\\r\\n\\t\\t\\t\\t\\tif ( callback.onProgress ) callback.onProgress( event );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}, false );\\r\\n\\r\\n\\t\\t\\trequest.addEventListener( 'error', function ( event ) {\\r\\n\\r\\n\\t\\t\\t\\tvar callbacks = loading[ url ];\\r\\n\\r\\n\\t\\t\\t\\tdelete loading[ url ];\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, il = callbacks.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar callback = callbacks[ i ];\\r\\n\\t\\t\\t\\t\\tif ( callback.onError ) callback.onError( event );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tscope.manager.itemError( url );\\r\\n\\t\\t\\t\\tscope.manager.itemEnd( url );\\r\\n\\r\\n\\t\\t\\t}, false );\\r\\n\\r\\n\\t\\t\\trequest.addEventListener( 'abort', function ( event ) {\\r\\n\\r\\n\\t\\t\\t\\tvar callbacks = loading[ url ];\\r\\n\\r\\n\\t\\t\\t\\tdelete loading[ url ];\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, il = callbacks.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar callback = callbacks[ i ];\\r\\n\\t\\t\\t\\t\\tif ( callback.onError ) callback.onError( event );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tscope.manager.itemError( url );\\r\\n\\t\\t\\t\\tscope.manager.itemEnd( url );\\r\\n\\r\\n\\t\\t\\t}, false );\\r\\n\\r\\n\\t\\t\\tif ( this.responseType !== undefined ) request.responseType = this.responseType;\\r\\n\\t\\t\\tif ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;\\r\\n\\r\\n\\t\\t\\tif ( request.overrideMimeType ) request.overrideMimeType( this.mimeType !== undefined ? this.mimeType : 'text/plain' );\\r\\n\\r\\n\\t\\t\\tfor ( var header in this.requestHeader ) {\\r\\n\\r\\n\\t\\t\\t\\trequest.setRequestHeader( header, this.requestHeader[ header ] );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\trequest.send( null );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tscope.manager.itemStart( url );\\r\\n\\r\\n\\t\\treturn request;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetResponseType: function ( value ) {\\r\\n\\r\\n\\t\\tthis.responseType = value;\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetWithCredentials: function ( value ) {\\r\\n\\r\\n\\t\\tthis.withCredentials = value;\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetMimeType: function ( value ) {\\r\\n\\r\\n\\t\\tthis.mimeType = value;\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author bhouston / http://clara.io/\\r\\n */\\r\\n\\r\\nfunction AnimationLoader( manager ) {\\r\\n\\r\\n\\tLoader.call( this, manager );\\r\\n\\r\\n}\\r\\n\\r\\nAnimationLoader.prototype = Object.assign( Object.create( Loader.prototype ), {\\r\\n\\r\\n\\tconstructor: AnimationLoader,\\r\\n\\r\\n\\tload: function ( url, onLoad, onProgress, onError ) {\\r\\n\\r\\n\\t\\tvar scope = this;\\r\\n\\r\\n\\t\\tvar loader = new FileLoader( scope.manager );\\r\\n\\t\\tloader.setPath( scope.path );\\r\\n\\t\\tloader.load( url, function ( text ) {\\r\\n\\r\\n\\t\\t\\ttry {\\r\\n\\r\\n\\t\\t\\t\\tonLoad( scope.parse( JSON.parse( text ) ) );\\r\\n\\r\\n\\t\\t\\t} catch ( e ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( onError ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tonError( e );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.error( e );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tscope.manager.itemError( url );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}, onProgress, onError );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tparse: function ( json ) {\\r\\n\\r\\n\\t\\tvar animations = [];\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < json.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar clip = AnimationClip.parse( json[ i ] );\\r\\n\\r\\n\\t\\t\\tanimations.push( clip );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn animations;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n *\\r\\n * Abstract Base class to block based textures loader (dds, pvr, ...)\\r\\n *\\r\\n * Sub classes have to implement the parse() method which will be used in load().\\r\\n */\\r\\n\\r\\nfunction CompressedTextureLoader( manager ) {\\r\\n\\r\\n\\tLoader.call( this, manager );\\r\\n\\r\\n}\\r\\n\\r\\nCompressedTextureLoader.prototype = Object.assign( Object.create( Loader.prototype ), {\\r\\n\\r\\n\\tconstructor: CompressedTextureLoader,\\r\\n\\r\\n\\tload: function ( url, onLoad, onProgress, onError ) {\\r\\n\\r\\n\\t\\tvar scope = this;\\r\\n\\r\\n\\t\\tvar images = [];\\r\\n\\r\\n\\t\\tvar texture = new CompressedTexture();\\r\\n\\t\\ttexture.image = images;\\r\\n\\r\\n\\t\\tvar loader = new FileLoader( this.manager );\\r\\n\\t\\tloader.setPath( this.path );\\r\\n\\t\\tloader.setResponseType( 'arraybuffer' );\\r\\n\\r\\n\\t\\tfunction loadTexture( i ) {\\r\\n\\r\\n\\t\\t\\tloader.load( url[ i ], function ( buffer ) {\\r\\n\\r\\n\\t\\t\\t\\tvar texDatas = scope.parse( buffer, true );\\r\\n\\r\\n\\t\\t\\t\\timages[ i ] = {\\r\\n\\t\\t\\t\\t\\twidth: texDatas.width,\\r\\n\\t\\t\\t\\t\\theight: texDatas.height,\\r\\n\\t\\t\\t\\t\\tformat: texDatas.format,\\r\\n\\t\\t\\t\\t\\tmipmaps: texDatas.mipmaps\\r\\n\\t\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\t\\tloaded += 1;\\r\\n\\r\\n\\t\\t\\t\\tif ( loaded === 6 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( texDatas.mipmapCount === 1 )\\r\\n\\t\\t\\t\\t\\t\\ttexture.minFilter = LinearFilter;\\r\\n\\r\\n\\t\\t\\t\\t\\ttexture.format = texDatas.format;\\r\\n\\t\\t\\t\\t\\ttexture.needsUpdate = true;\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( onLoad ) onLoad( texture );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}, onProgress, onError );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( Array.isArray( url ) ) {\\r\\n\\r\\n\\t\\t\\tvar loaded = 0;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, il = url.length; i < il; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\tloadTexture( i );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t// compressed cubemap texture stored in a single DDS file\\r\\n\\r\\n\\t\\t\\tloader.load( url, function ( buffer ) {\\r\\n\\r\\n\\t\\t\\t\\tvar texDatas = scope.parse( buffer, true );\\r\\n\\r\\n\\t\\t\\t\\tif ( texDatas.isCubemap ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar faces = texDatas.mipmaps.length / texDatas.mipmapCount;\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var f = 0; f < faces; f ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\timages[ f ] = { mipmaps: [] };\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0; i < texDatas.mipmapCount; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\timages[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\\r\\n\\t\\t\\t\\t\\t\\t\\timages[ f ].format = texDatas.format;\\r\\n\\t\\t\\t\\t\\t\\t\\timages[ f ].width = texDatas.width;\\r\\n\\t\\t\\t\\t\\t\\t\\timages[ f ].height = texDatas.height;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\ttexture.image.width = texDatas.width;\\r\\n\\t\\t\\t\\t\\ttexture.image.height = texDatas.height;\\r\\n\\t\\t\\t\\t\\ttexture.mipmaps = texDatas.mipmaps;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( texDatas.mipmapCount === 1 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\ttexture.minFilter = LinearFilter;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\ttexture.format = texDatas.format;\\r\\n\\t\\t\\t\\ttexture.needsUpdate = true;\\r\\n\\r\\n\\t\\t\\t\\tif ( onLoad ) onLoad( texture );\\r\\n\\r\\n\\t\\t\\t}, onProgress, onError );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn texture;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author Nikos M. / https://github.com/foo123/\\r\\n *\\r\\n * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\\r\\n *\\r\\n * Sub classes have to implement the parse() method which will be used in load().\\r\\n */\\r\\n\\r\\nfunction DataTextureLoader( manager ) {\\r\\n\\r\\n\\tLoader.call( this, manager );\\r\\n\\r\\n}\\r\\n\\r\\nDataTextureLoader.prototype = Object.assign( Object.create( Loader.prototype ), {\\r\\n\\r\\n\\tconstructor: DataTextureLoader,\\r\\n\\r\\n\\tload: function ( url, onLoad, onProgress, onError ) {\\r\\n\\r\\n\\t\\tvar scope = this;\\r\\n\\r\\n\\t\\tvar texture = new DataTexture();\\r\\n\\r\\n\\t\\tvar loader = new FileLoader( this.manager );\\r\\n\\t\\tloader.setResponseType( 'arraybuffer' );\\r\\n\\t\\tloader.setPath( this.path );\\r\\n\\t\\tloader.load( url, function ( buffer ) {\\r\\n\\r\\n\\t\\t\\tvar texData = scope.parse( buffer );\\r\\n\\r\\n\\t\\t\\tif ( ! texData ) return;\\r\\n\\r\\n\\t\\t\\tif ( texData.image !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\ttexture.image = texData.image;\\r\\n\\r\\n\\t\\t\\t} else if ( texData.data !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\ttexture.image.width = texData.width;\\r\\n\\t\\t\\t\\ttexture.image.height = texData.height;\\r\\n\\t\\t\\t\\ttexture.image.data = texData.data;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\ttexture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;\\r\\n\\t\\t\\ttexture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;\\r\\n\\r\\n\\t\\t\\ttexture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;\\r\\n\\t\\t\\ttexture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;\\r\\n\\r\\n\\t\\t\\ttexture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;\\r\\n\\r\\n\\t\\t\\tif ( texData.format !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\ttexture.format = texData.format;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( texData.type !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\ttexture.type = texData.type;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( texData.mipmaps !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\ttexture.mipmaps = texData.mipmaps;\\r\\n\\t\\t\\t\\ttexture.minFilter = LinearMipmapLinearFilter; // presumably...\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( texData.mipmapCount === 1 ) {\\r\\n\\r\\n\\t\\t\\t\\ttexture.minFilter = LinearFilter;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\ttexture.needsUpdate = true;\\r\\n\\r\\n\\t\\t\\tif ( onLoad ) onLoad( texture, texData );\\r\\n\\r\\n\\t\\t}, onProgress, onError );\\r\\n\\r\\n\\r\\n\\t\\treturn texture;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nfunction ImageLoader( manager ) {\\r\\n\\r\\n\\tLoader.call( this, manager );\\r\\n\\r\\n}\\r\\n\\r\\nImageLoader.prototype = Object.assign( Object.create( Loader.prototype ), {\\r\\n\\r\\n\\tconstructor: ImageLoader,\\r\\n\\r\\n\\tload: function ( url, onLoad, onProgress, onError ) {\\r\\n\\r\\n\\t\\tif ( this.path !== undefined ) url = this.path + url;\\r\\n\\r\\n\\t\\turl = this.manager.resolveURL( url );\\r\\n\\r\\n\\t\\tvar scope = this;\\r\\n\\r\\n\\t\\tvar cached = Cache.get( url );\\r\\n\\r\\n\\t\\tif ( cached !== undefined ) {\\r\\n\\r\\n\\t\\t\\tscope.manager.itemStart( url );\\r\\n\\r\\n\\t\\t\\tsetTimeout( function () {\\r\\n\\r\\n\\t\\t\\t\\tif ( onLoad ) onLoad( cached );\\r\\n\\r\\n\\t\\t\\t\\tscope.manager.itemEnd( url );\\r\\n\\r\\n\\t\\t\\t}, 0 );\\r\\n\\r\\n\\t\\t\\treturn cached;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );\\r\\n\\r\\n\\t\\tfunction onImageLoad() {\\r\\n\\r\\n\\t\\t\\timage.removeEventListener( 'load', onImageLoad, false );\\r\\n\\t\\t\\timage.removeEventListener( 'error', onImageError, false );\\r\\n\\r\\n\\t\\t\\tCache.add( url, this );\\r\\n\\r\\n\\t\\t\\tif ( onLoad ) onLoad( this );\\r\\n\\r\\n\\t\\t\\tscope.manager.itemEnd( url );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction onImageError( event ) {\\r\\n\\r\\n\\t\\t\\timage.removeEventListener( 'load', onImageLoad, false );\\r\\n\\t\\t\\timage.removeEventListener( 'error', onImageError, false );\\r\\n\\r\\n\\t\\t\\tif ( onError ) onError( event );\\r\\n\\r\\n\\t\\t\\tscope.manager.itemError( url );\\r\\n\\t\\t\\tscope.manager.itemEnd( url );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\timage.addEventListener( 'load', onImageLoad, false );\\r\\n\\t\\timage.addEventListener( 'error', onImageError, false );\\r\\n\\r\\n\\t\\tif ( url.substr( 0, 5 ) !== 'data:' ) {\\r\\n\\r\\n\\t\\t\\tif ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tscope.manager.itemStart( url );\\r\\n\\r\\n\\t\\timage.src = url;\\r\\n\\r\\n\\t\\treturn image;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\n\\r\\nfunction CubeTextureLoader( manager ) {\\r\\n\\r\\n\\tLoader.call( this, manager );\\r\\n\\r\\n}\\r\\n\\r\\nCubeTextureLoader.prototype = Object.assign( Object.create( Loader.prototype ), {\\r\\n\\r\\n\\tconstructor: CubeTextureLoader,\\r\\n\\r\\n\\tload: function ( urls, onLoad, onProgress, onError ) {\\r\\n\\r\\n\\t\\tvar texture = new CubeTexture();\\r\\n\\r\\n\\t\\tvar loader = new ImageLoader( this.manager );\\r\\n\\t\\tloader.setCrossOrigin( this.crossOrigin );\\r\\n\\t\\tloader.setPath( this.path );\\r\\n\\r\\n\\t\\tvar loaded = 0;\\r\\n\\r\\n\\t\\tfunction loadTexture( i ) {\\r\\n\\r\\n\\t\\t\\tloader.load( urls[ i ], function ( image ) {\\r\\n\\r\\n\\t\\t\\t\\ttexture.images[ i ] = image;\\r\\n\\r\\n\\t\\t\\t\\tloaded ++;\\r\\n\\r\\n\\t\\t\\t\\tif ( loaded === 6 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\ttexture.needsUpdate = true;\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( onLoad ) onLoad( texture );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}, undefined, onError );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < urls.length; ++ i ) {\\r\\n\\r\\n\\t\\t\\tloadTexture( i );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn texture;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nfunction TextureLoader( manager ) {\\r\\n\\r\\n\\tLoader.call( this, manager );\\r\\n\\r\\n}\\r\\n\\r\\nTextureLoader.prototype = Object.assign( Object.create( Loader.prototype ), {\\r\\n\\r\\n\\tconstructor: TextureLoader,\\r\\n\\r\\n\\tload: function ( url, onLoad, onProgress, onError ) {\\r\\n\\r\\n\\t\\tvar texture = new Texture();\\r\\n\\r\\n\\t\\tvar loader = new ImageLoader( this.manager );\\r\\n\\t\\tloader.setCrossOrigin( this.crossOrigin );\\r\\n\\t\\tloader.setPath( this.path );\\r\\n\\r\\n\\t\\tloader.load( url, function ( image ) {\\r\\n\\r\\n\\t\\t\\ttexture.image = image;\\r\\n\\r\\n\\t\\t\\t// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.\\r\\n\\t\\t\\tvar isJPEG = url.search( /\\\\.jpe?g($|\\\\?)/i ) > 0 || url.search( /^data\\\\:image\\\\/jpeg/ ) === 0;\\r\\n\\r\\n\\t\\t\\ttexture.format = isJPEG ? RGBFormat : RGBAFormat;\\r\\n\\t\\t\\ttexture.needsUpdate = true;\\r\\n\\r\\n\\t\\t\\tif ( onLoad !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tonLoad( texture );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}, onProgress, onError );\\r\\n\\r\\n\\t\\treturn texture;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author zz85 / http://www.lab4games.net/zz85/blog\\r\\n * Extensible curve object\\r\\n *\\r\\n * Some common of curve methods:\\r\\n * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )\\r\\n * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )\\r\\n * .getPoints(), .getSpacedPoints()\\r\\n * .getLength()\\r\\n * .updateArcLengths()\\r\\n *\\r\\n * This following curves inherit from THREE.Curve:\\r\\n *\\r\\n * -- 2D curves --\\r\\n * THREE.ArcCurve\\r\\n * THREE.CubicBezierCurve\\r\\n * THREE.EllipseCurve\\r\\n * THREE.LineCurve\\r\\n * THREE.QuadraticBezierCurve\\r\\n * THREE.SplineCurve\\r\\n *\\r\\n * -- 3D curves --\\r\\n * THREE.CatmullRomCurve3\\r\\n * THREE.CubicBezierCurve3\\r\\n * THREE.LineCurve3\\r\\n * THREE.QuadraticBezierCurve3\\r\\n *\\r\\n * A series of curves can be represented as a THREE.CurvePath.\\r\\n *\\r\\n **/\\r\\n\\r\\n/**************************************************************\\r\\n *\\tAbstract Curve base class\\r\\n **************************************************************/\\r\\n\\r\\nfunction Curve() {\\r\\n\\r\\n\\tthis.type = 'Curve';\\r\\n\\r\\n\\tthis.arcLengthDivisions = 200;\\r\\n\\r\\n}\\r\\n\\r\\nObject.assign( Curve.prototype, {\\r\\n\\r\\n\\t// Virtual base class method to overwrite and implement in subclasses\\r\\n\\t//\\t- t [0 .. 1]\\r\\n\\r\\n\\tgetPoint: function ( /* t, optionalTarget */ ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Curve: .getPoint() not implemented.' );\\r\\n\\t\\treturn null;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// Get point at relative position in curve according to arc length\\r\\n\\t// - u [0 .. 1]\\r\\n\\r\\n\\tgetPointAt: function ( u, optionalTarget ) {\\r\\n\\r\\n\\t\\tvar t = this.getUtoTmapping( u );\\r\\n\\t\\treturn this.getPoint( t, optionalTarget );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// Get sequence of points using getPoint( t )\\r\\n\\r\\n\\tgetPoints: function ( divisions ) {\\r\\n\\r\\n\\t\\tif ( divisions === undefined ) divisions = 5;\\r\\n\\r\\n\\t\\tvar points = [];\\r\\n\\r\\n\\t\\tfor ( var d = 0; d <= divisions; d ++ ) {\\r\\n\\r\\n\\t\\t\\tpoints.push( this.getPoint( d / divisions ) );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn points;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// Get sequence of points using getPointAt( u )\\r\\n\\r\\n\\tgetSpacedPoints: function ( divisions ) {\\r\\n\\r\\n\\t\\tif ( divisions === undefined ) divisions = 5;\\r\\n\\r\\n\\t\\tvar points = [];\\r\\n\\r\\n\\t\\tfor ( var d = 0; d <= divisions; d ++ ) {\\r\\n\\r\\n\\t\\t\\tpoints.push( this.getPointAt( d / divisions ) );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn points;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// Get total curve arc length\\r\\n\\r\\n\\tgetLength: function () {\\r\\n\\r\\n\\t\\tvar lengths = this.getLengths();\\r\\n\\t\\treturn lengths[ lengths.length - 1 ];\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// Get list of cumulative segment lengths\\r\\n\\r\\n\\tgetLengths: function ( divisions ) {\\r\\n\\r\\n\\t\\tif ( divisions === undefined ) divisions = this.arcLengthDivisions;\\r\\n\\r\\n\\t\\tif ( this.cacheArcLengths &&\\r\\n\\t\\t\\t( this.cacheArcLengths.length === divisions + 1 ) &&\\r\\n\\t\\t\\t! this.needsUpdate ) {\\r\\n\\r\\n\\t\\t\\treturn this.cacheArcLengths;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.needsUpdate = false;\\r\\n\\r\\n\\t\\tvar cache = [];\\r\\n\\t\\tvar current, last = this.getPoint( 0 );\\r\\n\\t\\tvar p, sum = 0;\\r\\n\\r\\n\\t\\tcache.push( 0 );\\r\\n\\r\\n\\t\\tfor ( p = 1; p <= divisions; p ++ ) {\\r\\n\\r\\n\\t\\t\\tcurrent = this.getPoint( p / divisions );\\r\\n\\t\\t\\tsum += current.distanceTo( last );\\r\\n\\t\\t\\tcache.push( sum );\\r\\n\\t\\t\\tlast = current;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.cacheArcLengths = cache;\\r\\n\\r\\n\\t\\treturn cache; // { sums: cache, sum: sum }; Sum is in the last element.\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tupdateArcLengths: function () {\\r\\n\\r\\n\\t\\tthis.needsUpdate = true;\\r\\n\\t\\tthis.getLengths();\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\\r\\n\\r\\n\\tgetUtoTmapping: function ( u, distance ) {\\r\\n\\r\\n\\t\\tvar arcLengths = this.getLengths();\\r\\n\\r\\n\\t\\tvar i = 0, il = arcLengths.length;\\r\\n\\r\\n\\t\\tvar targetArcLength; // The targeted u distance value to get\\r\\n\\r\\n\\t\\tif ( distance ) {\\r\\n\\r\\n\\t\\t\\ttargetArcLength = distance;\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\ttargetArcLength = u * arcLengths[ il - 1 ];\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// binary search for the index with largest value smaller than target u distance\\r\\n\\r\\n\\t\\tvar low = 0, high = il - 1, comparison;\\r\\n\\r\\n\\t\\twhile ( low <= high ) {\\r\\n\\r\\n\\t\\t\\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\\r\\n\\r\\n\\t\\t\\tcomparison = arcLengths[ i ] - targetArcLength;\\r\\n\\r\\n\\t\\t\\tif ( comparison < 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tlow = i + 1;\\r\\n\\r\\n\\t\\t\\t} else if ( comparison > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\thigh = i - 1;\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\thigh = i;\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t// DONE\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\ti = high;\\r\\n\\r\\n\\t\\tif ( arcLengths[ i ] === targetArcLength ) {\\r\\n\\r\\n\\t\\t\\treturn i / ( il - 1 );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// we could get finer grain at lengths, or use simple interpolation between two points\\r\\n\\r\\n\\t\\tvar lengthBefore = arcLengths[ i ];\\r\\n\\t\\tvar lengthAfter = arcLengths[ i + 1 ];\\r\\n\\r\\n\\t\\tvar segmentLength = lengthAfter - lengthBefore;\\r\\n\\r\\n\\t\\t// determine where we are between the 'before' and 'after' points\\r\\n\\r\\n\\t\\tvar segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\\r\\n\\r\\n\\t\\t// add that fractional amount to t\\r\\n\\r\\n\\t\\tvar t = ( i + segmentFraction ) / ( il - 1 );\\r\\n\\r\\n\\t\\treturn t;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// Returns a unit vector tangent at t\\r\\n\\t// In case any sub curve does not implement its tangent derivation,\\r\\n\\t// 2 points a small delta apart will be used to find its gradient\\r\\n\\t// which seems to give a reasonable approximation\\r\\n\\r\\n\\tgetTangent: function ( t, optionalTarget ) {\\r\\n\\r\\n\\t\\tvar delta = 0.0001;\\r\\n\\t\\tvar t1 = t - delta;\\r\\n\\t\\tvar t2 = t + delta;\\r\\n\\r\\n\\t\\t// Capping in case of danger\\r\\n\\r\\n\\t\\tif ( t1 < 0 ) t1 = 0;\\r\\n\\t\\tif ( t2 > 1 ) t2 = 1;\\r\\n\\r\\n\\t\\tvar pt1 = this.getPoint( t1 );\\r\\n\\t\\tvar pt2 = this.getPoint( t2 );\\r\\n\\r\\n\\t\\tvar tangent = optionalTarget || ( ( pt1.isVector2 ) ? new Vector2() : new Vector3() );\\r\\n\\r\\n\\t\\ttangent.copy( pt2 ).sub( pt1 ).normalize();\\r\\n\\r\\n\\t\\treturn tangent;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetTangentAt: function ( u, optionalTarget ) {\\r\\n\\r\\n\\t\\tvar t = this.getUtoTmapping( u );\\r\\n\\t\\treturn this.getTangent( t, optionalTarget );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcomputeFrenetFrames: function ( segments, closed ) {\\r\\n\\r\\n\\t\\t// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\\r\\n\\r\\n\\t\\tvar normal = new Vector3();\\r\\n\\r\\n\\t\\tvar tangents = [];\\r\\n\\t\\tvar normals = [];\\r\\n\\t\\tvar binormals = [];\\r\\n\\r\\n\\t\\tvar vec = new Vector3();\\r\\n\\t\\tvar mat = new Matrix4();\\r\\n\\r\\n\\t\\tvar i, u, theta;\\r\\n\\r\\n\\t\\t// compute the tangent vectors for each segment on the curve\\r\\n\\r\\n\\t\\tfor ( i = 0; i <= segments; i ++ ) {\\r\\n\\r\\n\\t\\t\\tu = i / segments;\\r\\n\\r\\n\\t\\t\\ttangents[ i ] = this.getTangentAt( u, new Vector3() );\\r\\n\\t\\t\\ttangents[ i ].normalize();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// select an initial normal vector perpendicular to the first tangent vector,\\r\\n\\t\\t// and in the direction of the minimum tangent xyz component\\r\\n\\r\\n\\t\\tnormals[ 0 ] = new Vector3();\\r\\n\\t\\tbinormals[ 0 ] = new Vector3();\\r\\n\\t\\tvar min = Number.MAX_VALUE;\\r\\n\\t\\tvar tx = Math.abs( tangents[ 0 ].x );\\r\\n\\t\\tvar ty = Math.abs( tangents[ 0 ].y );\\r\\n\\t\\tvar tz = Math.abs( tangents[ 0 ].z );\\r\\n\\r\\n\\t\\tif ( tx <= min ) {\\r\\n\\r\\n\\t\\t\\tmin = tx;\\r\\n\\t\\t\\tnormal.set( 1, 0, 0 );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( ty <= min ) {\\r\\n\\r\\n\\t\\t\\tmin = ty;\\r\\n\\t\\t\\tnormal.set( 0, 1, 0 );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( tz <= min ) {\\r\\n\\r\\n\\t\\t\\tnormal.set( 0, 0, 1 );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\\r\\n\\r\\n\\t\\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\\r\\n\\t\\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\\r\\n\\r\\n\\r\\n\\t\\t// compute the slowly-varying normal and binormal vectors for each segment on the curve\\r\\n\\r\\n\\t\\tfor ( i = 1; i <= segments; i ++ ) {\\r\\n\\r\\n\\t\\t\\tnormals[ i ] = normals[ i - 1 ].clone();\\r\\n\\r\\n\\t\\t\\tbinormals[ i ] = binormals[ i - 1 ].clone();\\r\\n\\r\\n\\t\\t\\tvec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\\r\\n\\r\\n\\t\\t\\tif ( vec.length() > Number.EPSILON ) {\\r\\n\\r\\n\\t\\t\\t\\tvec.normalize();\\r\\n\\r\\n\\t\\t\\t\\ttheta = Math.acos( MathUtils.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\\r\\n\\r\\n\\t\\t\\t\\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\\r\\n\\r\\n\\t\\tif ( closed === true ) {\\r\\n\\r\\n\\t\\t\\ttheta = Math.acos( MathUtils.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );\\r\\n\\t\\t\\ttheta /= segments;\\r\\n\\r\\n\\t\\t\\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\ttheta = - theta;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tfor ( i = 1; i <= segments; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t// twist a little...\\r\\n\\t\\t\\t\\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\\r\\n\\t\\t\\t\\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn {\\r\\n\\t\\t\\ttangents: tangents,\\r\\n\\t\\t\\tnormals: normals,\\r\\n\\t\\t\\tbinormals: binormals\\r\\n\\t\\t};\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclone: function () {\\r\\n\\r\\n\\t\\treturn new this.constructor().copy( this );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\tthis.arcLengthDivisions = source.arcLengthDivisions;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttoJSON: function () {\\r\\n\\r\\n\\t\\tvar data = {\\r\\n\\t\\t\\tmetadata: {\\r\\n\\t\\t\\t\\tversion: 4.5,\\r\\n\\t\\t\\t\\ttype: 'Curve',\\r\\n\\t\\t\\t\\tgenerator: 'Curve.toJSON'\\r\\n\\t\\t\\t}\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tdata.arcLengthDivisions = this.arcLengthDivisions;\\r\\n\\t\\tdata.type = this.type;\\r\\n\\r\\n\\t\\treturn data;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tfromJSON: function ( json ) {\\r\\n\\r\\n\\t\\tthis.arcLengthDivisions = json.arcLengthDivisions;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nfunction EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\\r\\n\\r\\n\\tCurve.call( this );\\r\\n\\r\\n\\tthis.type = 'EllipseCurve';\\r\\n\\r\\n\\tthis.aX = aX || 0;\\r\\n\\tthis.aY = aY || 0;\\r\\n\\r\\n\\tthis.xRadius = xRadius || 1;\\r\\n\\tthis.yRadius = yRadius || 1;\\r\\n\\r\\n\\tthis.aStartAngle = aStartAngle || 0;\\r\\n\\tthis.aEndAngle = aEndAngle || 2 * Math.PI;\\r\\n\\r\\n\\tthis.aClockwise = aClockwise || false;\\r\\n\\r\\n\\tthis.aRotation = aRotation || 0;\\r\\n\\r\\n}\\r\\n\\r\\nEllipseCurve.prototype = Object.create( Curve.prototype );\\r\\nEllipseCurve.prototype.constructor = EllipseCurve;\\r\\n\\r\\nEllipseCurve.prototype.isEllipseCurve = true;\\r\\n\\r\\nEllipseCurve.prototype.getPoint = function ( t, optionalTarget ) {\\r\\n\\r\\n\\tvar point = optionalTarget || new Vector2();\\r\\n\\r\\n\\tvar twoPi = Math.PI * 2;\\r\\n\\tvar deltaAngle = this.aEndAngle - this.aStartAngle;\\r\\n\\tvar samePoints = Math.abs( deltaAngle ) < Number.EPSILON;\\r\\n\\r\\n\\t// ensures that deltaAngle is 0 .. 2 PI\\r\\n\\twhile ( deltaAngle < 0 ) deltaAngle += twoPi;\\r\\n\\twhile ( deltaAngle > twoPi ) deltaAngle -= twoPi;\\r\\n\\r\\n\\tif ( deltaAngle < Number.EPSILON ) {\\r\\n\\r\\n\\t\\tif ( samePoints ) {\\r\\n\\r\\n\\t\\t\\tdeltaAngle = 0;\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tdeltaAngle = twoPi;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tif ( this.aClockwise === true && ! samePoints ) {\\r\\n\\r\\n\\t\\tif ( deltaAngle === twoPi ) {\\r\\n\\r\\n\\t\\t\\tdeltaAngle = - twoPi;\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tdeltaAngle = deltaAngle - twoPi;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tvar angle = this.aStartAngle + t * deltaAngle;\\r\\n\\tvar x = this.aX + this.xRadius * Math.cos( angle );\\r\\n\\tvar y = this.aY + this.yRadius * Math.sin( angle );\\r\\n\\r\\n\\tif ( this.aRotation !== 0 ) {\\r\\n\\r\\n\\t\\tvar cos = Math.cos( this.aRotation );\\r\\n\\t\\tvar sin = Math.sin( this.aRotation );\\r\\n\\r\\n\\t\\tvar tx = x - this.aX;\\r\\n\\t\\tvar ty = y - this.aY;\\r\\n\\r\\n\\t\\t// Rotate the point about the center of the ellipse.\\r\\n\\t\\tx = tx * cos - ty * sin + this.aX;\\r\\n\\t\\ty = tx * sin + ty * cos + this.aY;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn point.set( x, y );\\r\\n\\r\\n};\\r\\n\\r\\nEllipseCurve.prototype.copy = function ( source ) {\\r\\n\\r\\n\\tCurve.prototype.copy.call( this, source );\\r\\n\\r\\n\\tthis.aX = source.aX;\\r\\n\\tthis.aY = source.aY;\\r\\n\\r\\n\\tthis.xRadius = source.xRadius;\\r\\n\\tthis.yRadius = source.yRadius;\\r\\n\\r\\n\\tthis.aStartAngle = source.aStartAngle;\\r\\n\\tthis.aEndAngle = source.aEndAngle;\\r\\n\\r\\n\\tthis.aClockwise = source.aClockwise;\\r\\n\\r\\n\\tthis.aRotation = source.aRotation;\\r\\n\\r\\n\\treturn this;\\r\\n\\r\\n};\\r\\n\\r\\n\\r\\nEllipseCurve.prototype.toJSON = function () {\\r\\n\\r\\n\\tvar data = Curve.prototype.toJSON.call( this );\\r\\n\\r\\n\\tdata.aX = this.aX;\\r\\n\\tdata.aY = this.aY;\\r\\n\\r\\n\\tdata.xRadius = this.xRadius;\\r\\n\\tdata.yRadius = this.yRadius;\\r\\n\\r\\n\\tdata.aStartAngle = this.aStartAngle;\\r\\n\\tdata.aEndAngle = this.aEndAngle;\\r\\n\\r\\n\\tdata.aClockwise = this.aClockwise;\\r\\n\\r\\n\\tdata.aRotation = this.aRotation;\\r\\n\\r\\n\\treturn data;\\r\\n\\r\\n};\\r\\n\\r\\nEllipseCurve.prototype.fromJSON = function ( json ) {\\r\\n\\r\\n\\tCurve.prototype.fromJSON.call( this, json );\\r\\n\\r\\n\\tthis.aX = json.aX;\\r\\n\\tthis.aY = json.aY;\\r\\n\\r\\n\\tthis.xRadius = json.xRadius;\\r\\n\\tthis.yRadius = json.yRadius;\\r\\n\\r\\n\\tthis.aStartAngle = json.aStartAngle;\\r\\n\\tthis.aEndAngle = json.aEndAngle;\\r\\n\\r\\n\\tthis.aClockwise = json.aClockwise;\\r\\n\\r\\n\\tthis.aRotation = json.aRotation;\\r\\n\\r\\n\\treturn this;\\r\\n\\r\\n};\\r\\n\\r\\nfunction ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\\r\\n\\r\\n\\tEllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\\r\\n\\r\\n\\tthis.type = 'ArcCurve';\\r\\n\\r\\n}\\r\\n\\r\\nArcCurve.prototype = Object.create( EllipseCurve.prototype );\\r\\nArcCurve.prototype.constructor = ArcCurve;\\r\\n\\r\\nArcCurve.prototype.isArcCurve = true;\\r\\n\\r\\n/**\\r\\n * @author zz85 https://github.com/zz85\\r\\n *\\r\\n * Centripetal CatmullRom Curve - which is useful for avoiding\\r\\n * cusps and self-intersections in non-uniform catmull rom curves.\\r\\n * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\\r\\n *\\r\\n * curve.type accepts centripetal(default), chordal and catmullrom\\r\\n * curve.tension is used for catmullrom which defaults to 0.5\\r\\n */\\r\\n\\r\\n\\r\\n/*\\r\\nBased on an optimized c++ solution in\\r\\n - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\\r\\n - http://ideone.com/NoEbVM\\r\\n\\r\\nThis CubicPoly class could be used for reusing some variables and calculations,\\r\\nbut for three.js curve use, it could be possible inlined and flatten into a single function call\\r\\nwhich can be placed in CurveUtils.\\r\\n*/\\r\\n\\r\\nfunction CubicPoly() {\\r\\n\\r\\n\\tvar c0 = 0, c1 = 0, c2 = 0, c3 = 0;\\r\\n\\r\\n\\t/*\\r\\n\\t * Compute coefficients for a cubic polynomial\\r\\n\\t *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\\r\\n\\t * such that\\r\\n\\t *   p(0) = x0, p(1) = x1\\r\\n\\t *  and\\r\\n\\t *   p'(0) = t0, p'(1) = t1.\\r\\n\\t */\\r\\n\\tfunction init( x0, x1, t0, t1 ) {\\r\\n\\r\\n\\t\\tc0 = x0;\\r\\n\\t\\tc1 = t0;\\r\\n\\t\\tc2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;\\r\\n\\t\\tc3 = 2 * x0 - 2 * x1 + t0 + t1;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn {\\r\\n\\r\\n\\t\\tinitCatmullRom: function ( x0, x1, x2, x3, tension ) {\\r\\n\\r\\n\\t\\t\\tinit( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tinitNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {\\r\\n\\r\\n\\t\\t\\t// compute tangents when parameterized in [t1,t2]\\r\\n\\t\\t\\tvar t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;\\r\\n\\t\\t\\tvar t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;\\r\\n\\r\\n\\t\\t\\t// rescale tangents for parametrization in [0,1]\\r\\n\\t\\t\\tt1 *= dt1;\\r\\n\\t\\t\\tt2 *= dt1;\\r\\n\\r\\n\\t\\t\\tinit( x1, x2, t1, t2 );\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tcalc: function ( t ) {\\r\\n\\r\\n\\t\\t\\tvar t2 = t * t;\\r\\n\\t\\t\\tvar t3 = t2 * t;\\r\\n\\t\\t\\treturn c0 + c1 * t + c2 * t2 + c3 * t3;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t};\\r\\n\\r\\n}\\r\\n\\r\\n//\\r\\n\\r\\nvar tmp = new Vector3();\\r\\nvar px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();\\r\\n\\r\\nfunction CatmullRomCurve3( points, closed, curveType, tension ) {\\r\\n\\r\\n\\tCurve.call( this );\\r\\n\\r\\n\\tthis.type = 'CatmullRomCurve3';\\r\\n\\r\\n\\tthis.points = points || [];\\r\\n\\tthis.closed = closed || false;\\r\\n\\tthis.curveType = curveType || 'centripetal';\\r\\n\\tthis.tension = tension || 0.5;\\r\\n\\r\\n}\\r\\n\\r\\nCatmullRomCurve3.prototype = Object.create( Curve.prototype );\\r\\nCatmullRomCurve3.prototype.constructor = CatmullRomCurve3;\\r\\n\\r\\nCatmullRomCurve3.prototype.isCatmullRomCurve3 = true;\\r\\n\\r\\nCatmullRomCurve3.prototype.getPoint = function ( t, optionalTarget ) {\\r\\n\\r\\n\\tvar point = optionalTarget || new Vector3();\\r\\n\\r\\n\\tvar points = this.points;\\r\\n\\tvar l = points.length;\\r\\n\\r\\n\\tvar p = ( l - ( this.closed ? 0 : 1 ) ) * t;\\r\\n\\tvar intPoint = Math.floor( p );\\r\\n\\tvar weight = p - intPoint;\\r\\n\\r\\n\\tif ( this.closed ) {\\r\\n\\r\\n\\t\\tintPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / l ) + 1 ) * l;\\r\\n\\r\\n\\t} else if ( weight === 0 && intPoint === l - 1 ) {\\r\\n\\r\\n\\t\\tintPoint = l - 2;\\r\\n\\t\\tweight = 1;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tvar p0, p1, p2, p3; // 4 points\\r\\n\\r\\n\\tif ( this.closed || intPoint > 0 ) {\\r\\n\\r\\n\\t\\tp0 = points[ ( intPoint - 1 ) % l ];\\r\\n\\r\\n\\t} else {\\r\\n\\r\\n\\t\\t// extrapolate first point\\r\\n\\t\\ttmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );\\r\\n\\t\\tp0 = tmp;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tp1 = points[ intPoint % l ];\\r\\n\\tp2 = points[ ( intPoint + 1 ) % l ];\\r\\n\\r\\n\\tif ( this.closed || intPoint + 2 < l ) {\\r\\n\\r\\n\\t\\tp3 = points[ ( intPoint + 2 ) % l ];\\r\\n\\r\\n\\t} else {\\r\\n\\r\\n\\t\\t// extrapolate last point\\r\\n\\t\\ttmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );\\r\\n\\t\\tp3 = tmp;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tif ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {\\r\\n\\r\\n\\t\\t// init Centripetal / Chordal Catmull-Rom\\r\\n\\t\\tvar pow = this.curveType === 'chordal' ? 0.5 : 0.25;\\r\\n\\t\\tvar dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );\\r\\n\\t\\tvar dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );\\r\\n\\t\\tvar dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );\\r\\n\\r\\n\\t\\t// safety check for repeated points\\r\\n\\t\\tif ( dt1 < 1e-4 ) dt1 = 1.0;\\r\\n\\t\\tif ( dt0 < 1e-4 ) dt0 = dt1;\\r\\n\\t\\tif ( dt2 < 1e-4 ) dt2 = dt1;\\r\\n\\r\\n\\t\\tpx.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );\\r\\n\\t\\tpy.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );\\r\\n\\t\\tpz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );\\r\\n\\r\\n\\t} else if ( this.curveType === 'catmullrom' ) {\\r\\n\\r\\n\\t\\tpx.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );\\r\\n\\t\\tpy.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );\\r\\n\\t\\tpz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tpoint.set(\\r\\n\\t\\tpx.calc( weight ),\\r\\n\\t\\tpy.calc( weight ),\\r\\n\\t\\tpz.calc( weight )\\r\\n\\t);\\r\\n\\r\\n\\treturn point;\\r\\n\\r\\n};\\r\\n\\r\\nCatmullRomCurve3.prototype.copy = function ( source ) {\\r\\n\\r\\n\\tCurve.prototype.copy.call( this, source );\\r\\n\\r\\n\\tthis.points = [];\\r\\n\\r\\n\\tfor ( var i = 0, l = source.points.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\tvar point = source.points[ i ];\\r\\n\\r\\n\\t\\tthis.points.push( point.clone() );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tthis.closed = source.closed;\\r\\n\\tthis.curveType = source.curveType;\\r\\n\\tthis.tension = source.tension;\\r\\n\\r\\n\\treturn this;\\r\\n\\r\\n};\\r\\n\\r\\nCatmullRomCurve3.prototype.toJSON = function () {\\r\\n\\r\\n\\tvar data = Curve.prototype.toJSON.call( this );\\r\\n\\r\\n\\tdata.points = [];\\r\\n\\r\\n\\tfor ( var i = 0, l = this.points.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\tvar point = this.points[ i ];\\r\\n\\t\\tdata.points.push( point.toArray() );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tdata.closed = this.closed;\\r\\n\\tdata.curveType = this.curveType;\\r\\n\\tdata.tension = this.tension;\\r\\n\\r\\n\\treturn data;\\r\\n\\r\\n};\\r\\n\\r\\nCatmullRomCurve3.prototype.fromJSON = function ( json ) {\\r\\n\\r\\n\\tCurve.prototype.fromJSON.call( this, json );\\r\\n\\r\\n\\tthis.points = [];\\r\\n\\r\\n\\tfor ( var i = 0, l = json.points.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\tvar point = json.points[ i ];\\r\\n\\t\\tthis.points.push( new Vector3().fromArray( point ) );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tthis.closed = json.closed;\\r\\n\\tthis.curveType = json.curveType;\\r\\n\\tthis.tension = json.tension;\\r\\n\\r\\n\\treturn this;\\r\\n\\r\\n};\\r\\n\\r\\n/**\\r\\n * @author zz85 / http://www.lab4games.net/zz85/blog\\r\\n *\\r\\n * Bezier Curves formulas obtained from\\r\\n * http://en.wikipedia.org/wiki/Bzier_curve\\r\\n */\\r\\n\\r\\nfunction CatmullRom( t, p0, p1, p2, p3 ) {\\r\\n\\r\\n\\tvar v0 = ( p2 - p0 ) * 0.5;\\r\\n\\tvar v1 = ( p3 - p1 ) * 0.5;\\r\\n\\tvar t2 = t * t;\\r\\n\\tvar t3 = t * t2;\\r\\n\\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\\r\\n\\r\\n}\\r\\n\\r\\n//\\r\\n\\r\\nfunction QuadraticBezierP0( t, p ) {\\r\\n\\r\\n\\tvar k = 1 - t;\\r\\n\\treturn k * k * p;\\r\\n\\r\\n}\\r\\n\\r\\nfunction QuadraticBezierP1( t, p ) {\\r\\n\\r\\n\\treturn 2 * ( 1 - t ) * t * p;\\r\\n\\r\\n}\\r\\n\\r\\nfunction QuadraticBezierP2( t, p ) {\\r\\n\\r\\n\\treturn t * t * p;\\r\\n\\r\\n}\\r\\n\\r\\nfunction QuadraticBezier( t, p0, p1, p2 ) {\\r\\n\\r\\n\\treturn QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +\\r\\n\\t\\tQuadraticBezierP2( t, p2 );\\r\\n\\r\\n}\\r\\n\\r\\n//\\r\\n\\r\\nfunction CubicBezierP0( t, p ) {\\r\\n\\r\\n\\tvar k = 1 - t;\\r\\n\\treturn k * k * k * p;\\r\\n\\r\\n}\\r\\n\\r\\nfunction CubicBezierP1( t, p ) {\\r\\n\\r\\n\\tvar k = 1 - t;\\r\\n\\treturn 3 * k * k * t * p;\\r\\n\\r\\n}\\r\\n\\r\\nfunction CubicBezierP2( t, p ) {\\r\\n\\r\\n\\treturn 3 * ( 1 - t ) * t * t * p;\\r\\n\\r\\n}\\r\\n\\r\\nfunction CubicBezierP3( t, p ) {\\r\\n\\r\\n\\treturn t * t * t * p;\\r\\n\\r\\n}\\r\\n\\r\\nfunction CubicBezier( t, p0, p1, p2, p3 ) {\\r\\n\\r\\n\\treturn CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +\\r\\n\\t\\tCubicBezierP3( t, p3 );\\r\\n\\r\\n}\\r\\n\\r\\nfunction CubicBezierCurve( v0, v1, v2, v3 ) {\\r\\n\\r\\n\\tCurve.call( this );\\r\\n\\r\\n\\tthis.type = 'CubicBezierCurve';\\r\\n\\r\\n\\tthis.v0 = v0 || new Vector2();\\r\\n\\tthis.v1 = v1 || new Vector2();\\r\\n\\tthis.v2 = v2 || new Vector2();\\r\\n\\tthis.v3 = v3 || new Vector2();\\r\\n\\r\\n}\\r\\n\\r\\nCubicBezierCurve.prototype = Object.create( Curve.prototype );\\r\\nCubicBezierCurve.prototype.constructor = CubicBezierCurve;\\r\\n\\r\\nCubicBezierCurve.prototype.isCubicBezierCurve = true;\\r\\n\\r\\nCubicBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {\\r\\n\\r\\n\\tvar point = optionalTarget || new Vector2();\\r\\n\\r\\n\\tvar v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;\\r\\n\\r\\n\\tpoint.set(\\r\\n\\t\\tCubicBezier( t, v0.x, v1.x, v2.x, v3.x ),\\r\\n\\t\\tCubicBezier( t, v0.y, v1.y, v2.y, v3.y )\\r\\n\\t);\\r\\n\\r\\n\\treturn point;\\r\\n\\r\\n};\\r\\n\\r\\nCubicBezierCurve.prototype.copy = function ( source ) {\\r\\n\\r\\n\\tCurve.prototype.copy.call( this, source );\\r\\n\\r\\n\\tthis.v0.copy( source.v0 );\\r\\n\\tthis.v1.copy( source.v1 );\\r\\n\\tthis.v2.copy( source.v2 );\\r\\n\\tthis.v3.copy( source.v3 );\\r\\n\\r\\n\\treturn this;\\r\\n\\r\\n};\\r\\n\\r\\nCubicBezierCurve.prototype.toJSON = function () {\\r\\n\\r\\n\\tvar data = Curve.prototype.toJSON.call( this );\\r\\n\\r\\n\\tdata.v0 = this.v0.toArray();\\r\\n\\tdata.v1 = this.v1.toArray();\\r\\n\\tdata.v2 = this.v2.toArray();\\r\\n\\tdata.v3 = this.v3.toArray();\\r\\n\\r\\n\\treturn data;\\r\\n\\r\\n};\\r\\n\\r\\nCubicBezierCurve.prototype.fromJSON = function ( json ) {\\r\\n\\r\\n\\tCurve.prototype.fromJSON.call( this, json );\\r\\n\\r\\n\\tthis.v0.fromArray( json.v0 );\\r\\n\\tthis.v1.fromArray( json.v1 );\\r\\n\\tthis.v2.fromArray( json.v2 );\\r\\n\\tthis.v3.fromArray( json.v3 );\\r\\n\\r\\n\\treturn this;\\r\\n\\r\\n};\\r\\n\\r\\nfunction CubicBezierCurve3( v0, v1, v2, v3 ) {\\r\\n\\r\\n\\tCurve.call( this );\\r\\n\\r\\n\\tthis.type = 'CubicBezierCurve3';\\r\\n\\r\\n\\tthis.v0 = v0 || new Vector3();\\r\\n\\tthis.v1 = v1 || new Vector3();\\r\\n\\tthis.v2 = v2 || new Vector3();\\r\\n\\tthis.v3 = v3 || new Vector3();\\r\\n\\r\\n}\\r\\n\\r\\nCubicBezierCurve3.prototype = Object.create( Curve.prototype );\\r\\nCubicBezierCurve3.prototype.constructor = CubicBezierCurve3;\\r\\n\\r\\nCubicBezierCurve3.prototype.isCubicBezierCurve3 = true;\\r\\n\\r\\nCubicBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {\\r\\n\\r\\n\\tvar point = optionalTarget || new Vector3();\\r\\n\\r\\n\\tvar v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;\\r\\n\\r\\n\\tpoint.set(\\r\\n\\t\\tCubicBezier( t, v0.x, v1.x, v2.x, v3.x ),\\r\\n\\t\\tCubicBezier( t, v0.y, v1.y, v2.y, v3.y ),\\r\\n\\t\\tCubicBezier( t, v0.z, v1.z, v2.z, v3.z )\\r\\n\\t);\\r\\n\\r\\n\\treturn point;\\r\\n\\r\\n};\\r\\n\\r\\nCubicBezierCurve3.prototype.copy = function ( source ) {\\r\\n\\r\\n\\tCurve.prototype.copy.call( this, source );\\r\\n\\r\\n\\tthis.v0.copy( source.v0 );\\r\\n\\tthis.v1.copy( source.v1 );\\r\\n\\tthis.v2.copy( source.v2 );\\r\\n\\tthis.v3.copy( source.v3 );\\r\\n\\r\\n\\treturn this;\\r\\n\\r\\n};\\r\\n\\r\\nCubicBezierCurve3.prototype.toJSON = function () {\\r\\n\\r\\n\\tvar data = Curve.prototype.toJSON.call( this );\\r\\n\\r\\n\\tdata.v0 = this.v0.toArray();\\r\\n\\tdata.v1 = this.v1.toArray();\\r\\n\\tdata.v2 = this.v2.toArray();\\r\\n\\tdata.v3 = this.v3.toArray();\\r\\n\\r\\n\\treturn data;\\r\\n\\r\\n};\\r\\n\\r\\nCubicBezierCurve3.prototype.fromJSON = function ( json ) {\\r\\n\\r\\n\\tCurve.prototype.fromJSON.call( this, json );\\r\\n\\r\\n\\tthis.v0.fromArray( json.v0 );\\r\\n\\tthis.v1.fromArray( json.v1 );\\r\\n\\tthis.v2.fromArray( json.v2 );\\r\\n\\tthis.v3.fromArray( json.v3 );\\r\\n\\r\\n\\treturn this;\\r\\n\\r\\n};\\r\\n\\r\\nfunction LineCurve( v1, v2 ) {\\r\\n\\r\\n\\tCurve.call( this );\\r\\n\\r\\n\\tthis.type = 'LineCurve';\\r\\n\\r\\n\\tthis.v1 = v1 || new Vector2();\\r\\n\\tthis.v2 = v2 || new Vector2();\\r\\n\\r\\n}\\r\\n\\r\\nLineCurve.prototype = Object.create( Curve.prototype );\\r\\nLineCurve.prototype.constructor = LineCurve;\\r\\n\\r\\nLineCurve.prototype.isLineCurve = true;\\r\\n\\r\\nLineCurve.prototype.getPoint = function ( t, optionalTarget ) {\\r\\n\\r\\n\\tvar point = optionalTarget || new Vector2();\\r\\n\\r\\n\\tif ( t === 1 ) {\\r\\n\\r\\n\\t\\tpoint.copy( this.v2 );\\r\\n\\r\\n\\t} else {\\r\\n\\r\\n\\t\\tpoint.copy( this.v2 ).sub( this.v1 );\\r\\n\\t\\tpoint.multiplyScalar( t ).add( this.v1 );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn point;\\r\\n\\r\\n};\\r\\n\\r\\n// Line curve is linear, so we can overwrite default getPointAt\\r\\n\\r\\nLineCurve.prototype.getPointAt = function ( u, optionalTarget ) {\\r\\n\\r\\n\\treturn this.getPoint( u, optionalTarget );\\r\\n\\r\\n};\\r\\n\\r\\nLineCurve.prototype.getTangent = function ( t, optionalTarget ) {\\r\\n\\r\\n\\tvar tangent = optionalTarget || new Vector2();\\r\\n\\r\\n\\tvar tangent = tangent.copy( this.v2 ).sub( this.v1 ).normalize();\\r\\n\\r\\n\\treturn tangent;\\r\\n\\r\\n};\\r\\n\\r\\nLineCurve.prototype.copy = function ( source ) {\\r\\n\\r\\n\\tCurve.prototype.copy.call( this, source );\\r\\n\\r\\n\\tthis.v1.copy( source.v1 );\\r\\n\\tthis.v2.copy( source.v2 );\\r\\n\\r\\n\\treturn this;\\r\\n\\r\\n};\\r\\n\\r\\nLineCurve.prototype.toJSON = function () {\\r\\n\\r\\n\\tvar data = Curve.prototype.toJSON.call( this );\\r\\n\\r\\n\\tdata.v1 = this.v1.toArray();\\r\\n\\tdata.v2 = this.v2.toArray();\\r\\n\\r\\n\\treturn data;\\r\\n\\r\\n};\\r\\n\\r\\nLineCurve.prototype.fromJSON = function ( json ) {\\r\\n\\r\\n\\tCurve.prototype.fromJSON.call( this, json );\\r\\n\\r\\n\\tthis.v1.fromArray( json.v1 );\\r\\n\\tthis.v2.fromArray( json.v2 );\\r\\n\\r\\n\\treturn this;\\r\\n\\r\\n};\\r\\n\\r\\nfunction LineCurve3( v1, v2 ) {\\r\\n\\r\\n\\tCurve.call( this );\\r\\n\\r\\n\\tthis.type = 'LineCurve3';\\r\\n\\r\\n\\tthis.v1 = v1 || new Vector3();\\r\\n\\tthis.v2 = v2 || new Vector3();\\r\\n\\r\\n}\\r\\n\\r\\nLineCurve3.prototype = Object.create( Curve.prototype );\\r\\nLineCurve3.prototype.constructor = LineCurve3;\\r\\n\\r\\nLineCurve3.prototype.isLineCurve3 = true;\\r\\n\\r\\nLineCurve3.prototype.getPoint = function ( t, optionalTarget ) {\\r\\n\\r\\n\\tvar point = optionalTarget || new Vector3();\\r\\n\\r\\n\\tif ( t === 1 ) {\\r\\n\\r\\n\\t\\tpoint.copy( this.v2 );\\r\\n\\r\\n\\t} else {\\r\\n\\r\\n\\t\\tpoint.copy( this.v2 ).sub( this.v1 );\\r\\n\\t\\tpoint.multiplyScalar( t ).add( this.v1 );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn point;\\r\\n\\r\\n};\\r\\n\\r\\n// Line curve is linear, so we can overwrite default getPointAt\\r\\n\\r\\nLineCurve3.prototype.getPointAt = function ( u, optionalTarget ) {\\r\\n\\r\\n\\treturn this.getPoint( u, optionalTarget );\\r\\n\\r\\n};\\r\\n\\r\\nLineCurve3.prototype.copy = function ( source ) {\\r\\n\\r\\n\\tCurve.prototype.copy.call( this, source );\\r\\n\\r\\n\\tthis.v1.copy( source.v1 );\\r\\n\\tthis.v2.copy( source.v2 );\\r\\n\\r\\n\\treturn this;\\r\\n\\r\\n};\\r\\n\\r\\nLineCurve3.prototype.toJSON = function () {\\r\\n\\r\\n\\tvar data = Curve.prototype.toJSON.call( this );\\r\\n\\r\\n\\tdata.v1 = this.v1.toArray();\\r\\n\\tdata.v2 = this.v2.toArray();\\r\\n\\r\\n\\treturn data;\\r\\n\\r\\n};\\r\\n\\r\\nLineCurve3.prototype.fromJSON = function ( json ) {\\r\\n\\r\\n\\tCurve.prototype.fromJSON.call( this, json );\\r\\n\\r\\n\\tthis.v1.fromArray( json.v1 );\\r\\n\\tthis.v2.fromArray( json.v2 );\\r\\n\\r\\n\\treturn this;\\r\\n\\r\\n};\\r\\n\\r\\nfunction QuadraticBezierCurve( v0, v1, v2 ) {\\r\\n\\r\\n\\tCurve.call( this );\\r\\n\\r\\n\\tthis.type = 'QuadraticBezierCurve';\\r\\n\\r\\n\\tthis.v0 = v0 || new Vector2();\\r\\n\\tthis.v1 = v1 || new Vector2();\\r\\n\\tthis.v2 = v2 || new Vector2();\\r\\n\\r\\n}\\r\\n\\r\\nQuadraticBezierCurve.prototype = Object.create( Curve.prototype );\\r\\nQuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;\\r\\n\\r\\nQuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;\\r\\n\\r\\nQuadraticBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {\\r\\n\\r\\n\\tvar point = optionalTarget || new Vector2();\\r\\n\\r\\n\\tvar v0 = this.v0, v1 = this.v1, v2 = this.v2;\\r\\n\\r\\n\\tpoint.set(\\r\\n\\t\\tQuadraticBezier( t, v0.x, v1.x, v2.x ),\\r\\n\\t\\tQuadraticBezier( t, v0.y, v1.y, v2.y )\\r\\n\\t);\\r\\n\\r\\n\\treturn point;\\r\\n\\r\\n};\\r\\n\\r\\nQuadraticBezierCurve.prototype.copy = function ( source ) {\\r\\n\\r\\n\\tCurve.prototype.copy.call( this, source );\\r\\n\\r\\n\\tthis.v0.copy( source.v0 );\\r\\n\\tthis.v1.copy( source.v1 );\\r\\n\\tthis.v2.copy( source.v2 );\\r\\n\\r\\n\\treturn this;\\r\\n\\r\\n};\\r\\n\\r\\nQuadraticBezierCurve.prototype.toJSON = function () {\\r\\n\\r\\n\\tvar data = Curve.prototype.toJSON.call( this );\\r\\n\\r\\n\\tdata.v0 = this.v0.toArray();\\r\\n\\tdata.v1 = this.v1.toArray();\\r\\n\\tdata.v2 = this.v2.toArray();\\r\\n\\r\\n\\treturn data;\\r\\n\\r\\n};\\r\\n\\r\\nQuadraticBezierCurve.prototype.fromJSON = function ( json ) {\\r\\n\\r\\n\\tCurve.prototype.fromJSON.call( this, json );\\r\\n\\r\\n\\tthis.v0.fromArray( json.v0 );\\r\\n\\tthis.v1.fromArray( json.v1 );\\r\\n\\tthis.v2.fromArray( json.v2 );\\r\\n\\r\\n\\treturn this;\\r\\n\\r\\n};\\r\\n\\r\\nfunction QuadraticBezierCurve3( v0, v1, v2 ) {\\r\\n\\r\\n\\tCurve.call( this );\\r\\n\\r\\n\\tthis.type = 'QuadraticBezierCurve3';\\r\\n\\r\\n\\tthis.v0 = v0 || new Vector3();\\r\\n\\tthis.v1 = v1 || new Vector3();\\r\\n\\tthis.v2 = v2 || new Vector3();\\r\\n\\r\\n}\\r\\n\\r\\nQuadraticBezierCurve3.prototype = Object.create( Curve.prototype );\\r\\nQuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;\\r\\n\\r\\nQuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;\\r\\n\\r\\nQuadraticBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {\\r\\n\\r\\n\\tvar point = optionalTarget || new Vector3();\\r\\n\\r\\n\\tvar v0 = this.v0, v1 = this.v1, v2 = this.v2;\\r\\n\\r\\n\\tpoint.set(\\r\\n\\t\\tQuadraticBezier( t, v0.x, v1.x, v2.x ),\\r\\n\\t\\tQuadraticBezier( t, v0.y, v1.y, v2.y ),\\r\\n\\t\\tQuadraticBezier( t, v0.z, v1.z, v2.z )\\r\\n\\t);\\r\\n\\r\\n\\treturn point;\\r\\n\\r\\n};\\r\\n\\r\\nQuadraticBezierCurve3.prototype.copy = function ( source ) {\\r\\n\\r\\n\\tCurve.prototype.copy.call( this, source );\\r\\n\\r\\n\\tthis.v0.copy( source.v0 );\\r\\n\\tthis.v1.copy( source.v1 );\\r\\n\\tthis.v2.copy( source.v2 );\\r\\n\\r\\n\\treturn this;\\r\\n\\r\\n};\\r\\n\\r\\nQuadraticBezierCurve3.prototype.toJSON = function () {\\r\\n\\r\\n\\tvar data = Curve.prototype.toJSON.call( this );\\r\\n\\r\\n\\tdata.v0 = this.v0.toArray();\\r\\n\\tdata.v1 = this.v1.toArray();\\r\\n\\tdata.v2 = this.v2.toArray();\\r\\n\\r\\n\\treturn data;\\r\\n\\r\\n};\\r\\n\\r\\nQuadraticBezierCurve3.prototype.fromJSON = function ( json ) {\\r\\n\\r\\n\\tCurve.prototype.fromJSON.call( this, json );\\r\\n\\r\\n\\tthis.v0.fromArray( json.v0 );\\r\\n\\tthis.v1.fromArray( json.v1 );\\r\\n\\tthis.v2.fromArray( json.v2 );\\r\\n\\r\\n\\treturn this;\\r\\n\\r\\n};\\r\\n\\r\\nfunction SplineCurve( points /* array of Vector2 */ ) {\\r\\n\\r\\n\\tCurve.call( this );\\r\\n\\r\\n\\tthis.type = 'SplineCurve';\\r\\n\\r\\n\\tthis.points = points || [];\\r\\n\\r\\n}\\r\\n\\r\\nSplineCurve.prototype = Object.create( Curve.prototype );\\r\\nSplineCurve.prototype.constructor = SplineCurve;\\r\\n\\r\\nSplineCurve.prototype.isSplineCurve = true;\\r\\n\\r\\nSplineCurve.prototype.getPoint = function ( t, optionalTarget ) {\\r\\n\\r\\n\\tvar point = optionalTarget || new Vector2();\\r\\n\\r\\n\\tvar points = this.points;\\r\\n\\tvar p = ( points.length - 1 ) * t;\\r\\n\\r\\n\\tvar intPoint = Math.floor( p );\\r\\n\\tvar weight = p - intPoint;\\r\\n\\r\\n\\tvar p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];\\r\\n\\tvar p1 = points[ intPoint ];\\r\\n\\tvar p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\\r\\n\\tvar p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\\r\\n\\r\\n\\tpoint.set(\\r\\n\\t\\tCatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),\\r\\n\\t\\tCatmullRom( weight, p0.y, p1.y, p2.y, p3.y )\\r\\n\\t);\\r\\n\\r\\n\\treturn point;\\r\\n\\r\\n};\\r\\n\\r\\nSplineCurve.prototype.copy = function ( source ) {\\r\\n\\r\\n\\tCurve.prototype.copy.call( this, source );\\r\\n\\r\\n\\tthis.points = [];\\r\\n\\r\\n\\tfor ( var i = 0, l = source.points.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\tvar point = source.points[ i ];\\r\\n\\r\\n\\t\\tthis.points.push( point.clone() );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn this;\\r\\n\\r\\n};\\r\\n\\r\\nSplineCurve.prototype.toJSON = function () {\\r\\n\\r\\n\\tvar data = Curve.prototype.toJSON.call( this );\\r\\n\\r\\n\\tdata.points = [];\\r\\n\\r\\n\\tfor ( var i = 0, l = this.points.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\tvar point = this.points[ i ];\\r\\n\\t\\tdata.points.push( point.toArray() );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn data;\\r\\n\\r\\n};\\r\\n\\r\\nSplineCurve.prototype.fromJSON = function ( json ) {\\r\\n\\r\\n\\tCurve.prototype.fromJSON.call( this, json );\\r\\n\\r\\n\\tthis.points = [];\\r\\n\\r\\n\\tfor ( var i = 0, l = json.points.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\tvar point = json.points[ i ];\\r\\n\\t\\tthis.points.push( new Vector2().fromArray( point ) );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn this;\\r\\n\\r\\n};\\r\\n\\r\\nvar Curves = /*#__PURE__*/Object.freeze({\\r\\n\\t__proto__: null,\\r\\n\\tArcCurve: ArcCurve,\\r\\n\\tCatmullRomCurve3: CatmullRomCurve3,\\r\\n\\tCubicBezierCurve: CubicBezierCurve,\\r\\n\\tCubicBezierCurve3: CubicBezierCurve3,\\r\\n\\tEllipseCurve: EllipseCurve,\\r\\n\\tLineCurve: LineCurve,\\r\\n\\tLineCurve3: LineCurve3,\\r\\n\\tQuadraticBezierCurve: QuadraticBezierCurve,\\r\\n\\tQuadraticBezierCurve3: QuadraticBezierCurve3,\\r\\n\\tSplineCurve: SplineCurve\\r\\n});\\r\\n\\r\\n/**\\r\\n * @author zz85 / http://www.lab4games.net/zz85/blog\\r\\n *\\r\\n **/\\r\\n\\r\\n/**************************************************************\\r\\n *\\tCurved Path - a curve path is simply a array of connected\\r\\n *  curves, but retains the api of a curve\\r\\n **************************************************************/\\r\\n\\r\\nfunction CurvePath() {\\r\\n\\r\\n\\tCurve.call( this );\\r\\n\\r\\n\\tthis.type = 'CurvePath';\\r\\n\\r\\n\\tthis.curves = [];\\r\\n\\tthis.autoClose = false; // Automatically closes the path\\r\\n\\r\\n}\\r\\n\\r\\nCurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {\\r\\n\\r\\n\\tconstructor: CurvePath,\\r\\n\\r\\n\\tadd: function ( curve ) {\\r\\n\\r\\n\\t\\tthis.curves.push( curve );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclosePath: function () {\\r\\n\\r\\n\\t\\t// Add a line curve if start and end of lines are not connected\\r\\n\\t\\tvar startPoint = this.curves[ 0 ].getPoint( 0 );\\r\\n\\t\\tvar endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );\\r\\n\\r\\n\\t\\tif ( ! startPoint.equals( endPoint ) ) {\\r\\n\\r\\n\\t\\t\\tthis.curves.push( new LineCurve( endPoint, startPoint ) );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// To get accurate point with reference to\\r\\n\\t// entire path distance at time t,\\r\\n\\t// following has to be done:\\r\\n\\r\\n\\t// 1. Length of each sub path have to be known\\r\\n\\t// 2. Locate and identify type of curve\\r\\n\\t// 3. Get t for the curve\\r\\n\\t// 4. Return curve.getPointAt(t')\\r\\n\\r\\n\\tgetPoint: function ( t ) {\\r\\n\\r\\n\\t\\tvar d = t * this.getLength();\\r\\n\\t\\tvar curveLengths = this.getCurveLengths();\\r\\n\\t\\tvar i = 0;\\r\\n\\r\\n\\t\\t// To think about boundaries points.\\r\\n\\r\\n\\t\\twhile ( i < curveLengths.length ) {\\r\\n\\r\\n\\t\\t\\tif ( curveLengths[ i ] >= d ) {\\r\\n\\r\\n\\t\\t\\t\\tvar diff = curveLengths[ i ] - d;\\r\\n\\t\\t\\t\\tvar curve = this.curves[ i ];\\r\\n\\r\\n\\t\\t\\t\\tvar segmentLength = curve.getLength();\\r\\n\\t\\t\\t\\tvar u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\\r\\n\\r\\n\\t\\t\\t\\treturn curve.getPointAt( u );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\ti ++;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn null;\\r\\n\\r\\n\\t\\t// loop where sum != 0, sum > d , sum+1 <d\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// We cannot use the default THREE.Curve getPoint() with getLength() because in\\r\\n\\t// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\\r\\n\\t// getPoint() depends on getLength\\r\\n\\r\\n\\tgetLength: function () {\\r\\n\\r\\n\\t\\tvar lens = this.getCurveLengths();\\r\\n\\t\\treturn lens[ lens.length - 1 ];\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// cacheLengths must be recalculated.\\r\\n\\tupdateArcLengths: function () {\\r\\n\\r\\n\\t\\tthis.needsUpdate = true;\\r\\n\\t\\tthis.cacheLengths = null;\\r\\n\\t\\tthis.getCurveLengths();\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// Compute lengths and cache them\\r\\n\\t// We cannot overwrite getLengths() because UtoT mapping uses it.\\r\\n\\r\\n\\tgetCurveLengths: function () {\\r\\n\\r\\n\\t\\t// We use cache values if curves and cache array are same length\\r\\n\\r\\n\\t\\tif ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {\\r\\n\\r\\n\\t\\t\\treturn this.cacheLengths;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Get length of sub-curve\\r\\n\\t\\t// Push sums into cached array\\r\\n\\r\\n\\t\\tvar lengths = [], sums = 0;\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = this.curves.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\tsums += this.curves[ i ].getLength();\\r\\n\\t\\t\\tlengths.push( sums );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.cacheLengths = lengths;\\r\\n\\r\\n\\t\\treturn lengths;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetSpacedPoints: function ( divisions ) {\\r\\n\\r\\n\\t\\tif ( divisions === undefined ) divisions = 40;\\r\\n\\r\\n\\t\\tvar points = [];\\r\\n\\r\\n\\t\\tfor ( var i = 0; i <= divisions; i ++ ) {\\r\\n\\r\\n\\t\\t\\tpoints.push( this.getPoint( i / divisions ) );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( this.autoClose ) {\\r\\n\\r\\n\\t\\t\\tpoints.push( points[ 0 ] );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn points;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetPoints: function ( divisions ) {\\r\\n\\r\\n\\t\\tdivisions = divisions || 12;\\r\\n\\r\\n\\t\\tvar points = [], last;\\r\\n\\r\\n\\t\\tfor ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar curve = curves[ i ];\\r\\n\\t\\t\\tvar resolution = ( curve && curve.isEllipseCurve ) ? divisions * 2\\r\\n\\t\\t\\t\\t: ( curve && ( curve.isLineCurve || curve.isLineCurve3 ) ) ? 1\\r\\n\\t\\t\\t\\t\\t: ( curve && curve.isSplineCurve ) ? divisions * curve.points.length\\r\\n\\t\\t\\t\\t\\t\\t: divisions;\\r\\n\\r\\n\\t\\t\\tvar pts = curve.getPoints( resolution );\\r\\n\\r\\n\\t\\t\\tfor ( var j = 0; j < pts.length; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar point = pts[ j ];\\r\\n\\r\\n\\t\\t\\t\\tif ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates\\r\\n\\r\\n\\t\\t\\t\\tpoints.push( point );\\r\\n\\t\\t\\t\\tlast = point;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {\\r\\n\\r\\n\\t\\t\\tpoints.push( points[ 0 ] );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn points;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\tCurve.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\tthis.curves = [];\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = source.curves.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar curve = source.curves[ i ];\\r\\n\\r\\n\\t\\t\\tthis.curves.push( curve.clone() );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.autoClose = source.autoClose;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttoJSON: function () {\\r\\n\\r\\n\\t\\tvar data = Curve.prototype.toJSON.call( this );\\r\\n\\r\\n\\t\\tdata.autoClose = this.autoClose;\\r\\n\\t\\tdata.curves = [];\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = this.curves.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar curve = this.curves[ i ];\\r\\n\\t\\t\\tdata.curves.push( curve.toJSON() );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn data;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tfromJSON: function ( json ) {\\r\\n\\r\\n\\t\\tCurve.prototype.fromJSON.call( this, json );\\r\\n\\r\\n\\t\\tthis.autoClose = json.autoClose;\\r\\n\\t\\tthis.curves = [];\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = json.curves.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar curve = json.curves[ i ];\\r\\n\\t\\t\\tthis.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author zz85 / http://www.lab4games.net/zz85/blog\\r\\n * Creates free form 2d path using series of points, lines or curves.\\r\\n **/\\r\\n\\r\\nfunction Path( points ) {\\r\\n\\r\\n\\tCurvePath.call( this );\\r\\n\\r\\n\\tthis.type = 'Path';\\r\\n\\r\\n\\tthis.currentPoint = new Vector2();\\r\\n\\r\\n\\tif ( points ) {\\r\\n\\r\\n\\t\\tthis.setFromPoints( points );\\r\\n\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\\r\\nPath.prototype = Object.assign( Object.create( CurvePath.prototype ), {\\r\\n\\r\\n\\tconstructor: Path,\\r\\n\\r\\n\\tsetFromPoints: function ( points ) {\\r\\n\\r\\n\\t\\tthis.moveTo( points[ 0 ].x, points[ 0 ].y );\\r\\n\\r\\n\\t\\tfor ( var i = 1, l = points.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\tthis.lineTo( points[ i ].x, points[ i ].y );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tmoveTo: function ( x, y ) {\\r\\n\\r\\n\\t\\tthis.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tlineTo: function ( x, y ) {\\r\\n\\r\\n\\t\\tvar curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );\\r\\n\\t\\tthis.curves.push( curve );\\r\\n\\r\\n\\t\\tthis.currentPoint.set( x, y );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tquadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\\r\\n\\r\\n\\t\\tvar curve = new QuadraticBezierCurve(\\r\\n\\t\\t\\tthis.currentPoint.clone(),\\r\\n\\t\\t\\tnew Vector2( aCPx, aCPy ),\\r\\n\\t\\t\\tnew Vector2( aX, aY )\\r\\n\\t\\t);\\r\\n\\r\\n\\t\\tthis.curves.push( curve );\\r\\n\\r\\n\\t\\tthis.currentPoint.set( aX, aY );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tbezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\\r\\n\\r\\n\\t\\tvar curve = new CubicBezierCurve(\\r\\n\\t\\t\\tthis.currentPoint.clone(),\\r\\n\\t\\t\\tnew Vector2( aCP1x, aCP1y ),\\r\\n\\t\\t\\tnew Vector2( aCP2x, aCP2y ),\\r\\n\\t\\t\\tnew Vector2( aX, aY )\\r\\n\\t\\t);\\r\\n\\r\\n\\t\\tthis.curves.push( curve );\\r\\n\\r\\n\\t\\tthis.currentPoint.set( aX, aY );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsplineThru: function ( pts /*Array of Vector*/ ) {\\r\\n\\r\\n\\t\\tvar npts = [ this.currentPoint.clone() ].concat( pts );\\r\\n\\r\\n\\t\\tvar curve = new SplineCurve( npts );\\r\\n\\t\\tthis.curves.push( curve );\\r\\n\\r\\n\\t\\tthis.currentPoint.copy( pts[ pts.length - 1 ] );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\\r\\n\\r\\n\\t\\tvar x0 = this.currentPoint.x;\\r\\n\\t\\tvar y0 = this.currentPoint.y;\\r\\n\\r\\n\\t\\tthis.absarc( aX + x0, aY + y0, aRadius,\\r\\n\\t\\t\\taStartAngle, aEndAngle, aClockwise );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tabsarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\\r\\n\\r\\n\\t\\tthis.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\\r\\n\\r\\n\\t\\tvar x0 = this.currentPoint.x;\\r\\n\\t\\tvar y0 = this.currentPoint.y;\\r\\n\\r\\n\\t\\tthis.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tabsellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\\r\\n\\r\\n\\t\\tvar curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\\r\\n\\r\\n\\t\\tif ( this.curves.length > 0 ) {\\r\\n\\r\\n\\t\\t\\t// if a previous curve is present, attempt to join\\r\\n\\t\\t\\tvar firstPoint = curve.getPoint( 0 );\\r\\n\\r\\n\\t\\t\\tif ( ! firstPoint.equals( this.currentPoint ) ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.lineTo( firstPoint.x, firstPoint.y );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.curves.push( curve );\\r\\n\\r\\n\\t\\tvar lastPoint = curve.getPoint( 1 );\\r\\n\\t\\tthis.currentPoint.copy( lastPoint );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\tCurvePath.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\tthis.currentPoint.copy( source.currentPoint );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttoJSON: function () {\\r\\n\\r\\n\\t\\tvar data = CurvePath.prototype.toJSON.call( this );\\r\\n\\r\\n\\t\\tdata.currentPoint = this.currentPoint.toArray();\\r\\n\\r\\n\\t\\treturn data;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tfromJSON: function ( json ) {\\r\\n\\r\\n\\t\\tCurvePath.prototype.fromJSON.call( this, json );\\r\\n\\r\\n\\t\\tthis.currentPoint.fromArray( json.currentPoint );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author zz85 / http://www.lab4games.net/zz85/blog\\r\\n * Defines a 2d shape plane using paths.\\r\\n **/\\r\\n\\r\\n// STEP 1 Create a path.\\r\\n// STEP 2 Turn path into shape.\\r\\n// STEP 3 ExtrudeGeometry takes in Shape/Shapes\\r\\n// STEP 3a - Extract points from each shape, turn to vertices\\r\\n// STEP 3b - Triangulate each shape, add faces.\\r\\n\\r\\nfunction Shape( points ) {\\r\\n\\r\\n\\tPath.call( this, points );\\r\\n\\r\\n\\tthis.uuid = MathUtils.generateUUID();\\r\\n\\r\\n\\tthis.type = 'Shape';\\r\\n\\r\\n\\tthis.holes = [];\\r\\n\\r\\n}\\r\\n\\r\\nShape.prototype = Object.assign( Object.create( Path.prototype ), {\\r\\n\\r\\n\\tconstructor: Shape,\\r\\n\\r\\n\\tgetPointsHoles: function ( divisions ) {\\r\\n\\r\\n\\t\\tvar holesPts = [];\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = this.holes.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\tholesPts[ i ] = this.holes[ i ].getPoints( divisions );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn holesPts;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// get points of shape and holes (keypoints based on segments parameter)\\r\\n\\r\\n\\textractPoints: function ( divisions ) {\\r\\n\\r\\n\\t\\treturn {\\r\\n\\r\\n\\t\\t\\tshape: this.getPoints( divisions ),\\r\\n\\t\\t\\tholes: this.getPointsHoles( divisions )\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\tPath.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\tthis.holes = [];\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = source.holes.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar hole = source.holes[ i ];\\r\\n\\r\\n\\t\\t\\tthis.holes.push( hole.clone() );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttoJSON: function () {\\r\\n\\r\\n\\t\\tvar data = Path.prototype.toJSON.call( this );\\r\\n\\r\\n\\t\\tdata.uuid = this.uuid;\\r\\n\\t\\tdata.holes = [];\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = this.holes.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar hole = this.holes[ i ];\\r\\n\\t\\t\\tdata.holes.push( hole.toJSON() );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn data;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tfromJSON: function ( json ) {\\r\\n\\r\\n\\t\\tPath.prototype.fromJSON.call( this, json );\\r\\n\\r\\n\\t\\tthis.uuid = json.uuid;\\r\\n\\t\\tthis.holes = [];\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = json.holes.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar hole = json.holes[ i ];\\r\\n\\t\\t\\tthis.holes.push( new Path().fromJSON( hole ) );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n */\\r\\n\\r\\nfunction Light( color, intensity ) {\\r\\n\\r\\n\\tObject3D.call( this );\\r\\n\\r\\n\\tthis.type = 'Light';\\r\\n\\r\\n\\tthis.color = new Color( color );\\r\\n\\tthis.intensity = intensity !== undefined ? intensity : 1;\\r\\n\\r\\n\\tthis.receiveShadow = undefined;\\r\\n\\r\\n}\\r\\n\\r\\nLight.prototype = Object.assign( Object.create( Object3D.prototype ), {\\r\\n\\r\\n\\tconstructor: Light,\\r\\n\\r\\n\\tisLight: true,\\r\\n\\r\\n\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\tObject3D.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\tthis.color.copy( source.color );\\r\\n\\t\\tthis.intensity = source.intensity;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttoJSON: function ( meta ) {\\r\\n\\r\\n\\t\\tvar data = Object3D.prototype.toJSON.call( this, meta );\\r\\n\\r\\n\\t\\tdata.object.color = this.color.getHex();\\r\\n\\t\\tdata.object.intensity = this.intensity;\\r\\n\\r\\n\\t\\tif ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();\\r\\n\\r\\n\\t\\tif ( this.distance !== undefined ) data.object.distance = this.distance;\\r\\n\\t\\tif ( this.angle !== undefined ) data.object.angle = this.angle;\\r\\n\\t\\tif ( this.decay !== undefined ) data.object.decay = this.decay;\\r\\n\\t\\tif ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;\\r\\n\\r\\n\\t\\tif ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();\\r\\n\\r\\n\\t\\treturn data;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n */\\r\\n\\r\\nfunction HemisphereLight( skyColor, groundColor, intensity ) {\\r\\n\\r\\n\\tLight.call( this, skyColor, intensity );\\r\\n\\r\\n\\tthis.type = 'HemisphereLight';\\r\\n\\r\\n\\tthis.castShadow = undefined;\\r\\n\\r\\n\\tthis.position.copy( Object3D.DefaultUp );\\r\\n\\tthis.updateMatrix();\\r\\n\\r\\n\\tthis.groundColor = new Color( groundColor );\\r\\n\\r\\n}\\r\\n\\r\\nHemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), {\\r\\n\\r\\n\\tconstructor: HemisphereLight,\\r\\n\\r\\n\\tisHemisphereLight: true,\\r\\n\\r\\n\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\tLight.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\tthis.groundColor.copy( source.groundColor );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nfunction LightShadow( camera ) {\\r\\n\\r\\n\\tthis.camera = camera;\\r\\n\\r\\n\\tthis.bias = 0;\\r\\n\\tthis.radius = 1;\\r\\n\\r\\n\\tthis.mapSize = new Vector2( 512, 512 );\\r\\n\\r\\n\\tthis.map = null;\\r\\n\\tthis.mapPass = null;\\r\\n\\tthis.matrix = new Matrix4();\\r\\n\\r\\n\\tthis._frustum = new Frustum();\\r\\n\\tthis._frameExtents = new Vector2( 1, 1 );\\r\\n\\r\\n\\tthis._viewportCount = 1;\\r\\n\\r\\n\\tthis._viewports = [\\r\\n\\r\\n\\t\\tnew Vector4( 0, 0, 1, 1 )\\r\\n\\r\\n\\t];\\r\\n\\r\\n}\\r\\n\\r\\nObject.assign( LightShadow.prototype, {\\r\\n\\r\\n\\t_projScreenMatrix: new Matrix4(),\\r\\n\\r\\n\\t_lightPositionWorld: new Vector3(),\\r\\n\\r\\n\\t_lookTarget: new Vector3(),\\r\\n\\r\\n\\tgetViewportCount: function () {\\r\\n\\r\\n\\t\\treturn this._viewportCount;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetFrustum: function () {\\r\\n\\r\\n\\t\\treturn this._frustum;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tupdateMatrices: function ( light ) {\\r\\n\\r\\n\\t\\tvar shadowCamera = this.camera,\\r\\n\\t\\t\\tshadowMatrix = this.matrix,\\r\\n\\t\\t\\tprojScreenMatrix = this._projScreenMatrix,\\r\\n\\t\\t\\tlookTarget = this._lookTarget,\\r\\n\\t\\t\\tlightPositionWorld = this._lightPositionWorld;\\r\\n\\r\\n\\t\\tlightPositionWorld.setFromMatrixPosition( light.matrixWorld );\\r\\n\\t\\tshadowCamera.position.copy( lightPositionWorld );\\r\\n\\r\\n\\t\\tlookTarget.setFromMatrixPosition( light.target.matrixWorld );\\r\\n\\t\\tshadowCamera.lookAt( lookTarget );\\r\\n\\t\\tshadowCamera.updateMatrixWorld();\\r\\n\\r\\n\\t\\tprojScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\\r\\n\\t\\tthis._frustum.setFromProjectionMatrix( projScreenMatrix );\\r\\n\\r\\n\\t\\tshadowMatrix.set(\\r\\n\\t\\t\\t0.5, 0.0, 0.0, 0.5,\\r\\n\\t\\t\\t0.0, 0.5, 0.0, 0.5,\\r\\n\\t\\t\\t0.0, 0.0, 0.5, 0.5,\\r\\n\\t\\t\\t0.0, 0.0, 0.0, 1.0\\r\\n\\t\\t);\\r\\n\\r\\n\\t\\tshadowMatrix.multiply( shadowCamera.projectionMatrix );\\r\\n\\t\\tshadowMatrix.multiply( shadowCamera.matrixWorldInverse );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetViewport: function ( viewportIndex ) {\\r\\n\\r\\n\\t\\treturn this._viewports[ viewportIndex ];\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetFrameExtents: function () {\\r\\n\\r\\n\\t\\treturn this._frameExtents;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\tthis.camera = source.camera.clone();\\r\\n\\r\\n\\t\\tthis.bias = source.bias;\\r\\n\\t\\tthis.radius = source.radius;\\r\\n\\r\\n\\t\\tthis.mapSize.copy( source.mapSize );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclone: function () {\\r\\n\\r\\n\\t\\treturn new this.constructor().copy( this );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttoJSON: function () {\\r\\n\\r\\n\\t\\tvar object = {};\\r\\n\\r\\n\\t\\tif ( this.bias !== 0 ) object.bias = this.bias;\\r\\n\\t\\tif ( this.radius !== 1 ) object.radius = this.radius;\\r\\n\\t\\tif ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();\\r\\n\\r\\n\\t\\tobject.camera = this.camera.toJSON( false ).object;\\r\\n\\t\\tdelete object.camera.matrix;\\r\\n\\r\\n\\t\\treturn object;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nfunction SpotLightShadow() {\\r\\n\\r\\n\\tLightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) );\\r\\n\\r\\n}\\r\\n\\r\\nSpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {\\r\\n\\r\\n\\tconstructor: SpotLightShadow,\\r\\n\\r\\n\\tisSpotLightShadow: true,\\r\\n\\r\\n\\tupdateMatrices: function ( light ) {\\r\\n\\r\\n\\t\\tvar camera = this.camera;\\r\\n\\r\\n\\t\\tvar fov = MathUtils.RAD2DEG * 2 * light.angle;\\r\\n\\t\\tvar aspect = this.mapSize.width / this.mapSize.height;\\r\\n\\t\\tvar far = light.distance || camera.far;\\r\\n\\r\\n\\t\\tif ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {\\r\\n\\r\\n\\t\\t\\tcamera.fov = fov;\\r\\n\\t\\t\\tcamera.aspect = aspect;\\r\\n\\t\\t\\tcamera.far = far;\\r\\n\\t\\t\\tcamera.updateProjectionMatrix();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tLightShadow.prototype.updateMatrices.call( this, light );\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n */\\r\\n\\r\\nfunction SpotLight( color, intensity, distance, angle, penumbra, decay ) {\\r\\n\\r\\n\\tLight.call( this, color, intensity );\\r\\n\\r\\n\\tthis.type = 'SpotLight';\\r\\n\\r\\n\\tthis.position.copy( Object3D.DefaultUp );\\r\\n\\tthis.updateMatrix();\\r\\n\\r\\n\\tthis.target = new Object3D();\\r\\n\\r\\n\\tObject.defineProperty( this, 'power', {\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\t// intensity = power per solid angle.\\r\\n\\t\\t\\t// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\\r\\n\\t\\t\\treturn this.intensity * Math.PI;\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tset: function ( power ) {\\r\\n\\r\\n\\t\\t\\t// intensity = power per solid angle.\\r\\n\\t\\t\\t// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\\r\\n\\t\\t\\tthis.intensity = power / Math.PI;\\r\\n\\r\\n\\t\\t}\\r\\n\\t} );\\r\\n\\r\\n\\tthis.distance = ( distance !== undefined ) ? distance : 0;\\r\\n\\tthis.angle = ( angle !== undefined ) ? angle : Math.PI / 3;\\r\\n\\tthis.penumbra = ( penumbra !== undefined ) ? penumbra : 0;\\r\\n\\tthis.decay = ( decay !== undefined ) ? decay : 1;\\t// for physically correct lights, should be 2.\\r\\n\\r\\n\\tthis.shadow = new SpotLightShadow();\\r\\n\\r\\n}\\r\\n\\r\\nSpotLight.prototype = Object.assign( Object.create( Light.prototype ), {\\r\\n\\r\\n\\tconstructor: SpotLight,\\r\\n\\r\\n\\tisSpotLight: true,\\r\\n\\r\\n\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\tLight.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\tthis.distance = source.distance;\\r\\n\\t\\tthis.angle = source.angle;\\r\\n\\t\\tthis.penumbra = source.penumbra;\\r\\n\\t\\tthis.decay = source.decay;\\r\\n\\r\\n\\t\\tthis.target = source.target.clone();\\r\\n\\r\\n\\t\\tthis.shadow = source.shadow.clone();\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nfunction PointLightShadow() {\\r\\n\\r\\n\\tLightShadow.call( this, new PerspectiveCamera( 90, 1, 0.5, 500 ) );\\r\\n\\r\\n\\tthis._frameExtents = new Vector2( 4, 2 );\\r\\n\\r\\n\\tthis._viewportCount = 6;\\r\\n\\r\\n\\tthis._viewports = [\\r\\n\\t\\t// These viewports map a cube-map onto a 2D texture with the\\r\\n\\t\\t// following orientation:\\r\\n\\t\\t//\\r\\n\\t\\t//  xzXZ\\r\\n\\t\\t//   y Y\\r\\n\\t\\t//\\r\\n\\t\\t// X - Positive x direction\\r\\n\\t\\t// x - Negative x direction\\r\\n\\t\\t// Y - Positive y direction\\r\\n\\t\\t// y - Negative y direction\\r\\n\\t\\t// Z - Positive z direction\\r\\n\\t\\t// z - Negative z direction\\r\\n\\r\\n\\t\\t// positive X\\r\\n\\t\\tnew Vector4( 2, 1, 1, 1 ),\\r\\n\\t\\t// negative X\\r\\n\\t\\tnew Vector4( 0, 1, 1, 1 ),\\r\\n\\t\\t// positive Z\\r\\n\\t\\tnew Vector4( 3, 1, 1, 1 ),\\r\\n\\t\\t// negative Z\\r\\n\\t\\tnew Vector4( 1, 1, 1, 1 ),\\r\\n\\t\\t// positive Y\\r\\n\\t\\tnew Vector4( 3, 0, 1, 1 ),\\r\\n\\t\\t// negative Y\\r\\n\\t\\tnew Vector4( 1, 0, 1, 1 )\\r\\n\\t];\\r\\n\\r\\n\\tthis._cubeDirections = [\\r\\n\\t\\tnew Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),\\r\\n\\t\\tnew Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )\\r\\n\\t];\\r\\n\\r\\n\\tthis._cubeUps = [\\r\\n\\t\\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),\\r\\n\\t\\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),\\tnew Vector3( 0, 0, - 1 )\\r\\n\\t];\\r\\n\\r\\n}\\r\\n\\r\\nPointLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {\\r\\n\\r\\n\\tconstructor: PointLightShadow,\\r\\n\\r\\n\\tisPointLightShadow: true,\\r\\n\\r\\n\\tupdateMatrices: function ( light, viewportIndex ) {\\r\\n\\r\\n\\t\\tif ( viewportIndex === undefined ) viewportIndex = 0;\\r\\n\\r\\n\\t\\tvar camera = this.camera,\\r\\n\\t\\t\\tshadowMatrix = this.matrix,\\r\\n\\t\\t\\tlightPositionWorld = this._lightPositionWorld,\\r\\n\\t\\t\\tlookTarget = this._lookTarget,\\r\\n\\t\\t\\tprojScreenMatrix = this._projScreenMatrix;\\r\\n\\r\\n\\t\\tlightPositionWorld.setFromMatrixPosition( light.matrixWorld );\\r\\n\\t\\tcamera.position.copy( lightPositionWorld );\\r\\n\\r\\n\\t\\tlookTarget.copy( camera.position );\\r\\n\\t\\tlookTarget.add( this._cubeDirections[ viewportIndex ] );\\r\\n\\t\\tcamera.up.copy( this._cubeUps[ viewportIndex ] );\\r\\n\\t\\tcamera.lookAt( lookTarget );\\r\\n\\t\\tcamera.updateMatrixWorld();\\r\\n\\r\\n\\t\\tshadowMatrix.makeTranslation( - lightPositionWorld.x, - lightPositionWorld.y, - lightPositionWorld.z );\\r\\n\\r\\n\\t\\tprojScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\\r\\n\\t\\tthis._frustum.setFromProjectionMatrix( projScreenMatrix );\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\n\\r\\nfunction PointLight( color, intensity, distance, decay ) {\\r\\n\\r\\n\\tLight.call( this, color, intensity );\\r\\n\\r\\n\\tthis.type = 'PointLight';\\r\\n\\r\\n\\tObject.defineProperty( this, 'power', {\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\t// intensity = power per solid angle.\\r\\n\\t\\t\\t// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\\r\\n\\t\\t\\treturn this.intensity * 4 * Math.PI;\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tset: function ( power ) {\\r\\n\\r\\n\\t\\t\\t// intensity = power per solid angle.\\r\\n\\t\\t\\t// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\\r\\n\\t\\t\\tthis.intensity = power / ( 4 * Math.PI );\\r\\n\\r\\n\\t\\t}\\r\\n\\t} );\\r\\n\\r\\n\\tthis.distance = ( distance !== undefined ) ? distance : 0;\\r\\n\\tthis.decay = ( decay !== undefined ) ? decay : 1;\\t// for physically correct lights, should be 2.\\r\\n\\r\\n\\tthis.shadow = new PointLightShadow();\\r\\n\\r\\n}\\r\\n\\r\\nPointLight.prototype = Object.assign( Object.create( Light.prototype ), {\\r\\n\\r\\n\\tconstructor: PointLight,\\r\\n\\r\\n\\tisPointLight: true,\\r\\n\\r\\n\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\tLight.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\tthis.distance = source.distance;\\r\\n\\t\\tthis.decay = source.decay;\\r\\n\\r\\n\\t\\tthis.shadow = source.shadow.clone();\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n * @author arose / http://github.com/arose\\r\\n */\\r\\n\\r\\nfunction OrthographicCamera( left, right, top, bottom, near, far ) {\\r\\n\\r\\n\\tCamera.call( this );\\r\\n\\r\\n\\tthis.type = 'OrthographicCamera';\\r\\n\\r\\n\\tthis.zoom = 1;\\r\\n\\tthis.view = null;\\r\\n\\r\\n\\tthis.left = ( left !== undefined ) ? left : - 1;\\r\\n\\tthis.right = ( right !== undefined ) ? right : 1;\\r\\n\\tthis.top = ( top !== undefined ) ? top : 1;\\r\\n\\tthis.bottom = ( bottom !== undefined ) ? bottom : - 1;\\r\\n\\r\\n\\tthis.near = ( near !== undefined ) ? near : 0.1;\\r\\n\\tthis.far = ( far !== undefined ) ? far : 2000;\\r\\n\\r\\n\\tthis.updateProjectionMatrix();\\r\\n\\r\\n}\\r\\n\\r\\nOrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {\\r\\n\\r\\n\\tconstructor: OrthographicCamera,\\r\\n\\r\\n\\tisOrthographicCamera: true,\\r\\n\\r\\n\\tcopy: function ( source, recursive ) {\\r\\n\\r\\n\\t\\tCamera.prototype.copy.call( this, source, recursive );\\r\\n\\r\\n\\t\\tthis.left = source.left;\\r\\n\\t\\tthis.right = source.right;\\r\\n\\t\\tthis.top = source.top;\\r\\n\\t\\tthis.bottom = source.bottom;\\r\\n\\t\\tthis.near = source.near;\\r\\n\\t\\tthis.far = source.far;\\r\\n\\r\\n\\t\\tthis.zoom = source.zoom;\\r\\n\\t\\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {\\r\\n\\r\\n\\t\\tif ( this.view === null ) {\\r\\n\\r\\n\\t\\t\\tthis.view = {\\r\\n\\t\\t\\t\\tenabled: true,\\r\\n\\t\\t\\t\\tfullWidth: 1,\\r\\n\\t\\t\\t\\tfullHeight: 1,\\r\\n\\t\\t\\t\\toffsetX: 0,\\r\\n\\t\\t\\t\\toffsetY: 0,\\r\\n\\t\\t\\t\\twidth: 1,\\r\\n\\t\\t\\t\\theight: 1\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.view.enabled = true;\\r\\n\\t\\tthis.view.fullWidth = fullWidth;\\r\\n\\t\\tthis.view.fullHeight = fullHeight;\\r\\n\\t\\tthis.view.offsetX = x;\\r\\n\\t\\tthis.view.offsetY = y;\\r\\n\\t\\tthis.view.width = width;\\r\\n\\t\\tthis.view.height = height;\\r\\n\\r\\n\\t\\tthis.updateProjectionMatrix();\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclearViewOffset: function () {\\r\\n\\r\\n\\t\\tif ( this.view !== null ) {\\r\\n\\r\\n\\t\\t\\tthis.view.enabled = false;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.updateProjectionMatrix();\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tupdateProjectionMatrix: function () {\\r\\n\\r\\n\\t\\tvar dx = ( this.right - this.left ) / ( 2 * this.zoom );\\r\\n\\t\\tvar dy = ( this.top - this.bottom ) / ( 2 * this.zoom );\\r\\n\\t\\tvar cx = ( this.right + this.left ) / 2;\\r\\n\\t\\tvar cy = ( this.top + this.bottom ) / 2;\\r\\n\\r\\n\\t\\tvar left = cx - dx;\\r\\n\\t\\tvar right = cx + dx;\\r\\n\\t\\tvar top = cy + dy;\\r\\n\\t\\tvar bottom = cy - dy;\\r\\n\\r\\n\\t\\tif ( this.view !== null && this.view.enabled ) {\\r\\n\\r\\n\\t\\t\\tvar scaleW = ( this.right - this.left ) / this.view.fullWidth / this.zoom;\\r\\n\\t\\t\\tvar scaleH = ( this.top - this.bottom ) / this.view.fullHeight / this.zoom;\\r\\n\\r\\n\\t\\t\\tleft += scaleW * this.view.offsetX;\\r\\n\\t\\t\\tright = left + scaleW * this.view.width;\\r\\n\\t\\t\\ttop -= scaleH * this.view.offsetY;\\r\\n\\t\\t\\tbottom = top - scaleH * this.view.height;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );\\r\\n\\r\\n\\t\\tthis.projectionMatrixInverse.getInverse( this.projectionMatrix );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttoJSON: function ( meta ) {\\r\\n\\r\\n\\t\\tvar data = Object3D.prototype.toJSON.call( this, meta );\\r\\n\\r\\n\\t\\tdata.object.zoom = this.zoom;\\r\\n\\t\\tdata.object.left = this.left;\\r\\n\\t\\tdata.object.right = this.right;\\r\\n\\t\\tdata.object.top = this.top;\\r\\n\\t\\tdata.object.bottom = this.bottom;\\r\\n\\t\\tdata.object.near = this.near;\\r\\n\\t\\tdata.object.far = this.far;\\r\\n\\r\\n\\t\\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\\r\\n\\r\\n\\t\\treturn data;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nfunction DirectionalLightShadow() {\\r\\n\\r\\n\\tLightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );\\r\\n\\r\\n}\\r\\n\\r\\nDirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {\\r\\n\\r\\n\\tconstructor: DirectionalLightShadow,\\r\\n\\r\\n\\tisDirectionalLightShadow: true,\\r\\n\\r\\n\\tupdateMatrices: function ( light ) {\\r\\n\\r\\n\\t\\tLightShadow.prototype.updateMatrices.call( this, light );\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n */\\r\\n\\r\\nfunction DirectionalLight( color, intensity ) {\\r\\n\\r\\n\\tLight.call( this, color, intensity );\\r\\n\\r\\n\\tthis.type = 'DirectionalLight';\\r\\n\\r\\n\\tthis.position.copy( Object3D.DefaultUp );\\r\\n\\tthis.updateMatrix();\\r\\n\\r\\n\\tthis.target = new Object3D();\\r\\n\\r\\n\\tthis.shadow = new DirectionalLightShadow();\\r\\n\\r\\n}\\r\\n\\r\\nDirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), {\\r\\n\\r\\n\\tconstructor: DirectionalLight,\\r\\n\\r\\n\\tisDirectionalLight: true,\\r\\n\\r\\n\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\tLight.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\tthis.target = source.target.clone();\\r\\n\\r\\n\\t\\tthis.shadow = source.shadow.clone();\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nfunction AmbientLight( color, intensity ) {\\r\\n\\r\\n\\tLight.call( this, color, intensity );\\r\\n\\r\\n\\tthis.type = 'AmbientLight';\\r\\n\\r\\n\\tthis.castShadow = undefined;\\r\\n\\r\\n}\\r\\n\\r\\nAmbientLight.prototype = Object.assign( Object.create( Light.prototype ), {\\r\\n\\r\\n\\tconstructor: AmbientLight,\\r\\n\\r\\n\\tisAmbientLight: true\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author abelnation / http://github.com/abelnation\\r\\n */\\r\\n\\r\\nfunction RectAreaLight( color, intensity, width, height ) {\\r\\n\\r\\n\\tLight.call( this, color, intensity );\\r\\n\\r\\n\\tthis.type = 'RectAreaLight';\\r\\n\\r\\n\\tthis.width = ( width !== undefined ) ? width : 10;\\r\\n\\tthis.height = ( height !== undefined ) ? height : 10;\\r\\n\\r\\n}\\r\\n\\r\\nRectAreaLight.prototype = Object.assign( Object.create( Light.prototype ), {\\r\\n\\r\\n\\tconstructor: RectAreaLight,\\r\\n\\r\\n\\tisRectAreaLight: true,\\r\\n\\r\\n\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\tLight.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\tthis.width = source.width;\\r\\n\\t\\tthis.height = source.height;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttoJSON: function ( meta ) {\\r\\n\\r\\n\\t\\tvar data = Light.prototype.toJSON.call( this, meta );\\r\\n\\r\\n\\t\\tdata.object.width = this.width;\\r\\n\\t\\tdata.object.height = this.height;\\r\\n\\r\\n\\t\\treturn data;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author bhouston / http://clara.io\\r\\n * @author WestLangley / http://github.com/WestLangley\\r\\n *\\r\\n * Primary reference:\\r\\n *   https://graphics.stanford.edu/papers/envmap/envmap.pdf\\r\\n *\\r\\n * Secondary reference:\\r\\n *   https://www.ppsloan.org/publications/StupidSH36.pdf\\r\\n */\\r\\n\\r\\n// 3-band SH defined by 9 coefficients\\r\\n\\r\\nfunction SphericalHarmonics3() {\\r\\n\\r\\n\\tthis.coefficients = [];\\r\\n\\r\\n\\tfor ( var i = 0; i < 9; i ++ ) {\\r\\n\\r\\n\\t\\tthis.coefficients.push( new Vector3() );\\r\\n\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\\r\\nObject.assign( SphericalHarmonics3.prototype, {\\r\\n\\r\\n\\tisSphericalHarmonics3: true,\\r\\n\\r\\n\\tset: function ( coefficients ) {\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < 9; i ++ ) {\\r\\n\\r\\n\\t\\t\\tthis.coefficients[ i ].copy( coefficients[ i ] );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tzero: function () {\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < 9; i ++ ) {\\r\\n\\r\\n\\t\\t\\tthis.coefficients[ i ].set( 0, 0, 0 );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// get the radiance in the direction of the normal\\r\\n\\t// target is a Vector3\\r\\n\\tgetAt: function ( normal, target ) {\\r\\n\\r\\n\\t\\t// normal is assumed to be unit length\\r\\n\\r\\n\\t\\tvar x = normal.x, y = normal.y, z = normal.z;\\r\\n\\r\\n\\t\\tvar coeff = this.coefficients;\\r\\n\\r\\n\\t\\t// band 0\\r\\n\\t\\ttarget.copy( coeff[ 0 ] ).multiplyScalar( 0.282095 );\\r\\n\\r\\n\\t\\t// band 1\\r\\n\\t\\ttarget.addScaledVector( coeff[ 1 ], 0.488603 * y );\\r\\n\\t\\ttarget.addScaledVector( coeff[ 2 ], 0.488603 * z );\\r\\n\\t\\ttarget.addScaledVector( coeff[ 3 ], 0.488603 * x );\\r\\n\\r\\n\\t\\t// band 2\\r\\n\\t\\ttarget.addScaledVector( coeff[ 4 ], 1.092548 * ( x * y ) );\\r\\n\\t\\ttarget.addScaledVector( coeff[ 5 ], 1.092548 * ( y * z ) );\\r\\n\\t\\ttarget.addScaledVector( coeff[ 6 ], 0.315392 * ( 3.0 * z * z - 1.0 ) );\\r\\n\\t\\ttarget.addScaledVector( coeff[ 7 ], 1.092548 * ( x * z ) );\\r\\n\\t\\ttarget.addScaledVector( coeff[ 8 ], 0.546274 * ( x * x - y * y ) );\\r\\n\\r\\n\\t\\treturn target;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// get the irradiance (radiance convolved with cosine lobe) in the direction of the normal\\r\\n\\t// target is a Vector3\\r\\n\\t// https://graphics.stanford.edu/papers/envmap/envmap.pdf\\r\\n\\tgetIrradianceAt: function ( normal, target ) {\\r\\n\\r\\n\\t\\t// normal is assumed to be unit length\\r\\n\\r\\n\\t\\tvar x = normal.x, y = normal.y, z = normal.z;\\r\\n\\r\\n\\t\\tvar coeff = this.coefficients;\\r\\n\\r\\n\\t\\t// band 0\\r\\n\\t\\ttarget.copy( coeff[ 0 ] ).multiplyScalar( 0.886227 ); //  * 0.282095\\r\\n\\r\\n\\t\\t// band 1\\r\\n\\t\\ttarget.addScaledVector( coeff[ 1 ], 2.0 * 0.511664 * y ); // ( 2 *  / 3 ) * 0.488603\\r\\n\\t\\ttarget.addScaledVector( coeff[ 2 ], 2.0 * 0.511664 * z );\\r\\n\\t\\ttarget.addScaledVector( coeff[ 3 ], 2.0 * 0.511664 * x );\\r\\n\\r\\n\\t\\t// band 2\\r\\n\\t\\ttarget.addScaledVector( coeff[ 4 ], 2.0 * 0.429043 * x * y ); // (  / 4 ) * 1.092548\\r\\n\\t\\ttarget.addScaledVector( coeff[ 5 ], 2.0 * 0.429043 * y * z );\\r\\n\\t\\ttarget.addScaledVector( coeff[ 6 ], 0.743125 * z * z - 0.247708 ); // (  / 4 ) * 0.315392 * 3\\r\\n\\t\\ttarget.addScaledVector( coeff[ 7 ], 2.0 * 0.429043 * x * z );\\r\\n\\t\\ttarget.addScaledVector( coeff[ 8 ], 0.429043 * ( x * x - y * y ) ); // (  / 4 ) * 0.546274\\r\\n\\r\\n\\t\\treturn target;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tadd: function ( sh ) {\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < 9; i ++ ) {\\r\\n\\r\\n\\t\\t\\tthis.coefficients[ i ].add( sh.coefficients[ i ] );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\taddScaledSH: function ( sh, s ) {\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < 9; i ++ ) {\\r\\n\\r\\n\\t\\t\\tthis.coefficients[ i ].addScaledVector( sh.coefficients[ i ], s );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tscale: function ( s ) {\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < 9; i ++ ) {\\r\\n\\r\\n\\t\\t\\tthis.coefficients[ i ].multiplyScalar( s );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tlerp: function ( sh, alpha ) {\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < 9; i ++ ) {\\r\\n\\r\\n\\t\\t\\tthis.coefficients[ i ].lerp( sh.coefficients[ i ], alpha );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tequals: function ( sh ) {\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < 9; i ++ ) {\\r\\n\\r\\n\\t\\t\\tif ( ! this.coefficients[ i ].equals( sh.coefficients[ i ] ) ) {\\r\\n\\r\\n\\t\\t\\t\\treturn false;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn true;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcopy: function ( sh ) {\\r\\n\\r\\n\\t\\treturn this.set( sh.coefficients );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclone: function () {\\r\\n\\r\\n\\t\\treturn new this.constructor().copy( this );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tfromArray: function ( array, offset ) {\\r\\n\\r\\n\\t\\tif ( offset === undefined ) offset = 0;\\r\\n\\r\\n\\t\\tvar coefficients = this.coefficients;\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < 9; i ++ ) {\\r\\n\\r\\n\\t\\t\\tcoefficients[ i ].fromArray( array, offset + ( i * 3 ) );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttoArray: function ( array, offset ) {\\r\\n\\r\\n\\t\\tif ( array === undefined ) array = [];\\r\\n\\t\\tif ( offset === undefined ) offset = 0;\\r\\n\\r\\n\\t\\tvar coefficients = this.coefficients;\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < 9; i ++ ) {\\r\\n\\r\\n\\t\\t\\tcoefficients[ i ].toArray( array, offset + ( i * 3 ) );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn array;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nObject.assign( SphericalHarmonics3, {\\r\\n\\r\\n\\t// evaluate the basis functions\\r\\n\\t// shBasis is an Array[ 9 ]\\r\\n\\tgetBasisAt: function ( normal, shBasis ) {\\r\\n\\r\\n\\t\\t// normal is assumed to be unit length\\r\\n\\r\\n\\t\\tvar x = normal.x, y = normal.y, z = normal.z;\\r\\n\\r\\n\\t\\t// band 0\\r\\n\\t\\tshBasis[ 0 ] = 0.282095;\\r\\n\\r\\n\\t\\t// band 1\\r\\n\\t\\tshBasis[ 1 ] = 0.488603 * y;\\r\\n\\t\\tshBasis[ 2 ] = 0.488603 * z;\\r\\n\\t\\tshBasis[ 3 ] = 0.488603 * x;\\r\\n\\r\\n\\t\\t// band 2\\r\\n\\t\\tshBasis[ 4 ] = 1.092548 * x * y;\\r\\n\\t\\tshBasis[ 5 ] = 1.092548 * y * z;\\r\\n\\t\\tshBasis[ 6 ] = 0.315392 * ( 3 * z * z - 1 );\\r\\n\\t\\tshBasis[ 7 ] = 1.092548 * x * z;\\r\\n\\t\\tshBasis[ 8 ] = 0.546274 * ( x * x - y * y );\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author WestLangley / http://github.com/WestLangley\\r\\n *\\r\\n * A LightProbe is a source of indirect-diffuse light\\r\\n */\\r\\n\\r\\nfunction LightProbe( sh, intensity ) {\\r\\n\\r\\n\\tLight.call( this, undefined, intensity );\\r\\n\\r\\n\\tthis.type = 'LightProbe';\\r\\n\\r\\n\\tthis.sh = ( sh !== undefined ) ? sh : new SphericalHarmonics3();\\r\\n\\r\\n}\\r\\n\\r\\nLightProbe.prototype = Object.assign( Object.create( Light.prototype ), {\\r\\n\\r\\n\\tconstructor: LightProbe,\\r\\n\\r\\n\\tisLightProbe: true,\\r\\n\\r\\n\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\tLight.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\tthis.sh.copy( source.sh );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tfromJSON: function ( json ) {\\r\\n\\r\\n\\t\\tthis.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();\\r\\n\\t\\tthis.sh.fromArray( json.sh );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttoJSON: function ( meta ) {\\r\\n\\r\\n\\t\\tvar data = Light.prototype.toJSON.call( this, meta );\\r\\n\\r\\n\\t\\tdata.object.sh = this.sh.toArray();\\r\\n\\r\\n\\t\\treturn data;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nfunction MaterialLoader( manager ) {\\r\\n\\r\\n\\tLoader.call( this, manager );\\r\\n\\r\\n\\tthis.textures = {};\\r\\n\\r\\n}\\r\\n\\r\\nMaterialLoader.prototype = Object.assign( Object.create( Loader.prototype ), {\\r\\n\\r\\n\\tconstructor: MaterialLoader,\\r\\n\\r\\n\\tload: function ( url, onLoad, onProgress, onError ) {\\r\\n\\r\\n\\t\\tvar scope = this;\\r\\n\\r\\n\\t\\tvar loader = new FileLoader( scope.manager );\\r\\n\\t\\tloader.setPath( scope.path );\\r\\n\\t\\tloader.load( url, function ( text ) {\\r\\n\\r\\n\\t\\t\\ttry {\\r\\n\\r\\n\\t\\t\\t\\tonLoad( scope.parse( JSON.parse( text ) ) );\\r\\n\\r\\n\\t\\t\\t} catch ( e ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( onError ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tonError( e );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.error( e );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tscope.manager.itemError( url );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}, onProgress, onError );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tparse: function ( json ) {\\r\\n\\r\\n\\t\\tvar textures = this.textures;\\r\\n\\r\\n\\t\\tfunction getTexture( name ) {\\r\\n\\r\\n\\t\\t\\tif ( textures[ name ] === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.MaterialLoader: Undefined texture', name );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn textures[ name ];\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar material = new Materials[ json.type ]();\\r\\n\\r\\n\\t\\tif ( json.uuid !== undefined ) material.uuid = json.uuid;\\r\\n\\t\\tif ( json.name !== undefined ) material.name = json.name;\\r\\n\\t\\tif ( json.color !== undefined ) material.color.setHex( json.color );\\r\\n\\t\\tif ( json.roughness !== undefined ) material.roughness = json.roughness;\\r\\n\\t\\tif ( json.metalness !== undefined ) material.metalness = json.metalness;\\r\\n\\t\\tif ( json.sheen !== undefined ) material.sheen = new Color().setHex( json.sheen );\\r\\n\\t\\tif ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );\\r\\n\\t\\tif ( json.specular !== undefined ) material.specular.setHex( json.specular );\\r\\n\\t\\tif ( json.shininess !== undefined ) material.shininess = json.shininess;\\r\\n\\t\\tif ( json.clearcoat !== undefined ) material.clearcoat = json.clearcoat;\\r\\n\\t\\tif ( json.clearcoatRoughness !== undefined ) material.clearcoatRoughness = json.clearcoatRoughness;\\r\\n\\t\\tif ( json.fog !== undefined ) material.fog = json.fog;\\r\\n\\t\\tif ( json.flatShading !== undefined ) material.flatShading = json.flatShading;\\r\\n\\t\\tif ( json.blending !== undefined ) material.blending = json.blending;\\r\\n\\t\\tif ( json.combine !== undefined ) material.combine = json.combine;\\r\\n\\t\\tif ( json.side !== undefined ) material.side = json.side;\\r\\n\\t\\tif ( json.opacity !== undefined ) material.opacity = json.opacity;\\r\\n\\t\\tif ( json.transparent !== undefined ) material.transparent = json.transparent;\\r\\n\\t\\tif ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;\\r\\n\\t\\tif ( json.depthTest !== undefined ) material.depthTest = json.depthTest;\\r\\n\\t\\tif ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;\\r\\n\\t\\tif ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;\\r\\n\\r\\n\\t\\tif ( json.stencilWrite !== undefined ) material.stencilWrite = json.stencilWrite;\\r\\n\\t\\tif ( json.stencilWriteMask !== undefined ) material.stencilWriteMask = json.stencilWriteMask;\\r\\n\\t\\tif ( json.stencilFunc !== undefined ) material.stencilFunc = json.stencilFunc;\\r\\n\\t\\tif ( json.stencilRef !== undefined ) material.stencilRef = json.stencilRef;\\r\\n\\t\\tif ( json.stencilFuncMask !== undefined ) material.stencilFuncMask = json.stencilFuncMask;\\r\\n\\t\\tif ( json.stencilFail !== undefined ) material.stencilFail = json.stencilFail;\\r\\n\\t\\tif ( json.stencilZFail !== undefined ) material.stencilZFail = json.stencilZFail;\\r\\n\\t\\tif ( json.stencilZPass !== undefined ) material.stencilZPass = json.stencilZPass;\\r\\n\\r\\n\\t\\tif ( json.wireframe !== undefined ) material.wireframe = json.wireframe;\\r\\n\\t\\tif ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;\\r\\n\\t\\tif ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;\\r\\n\\t\\tif ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;\\r\\n\\r\\n\\t\\tif ( json.rotation !== undefined ) material.rotation = json.rotation;\\r\\n\\r\\n\\t\\tif ( json.linewidth !== 1 ) material.linewidth = json.linewidth;\\r\\n\\t\\tif ( json.dashSize !== undefined ) material.dashSize = json.dashSize;\\r\\n\\t\\tif ( json.gapSize !== undefined ) material.gapSize = json.gapSize;\\r\\n\\t\\tif ( json.scale !== undefined ) material.scale = json.scale;\\r\\n\\r\\n\\t\\tif ( json.polygonOffset !== undefined ) material.polygonOffset = json.polygonOffset;\\r\\n\\t\\tif ( json.polygonOffsetFactor !== undefined ) material.polygonOffsetFactor = json.polygonOffsetFactor;\\r\\n\\t\\tif ( json.polygonOffsetUnits !== undefined ) material.polygonOffsetUnits = json.polygonOffsetUnits;\\r\\n\\r\\n\\t\\tif ( json.skinning !== undefined ) material.skinning = json.skinning;\\r\\n\\t\\tif ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;\\r\\n\\t\\tif ( json.morphNormals !== undefined ) material.morphNormals = json.morphNormals;\\r\\n\\t\\tif ( json.dithering !== undefined ) material.dithering = json.dithering;\\r\\n\\r\\n\\t\\tif ( json.vertexTangents !== undefined ) material.vertexTangents = json.vertexTangents;\\r\\n\\r\\n\\t\\tif ( json.visible !== undefined ) material.visible = json.visible;\\r\\n\\r\\n\\t\\tif ( json.toneMapped !== undefined ) material.toneMapped = json.toneMapped;\\r\\n\\r\\n\\t\\tif ( json.userData !== undefined ) material.userData = json.userData;\\r\\n\\r\\n\\t\\tif ( json.vertexColors !== undefined ) {\\r\\n\\r\\n\\t\\t\\tif ( typeof json.vertexColors === 'number' ) {\\r\\n\\r\\n\\t\\t\\t\\tmaterial.vertexColors = ( json.vertexColors > 0 ) ? true : false;\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tmaterial.vertexColors = json.vertexColors;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Shader Material\\r\\n\\r\\n\\t\\tif ( json.uniforms !== undefined ) {\\r\\n\\r\\n\\t\\t\\tfor ( var name in json.uniforms ) {\\r\\n\\r\\n\\t\\t\\t\\tvar uniform = json.uniforms[ name ];\\r\\n\\r\\n\\t\\t\\t\\tmaterial.uniforms[ name ] = {};\\r\\n\\r\\n\\t\\t\\t\\tswitch ( uniform.type ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 't':\\r\\n\\t\\t\\t\\t\\t\\tmaterial.uniforms[ name ].value = getTexture( uniform.value );\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'c':\\r\\n\\t\\t\\t\\t\\t\\tmaterial.uniforms[ name ].value = new Color().setHex( uniform.value );\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'v2':\\r\\n\\t\\t\\t\\t\\t\\tmaterial.uniforms[ name ].value = new Vector2().fromArray( uniform.value );\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'v3':\\r\\n\\t\\t\\t\\t\\t\\tmaterial.uniforms[ name ].value = new Vector3().fromArray( uniform.value );\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'v4':\\r\\n\\t\\t\\t\\t\\t\\tmaterial.uniforms[ name ].value = new Vector4().fromArray( uniform.value );\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'm3':\\r\\n\\t\\t\\t\\t\\t\\tmaterial.uniforms[ name ].value = new Matrix3().fromArray( uniform.value );\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'm4':\\r\\n\\t\\t\\t\\t\\t\\tmaterial.uniforms[ name ].value = new Matrix4().fromArray( uniform.value );\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tdefault:\\r\\n\\t\\t\\t\\t\\t\\tmaterial.uniforms[ name ].value = uniform.value;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( json.defines !== undefined ) material.defines = json.defines;\\r\\n\\t\\tif ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;\\r\\n\\t\\tif ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;\\r\\n\\r\\n\\t\\tif ( json.extensions !== undefined ) {\\r\\n\\r\\n\\t\\t\\tfor ( var key in json.extensions ) {\\r\\n\\r\\n\\t\\t\\t\\tmaterial.extensions[ key ] = json.extensions[ key ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Deprecated\\r\\n\\r\\n\\t\\tif ( json.shading !== undefined ) material.flatShading = json.shading === 1; // THREE.FlatShading\\r\\n\\r\\n\\t\\t// for PointsMaterial\\r\\n\\r\\n\\t\\tif ( json.size !== undefined ) material.size = json.size;\\r\\n\\t\\tif ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;\\r\\n\\r\\n\\t\\t// maps\\r\\n\\r\\n\\t\\tif ( json.map !== undefined ) material.map = getTexture( json.map );\\r\\n\\t\\tif ( json.matcap !== undefined ) material.matcap = getTexture( json.matcap );\\r\\n\\r\\n\\t\\tif ( json.alphaMap !== undefined ) material.alphaMap = getTexture( json.alphaMap );\\r\\n\\r\\n\\t\\tif ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );\\r\\n\\t\\tif ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;\\r\\n\\r\\n\\t\\tif ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );\\r\\n\\t\\tif ( json.normalMapType !== undefined ) material.normalMapType = json.normalMapType;\\r\\n\\t\\tif ( json.normalScale !== undefined ) {\\r\\n\\r\\n\\t\\t\\tvar normalScale = json.normalScale;\\r\\n\\r\\n\\t\\t\\tif ( Array.isArray( normalScale ) === false ) {\\r\\n\\r\\n\\t\\t\\t\\t// Blender exporter used to export a scalar. See #7459\\r\\n\\r\\n\\t\\t\\t\\tnormalScale = [ normalScale, normalScale ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tmaterial.normalScale = new Vector2().fromArray( normalScale );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );\\r\\n\\t\\tif ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;\\r\\n\\t\\tif ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;\\r\\n\\r\\n\\t\\tif ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );\\r\\n\\t\\tif ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );\\r\\n\\r\\n\\t\\tif ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );\\r\\n\\t\\tif ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;\\r\\n\\r\\n\\t\\tif ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );\\r\\n\\r\\n\\t\\tif ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );\\r\\n\\t\\tif ( json.envMapIntensity !== undefined ) material.envMapIntensity = json.envMapIntensity;\\r\\n\\r\\n\\t\\tif ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;\\r\\n\\t\\tif ( json.refractionRatio !== undefined ) material.refractionRatio = json.refractionRatio;\\r\\n\\r\\n\\t\\tif ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );\\r\\n\\t\\tif ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;\\r\\n\\r\\n\\t\\tif ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );\\r\\n\\t\\tif ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;\\r\\n\\r\\n\\t\\tif ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );\\r\\n\\r\\n\\t\\tif ( json.clearcoatMap !== undefined ) material.clearcoatMap = getTexture( json.clearcoatMap );\\r\\n\\t\\tif ( json.clearcoatRoughnessMap !== undefined ) material.clearcoatRoughnessMap = getTexture( json.clearcoatRoughnessMap );\\r\\n\\t\\tif ( json.clearcoatNormalMap !== undefined ) material.clearcoatNormalMap = getTexture( json.clearcoatNormalMap );\\r\\n\\t\\tif ( json.clearcoatNormalScale !== undefined ) material.clearcoatNormalScale = new Vector2().fromArray( json.clearcoatNormalScale );\\r\\n\\r\\n\\t\\treturn material;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetTextures: function ( value ) {\\r\\n\\r\\n\\t\\tthis.textures = value;\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author Don McCurdy / https://www.donmccurdy.com\\r\\n */\\r\\n\\r\\nvar LoaderUtils = {\\r\\n\\r\\n\\tdecodeText: function ( array ) {\\r\\n\\r\\n\\t\\tif ( typeof TextDecoder !== 'undefined' ) {\\r\\n\\r\\n\\t\\t\\treturn new TextDecoder().decode( array );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Avoid the String.fromCharCode.apply(null, array) shortcut, which\\r\\n\\t\\t// throws a \\\"maximum call stack size exceeded\\\" error for large arrays.\\r\\n\\r\\n\\t\\tvar s = '';\\r\\n\\r\\n\\t\\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t// Implicitly assumes little-endian.\\r\\n\\t\\t\\ts += String.fromCharCode( array[ i ] );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\ttry {\\r\\n\\r\\n\\t\\t\\t// merges multi-byte utf-8 characters.\\r\\n\\r\\n\\t\\t\\treturn decodeURIComponent( escape( s ) );\\r\\n\\r\\n\\t\\t} catch ( e ) { // see #16358\\r\\n\\r\\n\\t\\t\\treturn s;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\textractUrlBase: function ( url ) {\\r\\n\\r\\n\\t\\tvar index = url.lastIndexOf( '/' );\\r\\n\\r\\n\\t\\tif ( index === - 1 ) return './';\\r\\n\\r\\n\\t\\treturn url.substr( 0, index + 1 );\\r\\n\\r\\n\\t}\\r\\n\\r\\n};\\r\\n\\r\\n/**\\r\\n * @author benaadams / https://twitter.com/ben_a_adams\\r\\n */\\r\\n\\r\\nfunction InstancedBufferGeometry() {\\r\\n\\r\\n\\tBufferGeometry.call( this );\\r\\n\\r\\n\\tthis.type = 'InstancedBufferGeometry';\\r\\n\\tthis.instanceCount = Infinity;\\r\\n\\r\\n}\\r\\n\\r\\nInstancedBufferGeometry.prototype = Object.assign( Object.create( BufferGeometry.prototype ), {\\r\\n\\r\\n\\tconstructor: InstancedBufferGeometry,\\r\\n\\r\\n\\tisInstancedBufferGeometry: true,\\r\\n\\r\\n\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\tBufferGeometry.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\tthis.instanceCount = source.instanceCount;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclone: function () {\\r\\n\\r\\n\\t\\treturn new this.constructor().copy( this );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttoJSON: function () {\\r\\n\\r\\n\\t\\tvar data = BufferGeometry.prototype.toJSON.call( this );\\r\\n\\r\\n\\t\\tdata.instanceCount = this.instanceCount;\\r\\n\\r\\n\\t\\tdata.isInstancedBufferGeometry = true;\\r\\n\\r\\n\\t\\treturn data;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author benaadams / https://twitter.com/ben_a_adams\\r\\n */\\r\\n\\r\\nfunction InstancedBufferAttribute( array, itemSize, normalized, meshPerAttribute ) {\\r\\n\\r\\n\\tif ( typeof ( normalized ) === 'number' ) {\\r\\n\\r\\n\\t\\tmeshPerAttribute = normalized;\\r\\n\\r\\n\\t\\tnormalized = false;\\r\\n\\r\\n\\t\\tconsole.error( 'THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.' );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tBufferAttribute.call( this, array, itemSize, normalized );\\r\\n\\r\\n\\tthis.meshPerAttribute = meshPerAttribute || 1;\\r\\n\\r\\n}\\r\\n\\r\\nInstancedBufferAttribute.prototype = Object.assign( Object.create( BufferAttribute.prototype ), {\\r\\n\\r\\n\\tconstructor: InstancedBufferAttribute,\\r\\n\\r\\n\\tisInstancedBufferAttribute: true,\\r\\n\\r\\n\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\tBufferAttribute.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\tthis.meshPerAttribute = source.meshPerAttribute;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttoJSON: function ()\\t{\\r\\n\\r\\n\\t\\tvar data = BufferAttribute.prototype.toJSON.call( this );\\r\\n\\r\\n\\t\\tdata.meshPerAttribute = this.meshPerAttribute;\\r\\n\\r\\n\\t\\tdata.isInstancedBufferAttribute = true;\\r\\n\\r\\n\\t\\treturn data;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nfunction BufferGeometryLoader( manager ) {\\r\\n\\r\\n\\tLoader.call( this, manager );\\r\\n\\r\\n}\\r\\n\\r\\nBufferGeometryLoader.prototype = Object.assign( Object.create( Loader.prototype ), {\\r\\n\\r\\n\\tconstructor: BufferGeometryLoader,\\r\\n\\r\\n\\tload: function ( url, onLoad, onProgress, onError ) {\\r\\n\\r\\n\\t\\tvar scope = this;\\r\\n\\r\\n\\t\\tvar loader = new FileLoader( scope.manager );\\r\\n\\t\\tloader.setPath( scope.path );\\r\\n\\t\\tloader.load( url, function ( text ) {\\r\\n\\r\\n\\t\\t\\ttry {\\r\\n\\r\\n\\t\\t\\t\\tonLoad( scope.parse( JSON.parse( text ) ) );\\r\\n\\r\\n\\t\\t\\t} catch ( e ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( onError ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tonError( e );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.error( e );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tscope.manager.itemError( url );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}, onProgress, onError );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tparse: function ( json ) {\\r\\n\\r\\n\\t\\tvar geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();\\r\\n\\r\\n\\t\\tvar index = json.data.index;\\r\\n\\r\\n\\t\\tif ( index !== undefined ) {\\r\\n\\r\\n\\t\\t\\tvar typedArray = new TYPED_ARRAYS[ index.type ]( index.array );\\r\\n\\t\\t\\tgeometry.setIndex( new BufferAttribute( typedArray, 1 ) );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar attributes = json.data.attributes;\\r\\n\\r\\n\\t\\tfor ( var key in attributes ) {\\r\\n\\r\\n\\t\\t\\tvar attribute = attributes[ key ];\\r\\n\\t\\t\\tvar typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );\\r\\n\\t\\t\\tvar bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;\\r\\n\\t\\t\\tvar bufferAttribute = new bufferAttributeConstr( typedArray, attribute.itemSize, attribute.normalized );\\r\\n\\t\\t\\tif ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;\\r\\n\\t\\t\\tgeometry.setAttribute( key, bufferAttribute );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar morphAttributes = json.data.morphAttributes;\\r\\n\\r\\n\\t\\tif ( morphAttributes ) {\\r\\n\\r\\n\\t\\t\\tfor ( var key in morphAttributes ) {\\r\\n\\r\\n\\t\\t\\t\\tvar attributeArray = morphAttributes[ key ];\\r\\n\\r\\n\\t\\t\\t\\tvar array = [];\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, il = attributeArray.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar attribute = attributeArray[ i ];\\r\\n\\t\\t\\t\\t\\tvar typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );\\r\\n\\r\\n\\t\\t\\t\\t\\tvar bufferAttribute = new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized );\\r\\n\\t\\t\\t\\t\\tif ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;\\r\\n\\t\\t\\t\\t\\tarray.push( bufferAttribute );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tgeometry.morphAttributes[ key ] = array;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar morphTargetsRelative = json.data.morphTargetsRelative;\\r\\n\\r\\n\\t\\tif ( morphTargetsRelative ) {\\r\\n\\r\\n\\t\\t\\tgeometry.morphTargetsRelative = true;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar groups = json.data.groups || json.data.drawcalls || json.data.offsets;\\r\\n\\r\\n\\t\\tif ( groups !== undefined ) {\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, n = groups.length; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\tvar group = groups[ i ];\\r\\n\\r\\n\\t\\t\\t\\tgeometry.addGroup( group.start, group.count, group.materialIndex );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar boundingSphere = json.data.boundingSphere;\\r\\n\\r\\n\\t\\tif ( boundingSphere !== undefined ) {\\r\\n\\r\\n\\t\\t\\tvar center = new Vector3();\\r\\n\\r\\n\\t\\t\\tif ( boundingSphere.center !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tcenter.fromArray( boundingSphere.center );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tgeometry.boundingSphere = new Sphere( center, boundingSphere.radius );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( json.name ) geometry.name = json.name;\\r\\n\\t\\tif ( json.userData ) geometry.userData = json.userData;\\r\\n\\r\\n\\t\\treturn geometry;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nvar TYPED_ARRAYS = {\\r\\n\\tInt8Array: Int8Array,\\r\\n\\tUint8Array: Uint8Array,\\r\\n\\t// Workaround for IE11 pre KB2929437. See #11440\\r\\n\\tUint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array,\\r\\n\\tInt16Array: Int16Array,\\r\\n\\tUint16Array: Uint16Array,\\r\\n\\tInt32Array: Int32Array,\\r\\n\\tUint32Array: Uint32Array,\\r\\n\\tFloat32Array: Float32Array,\\r\\n\\tFloat64Array: Float64Array\\r\\n};\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nfunction ObjectLoader( manager ) {\\r\\n\\r\\n\\tLoader.call( this, manager );\\r\\n\\r\\n}\\r\\n\\r\\nObjectLoader.prototype = Object.assign( Object.create( Loader.prototype ), {\\r\\n\\r\\n\\tconstructor: ObjectLoader,\\r\\n\\r\\n\\tload: function ( url, onLoad, onProgress, onError ) {\\r\\n\\r\\n\\t\\tvar scope = this;\\r\\n\\r\\n\\t\\tvar path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;\\r\\n\\t\\tthis.resourcePath = this.resourcePath || path;\\r\\n\\r\\n\\t\\tvar loader = new FileLoader( scope.manager );\\r\\n\\t\\tloader.setPath( this.path );\\r\\n\\t\\tloader.load( url, function ( text ) {\\r\\n\\r\\n\\t\\t\\tvar json = null;\\r\\n\\r\\n\\t\\t\\ttry {\\r\\n\\r\\n\\t\\t\\t\\tjson = JSON.parse( text );\\r\\n\\r\\n\\t\\t\\t} catch ( error ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( onError !== undefined ) onError( error );\\r\\n\\r\\n\\t\\t\\t\\tconsole.error( 'THREE:ObjectLoader: Can\\\\'t parse ' + url + '.', error.message );\\r\\n\\r\\n\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar metadata = json.metadata;\\r\\n\\r\\n\\t\\t\\tif ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.error( 'THREE.ObjectLoader: Can\\\\'t load ' + url );\\r\\n\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tscope.parse( json, onLoad );\\r\\n\\r\\n\\t\\t}, onProgress, onError );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tparse: function ( json, onLoad ) {\\r\\n\\r\\n\\t\\tvar shapes = this.parseShape( json.shapes );\\r\\n\\t\\tvar geometries = this.parseGeometries( json.geometries, shapes );\\r\\n\\r\\n\\t\\tvar images = this.parseImages( json.images, function () {\\r\\n\\r\\n\\t\\t\\tif ( onLoad !== undefined ) onLoad( object );\\r\\n\\r\\n\\t\\t} );\\r\\n\\r\\n\\t\\tvar textures = this.parseTextures( json.textures, images );\\r\\n\\t\\tvar materials = this.parseMaterials( json.materials, textures );\\r\\n\\r\\n\\t\\tvar object = this.parseObject( json.object, geometries, materials );\\r\\n\\r\\n\\t\\tif ( json.animations ) {\\r\\n\\r\\n\\t\\t\\tobject.animations = this.parseAnimations( json.animations );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( json.images === undefined || json.images.length === 0 ) {\\r\\n\\r\\n\\t\\t\\tif ( onLoad !== undefined ) onLoad( object );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn object;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tparseShape: function ( json ) {\\r\\n\\r\\n\\t\\tvar shapes = {};\\r\\n\\r\\n\\t\\tif ( json !== undefined ) {\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar shape = new Shape().fromJSON( json[ i ] );\\r\\n\\r\\n\\t\\t\\t\\tshapes[ shape.uuid ] = shape;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn shapes;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tparseGeometries: function ( json, shapes ) {\\r\\n\\r\\n\\t\\tvar geometries = {};\\r\\n\\r\\n\\t\\tif ( json !== undefined ) {\\r\\n\\r\\n\\t\\t\\tvar bufferGeometryLoader = new BufferGeometryLoader();\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar geometry;\\r\\n\\t\\t\\t\\tvar data = json[ i ];\\r\\n\\r\\n\\t\\t\\t\\tswitch ( data.type ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'PlaneGeometry':\\r\\n\\t\\t\\t\\t\\tcase 'PlaneBufferGeometry':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.width,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.height,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.widthSegments,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.heightSegments\\r\\n\\t\\t\\t\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'BoxGeometry':\\r\\n\\t\\t\\t\\t\\tcase 'BoxBufferGeometry':\\r\\n\\t\\t\\t\\t\\tcase 'CubeGeometry': // backwards compatible\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.width,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.height,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.depth,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.widthSegments,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.heightSegments,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.depthSegments\\r\\n\\t\\t\\t\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'CircleGeometry':\\r\\n\\t\\t\\t\\t\\tcase 'CircleBufferGeometry':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.radius,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.segments,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.thetaStart,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.thetaLength\\r\\n\\t\\t\\t\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'CylinderGeometry':\\r\\n\\t\\t\\t\\t\\tcase 'CylinderBufferGeometry':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.radiusTop,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.radiusBottom,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.height,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.radialSegments,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.heightSegments,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.openEnded,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.thetaStart,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.thetaLength\\r\\n\\t\\t\\t\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'ConeGeometry':\\r\\n\\t\\t\\t\\t\\tcase 'ConeBufferGeometry':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.radius,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.height,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.radialSegments,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.heightSegments,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.openEnded,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.thetaStart,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.thetaLength\\r\\n\\t\\t\\t\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'SphereGeometry':\\r\\n\\t\\t\\t\\t\\tcase 'SphereBufferGeometry':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.radius,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.widthSegments,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.heightSegments,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.phiStart,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.phiLength,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.thetaStart,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.thetaLength\\r\\n\\t\\t\\t\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'DodecahedronGeometry':\\r\\n\\t\\t\\t\\t\\tcase 'DodecahedronBufferGeometry':\\r\\n\\t\\t\\t\\t\\tcase 'IcosahedronGeometry':\\r\\n\\t\\t\\t\\t\\tcase 'IcosahedronBufferGeometry':\\r\\n\\t\\t\\t\\t\\tcase 'OctahedronGeometry':\\r\\n\\t\\t\\t\\t\\tcase 'OctahedronBufferGeometry':\\r\\n\\t\\t\\t\\t\\tcase 'TetrahedronGeometry':\\r\\n\\t\\t\\t\\t\\tcase 'TetrahedronBufferGeometry':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.radius,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.detail\\r\\n\\t\\t\\t\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'RingGeometry':\\r\\n\\t\\t\\t\\t\\tcase 'RingBufferGeometry':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.innerRadius,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.outerRadius,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.thetaSegments,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.phiSegments,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.thetaStart,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.thetaLength\\r\\n\\t\\t\\t\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'TorusGeometry':\\r\\n\\t\\t\\t\\t\\tcase 'TorusBufferGeometry':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.radius,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.tube,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.radialSegments,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.tubularSegments,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.arc\\r\\n\\t\\t\\t\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'TorusKnotGeometry':\\r\\n\\t\\t\\t\\t\\tcase 'TorusKnotBufferGeometry':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.radius,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.tube,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.tubularSegments,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.radialSegments,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.p,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.q\\r\\n\\t\\t\\t\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'TubeGeometry':\\r\\n\\t\\t\\t\\t\\tcase 'TubeBufferGeometry':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// This only works for built-in curves (e.g. CatmullRomCurve3).\\r\\n\\t\\t\\t\\t\\t\\t// User defined curves or instances of CurvePath will not be deserialized.\\r\\n\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\r\\n\\t\\t\\t\\t\\t\\t\\tnew Curves[ data.path.type ]().fromJSON( data.path ),\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.tubularSegments,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.radius,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.radialSegments,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.closed\\r\\n\\t\\t\\t\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'LatheGeometry':\\r\\n\\t\\t\\t\\t\\tcase 'LatheBufferGeometry':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.points,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.segments,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.phiStart,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.phiLength\\r\\n\\t\\t\\t\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'PolyhedronGeometry':\\r\\n\\t\\t\\t\\t\\tcase 'PolyhedronBufferGeometry':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.vertices,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.indices,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.radius,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.details\\r\\n\\t\\t\\t\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'ShapeGeometry':\\r\\n\\t\\t\\t\\t\\tcase 'ShapeBufferGeometry':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar geometryShapes = [];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tfor ( var j = 0, jl = data.shapes.length; j < jl; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tvar shape = shapes[ data.shapes[ j ] ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tgeometryShapes.push( shape );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\r\\n\\t\\t\\t\\t\\t\\t\\tgeometryShapes,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.curveSegments\\r\\n\\t\\t\\t\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'ExtrudeGeometry':\\r\\n\\t\\t\\t\\t\\tcase 'ExtrudeBufferGeometry':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar geometryShapes = [];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tfor ( var j = 0, jl = data.shapes.length; j < jl; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tvar shape = shapes[ data.shapes[ j ] ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tgeometryShapes.push( shape );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar extrudePath = data.options.extrudePath;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( extrudePath !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.options.extrudePath = new Curves[ extrudePath.type ]().fromJSON( extrudePath );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\r\\n\\t\\t\\t\\t\\t\\t\\tgeometryShapes,\\r\\n\\t\\t\\t\\t\\t\\t\\tdata.options\\r\\n\\t\\t\\t\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'BufferGeometry':\\r\\n\\t\\t\\t\\t\\tcase 'InstancedBufferGeometry':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tgeometry = bufferGeometryLoader.parse( data );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tcase 'Geometry':\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.ObjectLoader: Loading \\\"Geometry\\\" is not supported anymore.' );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\tdefault:\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.ObjectLoader: Unsupported geometry type \\\"' + data.type + '\\\"' );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tcontinue;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tgeometry.uuid = data.uuid;\\r\\n\\r\\n\\t\\t\\t\\tif ( data.name !== undefined ) geometry.name = data.name;\\r\\n\\t\\t\\t\\tif ( geometry.isBufferGeometry === true && data.userData !== undefined ) geometry.userData = data.userData;\\r\\n\\r\\n\\t\\t\\t\\tgeometries[ data.uuid ] = geometry;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn geometries;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tparseMaterials: function ( json, textures ) {\\r\\n\\r\\n\\t\\tvar cache = {}; // MultiMaterial\\r\\n\\t\\tvar materials = {};\\r\\n\\r\\n\\t\\tif ( json !== undefined ) {\\r\\n\\r\\n\\t\\t\\tvar loader = new MaterialLoader();\\r\\n\\t\\t\\tloader.setTextures( textures );\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar data = json[ i ];\\r\\n\\r\\n\\t\\t\\t\\tif ( data.type === 'MultiMaterial' ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// Deprecated\\r\\n\\r\\n\\t\\t\\t\\t\\tvar array = [];\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var j = 0; j < data.materials.length; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar material = data.materials[ j ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( cache[ material.uuid ] === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tcache[ material.uuid ] = loader.parse( material );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tarray.push( cache[ material.uuid ] );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tmaterials[ data.uuid ] = array;\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( cache[ data.uuid ] === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tcache[ data.uuid ] = loader.parse( data );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tmaterials[ data.uuid ] = cache[ data.uuid ];\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn materials;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tparseAnimations: function ( json ) {\\r\\n\\r\\n\\t\\tvar animations = [];\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < json.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar data = json[ i ];\\r\\n\\r\\n\\t\\t\\tvar clip = AnimationClip.parse( data );\\r\\n\\r\\n\\t\\t\\tif ( data.uuid !== undefined ) clip.uuid = data.uuid;\\r\\n\\r\\n\\t\\t\\tanimations.push( clip );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn animations;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tparseImages: function ( json, onLoad ) {\\r\\n\\r\\n\\t\\tvar scope = this;\\r\\n\\t\\tvar images = {};\\r\\n\\r\\n\\t\\tfunction loadImage( url ) {\\r\\n\\r\\n\\t\\t\\tscope.manager.itemStart( url );\\r\\n\\r\\n\\t\\t\\treturn loader.load( url, function () {\\r\\n\\r\\n\\t\\t\\t\\tscope.manager.itemEnd( url );\\r\\n\\r\\n\\t\\t\\t}, undefined, function () {\\r\\n\\r\\n\\t\\t\\t\\tscope.manager.itemError( url );\\r\\n\\t\\t\\t\\tscope.manager.itemEnd( url );\\r\\n\\r\\n\\t\\t\\t} );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( json !== undefined && json.length > 0 ) {\\r\\n\\r\\n\\t\\t\\tvar manager = new LoadingManager( onLoad );\\r\\n\\r\\n\\t\\t\\tvar loader = new ImageLoader( manager );\\r\\n\\t\\t\\tloader.setCrossOrigin( this.crossOrigin );\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, il = json.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar image = json[ i ];\\r\\n\\t\\t\\t\\tvar url = image.url;\\r\\n\\r\\n\\t\\t\\t\\tif ( Array.isArray( url ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// load array of images e.g CubeTexture\\r\\n\\r\\n\\t\\t\\t\\t\\timages[ image.uuid ] = [];\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var j = 0, jl = url.length; j < jl; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar currentUrl = url[ j ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar path = /^(\\\\/\\\\/)|([a-z]+:(\\\\/\\\\/)?)/i.test( currentUrl ) ? currentUrl : scope.resourcePath + currentUrl;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\timages[ image.uuid ].push( loadImage( path ) );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t// load single image\\r\\n\\r\\n\\t\\t\\t\\t\\tvar path = /^(\\\\/\\\\/)|([a-z]+:(\\\\/\\\\/)?)/i.test( image.url ) ? image.url : scope.resourcePath + image.url;\\r\\n\\r\\n\\t\\t\\t\\t\\timages[ image.uuid ] = loadImage( path );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn images;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tparseTextures: function ( json, images ) {\\r\\n\\r\\n\\t\\tfunction parseConstant( value, type ) {\\r\\n\\r\\n\\t\\t\\tif ( typeof value === 'number' ) return value;\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );\\r\\n\\r\\n\\t\\t\\treturn type[ value ];\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar textures = {};\\r\\n\\r\\n\\t\\tif ( json !== undefined ) {\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar data = json[ i ];\\r\\n\\r\\n\\t\\t\\t\\tif ( data.image === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.ObjectLoader: No \\\"image\\\" specified for', data.uuid );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( images[ data.image ] === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.ObjectLoader: Undefined image', data.image );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tvar texture;\\r\\n\\r\\n\\t\\t\\t\\tif ( Array.isArray( images[ data.image ] ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\ttexture = new CubeTexture( images[ data.image ] );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\ttexture = new Texture( images[ data.image ] );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\ttexture.needsUpdate = true;\\r\\n\\r\\n\\t\\t\\t\\ttexture.uuid = data.uuid;\\r\\n\\r\\n\\t\\t\\t\\tif ( data.name !== undefined ) texture.name = data.name;\\r\\n\\r\\n\\t\\t\\t\\tif ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING );\\r\\n\\r\\n\\t\\t\\t\\tif ( data.offset !== undefined ) texture.offset.fromArray( data.offset );\\r\\n\\t\\t\\t\\tif ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );\\r\\n\\t\\t\\t\\tif ( data.center !== undefined ) texture.center.fromArray( data.center );\\r\\n\\t\\t\\t\\tif ( data.rotation !== undefined ) texture.rotation = data.rotation;\\r\\n\\r\\n\\t\\t\\t\\tif ( data.wrap !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\ttexture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );\\r\\n\\t\\t\\t\\t\\ttexture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( data.format !== undefined ) texture.format = data.format;\\r\\n\\t\\t\\t\\tif ( data.type !== undefined ) texture.type = data.type;\\r\\n\\t\\t\\t\\tif ( data.encoding !== undefined ) texture.encoding = data.encoding;\\r\\n\\r\\n\\t\\t\\t\\tif ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER );\\r\\n\\t\\t\\t\\tif ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER );\\r\\n\\t\\t\\t\\tif ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;\\r\\n\\r\\n\\t\\t\\t\\tif ( data.flipY !== undefined ) texture.flipY = data.flipY;\\r\\n\\r\\n\\t\\t\\t\\tif ( data.premultiplyAlpha !== undefined ) texture.premultiplyAlpha = data.premultiplyAlpha;\\r\\n\\t\\t\\t\\tif ( data.unpackAlignment !== undefined ) texture.unpackAlignment = data.unpackAlignment;\\r\\n\\r\\n\\t\\t\\t\\ttextures[ data.uuid ] = texture;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn textures;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tparseObject: function ( data, geometries, materials ) {\\r\\n\\r\\n\\t\\tvar object;\\r\\n\\r\\n\\t\\tfunction getGeometry( name ) {\\r\\n\\r\\n\\t\\t\\tif ( geometries[ name ] === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.ObjectLoader: Undefined geometry', name );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn geometries[ name ];\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction getMaterial( name ) {\\r\\n\\r\\n\\t\\t\\tif ( name === undefined ) return undefined;\\r\\n\\r\\n\\t\\t\\tif ( Array.isArray( name ) ) {\\r\\n\\r\\n\\t\\t\\t\\tvar array = [];\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, l = name.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar uuid = name[ i ];\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( materials[ uuid ] === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.ObjectLoader: Undefined material', uuid );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tarray.push( materials[ uuid ] );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\treturn array;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( materials[ name ] === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.ObjectLoader: Undefined material', name );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn materials[ name ];\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tswitch ( data.type ) {\\r\\n\\r\\n\\t\\t\\tcase 'Scene':\\r\\n\\r\\n\\t\\t\\t\\tobject = new Scene();\\r\\n\\r\\n\\t\\t\\t\\tif ( data.background !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( Number.isInteger( data.background ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tobject.background = new Color( data.background );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( data.fog !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( data.fog.type === 'Fog' ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tobject.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );\\r\\n\\r\\n\\t\\t\\t\\t\\t} else if ( data.fog.type === 'FogExp2' ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tobject.fog = new FogExp2( data.fog.color, data.fog.density );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tcase 'PerspectiveCamera':\\r\\n\\r\\n\\t\\t\\t\\tobject = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );\\r\\n\\r\\n\\t\\t\\t\\tif ( data.focus !== undefined ) object.focus = data.focus;\\r\\n\\t\\t\\t\\tif ( data.zoom !== undefined ) object.zoom = data.zoom;\\r\\n\\t\\t\\t\\tif ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;\\r\\n\\t\\t\\t\\tif ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;\\r\\n\\t\\t\\t\\tif ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\\r\\n\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tcase 'OrthographicCamera':\\r\\n\\r\\n\\t\\t\\t\\tobject = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\\r\\n\\r\\n\\t\\t\\t\\tif ( data.zoom !== undefined ) object.zoom = data.zoom;\\r\\n\\t\\t\\t\\tif ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\\r\\n\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tcase 'AmbientLight':\\r\\n\\r\\n\\t\\t\\t\\tobject = new AmbientLight( data.color, data.intensity );\\r\\n\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tcase 'DirectionalLight':\\r\\n\\r\\n\\t\\t\\t\\tobject = new DirectionalLight( data.color, data.intensity );\\r\\n\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tcase 'PointLight':\\r\\n\\r\\n\\t\\t\\t\\tobject = new PointLight( data.color, data.intensity, data.distance, data.decay );\\r\\n\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tcase 'RectAreaLight':\\r\\n\\r\\n\\t\\t\\t\\tobject = new RectAreaLight( data.color, data.intensity, data.width, data.height );\\r\\n\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tcase 'SpotLight':\\r\\n\\r\\n\\t\\t\\t\\tobject = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );\\r\\n\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tcase 'HemisphereLight':\\r\\n\\r\\n\\t\\t\\t\\tobject = new HemisphereLight( data.color, data.groundColor, data.intensity );\\r\\n\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tcase 'LightProbe':\\r\\n\\r\\n\\t\\t\\t\\tobject = new LightProbe().fromJSON( data );\\r\\n\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tcase 'SkinnedMesh':\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.' );\\r\\n\\r\\n\\t\\t\\tcase 'Mesh':\\r\\n\\r\\n\\t\\t\\t\\tvar geometry = getGeometry( data.geometry );\\r\\n\\t\\t\\t\\tvar material = getMaterial( data.material );\\r\\n\\r\\n\\t\\t\\t\\tobject = new Mesh( geometry, material );\\r\\n\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tcase 'InstancedMesh':\\r\\n\\r\\n\\t\\t\\t\\tvar geometry = getGeometry( data.geometry );\\r\\n\\t\\t\\t\\tvar material = getMaterial( data.material );\\r\\n\\t\\t\\t\\tvar count = data.count;\\r\\n\\t\\t\\t\\tvar instanceMatrix = data.instanceMatrix;\\r\\n\\r\\n\\t\\t\\t\\tobject = new InstancedMesh( geometry, material, count );\\r\\n\\t\\t\\t\\tobject.instanceMatrix = new BufferAttribute( new Float32Array( instanceMatrix.array ), 16 );\\r\\n\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tcase 'LOD':\\r\\n\\r\\n\\t\\t\\t\\tobject = new LOD();\\r\\n\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tcase 'Line':\\r\\n\\r\\n\\t\\t\\t\\tobject = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );\\r\\n\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tcase 'LineLoop':\\r\\n\\r\\n\\t\\t\\t\\tobject = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );\\r\\n\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tcase 'LineSegments':\\r\\n\\r\\n\\t\\t\\t\\tobject = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );\\r\\n\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tcase 'PointCloud':\\r\\n\\t\\t\\tcase 'Points':\\r\\n\\r\\n\\t\\t\\t\\tobject = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );\\r\\n\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tcase 'Sprite':\\r\\n\\r\\n\\t\\t\\t\\tobject = new Sprite( getMaterial( data.material ) );\\r\\n\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tcase 'Group':\\r\\n\\r\\n\\t\\t\\t\\tobject = new Group();\\r\\n\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\tdefault:\\r\\n\\r\\n\\t\\t\\t\\tobject = new Object3D();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tobject.uuid = data.uuid;\\r\\n\\r\\n\\t\\tif ( data.name !== undefined ) object.name = data.name;\\r\\n\\r\\n\\t\\tif ( data.matrix !== undefined ) {\\r\\n\\r\\n\\t\\t\\tobject.matrix.fromArray( data.matrix );\\r\\n\\r\\n\\t\\t\\tif ( data.matrixAutoUpdate !== undefined ) object.matrixAutoUpdate = data.matrixAutoUpdate;\\r\\n\\t\\t\\tif ( object.matrixAutoUpdate ) object.matrix.decompose( object.position, object.quaternion, object.scale );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tif ( data.position !== undefined ) object.position.fromArray( data.position );\\r\\n\\t\\t\\tif ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\\r\\n\\t\\t\\tif ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );\\r\\n\\t\\t\\tif ( data.scale !== undefined ) object.scale.fromArray( data.scale );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( data.castShadow !== undefined ) object.castShadow = data.castShadow;\\r\\n\\t\\tif ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;\\r\\n\\r\\n\\t\\tif ( data.shadow ) {\\r\\n\\r\\n\\t\\t\\tif ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;\\r\\n\\t\\t\\tif ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;\\r\\n\\t\\t\\tif ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );\\r\\n\\t\\t\\tif ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( data.visible !== undefined ) object.visible = data.visible;\\r\\n\\t\\tif ( data.frustumCulled !== undefined ) object.frustumCulled = data.frustumCulled;\\r\\n\\t\\tif ( data.renderOrder !== undefined ) object.renderOrder = data.renderOrder;\\r\\n\\t\\tif ( data.userData !== undefined ) object.userData = data.userData;\\r\\n\\t\\tif ( data.layers !== undefined ) object.layers.mask = data.layers;\\r\\n\\r\\n\\t\\tif ( data.children !== undefined ) {\\r\\n\\r\\n\\t\\t\\tvar children = data.children;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i < children.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tobject.add( this.parseObject( children[ i ], geometries, materials ) );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( data.type === 'LOD' ) {\\r\\n\\r\\n\\t\\t\\tif ( data.autoUpdate !== undefined ) object.autoUpdate = data.autoUpdate;\\r\\n\\r\\n\\t\\t\\tvar levels = data.levels;\\r\\n\\r\\n\\t\\t\\tfor ( var l = 0; l < levels.length; l ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar level = levels[ l ];\\r\\n\\t\\t\\t\\tvar child = object.getObjectByProperty( 'uuid', level.object );\\r\\n\\r\\n\\t\\t\\t\\tif ( child !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tobject.addLevel( child, level.distance );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn object;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nvar TEXTURE_MAPPING = {\\r\\n\\tUVMapping: UVMapping,\\r\\n\\tCubeReflectionMapping: CubeReflectionMapping,\\r\\n\\tCubeRefractionMapping: CubeRefractionMapping,\\r\\n\\tEquirectangularReflectionMapping: EquirectangularReflectionMapping,\\r\\n\\tEquirectangularRefractionMapping: EquirectangularRefractionMapping,\\r\\n\\tSphericalReflectionMapping: SphericalReflectionMapping,\\r\\n\\tCubeUVReflectionMapping: CubeUVReflectionMapping,\\r\\n\\tCubeUVRefractionMapping: CubeUVRefractionMapping\\r\\n};\\r\\n\\r\\nvar TEXTURE_WRAPPING = {\\r\\n\\tRepeatWrapping: RepeatWrapping,\\r\\n\\tClampToEdgeWrapping: ClampToEdgeWrapping,\\r\\n\\tMirroredRepeatWrapping: MirroredRepeatWrapping\\r\\n};\\r\\n\\r\\nvar TEXTURE_FILTER = {\\r\\n\\tNearestFilter: NearestFilter,\\r\\n\\tNearestMipmapNearestFilter: NearestMipmapNearestFilter,\\r\\n\\tNearestMipmapLinearFilter: NearestMipmapLinearFilter,\\r\\n\\tLinearFilter: LinearFilter,\\r\\n\\tLinearMipmapNearestFilter: LinearMipmapNearestFilter,\\r\\n\\tLinearMipmapLinearFilter: LinearMipmapLinearFilter\\r\\n};\\r\\n\\r\\n/**\\r\\n * @author thespite / http://clicktorelease.com/\\r\\n */\\r\\n\\r\\n\\r\\nfunction ImageBitmapLoader( manager ) {\\r\\n\\r\\n\\tif ( typeof createImageBitmap === 'undefined' ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tif ( typeof fetch === 'undefined' ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tLoader.call( this, manager );\\r\\n\\r\\n\\tthis.options = undefined;\\r\\n\\r\\n}\\r\\n\\r\\nImageBitmapLoader.prototype = Object.assign( Object.create( Loader.prototype ), {\\r\\n\\r\\n\\tconstructor: ImageBitmapLoader,\\r\\n\\r\\n\\tsetOptions: function setOptions( options ) {\\r\\n\\r\\n\\t\\tthis.options = options;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tload: function ( url, onLoad, onProgress, onError ) {\\r\\n\\r\\n\\t\\tif ( url === undefined ) url = '';\\r\\n\\r\\n\\t\\tif ( this.path !== undefined ) url = this.path + url;\\r\\n\\r\\n\\t\\turl = this.manager.resolveURL( url );\\r\\n\\r\\n\\t\\tvar scope = this;\\r\\n\\r\\n\\t\\tvar cached = Cache.get( url );\\r\\n\\r\\n\\t\\tif ( cached !== undefined ) {\\r\\n\\r\\n\\t\\t\\tscope.manager.itemStart( url );\\r\\n\\r\\n\\t\\t\\tsetTimeout( function () {\\r\\n\\r\\n\\t\\t\\t\\tif ( onLoad ) onLoad( cached );\\r\\n\\r\\n\\t\\t\\t\\tscope.manager.itemEnd( url );\\r\\n\\r\\n\\t\\t\\t}, 0 );\\r\\n\\r\\n\\t\\t\\treturn cached;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfetch( url ).then( function ( res ) {\\r\\n\\r\\n\\t\\t\\treturn res.blob();\\r\\n\\r\\n\\t\\t} ).then( function ( blob ) {\\r\\n\\r\\n\\t\\t\\tif ( scope.options === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t// Workaround for FireFox. It causes an error if you pass options.\\r\\n\\t\\t\\t\\treturn createImageBitmap( blob );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\treturn createImageBitmap( blob, scope.options );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t} ).then( function ( imageBitmap ) {\\r\\n\\r\\n\\t\\t\\tCache.add( url, imageBitmap );\\r\\n\\r\\n\\t\\t\\tif ( onLoad ) onLoad( imageBitmap );\\r\\n\\r\\n\\t\\t\\tscope.manager.itemEnd( url );\\r\\n\\r\\n\\t\\t} ).catch( function ( e ) {\\r\\n\\r\\n\\t\\t\\tif ( onError ) onError( e );\\r\\n\\r\\n\\t\\t\\tscope.manager.itemError( url );\\r\\n\\t\\t\\tscope.manager.itemEnd( url );\\r\\n\\r\\n\\t\\t} );\\r\\n\\r\\n\\t\\tscope.manager.itemStart( url );\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author zz85 / http://www.lab4games.net/zz85/blog\\r\\n * minimal class for proxing functions to Path. Replaces old \\\"extractSubpaths()\\\"\\r\\n **/\\r\\n\\r\\nfunction ShapePath() {\\r\\n\\r\\n\\tthis.type = 'ShapePath';\\r\\n\\r\\n\\tthis.color = new Color();\\r\\n\\r\\n\\tthis.subPaths = [];\\r\\n\\tthis.currentPath = null;\\r\\n\\r\\n}\\r\\n\\r\\nObject.assign( ShapePath.prototype, {\\r\\n\\r\\n\\tmoveTo: function ( x, y ) {\\r\\n\\r\\n\\t\\tthis.currentPath = new Path();\\r\\n\\t\\tthis.subPaths.push( this.currentPath );\\r\\n\\t\\tthis.currentPath.moveTo( x, y );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tlineTo: function ( x, y ) {\\r\\n\\r\\n\\t\\tthis.currentPath.lineTo( x, y );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tquadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\\r\\n\\r\\n\\t\\tthis.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tbezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\\r\\n\\r\\n\\t\\tthis.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsplineThru: function ( pts ) {\\r\\n\\r\\n\\t\\tthis.currentPath.splineThru( pts );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttoShapes: function ( isCCW, noHoles ) {\\r\\n\\r\\n\\t\\tfunction toShapesNoHoles( inSubpaths ) {\\r\\n\\r\\n\\t\\t\\tvar shapes = [];\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar tmpPath = inSubpaths[ i ];\\r\\n\\r\\n\\t\\t\\t\\tvar tmpShape = new Shape();\\r\\n\\t\\t\\t\\ttmpShape.curves = tmpPath.curves;\\r\\n\\r\\n\\t\\t\\t\\tshapes.push( tmpShape );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn shapes;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction isPointInsidePolygon( inPt, inPolygon ) {\\r\\n\\r\\n\\t\\t\\tvar polyLen = inPolygon.length;\\r\\n\\r\\n\\t\\t\\t// inPt on polygon contour => immediate success    or\\r\\n\\t\\t\\t// toggling of inside/outside at every single! intersection point of an edge\\r\\n\\t\\t\\t//  with the horizontal line through inPt, left of inPt\\r\\n\\t\\t\\t//  not counting lowerY endpoints of edges and whole edges on that line\\r\\n\\t\\t\\tvar inside = false;\\r\\n\\t\\t\\tfor ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar edgeLowPt = inPolygon[ p ];\\r\\n\\t\\t\\t\\tvar edgeHighPt = inPolygon[ q ];\\r\\n\\r\\n\\t\\t\\t\\tvar edgeDx = edgeHighPt.x - edgeLowPt.x;\\r\\n\\t\\t\\t\\tvar edgeDy = edgeHighPt.y - edgeLowPt.y;\\r\\n\\r\\n\\t\\t\\t\\tif ( Math.abs( edgeDy ) > Number.EPSILON ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// not parallel\\r\\n\\t\\t\\t\\t\\tif ( edgeDy < 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tedgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;\\r\\n\\t\\t\\t\\t\\t\\tedgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) \\t\\tcontinue;\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( inPt.y === edgeLowPt.y ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( inPt.x === edgeLowPt.x )\\t\\treturn\\ttrue;\\t\\t// inPt is on contour ?\\r\\n\\t\\t\\t\\t\\t\\t// continue;\\t\\t\\t\\t// no intersection or edgeLowPt => doesn't count !!!\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );\\r\\n\\t\\t\\t\\t\\t\\tif ( perpEdge === 0 )\\t\\t\\t\\treturn\\ttrue;\\t\\t// inPt is on contour ?\\r\\n\\t\\t\\t\\t\\t\\tif ( perpEdge < 0 ) \\t\\t\\t\\tcontinue;\\r\\n\\t\\t\\t\\t\\t\\tinside = ! inside;\\t\\t// true intersection left of inPt\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t// parallel or collinear\\r\\n\\t\\t\\t\\t\\tif ( inPt.y !== edgeLowPt.y ) \\t\\tcontinue;\\t\\t\\t// parallel\\r\\n\\t\\t\\t\\t\\t// edge lies on the same horizontal line as inPt\\r\\n\\t\\t\\t\\t\\tif ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\\r\\n\\t\\t\\t\\t\\t\\t ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )\\t\\treturn\\ttrue;\\t// inPt: Point on contour !\\r\\n\\t\\t\\t\\t\\t// continue;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn\\tinside;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar isClockWise = ShapeUtils.isClockWise;\\r\\n\\r\\n\\t\\tvar subPaths = this.subPaths;\\r\\n\\t\\tif ( subPaths.length === 0 ) return [];\\r\\n\\r\\n\\t\\tif ( noHoles === true )\\treturn\\ttoShapesNoHoles( subPaths );\\r\\n\\r\\n\\r\\n\\t\\tvar solid, tmpPath, tmpShape, shapes = [];\\r\\n\\r\\n\\t\\tif ( subPaths.length === 1 ) {\\r\\n\\r\\n\\t\\t\\ttmpPath = subPaths[ 0 ];\\r\\n\\t\\t\\ttmpShape = new Shape();\\r\\n\\t\\t\\ttmpShape.curves = tmpPath.curves;\\r\\n\\t\\t\\tshapes.push( tmpShape );\\r\\n\\t\\t\\treturn shapes;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );\\r\\n\\t\\tholesFirst = isCCW ? ! holesFirst : holesFirst;\\r\\n\\r\\n\\t\\t// console.log(\\\"Holes first\\\", holesFirst);\\r\\n\\r\\n\\t\\tvar betterShapeHoles = [];\\r\\n\\t\\tvar newShapes = [];\\r\\n\\t\\tvar newShapeHoles = [];\\r\\n\\t\\tvar mainIdx = 0;\\r\\n\\t\\tvar tmpPoints;\\r\\n\\r\\n\\t\\tnewShapes[ mainIdx ] = undefined;\\r\\n\\t\\tnewShapeHoles[ mainIdx ] = [];\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = subPaths.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\ttmpPath = subPaths[ i ];\\r\\n\\t\\t\\ttmpPoints = tmpPath.getPoints();\\r\\n\\t\\t\\tsolid = isClockWise( tmpPoints );\\r\\n\\t\\t\\tsolid = isCCW ? ! solid : solid;\\r\\n\\r\\n\\t\\t\\tif ( solid ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )\\tmainIdx ++;\\r\\n\\r\\n\\t\\t\\t\\tnewShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };\\r\\n\\t\\t\\t\\tnewShapes[ mainIdx ].s.curves = tmpPath.curves;\\r\\n\\r\\n\\t\\t\\t\\tif ( holesFirst )\\tmainIdx ++;\\r\\n\\t\\t\\t\\tnewShapeHoles[ mainIdx ] = [];\\r\\n\\r\\n\\t\\t\\t\\t//console.log('cw', i);\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tnewShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );\\r\\n\\r\\n\\t\\t\\t\\t//console.log('ccw', i);\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// only Holes? -> probably all Shapes with wrong orientation\\r\\n\\t\\tif ( ! newShapes[ 0 ] )\\treturn\\ttoShapesNoHoles( subPaths );\\r\\n\\r\\n\\r\\n\\t\\tif ( newShapes.length > 1 ) {\\r\\n\\r\\n\\t\\t\\tvar ambiguous = false;\\r\\n\\t\\t\\tvar toChange = [];\\r\\n\\r\\n\\t\\t\\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tbetterShapeHoles[ sIdx ] = [];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tvar sho = newShapeHoles[ sIdx ];\\r\\n\\r\\n\\t\\t\\t\\tfor ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar ho = sho[ hIdx ];\\r\\n\\t\\t\\t\\t\\tvar hole_unassigned = true;\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( sIdx !== s2Idx )\\ttoChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );\\r\\n\\t\\t\\t\\t\\t\\t\\tif ( hole_unassigned ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\thole_unassigned = false;\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tbetterShapeHoles[ s2Idx ].push( ho );\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tambiguous = true;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( hole_unassigned ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbetterShapeHoles[ sIdx ].push( ho );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t// console.log(\\\"ambiguous: \\\", ambiguous);\\r\\n\\r\\n\\t\\t\\tif ( toChange.length > 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t// console.log(\\\"to change: \\\", toChange);\\r\\n\\t\\t\\t\\tif ( ! ambiguous )\\tnewShapeHoles = betterShapeHoles;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar tmpHoles;\\r\\n\\r\\n\\t\\tfor ( var i = 0, il = newShapes.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\ttmpShape = newShapes[ i ].s;\\r\\n\\t\\t\\tshapes.push( tmpShape );\\r\\n\\t\\t\\ttmpHoles = newShapeHoles[ i ];\\r\\n\\r\\n\\t\\t\\tfor ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\\r\\n\\r\\n\\t\\t\\t\\ttmpShape.holes.push( tmpHoles[ j ].h );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t//console.log(\\\"shape\\\", shapes);\\r\\n\\r\\n\\t\\treturn shapes;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author zz85 / http://www.lab4games.net/zz85/blog\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\n\\r\\nfunction Font( data ) {\\r\\n\\r\\n\\tthis.type = 'Font';\\r\\n\\r\\n\\tthis.data = data;\\r\\n\\r\\n}\\r\\n\\r\\nObject.assign( Font.prototype, {\\r\\n\\r\\n\\tisFont: true,\\r\\n\\r\\n\\tgenerateShapes: function ( text, size ) {\\r\\n\\r\\n\\t\\tif ( size === undefined ) size = 100;\\r\\n\\r\\n\\t\\tvar shapes = [];\\r\\n\\t\\tvar paths = createPaths( text, size, this.data );\\r\\n\\r\\n\\t\\tfor ( var p = 0, pl = paths.length; p < pl; p ++ ) {\\r\\n\\r\\n\\t\\t\\tArray.prototype.push.apply( shapes, paths[ p ].toShapes() );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn shapes;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nfunction createPaths( text, size, data ) {\\r\\n\\r\\n\\tvar chars = Array.from ? Array.from( text ) : String( text ).split( '' ); // workaround for IE11, see #13988\\r\\n\\tvar scale = size / data.resolution;\\r\\n\\tvar line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale;\\r\\n\\r\\n\\tvar paths = [];\\r\\n\\r\\n\\tvar offsetX = 0, offsetY = 0;\\r\\n\\r\\n\\tfor ( var i = 0; i < chars.length; i ++ ) {\\r\\n\\r\\n\\t\\tvar char = chars[ i ];\\r\\n\\r\\n\\t\\tif ( char === '\\\\n' ) {\\r\\n\\r\\n\\t\\t\\toffsetX = 0;\\r\\n\\t\\t\\toffsetY -= line_height;\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tvar ret = createPath( char, scale, offsetX, offsetY, data );\\r\\n\\t\\t\\toffsetX += ret.offsetX;\\r\\n\\t\\t\\tpaths.push( ret.path );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn paths;\\r\\n\\r\\n}\\r\\n\\r\\nfunction createPath( char, scale, offsetX, offsetY, data ) {\\r\\n\\r\\n\\tvar glyph = data.glyphs[ char ] || data.glyphs[ '?' ];\\r\\n\\r\\n\\tif ( ! glyph ) {\\r\\n\\r\\n\\t\\tconsole.error( 'THREE.Font: character \\\"' + char + '\\\" does not exists in font family ' + data.familyName + '.' );\\r\\n\\r\\n\\t\\treturn;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tvar path = new ShapePath();\\r\\n\\r\\n\\tvar x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;\\r\\n\\r\\n\\tif ( glyph.o ) {\\r\\n\\r\\n\\t\\tvar outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = outline.length; i < l; ) {\\r\\n\\r\\n\\t\\t\\tvar action = outline[ i ++ ];\\r\\n\\r\\n\\t\\t\\tswitch ( action ) {\\r\\n\\r\\n\\t\\t\\t\\tcase 'm': // moveTo\\r\\n\\r\\n\\t\\t\\t\\t\\tx = outline[ i ++ ] * scale + offsetX;\\r\\n\\t\\t\\t\\t\\ty = outline[ i ++ ] * scale + offsetY;\\r\\n\\r\\n\\t\\t\\t\\t\\tpath.moveTo( x, y );\\r\\n\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\tcase 'l': // lineTo\\r\\n\\r\\n\\t\\t\\t\\t\\tx = outline[ i ++ ] * scale + offsetX;\\r\\n\\t\\t\\t\\t\\ty = outline[ i ++ ] * scale + offsetY;\\r\\n\\r\\n\\t\\t\\t\\t\\tpath.lineTo( x, y );\\r\\n\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\tcase 'q': // quadraticCurveTo\\r\\n\\r\\n\\t\\t\\t\\t\\tcpx = outline[ i ++ ] * scale + offsetX;\\r\\n\\t\\t\\t\\t\\tcpy = outline[ i ++ ] * scale + offsetY;\\r\\n\\t\\t\\t\\t\\tcpx1 = outline[ i ++ ] * scale + offsetX;\\r\\n\\t\\t\\t\\t\\tcpy1 = outline[ i ++ ] * scale + offsetY;\\r\\n\\r\\n\\t\\t\\t\\t\\tpath.quadraticCurveTo( cpx1, cpy1, cpx, cpy );\\r\\n\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\tcase 'b': // bezierCurveTo\\r\\n\\r\\n\\t\\t\\t\\t\\tcpx = outline[ i ++ ] * scale + offsetX;\\r\\n\\t\\t\\t\\t\\tcpy = outline[ i ++ ] * scale + offsetY;\\r\\n\\t\\t\\t\\t\\tcpx1 = outline[ i ++ ] * scale + offsetX;\\r\\n\\t\\t\\t\\t\\tcpy1 = outline[ i ++ ] * scale + offsetY;\\r\\n\\t\\t\\t\\t\\tcpx2 = outline[ i ++ ] * scale + offsetX;\\r\\n\\t\\t\\t\\t\\tcpy2 = outline[ i ++ ] * scale + offsetY;\\r\\n\\r\\n\\t\\t\\t\\t\\tpath.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );\\r\\n\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn { offsetX: glyph.ha * scale, path: path };\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nfunction FontLoader( manager ) {\\r\\n\\r\\n\\tLoader.call( this, manager );\\r\\n\\r\\n}\\r\\n\\r\\nFontLoader.prototype = Object.assign( Object.create( Loader.prototype ), {\\r\\n\\r\\n\\tconstructor: FontLoader,\\r\\n\\r\\n\\tload: function ( url, onLoad, onProgress, onError ) {\\r\\n\\r\\n\\t\\tvar scope = this;\\r\\n\\r\\n\\t\\tvar loader = new FileLoader( this.manager );\\r\\n\\t\\tloader.setPath( this.path );\\r\\n\\t\\tloader.load( url, function ( text ) {\\r\\n\\r\\n\\t\\t\\tvar json;\\r\\n\\r\\n\\t\\t\\ttry {\\r\\n\\r\\n\\t\\t\\t\\tjson = JSON.parse( text );\\r\\n\\r\\n\\t\\t\\t} catch ( e ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );\\r\\n\\t\\t\\t\\tjson = JSON.parse( text.substring( 65, text.length - 2 ) );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar font = scope.parse( json );\\r\\n\\r\\n\\t\\t\\tif ( onLoad ) onLoad( font );\\r\\n\\r\\n\\t\\t}, onProgress, onError );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tparse: function ( json ) {\\r\\n\\r\\n\\t\\treturn new Font( json );\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nvar _context;\\r\\n\\r\\nvar AudioContext = {\\r\\n\\r\\n\\tgetContext: function () {\\r\\n\\r\\n\\t\\tif ( _context === undefined ) {\\r\\n\\r\\n\\t\\t\\t_context = new ( window.AudioContext || window.webkitAudioContext )();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn _context;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetContext: function ( value ) {\\r\\n\\r\\n\\t\\t_context = value;\\r\\n\\r\\n\\t}\\r\\n\\r\\n};\\r\\n\\r\\n/**\\r\\n * @author Reece Aaron Lecrivain / http://reecenotes.com/\\r\\n */\\r\\n\\r\\nfunction AudioLoader( manager ) {\\r\\n\\r\\n\\tLoader.call( this, manager );\\r\\n\\r\\n}\\r\\n\\r\\nAudioLoader.prototype = Object.assign( Object.create( Loader.prototype ), {\\r\\n\\r\\n\\tconstructor: AudioLoader,\\r\\n\\r\\n\\tload: function ( url, onLoad, onProgress, onError ) {\\r\\n\\r\\n\\t\\tvar scope = this;\\r\\n\\r\\n\\t\\tvar loader = new FileLoader( scope.manager );\\r\\n\\t\\tloader.setResponseType( 'arraybuffer' );\\r\\n\\t\\tloader.setPath( scope.path );\\r\\n\\t\\tloader.load( url, function ( buffer ) {\\r\\n\\r\\n\\t\\t\\ttry {\\r\\n\\r\\n\\t\\t\\t\\t// Create a copy of the buffer. The `decodeAudioData` method\\r\\n\\t\\t\\t\\t// detaches the buffer when complete, preventing reuse.\\r\\n\\t\\t\\t\\tvar bufferCopy = buffer.slice( 0 );\\r\\n\\r\\n\\t\\t\\t\\tvar context = AudioContext.getContext();\\r\\n\\t\\t\\t\\tcontext.decodeAudioData( bufferCopy, function ( audioBuffer ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tonLoad( audioBuffer );\\r\\n\\r\\n\\t\\t\\t\\t} );\\r\\n\\r\\n\\t\\t\\t} catch ( e ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( onError ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tonError( e );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.error( e );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tscope.manager.itemError( url );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}, onProgress, onError );\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author WestLangley / http://github.com/WestLangley\\r\\n */\\r\\n\\r\\nfunction HemisphereLightProbe( skyColor, groundColor, intensity ) {\\r\\n\\r\\n\\tLightProbe.call( this, undefined, intensity );\\r\\n\\r\\n\\tvar color1 = new Color().set( skyColor );\\r\\n\\tvar color2 = new Color().set( groundColor );\\r\\n\\r\\n\\tvar sky = new Vector3( color1.r, color1.g, color1.b );\\r\\n\\tvar ground = new Vector3( color2.r, color2.g, color2.b );\\r\\n\\r\\n\\t// without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );\\r\\n\\tvar c0 = Math.sqrt( Math.PI );\\r\\n\\tvar c1 = c0 * Math.sqrt( 0.75 );\\r\\n\\r\\n\\tthis.sh.coefficients[ 0 ].copy( sky ).add( ground ).multiplyScalar( c0 );\\r\\n\\tthis.sh.coefficients[ 1 ].copy( sky ).sub( ground ).multiplyScalar( c1 );\\r\\n\\r\\n}\\r\\n\\r\\nHemisphereLightProbe.prototype = Object.assign( Object.create( LightProbe.prototype ), {\\r\\n\\r\\n\\tconstructor: HemisphereLightProbe,\\r\\n\\r\\n\\tisHemisphereLightProbe: true,\\r\\n\\r\\n\\tcopy: function ( source ) { // modifying colors not currently supported\\r\\n\\r\\n\\t\\tLightProbe.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttoJSON: function ( meta ) {\\r\\n\\r\\n\\t\\tvar data = LightProbe.prototype.toJSON.call( this, meta );\\r\\n\\r\\n\\t\\t// data.sh = this.sh.toArray(); // todo\\r\\n\\r\\n\\t\\treturn data;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author WestLangley / http://github.com/WestLangley\\r\\n */\\r\\n\\r\\nfunction AmbientLightProbe( color, intensity ) {\\r\\n\\r\\n\\tLightProbe.call( this, undefined, intensity );\\r\\n\\r\\n\\tvar color1 = new Color().set( color );\\r\\n\\r\\n\\t// without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );\\r\\n\\tthis.sh.coefficients[ 0 ].set( color1.r, color1.g, color1.b ).multiplyScalar( 2 * Math.sqrt( Math.PI ) );\\r\\n\\r\\n}\\r\\n\\r\\nAmbientLightProbe.prototype = Object.assign( Object.create( LightProbe.prototype ), {\\r\\n\\r\\n\\tconstructor: AmbientLightProbe,\\r\\n\\r\\n\\tisAmbientLightProbe: true,\\r\\n\\r\\n\\tcopy: function ( source ) { // modifying color not currently supported\\r\\n\\r\\n\\t\\tLightProbe.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttoJSON: function ( meta ) {\\r\\n\\r\\n\\t\\tvar data = LightProbe.prototype.toJSON.call( this, meta );\\r\\n\\r\\n\\t\\t// data.sh = this.sh.toArray(); // todo\\r\\n\\r\\n\\t\\treturn data;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nvar _eyeRight = new Matrix4();\\r\\nvar _eyeLeft = new Matrix4();\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nfunction StereoCamera() {\\r\\n\\r\\n\\tthis.type = 'StereoCamera';\\r\\n\\r\\n\\tthis.aspect = 1;\\r\\n\\r\\n\\tthis.eyeSep = 0.064;\\r\\n\\r\\n\\tthis.cameraL = new PerspectiveCamera();\\r\\n\\tthis.cameraL.layers.enable( 1 );\\r\\n\\tthis.cameraL.matrixAutoUpdate = false;\\r\\n\\r\\n\\tthis.cameraR = new PerspectiveCamera();\\r\\n\\tthis.cameraR.layers.enable( 2 );\\r\\n\\tthis.cameraR.matrixAutoUpdate = false;\\r\\n\\r\\n\\tthis._cache = {\\r\\n\\t\\tfocus: null,\\r\\n\\t\\tfov: null,\\r\\n\\t\\taspect: null,\\r\\n\\t\\tnear: null,\\r\\n\\t\\tfar: null,\\r\\n\\t\\tzoom: null,\\r\\n\\t\\teyeSep: null\\r\\n\\t};\\r\\n\\r\\n}\\r\\n\\r\\nObject.assign( StereoCamera.prototype, {\\r\\n\\r\\n\\tupdate: function ( camera ) {\\r\\n\\r\\n\\t\\tvar cache = this._cache;\\r\\n\\r\\n\\t\\tvar needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov ||\\r\\n\\t\\t\\tcache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near ||\\r\\n\\t\\t\\tcache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;\\r\\n\\r\\n\\t\\tif ( needsUpdate ) {\\r\\n\\r\\n\\t\\t\\tcache.focus = camera.focus;\\r\\n\\t\\t\\tcache.fov = camera.fov;\\r\\n\\t\\t\\tcache.aspect = camera.aspect * this.aspect;\\r\\n\\t\\t\\tcache.near = camera.near;\\r\\n\\t\\t\\tcache.far = camera.far;\\r\\n\\t\\t\\tcache.zoom = camera.zoom;\\r\\n\\t\\t\\tcache.eyeSep = this.eyeSep;\\r\\n\\r\\n\\t\\t\\t// Off-axis stereoscopic effect based on\\r\\n\\t\\t\\t// http://paulbourke.net/stereographics/stereorender/\\r\\n\\r\\n\\t\\t\\tvar projectionMatrix = camera.projectionMatrix.clone();\\r\\n\\t\\t\\tvar eyeSepHalf = cache.eyeSep / 2;\\r\\n\\t\\t\\tvar eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;\\r\\n\\t\\t\\tvar ymax = ( cache.near * Math.tan( MathUtils.DEG2RAD * cache.fov * 0.5 ) ) / cache.zoom;\\r\\n\\t\\t\\tvar xmin, xmax;\\r\\n\\r\\n\\t\\t\\t// translate xOffset\\r\\n\\r\\n\\t\\t\\t_eyeLeft.elements[ 12 ] = - eyeSepHalf;\\r\\n\\t\\t\\t_eyeRight.elements[ 12 ] = eyeSepHalf;\\r\\n\\r\\n\\t\\t\\t// for left eye\\r\\n\\r\\n\\t\\t\\txmin = - ymax * cache.aspect + eyeSepOnProjection;\\r\\n\\t\\t\\txmax = ymax * cache.aspect + eyeSepOnProjection;\\r\\n\\r\\n\\t\\t\\tprojectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );\\r\\n\\t\\t\\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\\r\\n\\r\\n\\t\\t\\tthis.cameraL.projectionMatrix.copy( projectionMatrix );\\r\\n\\r\\n\\t\\t\\t// for right eye\\r\\n\\r\\n\\t\\t\\txmin = - ymax * cache.aspect - eyeSepOnProjection;\\r\\n\\t\\t\\txmax = ymax * cache.aspect - eyeSepOnProjection;\\r\\n\\r\\n\\t\\t\\tprojectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );\\r\\n\\t\\t\\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\\r\\n\\r\\n\\t\\t\\tthis.cameraR.projectionMatrix.copy( projectionMatrix );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeLeft );\\r\\n\\t\\tthis.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeRight );\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n */\\r\\n\\r\\nfunction Clock( autoStart ) {\\r\\n\\r\\n\\tthis.autoStart = ( autoStart !== undefined ) ? autoStart : true;\\r\\n\\r\\n\\tthis.startTime = 0;\\r\\n\\tthis.oldTime = 0;\\r\\n\\tthis.elapsedTime = 0;\\r\\n\\r\\n\\tthis.running = false;\\r\\n\\r\\n}\\r\\n\\r\\nObject.assign( Clock.prototype, {\\r\\n\\r\\n\\tstart: function () {\\r\\n\\r\\n\\t\\tthis.startTime = ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732\\r\\n\\r\\n\\t\\tthis.oldTime = this.startTime;\\r\\n\\t\\tthis.elapsedTime = 0;\\r\\n\\t\\tthis.running = true;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tstop: function () {\\r\\n\\r\\n\\t\\tthis.getElapsedTime();\\r\\n\\t\\tthis.running = false;\\r\\n\\t\\tthis.autoStart = false;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetElapsedTime: function () {\\r\\n\\r\\n\\t\\tthis.getDelta();\\r\\n\\t\\treturn this.elapsedTime;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetDelta: function () {\\r\\n\\r\\n\\t\\tvar diff = 0;\\r\\n\\r\\n\\t\\tif ( this.autoStart && ! this.running ) {\\r\\n\\r\\n\\t\\t\\tthis.start();\\r\\n\\t\\t\\treturn 0;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( this.running ) {\\r\\n\\r\\n\\t\\t\\tvar newTime = ( typeof performance === 'undefined' ? Date : performance ).now();\\r\\n\\r\\n\\t\\t\\tdiff = ( newTime - this.oldTime ) / 1000;\\r\\n\\t\\t\\tthis.oldTime = newTime;\\r\\n\\r\\n\\t\\t\\tthis.elapsedTime += diff;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn diff;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nvar _position$2 = new Vector3();\\r\\nvar _quaternion$3 = new Quaternion();\\r\\nvar _scale$1 = new Vector3();\\r\\nvar _orientation = new Vector3();\\r\\n\\r\\nfunction AudioListener() {\\r\\n\\r\\n\\tObject3D.call( this );\\r\\n\\r\\n\\tthis.type = 'AudioListener';\\r\\n\\r\\n\\tthis.context = AudioContext.getContext();\\r\\n\\r\\n\\tthis.gain = this.context.createGain();\\r\\n\\tthis.gain.connect( this.context.destination );\\r\\n\\r\\n\\tthis.filter = null;\\r\\n\\r\\n\\tthis.timeDelta = 0;\\r\\n\\r\\n\\t// private\\r\\n\\r\\n\\tthis._clock = new Clock();\\r\\n\\r\\n}\\r\\n\\r\\nAudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), {\\r\\n\\r\\n\\tconstructor: AudioListener,\\r\\n\\r\\n\\tgetInput: function () {\\r\\n\\r\\n\\t\\treturn this.gain;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tremoveFilter: function ( ) {\\r\\n\\r\\n\\t\\tif ( this.filter !== null ) {\\r\\n\\r\\n\\t\\t\\tthis.gain.disconnect( this.filter );\\r\\n\\t\\t\\tthis.filter.disconnect( this.context.destination );\\r\\n\\t\\t\\tthis.gain.connect( this.context.destination );\\r\\n\\t\\t\\tthis.filter = null;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetFilter: function () {\\r\\n\\r\\n\\t\\treturn this.filter;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetFilter: function ( value ) {\\r\\n\\r\\n\\t\\tif ( this.filter !== null ) {\\r\\n\\r\\n\\t\\t\\tthis.gain.disconnect( this.filter );\\r\\n\\t\\t\\tthis.filter.disconnect( this.context.destination );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tthis.gain.disconnect( this.context.destination );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.filter = value;\\r\\n\\t\\tthis.gain.connect( this.filter );\\r\\n\\t\\tthis.filter.connect( this.context.destination );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetMasterVolume: function () {\\r\\n\\r\\n\\t\\treturn this.gain.gain.value;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetMasterVolume: function ( value ) {\\r\\n\\r\\n\\t\\tthis.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tupdateMatrixWorld: function ( force ) {\\r\\n\\r\\n\\t\\tObject3D.prototype.updateMatrixWorld.call( this, force );\\r\\n\\r\\n\\t\\tvar listener = this.context.listener;\\r\\n\\t\\tvar up = this.up;\\r\\n\\r\\n\\t\\tthis.timeDelta = this._clock.getDelta();\\r\\n\\r\\n\\t\\tthis.matrixWorld.decompose( _position$2, _quaternion$3, _scale$1 );\\r\\n\\r\\n\\t\\t_orientation.set( 0, 0, - 1 ).applyQuaternion( _quaternion$3 );\\r\\n\\r\\n\\t\\tif ( listener.positionX ) {\\r\\n\\r\\n\\t\\t\\t// code path for Chrome (see #14393)\\r\\n\\r\\n\\t\\t\\tvar endTime = this.context.currentTime + this.timeDelta;\\r\\n\\r\\n\\t\\t\\tlistener.positionX.linearRampToValueAtTime( _position$2.x, endTime );\\r\\n\\t\\t\\tlistener.positionY.linearRampToValueAtTime( _position$2.y, endTime );\\r\\n\\t\\t\\tlistener.positionZ.linearRampToValueAtTime( _position$2.z, endTime );\\r\\n\\t\\t\\tlistener.forwardX.linearRampToValueAtTime( _orientation.x, endTime );\\r\\n\\t\\t\\tlistener.forwardY.linearRampToValueAtTime( _orientation.y, endTime );\\r\\n\\t\\t\\tlistener.forwardZ.linearRampToValueAtTime( _orientation.z, endTime );\\r\\n\\t\\t\\tlistener.upX.linearRampToValueAtTime( up.x, endTime );\\r\\n\\t\\t\\tlistener.upY.linearRampToValueAtTime( up.y, endTime );\\r\\n\\t\\t\\tlistener.upZ.linearRampToValueAtTime( up.z, endTime );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tlistener.setPosition( _position$2.x, _position$2.y, _position$2.z );\\r\\n\\t\\t\\tlistener.setOrientation( _orientation.x, _orientation.y, _orientation.z, up.x, up.y, up.z );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n * @author Reece Aaron Lecrivain / http://reecenotes.com/\\r\\n */\\r\\n\\r\\nfunction Audio( listener ) {\\r\\n\\r\\n\\tObject3D.call( this );\\r\\n\\r\\n\\tthis.type = 'Audio';\\r\\n\\r\\n\\tthis.listener = listener;\\r\\n\\tthis.context = listener.context;\\r\\n\\r\\n\\tthis.gain = this.context.createGain();\\r\\n\\tthis.gain.connect( listener.getInput() );\\r\\n\\r\\n\\tthis.autoplay = false;\\r\\n\\r\\n\\tthis.buffer = null;\\r\\n\\tthis.detune = 0;\\r\\n\\tthis.loop = false;\\r\\n\\tthis.loopStart = 0;\\r\\n\\tthis.loopEnd = 0;\\r\\n\\tthis.offset = 0;\\r\\n\\tthis.duration = undefined;\\r\\n\\tthis.playbackRate = 1;\\r\\n\\tthis.isPlaying = false;\\r\\n\\tthis.hasPlaybackControl = true;\\r\\n\\tthis.sourceType = 'empty';\\r\\n\\r\\n\\tthis._startedAt = 0;\\r\\n\\tthis._progress = 0;\\r\\n\\r\\n\\tthis.filters = [];\\r\\n\\r\\n}\\r\\n\\r\\nAudio.prototype = Object.assign( Object.create( Object3D.prototype ), {\\r\\n\\r\\n\\tconstructor: Audio,\\r\\n\\r\\n\\tgetOutput: function () {\\r\\n\\r\\n\\t\\treturn this.gain;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetNodeSource: function ( audioNode ) {\\r\\n\\r\\n\\t\\tthis.hasPlaybackControl = false;\\r\\n\\t\\tthis.sourceType = 'audioNode';\\r\\n\\t\\tthis.source = audioNode;\\r\\n\\t\\tthis.connect();\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetMediaElementSource: function ( mediaElement ) {\\r\\n\\r\\n\\t\\tthis.hasPlaybackControl = false;\\r\\n\\t\\tthis.sourceType = 'mediaNode';\\r\\n\\t\\tthis.source = this.context.createMediaElementSource( mediaElement );\\r\\n\\t\\tthis.connect();\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetMediaStreamSource: function ( mediaStream ) {\\r\\n\\r\\n\\t\\tthis.hasPlaybackControl = false;\\r\\n\\t\\tthis.sourceType = 'mediaStreamNode';\\r\\n\\t\\tthis.source = this.context.createMediaStreamSource( mediaStream );\\r\\n\\t\\tthis.connect();\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetBuffer: function ( audioBuffer ) {\\r\\n\\r\\n\\t\\tthis.buffer = audioBuffer;\\r\\n\\t\\tthis.sourceType = 'buffer';\\r\\n\\r\\n\\t\\tif ( this.autoplay ) this.play();\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tplay: function ( delay ) {\\r\\n\\r\\n\\t\\tif ( delay === undefined ) delay = 0;\\r\\n\\r\\n\\t\\tif ( this.isPlaying === true ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Audio: Audio is already playing.' );\\r\\n\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( this.hasPlaybackControl === false ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\\r\\n\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis._startedAt = this.context.currentTime + delay;\\r\\n\\r\\n\\t\\tvar source = this.context.createBufferSource();\\r\\n\\t\\tsource.buffer = this.buffer;\\r\\n\\t\\tsource.loop = this.loop;\\r\\n\\t\\tsource.loopStart = this.loopStart;\\r\\n\\t\\tsource.loopEnd = this.loopEnd;\\r\\n\\t\\tsource.onended = this.onEnded.bind( this );\\r\\n\\t\\tsource.start( this._startedAt, this._progress + this.offset, this.duration );\\r\\n\\r\\n\\t\\tthis.isPlaying = true;\\r\\n\\r\\n\\t\\tthis.source = source;\\r\\n\\r\\n\\t\\tthis.setDetune( this.detune );\\r\\n\\t\\tthis.setPlaybackRate( this.playbackRate );\\r\\n\\r\\n\\t\\treturn this.connect();\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tpause: function () {\\r\\n\\r\\n\\t\\tif ( this.hasPlaybackControl === false ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\\r\\n\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( this.isPlaying === true ) {\\r\\n\\r\\n\\t\\t\\t// update current progress\\r\\n\\r\\n\\t\\t\\tthis._progress += Math.max( this.context.currentTime - this._startedAt, 0 ) * this.playbackRate;\\r\\n\\r\\n\\t\\t\\tif ( this.loop === true ) {\\r\\n\\r\\n\\t\\t\\t\\t// ensure _progress does not exceed duration with looped audios\\r\\n\\r\\n\\t\\t\\t\\tthis._progress = this._progress % ( this.duration || this.buffer.duration );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.source.stop();\\r\\n\\t\\t\\tthis.source.onended = null;\\r\\n\\r\\n\\t\\t\\tthis.isPlaying = false;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tstop: function () {\\r\\n\\r\\n\\t\\tif ( this.hasPlaybackControl === false ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\\r\\n\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis._progress = 0;\\r\\n\\r\\n\\t\\tthis.source.stop();\\r\\n\\t\\tthis.source.onended = null;\\r\\n\\t\\tthis.isPlaying = false;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tconnect: function () {\\r\\n\\r\\n\\t\\tif ( this.filters.length > 0 ) {\\r\\n\\r\\n\\t\\t\\tthis.source.connect( this.filters[ 0 ] );\\r\\n\\r\\n\\t\\t\\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.filters[ i - 1 ].connect( this.filters[ i ] );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.filters[ this.filters.length - 1 ].connect( this.getOutput() );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tthis.source.connect( this.getOutput() );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tdisconnect: function () {\\r\\n\\r\\n\\t\\tif ( this.filters.length > 0 ) {\\r\\n\\r\\n\\t\\t\\tthis.source.disconnect( this.filters[ 0 ] );\\r\\n\\r\\n\\t\\t\\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.filters[ i - 1 ].disconnect( this.filters[ i ] );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tthis.source.disconnect( this.getOutput() );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetFilters: function () {\\r\\n\\r\\n\\t\\treturn this.filters;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetFilters: function ( value ) {\\r\\n\\r\\n\\t\\tif ( ! value ) value = [];\\r\\n\\r\\n\\t\\tif ( this.isPlaying === true ) {\\r\\n\\r\\n\\t\\t\\tthis.disconnect();\\r\\n\\t\\t\\tthis.filters = value;\\r\\n\\t\\t\\tthis.connect();\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tthis.filters = value;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetDetune: function ( value ) {\\r\\n\\r\\n\\t\\tthis.detune = value;\\r\\n\\r\\n\\t\\tif ( this.source.detune === undefined ) return; // only set detune when available\\r\\n\\r\\n\\t\\tif ( this.isPlaying === true ) {\\r\\n\\r\\n\\t\\t\\tthis.source.detune.setTargetAtTime( this.detune, this.context.currentTime, 0.01 );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetDetune: function () {\\r\\n\\r\\n\\t\\treturn this.detune;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetFilter: function () {\\r\\n\\r\\n\\t\\treturn this.getFilters()[ 0 ];\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetFilter: function ( filter ) {\\r\\n\\r\\n\\t\\treturn this.setFilters( filter ? [ filter ] : [] );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetPlaybackRate: function ( value ) {\\r\\n\\r\\n\\t\\tif ( this.hasPlaybackControl === false ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\\r\\n\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.playbackRate = value;\\r\\n\\r\\n\\t\\tif ( this.isPlaying === true ) {\\r\\n\\r\\n\\t\\t\\tthis.source.playbackRate.setTargetAtTime( this.playbackRate, this.context.currentTime, 0.01 );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetPlaybackRate: function () {\\r\\n\\r\\n\\t\\treturn this.playbackRate;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tonEnded: function () {\\r\\n\\r\\n\\t\\tthis.isPlaying = false;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetLoop: function () {\\r\\n\\r\\n\\t\\tif ( this.hasPlaybackControl === false ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\\r\\n\\t\\t\\treturn false;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this.loop;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetLoop: function ( value ) {\\r\\n\\r\\n\\t\\tif ( this.hasPlaybackControl === false ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\\r\\n\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.loop = value;\\r\\n\\r\\n\\t\\tif ( this.isPlaying === true ) {\\r\\n\\r\\n\\t\\t\\tthis.source.loop = this.loop;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetLoopStart: function ( value ) {\\r\\n\\r\\n\\t\\tthis.loopStart = value;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetLoopEnd: function ( value ) {\\r\\n\\r\\n\\t\\tthis.loopEnd = value;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetVolume: function () {\\r\\n\\r\\n\\t\\treturn this.gain.gain.value;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetVolume: function ( value ) {\\r\\n\\r\\n\\t\\tthis.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nvar _position$3 = new Vector3();\\r\\nvar _quaternion$4 = new Quaternion();\\r\\nvar _scale$2 = new Vector3();\\r\\nvar _orientation$1 = new Vector3();\\r\\n\\r\\nfunction PositionalAudio( listener ) {\\r\\n\\r\\n\\tAudio.call( this, listener );\\r\\n\\r\\n\\tthis.panner = this.context.createPanner();\\r\\n\\tthis.panner.panningModel = 'HRTF';\\r\\n\\tthis.panner.connect( this.gain );\\r\\n\\r\\n}\\r\\n\\r\\nPositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), {\\r\\n\\r\\n\\tconstructor: PositionalAudio,\\r\\n\\r\\n\\tgetOutput: function () {\\r\\n\\r\\n\\t\\treturn this.panner;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetRefDistance: function () {\\r\\n\\r\\n\\t\\treturn this.panner.refDistance;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetRefDistance: function ( value ) {\\r\\n\\r\\n\\t\\tthis.panner.refDistance = value;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetRolloffFactor: function () {\\r\\n\\r\\n\\t\\treturn this.panner.rolloffFactor;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetRolloffFactor: function ( value ) {\\r\\n\\r\\n\\t\\tthis.panner.rolloffFactor = value;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetDistanceModel: function () {\\r\\n\\r\\n\\t\\treturn this.panner.distanceModel;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetDistanceModel: function ( value ) {\\r\\n\\r\\n\\t\\tthis.panner.distanceModel = value;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetMaxDistance: function () {\\r\\n\\r\\n\\t\\treturn this.panner.maxDistance;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetMaxDistance: function ( value ) {\\r\\n\\r\\n\\t\\tthis.panner.maxDistance = value;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetDirectionalCone: function ( coneInnerAngle, coneOuterAngle, coneOuterGain ) {\\r\\n\\r\\n\\t\\tthis.panner.coneInnerAngle = coneInnerAngle;\\r\\n\\t\\tthis.panner.coneOuterAngle = coneOuterAngle;\\r\\n\\t\\tthis.panner.coneOuterGain = coneOuterGain;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tupdateMatrixWorld: function ( force ) {\\r\\n\\r\\n\\t\\tObject3D.prototype.updateMatrixWorld.call( this, force );\\r\\n\\r\\n\\t\\tif ( this.hasPlaybackControl === true && this.isPlaying === false ) return;\\r\\n\\r\\n\\t\\tthis.matrixWorld.decompose( _position$3, _quaternion$4, _scale$2 );\\r\\n\\r\\n\\t\\t_orientation$1.set( 0, 0, 1 ).applyQuaternion( _quaternion$4 );\\r\\n\\r\\n\\t\\tvar panner = this.panner;\\r\\n\\r\\n\\t\\tif ( panner.positionX ) {\\r\\n\\r\\n\\t\\t\\t// code path for Chrome and Firefox (see #14393)\\r\\n\\r\\n\\t\\t\\tvar endTime = this.context.currentTime + this.listener.timeDelta;\\r\\n\\r\\n\\t\\t\\tpanner.positionX.linearRampToValueAtTime( _position$3.x, endTime );\\r\\n\\t\\t\\tpanner.positionY.linearRampToValueAtTime( _position$3.y, endTime );\\r\\n\\t\\t\\tpanner.positionZ.linearRampToValueAtTime( _position$3.z, endTime );\\r\\n\\t\\t\\tpanner.orientationX.linearRampToValueAtTime( _orientation$1.x, endTime );\\r\\n\\t\\t\\tpanner.orientationY.linearRampToValueAtTime( _orientation$1.y, endTime );\\r\\n\\t\\t\\tpanner.orientationZ.linearRampToValueAtTime( _orientation$1.z, endTime );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tpanner.setPosition( _position$3.x, _position$3.y, _position$3.z );\\r\\n\\t\\t\\tpanner.setOrientation( _orientation$1.x, _orientation$1.y, _orientation$1.z );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nfunction AudioAnalyser( audio, fftSize ) {\\r\\n\\r\\n\\tthis.analyser = audio.context.createAnalyser();\\r\\n\\tthis.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;\\r\\n\\r\\n\\tthis.data = new Uint8Array( this.analyser.frequencyBinCount );\\r\\n\\r\\n\\taudio.getOutput().connect( this.analyser );\\r\\n\\r\\n}\\r\\n\\r\\nObject.assign( AudioAnalyser.prototype, {\\r\\n\\r\\n\\tgetFrequencyData: function () {\\r\\n\\r\\n\\t\\tthis.analyser.getByteFrequencyData( this.data );\\r\\n\\r\\n\\t\\treturn this.data;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetAverageFrequency: function () {\\r\\n\\r\\n\\t\\tvar value = 0, data = this.getFrequencyData();\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < data.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvalue += data[ i ];\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn value / data.length;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n *\\r\\n * Buffered scene graph property that allows weighted accumulation.\\r\\n *\\r\\n *\\r\\n * @author Ben Houston / http://clara.io/\\r\\n * @author David Sarno / http://lighthaus.us/\\r\\n * @author tschw\\r\\n */\\r\\n\\r\\nfunction PropertyMixer( binding, typeName, valueSize ) {\\r\\n\\r\\n\\tthis.binding = binding;\\r\\n\\tthis.valueSize = valueSize;\\r\\n\\r\\n\\tvar mixFunction,\\r\\n\\t\\tmixFunctionAdditive,\\r\\n\\t\\tsetIdentity;\\r\\n\\r\\n\\t// buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]\\r\\n\\t//\\r\\n\\t// interpolators can use .buffer as their .result\\r\\n\\t// the data then goes to 'incoming'\\r\\n\\t//\\r\\n\\t// 'accu0' and 'accu1' are used frame-interleaved for\\r\\n\\t// the cumulative result and are compared to detect\\r\\n\\t// changes\\r\\n\\t//\\r\\n\\t// 'orig' stores the original state of the property\\r\\n\\t//\\r\\n\\t// 'add' is used for additive cumulative results\\r\\n\\t//\\r\\n\\t// 'work' is optional and is only present for quaternion types. It is used\\r\\n\\t// to store intermediate quaternion multiplication results\\r\\n\\r\\n\\tswitch ( typeName ) {\\r\\n\\r\\n\\t\\tcase 'quaternion':\\r\\n\\t\\t\\tmixFunction = this._slerp;\\r\\n\\t\\t\\tmixFunctionAdditive = this._slerpAdditive;\\r\\n\\t\\t\\tsetIdentity = this._setAdditiveIdentityQuaternion;\\r\\n\\r\\n\\t\\t\\tthis.buffer = new Float64Array( valueSize * 6 );\\r\\n\\t\\t\\tthis._workIndex = 5;\\r\\n\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\tcase 'string':\\r\\n\\t\\tcase 'bool':\\r\\n\\t\\t\\tmixFunction = this._select;\\r\\n\\r\\n\\t\\t\\t// Use the regular mix function and for additive on these types,\\r\\n\\t\\t\\t// additive is not relevant for non-numeric types\\r\\n\\t\\t\\tmixFunctionAdditive = this._select;\\r\\n\\r\\n\\t\\t\\tsetIdentity = this._setAdditiveIdentityOther;\\r\\n\\r\\n\\t\\t\\tthis.buffer = new Array( valueSize * 5 );\\r\\n\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\tdefault:\\r\\n\\t\\t\\tmixFunction = this._lerp;\\r\\n\\t\\t\\tmixFunctionAdditive = this._lerpAdditive;\\r\\n\\t\\t\\tsetIdentity = this._setAdditiveIdentityNumeric;\\r\\n\\r\\n\\t\\t\\tthis.buffer = new Float64Array( valueSize * 5 );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tthis._mixBufferRegion = mixFunction;\\r\\n\\tthis._mixBufferRegionAdditive = mixFunctionAdditive;\\r\\n\\tthis._setIdentity = setIdentity;\\r\\n\\tthis._origIndex = 3;\\r\\n\\tthis._addIndex = 4;\\r\\n\\r\\n\\tthis.cumulativeWeight = 0;\\r\\n\\tthis.cumulativeWeightAdditive = 0;\\r\\n\\r\\n\\tthis.useCount = 0;\\r\\n\\tthis.referenceCount = 0;\\r\\n\\r\\n}\\r\\n\\r\\nObject.assign( PropertyMixer.prototype, {\\r\\n\\r\\n\\t// accumulate data in the 'incoming' region into 'accu<i>'\\r\\n\\taccumulate: function ( accuIndex, weight ) {\\r\\n\\r\\n\\t\\t// note: happily accumulating nothing when weight = 0, the caller knows\\r\\n\\t\\t// the weight and shouldn't have made the call in the first place\\r\\n\\r\\n\\t\\tvar buffer = this.buffer,\\r\\n\\t\\t\\tstride = this.valueSize,\\r\\n\\t\\t\\toffset = accuIndex * stride + stride,\\r\\n\\r\\n\\t\\t\\tcurrentWeight = this.cumulativeWeight;\\r\\n\\r\\n\\t\\tif ( currentWeight === 0 ) {\\r\\n\\r\\n\\t\\t\\t// accuN := incoming * weight\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i !== stride; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\tbuffer[ offset + i ] = buffer[ i ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tcurrentWeight = weight;\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t// accuN := accuN + incoming * weight\\r\\n\\r\\n\\t\\t\\tcurrentWeight += weight;\\r\\n\\t\\t\\tvar mix = weight / currentWeight;\\r\\n\\t\\t\\tthis._mixBufferRegion( buffer, offset, 0, mix, stride );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.cumulativeWeight = currentWeight;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// accumulate data in the 'incoming' region into 'add'\\r\\n\\taccumulateAdditive: function ( weight ) {\\r\\n\\r\\n\\t\\tvar buffer = this.buffer,\\r\\n\\t\\t\\tstride = this.valueSize,\\r\\n\\t\\t\\toffset = stride * this._addIndex;\\r\\n\\r\\n\\t\\tif ( this.cumulativeWeightAdditive === 0 ) {\\r\\n\\r\\n\\t\\t\\t// add = identity\\r\\n\\r\\n\\t\\t\\tthis._setIdentity();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// add := add + incoming * weight\\r\\n\\r\\n\\t\\tthis._mixBufferRegionAdditive( buffer, offset, 0, weight, stride );\\r\\n\\t\\tthis.cumulativeWeightAdditive += weight;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// apply the state of 'accu<i>' to the binding when accus differ\\r\\n\\tapply: function ( accuIndex ) {\\r\\n\\r\\n\\t\\tvar stride = this.valueSize,\\r\\n\\t\\t\\tbuffer = this.buffer,\\r\\n\\t\\t\\toffset = accuIndex * stride + stride,\\r\\n\\r\\n\\t\\t\\tweight = this.cumulativeWeight,\\r\\n\\t\\t\\tweightAdditive = this.cumulativeWeightAdditive,\\r\\n\\r\\n\\t\\t\\tbinding = this.binding;\\r\\n\\r\\n\\t\\tthis.cumulativeWeight = 0;\\r\\n\\t\\tthis.cumulativeWeightAdditive = 0;\\r\\n\\r\\n\\t\\tif ( weight < 1 ) {\\r\\n\\r\\n\\t\\t\\t// accuN := accuN + original * ( 1 - cumulativeWeight )\\r\\n\\r\\n\\t\\t\\tvar originalValueOffset = stride * this._origIndex;\\r\\n\\r\\n\\t\\t\\tthis._mixBufferRegion(\\r\\n\\t\\t\\t\\tbuffer, offset, originalValueOffset, 1 - weight, stride );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( weightAdditive > 0 ) {\\r\\n\\r\\n\\t\\t\\t// accuN := accuN + additive accuN\\r\\n\\r\\n\\t\\t\\tthis._mixBufferRegionAdditive( buffer, offset, this._addIndex * stride, 1, stride );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfor ( var i = stride, e = stride + stride; i !== e; ++ i ) {\\r\\n\\r\\n\\t\\t\\tif ( buffer[ i ] !== buffer[ i + stride ] ) {\\r\\n\\r\\n\\t\\t\\t\\t// value has changed -> update scene graph\\r\\n\\r\\n\\t\\t\\t\\tbinding.setValue( buffer, offset );\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// remember the state of the bound property and copy it to both accus\\r\\n\\tsaveOriginalState: function () {\\r\\n\\r\\n\\t\\tvar binding = this.binding;\\r\\n\\r\\n\\t\\tvar buffer = this.buffer,\\r\\n\\t\\t\\tstride = this.valueSize,\\r\\n\\r\\n\\t\\t\\toriginalValueOffset = stride * this._origIndex;\\r\\n\\r\\n\\t\\tbinding.getValue( buffer, originalValueOffset );\\r\\n\\r\\n\\t\\t// accu[0..1] := orig -- initially detect changes against the original\\r\\n\\t\\tfor ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {\\r\\n\\r\\n\\t\\t\\tbuffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Add to identity for additive\\r\\n\\t\\tthis._setIdentity();\\r\\n\\r\\n\\t\\tthis.cumulativeWeight = 0;\\r\\n\\t\\tthis.cumulativeWeightAdditive = 0;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// apply the state previously taken via 'saveOriginalState' to the binding\\r\\n\\trestoreOriginalState: function () {\\r\\n\\r\\n\\t\\tvar originalValueOffset = this.valueSize * 3;\\r\\n\\t\\tthis.binding.setValue( this.buffer, originalValueOffset );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t_setAdditiveIdentityNumeric: function () {\\r\\n\\r\\n\\t\\tvar startIndex = this._addIndex * this.valueSize;\\r\\n\\t\\tvar endIndex = startIndex + this.valueSize;\\r\\n\\r\\n\\t\\tfor ( var i = startIndex; i < endIndex; i ++ ) {\\r\\n\\r\\n\\t\\t\\tthis.buffer[ i ] = 0;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t_setAdditiveIdentityQuaternion: function () {\\r\\n\\r\\n\\t\\tthis._setAdditiveIdentityNumeric();\\r\\n\\t\\tthis.buffer[ this._addIndex * 4 + 3 ] = 1;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t_setAdditiveIdentityOther: function () {\\r\\n\\r\\n\\t\\tvar startIndex = this._origIndex * this.valueSize;\\r\\n\\t\\tvar targetIndex = this._addIndex * this.valueSize;\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < this.valueSize; i ++ ) {\\r\\n\\r\\n\\t\\t\\tthis.buffer[ targetIndex + i ] = this.buffer[ startIndex + i ];\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\r\\n\\t// mix functions\\r\\n\\r\\n\\t_select: function ( buffer, dstOffset, srcOffset, t, stride ) {\\r\\n\\r\\n\\t\\tif ( t >= 0.5 ) {\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0; i !== stride; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\tbuffer[ dstOffset + i ] = buffer[ srcOffset + i ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t_slerp: function ( buffer, dstOffset, srcOffset, t ) {\\r\\n\\r\\n\\t\\tQuaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t_slerpAdditive: function ( buffer, dstOffset, srcOffset, t, stride ) {\\r\\n\\r\\n\\t\\tvar workOffset = this._workIndex * stride;\\r\\n\\r\\n\\t\\t// Store result in intermediate buffer offset\\r\\n\\t\\tQuaternion.multiplyQuaternionsFlat( buffer, workOffset, buffer, dstOffset, buffer, srcOffset );\\r\\n\\r\\n\\t\\t// Slerp to the intermediate result\\r\\n\\t\\tQuaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t_lerp: function ( buffer, dstOffset, srcOffset, t, stride ) {\\r\\n\\r\\n\\t\\tvar s = 1 - t;\\r\\n\\r\\n\\t\\tfor ( var i = 0; i !== stride; ++ i ) {\\r\\n\\r\\n\\t\\t\\tvar j = dstOffset + i;\\r\\n\\r\\n\\t\\t\\tbuffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t_lerpAdditive: function ( buffer, dstOffset, srcOffset, t, stride ) {\\r\\n\\r\\n\\t\\tfor ( var i = 0; i !== stride; ++ i ) {\\r\\n\\r\\n\\t\\t\\tvar j = dstOffset + i;\\r\\n\\r\\n\\t\\t\\tbuffer[ j ] = buffer[ j ] + buffer[ srcOffset + i ] * t;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n *\\r\\n * A reference to a real property in the scene graph.\\r\\n *\\r\\n *\\r\\n * @author Ben Houston / http://clara.io/\\r\\n * @author David Sarno / http://lighthaus.us/\\r\\n * @author tschw\\r\\n */\\r\\n\\r\\n// Characters [].:/ are reserved for track binding syntax.\\r\\nvar _RESERVED_CHARS_RE = '\\\\\\\\[\\\\\\\\]\\\\\\\\.:\\\\\\\\/';\\r\\nvar _reservedRe = new RegExp( '[' + _RESERVED_CHARS_RE + ']', 'g' );\\r\\n\\r\\n// Attempts to allow node names from any language. ES5's `\\\\w` regexp matches\\r\\n// only latin characters, and the unicode \\\\p{L} is not yet supported. So\\r\\n// instead, we exclude reserved characters and match everything else.\\r\\nvar _wordChar = '[^' + _RESERVED_CHARS_RE + ']';\\r\\nvar _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace( '\\\\\\\\.', '' ) + ']';\\r\\n\\r\\n// Parent directories, delimited by '/' or ':'. Currently unused, but must\\r\\n// be matched to parse the rest of the track name.\\r\\nvar _directoryRe = /((?:WC+[\\\\/:])*)/.source.replace( 'WC', _wordChar );\\r\\n\\r\\n// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.\\r\\nvar _nodeRe = /(WCOD+)?/.source.replace( 'WCOD', _wordCharOrDot );\\r\\n\\r\\n// Object on target node, and accessor. May not contain reserved\\r\\n// characters. Accessor may contain any character except closing bracket.\\r\\nvar _objectRe = /(?:\\\\.(WC+)(?:\\\\[(.+)\\\\])?)?/.source.replace( 'WC', _wordChar );\\r\\n\\r\\n// Property and accessor. May not contain reserved characters. Accessor may\\r\\n// contain any non-bracket characters.\\r\\nvar _propertyRe = /\\\\.(WC+)(?:\\\\[(.+)\\\\])?/.source.replace( 'WC', _wordChar );\\r\\n\\r\\nvar _trackRe = new RegExp( ''\\r\\n\\t+ '^'\\r\\n\\t+ _directoryRe\\r\\n\\t+ _nodeRe\\r\\n\\t+ _objectRe\\r\\n\\t+ _propertyRe\\r\\n\\t+ '$'\\r\\n);\\r\\n\\r\\nvar _supportedObjectNames = [ 'material', 'materials', 'bones' ];\\r\\n\\r\\nfunction Composite( targetGroup, path, optionalParsedPath ) {\\r\\n\\r\\n\\tvar parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );\\r\\n\\r\\n\\tthis._targetGroup = targetGroup;\\r\\n\\tthis._bindings = targetGroup.subscribe_( path, parsedPath );\\r\\n\\r\\n}\\r\\n\\r\\nObject.assign( Composite.prototype, {\\r\\n\\r\\n\\tgetValue: function ( array, offset ) {\\r\\n\\r\\n\\t\\tthis.bind(); // bind all binding\\r\\n\\r\\n\\t\\tvar firstValidIndex = this._targetGroup.nCachedObjects_,\\r\\n\\t\\t\\tbinding = this._bindings[ firstValidIndex ];\\r\\n\\r\\n\\t\\t// and only call .getValue on the first\\r\\n\\t\\tif ( binding !== undefined ) binding.getValue( array, offset );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetValue: function ( array, offset ) {\\r\\n\\r\\n\\t\\tvar bindings = this._bindings;\\r\\n\\r\\n\\t\\tfor ( var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\t\\tbindings[ i ].setValue( array, offset );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tbind: function () {\\r\\n\\r\\n\\t\\tvar bindings = this._bindings;\\r\\n\\r\\n\\t\\tfor ( var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\t\\tbindings[ i ].bind();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tunbind: function () {\\r\\n\\r\\n\\t\\tvar bindings = this._bindings;\\r\\n\\r\\n\\t\\tfor ( var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\t\\tbindings[ i ].unbind();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n\\r\\nfunction PropertyBinding( rootNode, path, parsedPath ) {\\r\\n\\r\\n\\tthis.path = path;\\r\\n\\tthis.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );\\r\\n\\r\\n\\tthis.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;\\r\\n\\r\\n\\tthis.rootNode = rootNode;\\r\\n\\r\\n}\\r\\n\\r\\nObject.assign( PropertyBinding, {\\r\\n\\r\\n\\tComposite: Composite,\\r\\n\\r\\n\\tcreate: function ( root, path, parsedPath ) {\\r\\n\\r\\n\\t\\tif ( ! ( root && root.isAnimationObjectGroup ) ) {\\r\\n\\r\\n\\t\\t\\treturn new PropertyBinding( root, path, parsedPath );\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\treturn new PropertyBinding.Composite( root, path, parsedPath );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t/**\\r\\n\\t * Replaces spaces with underscores and removes unsupported characters from\\r\\n\\t * node names, to ensure compatibility with parseTrackName().\\r\\n\\t *\\r\\n\\t * @param {string} name Node name to be sanitized.\\r\\n\\t * @return {string}\\r\\n\\t */\\r\\n\\tsanitizeNodeName: function ( name ) {\\r\\n\\r\\n\\t\\treturn name.replace( /\\\\s/g, '_' ).replace( _reservedRe, '' );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tparseTrackName: function ( trackName ) {\\r\\n\\r\\n\\t\\tvar matches = _trackRe.exec( trackName );\\r\\n\\r\\n\\t\\tif ( ! matches ) {\\r\\n\\r\\n\\t\\t\\tthrow new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar results = {\\r\\n\\t\\t\\t// directoryName: matches[ 1 ], // (tschw) currently unused\\r\\n\\t\\t\\tnodeName: matches[ 2 ],\\r\\n\\t\\t\\tobjectName: matches[ 3 ],\\r\\n\\t\\t\\tobjectIndex: matches[ 4 ],\\r\\n\\t\\t\\tpropertyName: matches[ 5 ], // required\\r\\n\\t\\t\\tpropertyIndex: matches[ 6 ]\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tvar lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );\\r\\n\\r\\n\\t\\tif ( lastDot !== undefined && lastDot !== - 1 ) {\\r\\n\\r\\n\\t\\t\\tvar objectName = results.nodeName.substring( lastDot + 1 );\\r\\n\\r\\n\\t\\t\\t// Object names must be checked against a whitelist. Otherwise, there\\r\\n\\t\\t\\t// is no way to parse 'foo.bar.baz': 'baz' must be a property, but\\r\\n\\t\\t\\t// 'bar' could be the objectName, or part of a nodeName (which can\\r\\n\\t\\t\\t// include '.' characters).\\r\\n\\t\\t\\tif ( _supportedObjectNames.indexOf( objectName ) !== - 1 ) {\\r\\n\\r\\n\\t\\t\\t\\tresults.nodeName = results.nodeName.substring( 0, lastDot );\\r\\n\\t\\t\\t\\tresults.objectName = objectName;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( results.propertyName === null || results.propertyName.length === 0 ) {\\r\\n\\r\\n\\t\\t\\tthrow new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn results;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tfindNode: function ( root, nodeName ) {\\r\\n\\r\\n\\t\\tif ( ! nodeName || nodeName === \\\"\\\" || nodeName === \\\".\\\" || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {\\r\\n\\r\\n\\t\\t\\treturn root;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// search into skeleton bones.\\r\\n\\t\\tif ( root.skeleton ) {\\r\\n\\r\\n\\t\\t\\tvar bone = root.skeleton.getBoneByName( nodeName );\\r\\n\\r\\n\\t\\t\\tif ( bone !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\treturn bone;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// search into node subtree.\\r\\n\\t\\tif ( root.children ) {\\r\\n\\r\\n\\t\\t\\tvar searchNodeSubtree = function ( children ) {\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0; i < children.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar childNode = children[ i ];\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( childNode.name === nodeName || childNode.uuid === nodeName ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\treturn childNode;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tvar result = searchNodeSubtree( childNode.children );\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( result ) return result;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\treturn null;\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\tvar subTreeNode = searchNodeSubtree( root.children );\\r\\n\\r\\n\\t\\t\\tif ( subTreeNode ) {\\r\\n\\r\\n\\t\\t\\t\\treturn subTreeNode;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn null;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nObject.assign( PropertyBinding.prototype, { // prototype, continued\\r\\n\\r\\n\\t// these are used to \\\"bind\\\" a nonexistent property\\r\\n\\t_getValue_unavailable: function () {},\\r\\n\\t_setValue_unavailable: function () {},\\r\\n\\r\\n\\tBindingType: {\\r\\n\\t\\tDirect: 0,\\r\\n\\t\\tEntireArray: 1,\\r\\n\\t\\tArrayElement: 2,\\r\\n\\t\\tHasFromToArray: 3\\r\\n\\t},\\r\\n\\r\\n\\tVersioning: {\\r\\n\\t\\tNone: 0,\\r\\n\\t\\tNeedsUpdate: 1,\\r\\n\\t\\tMatrixWorldNeedsUpdate: 2\\r\\n\\t},\\r\\n\\r\\n\\tGetterByBindingType: [\\r\\n\\r\\n\\t\\tfunction getValue_direct( buffer, offset ) {\\r\\n\\r\\n\\t\\t\\tbuffer[ offset ] = this.node[ this.propertyName ];\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tfunction getValue_array( buffer, offset ) {\\r\\n\\r\\n\\t\\t\\tvar source = this.resolvedProperty;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, n = source.length; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\tbuffer[ offset ++ ] = source[ i ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tfunction getValue_arrayElement( buffer, offset ) {\\r\\n\\r\\n\\t\\t\\tbuffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tfunction getValue_toArray( buffer, offset ) {\\r\\n\\r\\n\\t\\t\\tthis.resolvedProperty.toArray( buffer, offset );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t],\\r\\n\\r\\n\\tSetterByBindingTypeAndVersioning: [\\r\\n\\r\\n\\t\\t[\\r\\n\\t\\t\\t// Direct\\r\\n\\r\\n\\t\\t\\tfunction setValue_direct( buffer, offset ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\tfunction setValue_direct_setNeedsUpdate( buffer, offset ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\\r\\n\\t\\t\\t\\tthis.targetObject.needsUpdate = true;\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\tfunction setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\\r\\n\\t\\t\\t\\tthis.targetObject.matrixWorldNeedsUpdate = true;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t], [\\r\\n\\r\\n\\t\\t\\t// EntireArray\\r\\n\\r\\n\\t\\t\\tfunction setValue_array( buffer, offset ) {\\r\\n\\r\\n\\t\\t\\t\\tvar dest = this.resolvedProperty;\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tdest[ i ] = buffer[ offset ++ ];\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\tfunction setValue_array_setNeedsUpdate( buffer, offset ) {\\r\\n\\r\\n\\t\\t\\t\\tvar dest = this.resolvedProperty;\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tdest[ i ] = buffer[ offset ++ ];\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tthis.targetObject.needsUpdate = true;\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\tfunction setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {\\r\\n\\r\\n\\t\\t\\t\\tvar dest = this.resolvedProperty;\\r\\n\\r\\n\\t\\t\\t\\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tdest[ i ] = buffer[ offset ++ ];\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tthis.targetObject.matrixWorldNeedsUpdate = true;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t], [\\r\\n\\r\\n\\t\\t\\t// ArrayElement\\r\\n\\r\\n\\t\\t\\tfunction setValue_arrayElement( buffer, offset ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\tfunction setValue_arrayElement_setNeedsUpdate( buffer, offset ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\\r\\n\\t\\t\\t\\tthis.targetObject.needsUpdate = true;\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\tfunction setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\\r\\n\\t\\t\\t\\tthis.targetObject.matrixWorldNeedsUpdate = true;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t], [\\r\\n\\r\\n\\t\\t\\t// HasToFromArray\\r\\n\\r\\n\\t\\t\\tfunction setValue_fromArray( buffer, offset ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.resolvedProperty.fromArray( buffer, offset );\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\tfunction setValue_fromArray_setNeedsUpdate( buffer, offset ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.resolvedProperty.fromArray( buffer, offset );\\r\\n\\t\\t\\t\\tthis.targetObject.needsUpdate = true;\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\tfunction setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.resolvedProperty.fromArray( buffer, offset );\\r\\n\\t\\t\\t\\tthis.targetObject.matrixWorldNeedsUpdate = true;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t]\\r\\n\\r\\n\\t],\\r\\n\\r\\n\\tgetValue: function getValue_unbound( targetArray, offset ) {\\r\\n\\r\\n\\t\\tthis.bind();\\r\\n\\t\\tthis.getValue( targetArray, offset );\\r\\n\\r\\n\\t\\t// Note: This class uses a State pattern on a per-method basis:\\r\\n\\t\\t// 'bind' sets 'this.getValue' / 'setValue' and shadows the\\r\\n\\t\\t// prototype version of these methods with one that represents\\r\\n\\t\\t// the bound state. When the property is not found, the methods\\r\\n\\t\\t// become no-ops.\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetValue: function getValue_unbound( sourceArray, offset ) {\\r\\n\\r\\n\\t\\tthis.bind();\\r\\n\\t\\tthis.setValue( sourceArray, offset );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// create getter / setter pair for a property in the scene graph\\r\\n\\tbind: function () {\\r\\n\\r\\n\\t\\tvar targetObject = this.node,\\r\\n\\t\\t\\tparsedPath = this.parsedPath,\\r\\n\\r\\n\\t\\t\\tobjectName = parsedPath.objectName,\\r\\n\\t\\t\\tpropertyName = parsedPath.propertyName,\\r\\n\\t\\t\\tpropertyIndex = parsedPath.propertyIndex;\\r\\n\\r\\n\\t\\tif ( ! targetObject ) {\\r\\n\\r\\n\\t\\t\\ttargetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode;\\r\\n\\r\\n\\t\\t\\tthis.node = targetObject;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// set fail state so we can just 'return' on error\\r\\n\\t\\tthis.getValue = this._getValue_unavailable;\\r\\n\\t\\tthis.setValue = this._setValue_unavailable;\\r\\n\\r\\n\\t\\t// ensure there is a value node\\r\\n\\t\\tif ( ! targetObject ) {\\r\\n\\r\\n\\t\\t\\tconsole.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\\\\'t found.' );\\r\\n\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( objectName ) {\\r\\n\\r\\n\\t\\t\\tvar objectIndex = parsedPath.objectIndex;\\r\\n\\r\\n\\t\\t\\t// special cases were we need to reach deeper into the hierarchy to get the face materials....\\r\\n\\t\\t\\tswitch ( objectName ) {\\r\\n\\r\\n\\t\\t\\t\\tcase 'materials':\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( ! targetObject.material ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );\\r\\n\\t\\t\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( ! targetObject.material.materials ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );\\r\\n\\t\\t\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\ttargetObject = targetObject.material.materials;\\r\\n\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\tcase 'bones':\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( ! targetObject.skeleton ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );\\r\\n\\t\\t\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t// potential future optimization: skip this if propertyIndex is already an integer\\r\\n\\t\\t\\t\\t\\t// and convert the integer string to a true integer.\\r\\n\\r\\n\\t\\t\\t\\t\\ttargetObject = targetObject.skeleton.bones;\\r\\n\\r\\n\\t\\t\\t\\t\\t// support resolving morphTarget names into indices.\\r\\n\\t\\t\\t\\t\\tfor ( var i = 0; i < targetObject.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif ( targetObject[ i ].name === objectIndex ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\tobjectIndex = i;\\r\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\tdefault:\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( targetObject[ objectName ] === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );\\r\\n\\t\\t\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\ttargetObject = targetObject[ objectName ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\r\\n\\t\\t\\tif ( objectIndex !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tif ( targetObject[ objectIndex ] === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );\\r\\n\\t\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\ttargetObject = targetObject[ objectIndex ];\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// resolve property\\r\\n\\t\\tvar nodeProperty = targetObject[ propertyName ];\\r\\n\\r\\n\\t\\tif ( nodeProperty === undefined ) {\\r\\n\\r\\n\\t\\t\\tvar nodeName = parsedPath.nodeName;\\r\\n\\r\\n\\t\\t\\tconsole.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +\\r\\n\\t\\t\\t\\t'.' + propertyName + ' but it wasn\\\\'t found.', targetObject );\\r\\n\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// determine versioning scheme\\r\\n\\t\\tvar versioning = this.Versioning.None;\\r\\n\\r\\n\\t\\tthis.targetObject = targetObject;\\r\\n\\r\\n\\t\\tif ( targetObject.needsUpdate !== undefined ) { // material\\r\\n\\r\\n\\t\\t\\tversioning = this.Versioning.NeedsUpdate;\\r\\n\\r\\n\\t\\t} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform\\r\\n\\r\\n\\t\\t\\tversioning = this.Versioning.MatrixWorldNeedsUpdate;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// determine how the property gets bound\\r\\n\\t\\tvar bindingType = this.BindingType.Direct;\\r\\n\\r\\n\\t\\tif ( propertyIndex !== undefined ) {\\r\\n\\r\\n\\t\\t\\t// access a sub element of the property array (only primitives are supported right now)\\r\\n\\r\\n\\t\\t\\tif ( propertyName === \\\"morphTargetInfluences\\\" ) {\\r\\n\\r\\n\\t\\t\\t\\t// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\\r\\n\\r\\n\\t\\t\\t\\t// support resolving morphTarget names into indices.\\r\\n\\t\\t\\t\\tif ( ! targetObject.geometry ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );\\r\\n\\t\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( targetObject.geometry.isBufferGeometry ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( ! targetObject.geometry.morphAttributes ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );\\r\\n\\t\\t\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( targetObject.morphTargetDictionary[ propertyIndex ] !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tpropertyIndex = targetObject.morphTargetDictionary[ propertyIndex ];\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.', this );\\r\\n\\t\\t\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tbindingType = this.BindingType.ArrayElement;\\r\\n\\r\\n\\t\\t\\tthis.resolvedProperty = nodeProperty;\\r\\n\\t\\t\\tthis.propertyIndex = propertyIndex;\\r\\n\\r\\n\\t\\t} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {\\r\\n\\r\\n\\t\\t\\t// must use copy for Object3D.Euler/Quaternion\\r\\n\\r\\n\\t\\t\\tbindingType = this.BindingType.HasFromToArray;\\r\\n\\r\\n\\t\\t\\tthis.resolvedProperty = nodeProperty;\\r\\n\\r\\n\\t\\t} else if ( Array.isArray( nodeProperty ) ) {\\r\\n\\r\\n\\t\\t\\tbindingType = this.BindingType.EntireArray;\\r\\n\\r\\n\\t\\t\\tthis.resolvedProperty = nodeProperty;\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tthis.propertyName = propertyName;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// select getter / setter\\r\\n\\t\\tthis.getValue = this.GetterByBindingType[ bindingType ];\\r\\n\\t\\tthis.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tunbind: function () {\\r\\n\\r\\n\\t\\tthis.node = null;\\r\\n\\r\\n\\t\\t// back to the prototype version of getValue / setValue\\r\\n\\t\\t// note: avoiding to mutate the shape of 'this' via 'delete'\\r\\n\\t\\tthis.getValue = this._getValue_unbound;\\r\\n\\t\\tthis.setValue = this._setValue_unbound;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n// DECLARE ALIAS AFTER assign prototype\\r\\nObject.assign( PropertyBinding.prototype, {\\r\\n\\r\\n\\t// initial state of these methods that calls 'bind'\\r\\n\\t_getValue_unbound: PropertyBinding.prototype.getValue,\\r\\n\\t_setValue_unbound: PropertyBinding.prototype.setValue,\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n *\\r\\n * A group of objects that receives a shared animation state.\\r\\n *\\r\\n * Usage:\\r\\n *\\r\\n *  - Add objects you would otherwise pass as 'root' to the\\r\\n *    constructor or the .clipAction method of AnimationMixer.\\r\\n *\\r\\n *  - Instead pass this object as 'root'.\\r\\n *\\r\\n *  - You can also add and remove objects later when the mixer\\r\\n *    is running.\\r\\n *\\r\\n * Note:\\r\\n *\\r\\n *    Objects of this class appear as one object to the mixer,\\r\\n *    so cache control of the individual objects must be done\\r\\n *    on the group.\\r\\n *\\r\\n * Limitation:\\r\\n *\\r\\n *  - The animated properties must be compatible among the\\r\\n *    all objects in the group.\\r\\n *\\r\\n *  - A single property can either be controlled through a\\r\\n *    target group or directly, but not both.\\r\\n *\\r\\n * @author tschw\\r\\n */\\r\\n\\r\\nfunction AnimationObjectGroup() {\\r\\n\\r\\n\\tthis.uuid = MathUtils.generateUUID();\\r\\n\\r\\n\\t// cached objects followed by the active ones\\r\\n\\tthis._objects = Array.prototype.slice.call( arguments );\\r\\n\\r\\n\\tthis.nCachedObjects_ = 0; // threshold\\r\\n\\t// note: read by PropertyBinding.Composite\\r\\n\\r\\n\\tvar indices = {};\\r\\n\\tthis._indicesByUUID = indices; // for bookkeeping\\r\\n\\r\\n\\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\tindices[ arguments[ i ].uuid ] = i;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tthis._paths = []; // inside: string\\r\\n\\tthis._parsedPaths = []; // inside: { we don't care, here }\\r\\n\\tthis._bindings = []; // inside: Array< PropertyBinding >\\r\\n\\tthis._bindingsIndicesByPath = {}; // inside: indices in these arrays\\r\\n\\r\\n\\tvar scope = this;\\r\\n\\r\\n\\tthis.stats = {\\r\\n\\r\\n\\t\\tobjects: {\\r\\n\\t\\t\\tget total() {\\r\\n\\r\\n\\t\\t\\t\\treturn scope._objects.length;\\r\\n\\r\\n\\t\\t\\t},\\r\\n\\t\\t\\tget inUse() {\\r\\n\\r\\n\\t\\t\\t\\treturn this.total - scope.nCachedObjects_;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t},\\r\\n\\t\\tget bindingsPerObject() {\\r\\n\\r\\n\\t\\t\\treturn scope._bindings.length;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t};\\r\\n\\r\\n}\\r\\n\\r\\nObject.assign( AnimationObjectGroup.prototype, {\\r\\n\\r\\n\\tisAnimationObjectGroup: true,\\r\\n\\r\\n\\tadd: function () {\\r\\n\\r\\n\\t\\tvar objects = this._objects,\\r\\n\\t\\t\\tnObjects = objects.length,\\r\\n\\t\\t\\tnCachedObjects = this.nCachedObjects_,\\r\\n\\t\\t\\tindicesByUUID = this._indicesByUUID,\\r\\n\\t\\t\\tpaths = this._paths,\\r\\n\\t\\t\\tparsedPaths = this._parsedPaths,\\r\\n\\t\\t\\tbindings = this._bindings,\\r\\n\\t\\t\\tnBindings = bindings.length,\\r\\n\\t\\t\\tknownObject = undefined;\\r\\n\\r\\n\\t\\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\t\\tvar object = arguments[ i ],\\r\\n\\t\\t\\t\\tuuid = object.uuid,\\r\\n\\t\\t\\t\\tindex = indicesByUUID[ uuid ];\\r\\n\\r\\n\\t\\t\\tif ( index === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t// unknown object -> add it to the ACTIVE region\\r\\n\\r\\n\\t\\t\\t\\tindex = nObjects ++;\\r\\n\\t\\t\\t\\tindicesByUUID[ uuid ] = index;\\r\\n\\t\\t\\t\\tobjects.push( object );\\r\\n\\r\\n\\t\\t\\t\\t// accounting is done, now do the same for all bindings\\r\\n\\r\\n\\t\\t\\t\\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tbindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} else if ( index < nCachedObjects ) {\\r\\n\\r\\n\\t\\t\\t\\tknownObject = objects[ index ];\\r\\n\\r\\n\\t\\t\\t\\t// move existing object to the ACTIVE region\\r\\n\\r\\n\\t\\t\\t\\tvar firstActiveIndex = -- nCachedObjects,\\r\\n\\t\\t\\t\\t\\tlastCachedObject = objects[ firstActiveIndex ];\\r\\n\\r\\n\\t\\t\\t\\tindicesByUUID[ lastCachedObject.uuid ] = index;\\r\\n\\t\\t\\t\\tobjects[ index ] = lastCachedObject;\\r\\n\\r\\n\\t\\t\\t\\tindicesByUUID[ uuid ] = firstActiveIndex;\\r\\n\\t\\t\\t\\tobjects[ firstActiveIndex ] = object;\\r\\n\\r\\n\\t\\t\\t\\t// accounting is done, now do the same for all bindings\\r\\n\\r\\n\\t\\t\\t\\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar bindingsForPath = bindings[ j ],\\r\\n\\t\\t\\t\\t\\t\\tlastCached = bindingsForPath[ firstActiveIndex ],\\r\\n\\t\\t\\t\\t\\t\\tbinding = bindingsForPath[ index ];\\r\\n\\r\\n\\t\\t\\t\\t\\tbindingsForPath[ index ] = lastCached;\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( binding === undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// since we do not bother to create new bindings\\r\\n\\t\\t\\t\\t\\t\\t// for objects that are cached, the binding may\\r\\n\\t\\t\\t\\t\\t\\t// or may not exist\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbinding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tbindingsForPath[ firstActiveIndex ] = binding;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} else if ( objects[ index ] !== knownObject ) {\\r\\n\\r\\n\\t\\t\\t\\tconsole.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +\\r\\n\\t\\t\\t\\t\\t'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );\\r\\n\\r\\n\\t\\t\\t} // else the object is already where we want it to be\\r\\n\\r\\n\\t\\t} // for arguments\\r\\n\\r\\n\\t\\tthis.nCachedObjects_ = nCachedObjects;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tremove: function () {\\r\\n\\r\\n\\t\\tvar objects = this._objects,\\r\\n\\t\\t\\tnCachedObjects = this.nCachedObjects_,\\r\\n\\t\\t\\tindicesByUUID = this._indicesByUUID,\\r\\n\\t\\t\\tbindings = this._bindings,\\r\\n\\t\\t\\tnBindings = bindings.length;\\r\\n\\r\\n\\t\\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\t\\tvar object = arguments[ i ],\\r\\n\\t\\t\\t\\tuuid = object.uuid,\\r\\n\\t\\t\\t\\tindex = indicesByUUID[ uuid ];\\r\\n\\r\\n\\t\\t\\tif ( index !== undefined && index >= nCachedObjects ) {\\r\\n\\r\\n\\t\\t\\t\\t// move existing object into the CACHED region\\r\\n\\r\\n\\t\\t\\t\\tvar lastCachedIndex = nCachedObjects ++,\\r\\n\\t\\t\\t\\t\\tfirstActiveObject = objects[ lastCachedIndex ];\\r\\n\\r\\n\\t\\t\\t\\tindicesByUUID[ firstActiveObject.uuid ] = index;\\r\\n\\t\\t\\t\\tobjects[ index ] = firstActiveObject;\\r\\n\\r\\n\\t\\t\\t\\tindicesByUUID[ uuid ] = lastCachedIndex;\\r\\n\\t\\t\\t\\tobjects[ lastCachedIndex ] = object;\\r\\n\\r\\n\\t\\t\\t\\t// accounting is done, now do the same for all bindings\\r\\n\\r\\n\\t\\t\\t\\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tvar bindingsForPath = bindings[ j ],\\r\\n\\t\\t\\t\\t\\t\\tfirstActive = bindingsForPath[ lastCachedIndex ],\\r\\n\\t\\t\\t\\t\\t\\tbinding = bindingsForPath[ index ];\\r\\n\\r\\n\\t\\t\\t\\t\\tbindingsForPath[ index ] = firstActive;\\r\\n\\t\\t\\t\\t\\tbindingsForPath[ lastCachedIndex ] = binding;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t} // for arguments\\r\\n\\r\\n\\t\\tthis.nCachedObjects_ = nCachedObjects;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// remove & forget\\r\\n\\tuncache: function () {\\r\\n\\r\\n\\t\\tvar objects = this._objects,\\r\\n\\t\\t\\tnObjects = objects.length,\\r\\n\\t\\t\\tnCachedObjects = this.nCachedObjects_,\\r\\n\\t\\t\\tindicesByUUID = this._indicesByUUID,\\r\\n\\t\\t\\tbindings = this._bindings,\\r\\n\\t\\t\\tnBindings = bindings.length;\\r\\n\\r\\n\\t\\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\t\\tvar object = arguments[ i ],\\r\\n\\t\\t\\t\\tuuid = object.uuid,\\r\\n\\t\\t\\t\\tindex = indicesByUUID[ uuid ];\\r\\n\\r\\n\\t\\t\\tif ( index !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tdelete indicesByUUID[ uuid ];\\r\\n\\r\\n\\t\\t\\t\\tif ( index < nCachedObjects ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// object is cached, shrink the CACHED region\\r\\n\\r\\n\\t\\t\\t\\t\\tvar firstActiveIndex = -- nCachedObjects,\\r\\n\\t\\t\\t\\t\\t\\tlastCachedObject = objects[ firstActiveIndex ],\\r\\n\\t\\t\\t\\t\\t\\tlastIndex = -- nObjects,\\r\\n\\t\\t\\t\\t\\t\\tlastObject = objects[ lastIndex ];\\r\\n\\r\\n\\t\\t\\t\\t\\t// last cached object takes this object's place\\r\\n\\t\\t\\t\\t\\tindicesByUUID[ lastCachedObject.uuid ] = index;\\r\\n\\t\\t\\t\\t\\tobjects[ index ] = lastCachedObject;\\r\\n\\r\\n\\t\\t\\t\\t\\t// last object goes to the activated slot and pop\\r\\n\\t\\t\\t\\t\\tindicesByUUID[ lastObject.uuid ] = firstActiveIndex;\\r\\n\\t\\t\\t\\t\\tobjects[ firstActiveIndex ] = lastObject;\\r\\n\\t\\t\\t\\t\\tobjects.pop();\\r\\n\\r\\n\\t\\t\\t\\t\\t// accounting is done, now do the same for all bindings\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar bindingsForPath = bindings[ j ],\\r\\n\\t\\t\\t\\t\\t\\t\\tlastCached = bindingsForPath[ firstActiveIndex ],\\r\\n\\t\\t\\t\\t\\t\\t\\tlast = bindingsForPath[ lastIndex ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbindingsForPath[ index ] = lastCached;\\r\\n\\t\\t\\t\\t\\t\\tbindingsForPath[ firstActiveIndex ] = last;\\r\\n\\t\\t\\t\\t\\t\\tbindingsForPath.pop();\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t// object is active, just swap with the last and pop\\r\\n\\r\\n\\t\\t\\t\\t\\tvar lastIndex = -- nObjects,\\r\\n\\t\\t\\t\\t\\t\\tlastObject = objects[ lastIndex ];\\r\\n\\r\\n\\t\\t\\t\\t\\tindicesByUUID[ lastObject.uuid ] = index;\\r\\n\\t\\t\\t\\t\\tobjects[ index ] = lastObject;\\r\\n\\t\\t\\t\\t\\tobjects.pop();\\r\\n\\r\\n\\t\\t\\t\\t\\t// accounting is done, now do the same for all bindings\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar bindingsForPath = bindings[ j ];\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tbindingsForPath[ index ] = bindingsForPath[ lastIndex ];\\r\\n\\t\\t\\t\\t\\t\\tbindingsForPath.pop();\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t} // cached or active\\r\\n\\r\\n\\t\\t\\t} // if object is known\\r\\n\\r\\n\\t\\t} // for arguments\\r\\n\\r\\n\\t\\tthis.nCachedObjects_ = nCachedObjects;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// Internal interface used by befriended PropertyBinding.Composite:\\r\\n\\r\\n\\tsubscribe_: function ( path, parsedPath ) {\\r\\n\\r\\n\\t\\t// returns an array of bindings for the given path that is changed\\r\\n\\t\\t// according to the contained objects in the group\\r\\n\\r\\n\\t\\tvar indicesByPath = this._bindingsIndicesByPath,\\r\\n\\t\\t\\tindex = indicesByPath[ path ],\\r\\n\\t\\t\\tbindings = this._bindings;\\r\\n\\r\\n\\t\\tif ( index !== undefined ) return bindings[ index ];\\r\\n\\r\\n\\t\\tvar paths = this._paths,\\r\\n\\t\\t\\tparsedPaths = this._parsedPaths,\\r\\n\\t\\t\\tobjects = this._objects,\\r\\n\\t\\t\\tnObjects = objects.length,\\r\\n\\t\\t\\tnCachedObjects = this.nCachedObjects_,\\r\\n\\t\\t\\tbindingsForPath = new Array( nObjects );\\r\\n\\r\\n\\t\\tindex = bindings.length;\\r\\n\\r\\n\\t\\tindicesByPath[ path ] = index;\\r\\n\\r\\n\\t\\tpaths.push( path );\\r\\n\\t\\tparsedPaths.push( parsedPath );\\r\\n\\t\\tbindings.push( bindingsForPath );\\r\\n\\r\\n\\t\\tfor ( var i = nCachedObjects, n = objects.length; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\t\\tvar object = objects[ i ];\\r\\n\\t\\t\\tbindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn bindingsForPath;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tunsubscribe_: function ( path ) {\\r\\n\\r\\n\\t\\t// tells the group to forget about a property path and no longer\\r\\n\\t\\t// update the array previously obtained with 'subscribe_'\\r\\n\\r\\n\\t\\tvar indicesByPath = this._bindingsIndicesByPath,\\r\\n\\t\\t\\tindex = indicesByPath[ path ];\\r\\n\\r\\n\\t\\tif ( index !== undefined ) {\\r\\n\\r\\n\\t\\t\\tvar paths = this._paths,\\r\\n\\t\\t\\t\\tparsedPaths = this._parsedPaths,\\r\\n\\t\\t\\t\\tbindings = this._bindings,\\r\\n\\t\\t\\t\\tlastBindingsIndex = bindings.length - 1,\\r\\n\\t\\t\\t\\tlastBindings = bindings[ lastBindingsIndex ],\\r\\n\\t\\t\\t\\tlastBindingsPath = path[ lastBindingsIndex ];\\r\\n\\r\\n\\t\\t\\tindicesByPath[ lastBindingsPath ] = index;\\r\\n\\r\\n\\t\\t\\tbindings[ index ] = lastBindings;\\r\\n\\t\\t\\tbindings.pop();\\r\\n\\r\\n\\t\\t\\tparsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];\\r\\n\\t\\t\\tparsedPaths.pop();\\r\\n\\r\\n\\t\\t\\tpaths[ index ] = paths[ lastBindingsIndex ];\\r\\n\\t\\t\\tpaths.pop();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n *\\r\\n * Action provided by AnimationMixer for scheduling clip playback on specific\\r\\n * objects.\\r\\n *\\r\\n * @author Ben Houston / http://clara.io/\\r\\n * @author David Sarno / http://lighthaus.us/\\r\\n * @author tschw\\r\\n *\\r\\n */\\r\\n\\r\\nfunction AnimationAction( mixer, clip, localRoot, blendMode ) {\\r\\n\\r\\n\\tthis._mixer = mixer;\\r\\n\\tthis._clip = clip;\\r\\n\\tthis._localRoot = localRoot || null;\\r\\n\\tthis.blendMode = blendMode || clip.blendMode;\\r\\n\\r\\n\\tvar tracks = clip.tracks,\\r\\n\\t\\tnTracks = tracks.length,\\r\\n\\t\\tinterpolants = new Array( nTracks );\\r\\n\\r\\n\\tvar interpolantSettings = {\\r\\n\\t\\tendingStart: ZeroCurvatureEnding,\\r\\n\\t\\tendingEnd: ZeroCurvatureEnding\\r\\n\\t};\\r\\n\\r\\n\\tfor ( var i = 0; i !== nTracks; ++ i ) {\\r\\n\\r\\n\\t\\tvar interpolant = tracks[ i ].createInterpolant( null );\\r\\n\\t\\tinterpolants[ i ] = interpolant;\\r\\n\\t\\tinterpolant.settings = interpolantSettings;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tthis._interpolantSettings = interpolantSettings;\\r\\n\\r\\n\\tthis._interpolants = interpolants; // bound by the mixer\\r\\n\\r\\n\\t// inside: PropertyMixer (managed by the mixer)\\r\\n\\tthis._propertyBindings = new Array( nTracks );\\r\\n\\r\\n\\tthis._cacheIndex = null; // for the memory manager\\r\\n\\tthis._byClipCacheIndex = null; // for the memory manager\\r\\n\\r\\n\\tthis._timeScaleInterpolant = null;\\r\\n\\tthis._weightInterpolant = null;\\r\\n\\r\\n\\tthis.loop = LoopRepeat;\\r\\n\\tthis._loopCount = - 1;\\r\\n\\r\\n\\t// global mixer time when the action is to be started\\r\\n\\t// it's set back to 'null' upon start of the action\\r\\n\\tthis._startTime = null;\\r\\n\\r\\n\\t// scaled local time of the action\\r\\n\\t// gets clamped or wrapped to 0..clip.duration according to loop\\r\\n\\tthis.time = 0;\\r\\n\\r\\n\\tthis.timeScale = 1;\\r\\n\\tthis._effectiveTimeScale = 1;\\r\\n\\r\\n\\tthis.weight = 1;\\r\\n\\tthis._effectiveWeight = 1;\\r\\n\\r\\n\\tthis.repetitions = Infinity; // no. of repetitions when looping\\r\\n\\r\\n\\tthis.paused = false; // true -> zero effective time scale\\r\\n\\tthis.enabled = true; // false -> zero effective weight\\r\\n\\r\\n\\tthis.clampWhenFinished = false;// keep feeding the last frame?\\r\\n\\r\\n\\tthis.zeroSlopeAtStart = true;// for smooth interpolation w/o separate\\r\\n\\tthis.zeroSlopeAtEnd = true;// clips for start, loop and end\\r\\n\\r\\n}\\r\\n\\r\\nObject.assign( AnimationAction.prototype, {\\r\\n\\r\\n\\t// State & Scheduling\\r\\n\\r\\n\\tplay: function () {\\r\\n\\r\\n\\t\\tthis._mixer._activateAction( this );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tstop: function () {\\r\\n\\r\\n\\t\\tthis._mixer._deactivateAction( this );\\r\\n\\r\\n\\t\\treturn this.reset();\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\treset: function () {\\r\\n\\r\\n\\t\\tthis.paused = false;\\r\\n\\t\\tthis.enabled = true;\\r\\n\\r\\n\\t\\tthis.time = 0; // restart clip\\r\\n\\t\\tthis._loopCount = - 1;// forget previous loops\\r\\n\\t\\tthis._startTime = null;// forget scheduling\\r\\n\\r\\n\\t\\treturn this.stopFading().stopWarping();\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tisRunning: function () {\\r\\n\\r\\n\\t\\treturn this.enabled && ! this.paused && this.timeScale !== 0 &&\\r\\n\\t\\t\\tthis._startTime === null && this._mixer._isActiveAction( this );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// return true when play has been called\\r\\n\\tisScheduled: function () {\\r\\n\\r\\n\\t\\treturn this._mixer._isActiveAction( this );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tstartAt: function ( time ) {\\r\\n\\r\\n\\t\\tthis._startTime = time;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetLoop: function ( mode, repetitions ) {\\r\\n\\r\\n\\t\\tthis.loop = mode;\\r\\n\\t\\tthis.repetitions = repetitions;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// Weight\\r\\n\\r\\n\\t// set the weight stopping any scheduled fading\\r\\n\\t// although .enabled = false yields an effective weight of zero, this\\r\\n\\t// method does *not* change .enabled, because it would be confusing\\r\\n\\tsetEffectiveWeight: function ( weight ) {\\r\\n\\r\\n\\t\\tthis.weight = weight;\\r\\n\\r\\n\\t\\t// note: same logic as when updated at runtime\\r\\n\\t\\tthis._effectiveWeight = this.enabled ? weight : 0;\\r\\n\\r\\n\\t\\treturn this.stopFading();\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// return the weight considering fading and .enabled\\r\\n\\tgetEffectiveWeight: function () {\\r\\n\\r\\n\\t\\treturn this._effectiveWeight;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tfadeIn: function ( duration ) {\\r\\n\\r\\n\\t\\treturn this._scheduleFading( duration, 0, 1 );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tfadeOut: function ( duration ) {\\r\\n\\r\\n\\t\\treturn this._scheduleFading( duration, 1, 0 );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcrossFadeFrom: function ( fadeOutAction, duration, warp ) {\\r\\n\\r\\n\\t\\tfadeOutAction.fadeOut( duration );\\r\\n\\t\\tthis.fadeIn( duration );\\r\\n\\r\\n\\t\\tif ( warp ) {\\r\\n\\r\\n\\t\\t\\tvar fadeInDuration = this._clip.duration,\\r\\n\\t\\t\\t\\tfadeOutDuration = fadeOutAction._clip.duration,\\r\\n\\r\\n\\t\\t\\t\\tstartEndRatio = fadeOutDuration / fadeInDuration,\\r\\n\\t\\t\\t\\tendStartRatio = fadeInDuration / fadeOutDuration;\\r\\n\\r\\n\\t\\t\\tfadeOutAction.warp( 1.0, startEndRatio, duration );\\r\\n\\t\\t\\tthis.warp( endStartRatio, 1.0, duration );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcrossFadeTo: function ( fadeInAction, duration, warp ) {\\r\\n\\r\\n\\t\\treturn fadeInAction.crossFadeFrom( this, duration, warp );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tstopFading: function () {\\r\\n\\r\\n\\t\\tvar weightInterpolant = this._weightInterpolant;\\r\\n\\r\\n\\t\\tif ( weightInterpolant !== null ) {\\r\\n\\r\\n\\t\\t\\tthis._weightInterpolant = null;\\r\\n\\t\\t\\tthis._mixer._takeBackControlInterpolant( weightInterpolant );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// Time Scale Control\\r\\n\\r\\n\\t// set the time scale stopping any scheduled warping\\r\\n\\t// although .paused = true yields an effective time scale of zero, this\\r\\n\\t// method does *not* change .paused, because it would be confusing\\r\\n\\tsetEffectiveTimeScale: function ( timeScale ) {\\r\\n\\r\\n\\t\\tthis.timeScale = timeScale;\\r\\n\\t\\tthis._effectiveTimeScale = this.paused ? 0 : timeScale;\\r\\n\\r\\n\\t\\treturn this.stopWarping();\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// return the time scale considering warping and .paused\\r\\n\\tgetEffectiveTimeScale: function () {\\r\\n\\r\\n\\t\\treturn this._effectiveTimeScale;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetDuration: function ( duration ) {\\r\\n\\r\\n\\t\\tthis.timeScale = this._clip.duration / duration;\\r\\n\\r\\n\\t\\treturn this.stopWarping();\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsyncWith: function ( action ) {\\r\\n\\r\\n\\t\\tthis.time = action.time;\\r\\n\\t\\tthis.timeScale = action.timeScale;\\r\\n\\r\\n\\t\\treturn this.stopWarping();\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\thalt: function ( duration ) {\\r\\n\\r\\n\\t\\treturn this.warp( this._effectiveTimeScale, 0, duration );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\twarp: function ( startTimeScale, endTimeScale, duration ) {\\r\\n\\r\\n\\t\\tvar mixer = this._mixer, now = mixer.time,\\r\\n\\t\\t\\tinterpolant = this._timeScaleInterpolant,\\r\\n\\r\\n\\t\\t\\ttimeScale = this.timeScale;\\r\\n\\r\\n\\t\\tif ( interpolant === null ) {\\r\\n\\r\\n\\t\\t\\tinterpolant = mixer._lendControlInterpolant();\\r\\n\\t\\t\\tthis._timeScaleInterpolant = interpolant;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar times = interpolant.parameterPositions,\\r\\n\\t\\t\\tvalues = interpolant.sampleValues;\\r\\n\\r\\n\\t\\ttimes[ 0 ] = now;\\r\\n\\t\\ttimes[ 1 ] = now + duration;\\r\\n\\r\\n\\t\\tvalues[ 0 ] = startTimeScale / timeScale;\\r\\n\\t\\tvalues[ 1 ] = endTimeScale / timeScale;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tstopWarping: function () {\\r\\n\\r\\n\\t\\tvar timeScaleInterpolant = this._timeScaleInterpolant;\\r\\n\\r\\n\\t\\tif ( timeScaleInterpolant !== null ) {\\r\\n\\r\\n\\t\\t\\tthis._timeScaleInterpolant = null;\\r\\n\\t\\t\\tthis._mixer._takeBackControlInterpolant( timeScaleInterpolant );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// Object Accessors\\r\\n\\r\\n\\tgetMixer: function () {\\r\\n\\r\\n\\t\\treturn this._mixer;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetClip: function () {\\r\\n\\r\\n\\t\\treturn this._clip;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetRoot: function () {\\r\\n\\r\\n\\t\\treturn this._localRoot || this._mixer._root;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// Interna\\r\\n\\r\\n\\t_update: function ( time, deltaTime, timeDirection, accuIndex ) {\\r\\n\\r\\n\\t\\t// called by the mixer\\r\\n\\r\\n\\t\\tif ( ! this.enabled ) {\\r\\n\\r\\n\\t\\t\\t// call ._updateWeight() to update ._effectiveWeight\\r\\n\\r\\n\\t\\t\\tthis._updateWeight( time );\\r\\n\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar startTime = this._startTime;\\r\\n\\r\\n\\t\\tif ( startTime !== null ) {\\r\\n\\r\\n\\t\\t\\t// check for scheduled start of action\\r\\n\\r\\n\\t\\t\\tvar timeRunning = ( time - startTime ) * timeDirection;\\r\\n\\t\\t\\tif ( timeRunning < 0 || timeDirection === 0 ) {\\r\\n\\r\\n\\t\\t\\t\\treturn; // yet to come / don't decide when delta = 0\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// start\\r\\n\\r\\n\\t\\t\\tthis._startTime = null; // unschedule\\r\\n\\t\\t\\tdeltaTime = timeDirection * timeRunning;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// apply time scale and advance time\\r\\n\\r\\n\\t\\tdeltaTime *= this._updateTimeScale( time );\\r\\n\\t\\tvar clipTime = this._updateTime( deltaTime );\\r\\n\\r\\n\\t\\t// note: _updateTime may disable the action resulting in\\r\\n\\t\\t// an effective weight of 0\\r\\n\\r\\n\\t\\tvar weight = this._updateWeight( time );\\r\\n\\r\\n\\t\\tif ( weight > 0 ) {\\r\\n\\r\\n\\t\\t\\tvar interpolants = this._interpolants;\\r\\n\\t\\t\\tvar propertyMixers = this._propertyBindings;\\r\\n\\r\\n\\t\\t\\tswitch ( this.blendMode ) {\\r\\n\\r\\n\\t\\t\\t\\tcase AdditiveAnimationBlendMode:\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var j = 0, m = interpolants.length; j !== m; ++ j ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tinterpolants[ j ].evaluate( clipTime );\\r\\n\\t\\t\\t\\t\\t\\tpropertyMixers[ j ].accumulateAdditive( weight );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\r\\n\\t\\t\\t\\tcase NormalAnimationBlendMode:\\r\\n\\t\\t\\t\\tdefault:\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( var j = 0, m = interpolants.length; j !== m; ++ j ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tinterpolants[ j ].evaluate( clipTime );\\r\\n\\t\\t\\t\\t\\t\\tpropertyMixers[ j ].accumulate( accuIndex, weight );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t_updateWeight: function ( time ) {\\r\\n\\r\\n\\t\\tvar weight = 0;\\r\\n\\r\\n\\t\\tif ( this.enabled ) {\\r\\n\\r\\n\\t\\t\\tweight = this.weight;\\r\\n\\t\\t\\tvar interpolant = this._weightInterpolant;\\r\\n\\r\\n\\t\\t\\tif ( interpolant !== null ) {\\r\\n\\r\\n\\t\\t\\t\\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\\r\\n\\r\\n\\t\\t\\t\\tweight *= interpolantValue;\\r\\n\\r\\n\\t\\t\\t\\tif ( time > interpolant.parameterPositions[ 1 ] ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.stopFading();\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( interpolantValue === 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// faded out, disable\\r\\n\\t\\t\\t\\t\\t\\tthis.enabled = false;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis._effectiveWeight = weight;\\r\\n\\t\\treturn weight;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t_updateTimeScale: function ( time ) {\\r\\n\\r\\n\\t\\tvar timeScale = 0;\\r\\n\\r\\n\\t\\tif ( ! this.paused ) {\\r\\n\\r\\n\\t\\t\\ttimeScale = this.timeScale;\\r\\n\\r\\n\\t\\t\\tvar interpolant = this._timeScaleInterpolant;\\r\\n\\r\\n\\t\\t\\tif ( interpolant !== null ) {\\r\\n\\r\\n\\t\\t\\t\\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\\r\\n\\r\\n\\t\\t\\t\\ttimeScale *= interpolantValue;\\r\\n\\r\\n\\t\\t\\t\\tif ( time > interpolant.parameterPositions[ 1 ] ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.stopWarping();\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( timeScale === 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// motion has halted, pause\\r\\n\\t\\t\\t\\t\\t\\tthis.paused = true;\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// warp done - apply final time scale\\r\\n\\t\\t\\t\\t\\t\\tthis.timeScale = timeScale;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis._effectiveTimeScale = timeScale;\\r\\n\\t\\treturn timeScale;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t_updateTime: function ( deltaTime ) {\\r\\n\\r\\n\\t\\tvar time = this.time + deltaTime;\\r\\n\\t\\tvar duration = this._clip.duration;\\r\\n\\t\\tvar loop = this.loop;\\r\\n\\t\\tvar loopCount = this._loopCount;\\r\\n\\r\\n\\t\\tvar pingPong = ( loop === LoopPingPong );\\r\\n\\r\\n\\t\\tif ( deltaTime === 0 ) {\\r\\n\\r\\n\\t\\t\\tif ( loopCount === - 1 ) return time;\\r\\n\\r\\n\\t\\t\\treturn ( pingPong && ( loopCount & 1 ) === 1 ) ? duration - time : time;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( loop === LoopOnce ) {\\r\\n\\r\\n\\t\\t\\tif ( loopCount === - 1 ) {\\r\\n\\r\\n\\t\\t\\t\\t// just started\\r\\n\\r\\n\\t\\t\\t\\tthis._loopCount = 0;\\r\\n\\t\\t\\t\\tthis._setEndings( true, true, false );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\thandle_stop: {\\r\\n\\r\\n\\t\\t\\t\\tif ( time >= duration ) {\\r\\n\\r\\n\\t\\t\\t\\t\\ttime = duration;\\r\\n\\r\\n\\t\\t\\t\\t} else if ( time < 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\ttime = 0;\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.time = time;\\r\\n\\r\\n\\t\\t\\t\\t\\tbreak handle_stop;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif ( this.clampWhenFinished ) this.paused = true;\\r\\n\\t\\t\\t\\telse this.enabled = false;\\r\\n\\r\\n\\t\\t\\t\\tthis.time = time;\\r\\n\\r\\n\\t\\t\\t\\tthis._mixer.dispatchEvent( {\\r\\n\\t\\t\\t\\t\\ttype: 'finished', action: this,\\r\\n\\t\\t\\t\\t\\tdirection: deltaTime < 0 ? - 1 : 1\\r\\n\\t\\t\\t\\t} );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t} else { // repetitive Repeat or PingPong\\r\\n\\r\\n\\t\\t\\tif ( loopCount === - 1 ) {\\r\\n\\r\\n\\t\\t\\t\\t// just started\\r\\n\\r\\n\\t\\t\\t\\tif ( deltaTime >= 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tloopCount = 0;\\r\\n\\r\\n\\t\\t\\t\\t\\tthis._setEndings( true, this.repetitions === 0, pingPong );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t// when looping in reverse direction, the initial\\r\\n\\t\\t\\t\\t\\t// transition through zero counts as a repetition,\\r\\n\\t\\t\\t\\t\\t// so leave loopCount at -1\\r\\n\\r\\n\\t\\t\\t\\t\\tthis._setEndings( this.repetitions === 0, true, pingPong );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( time >= duration || time < 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t// wrap around\\r\\n\\r\\n\\t\\t\\t\\tvar loopDelta = Math.floor( time / duration ); // signed\\r\\n\\t\\t\\t\\ttime -= duration * loopDelta;\\r\\n\\r\\n\\t\\t\\t\\tloopCount += Math.abs( loopDelta );\\r\\n\\r\\n\\t\\t\\t\\tvar pending = this.repetitions - loopCount;\\r\\n\\r\\n\\t\\t\\t\\tif ( pending <= 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// have to stop (switch state, clamp time, fire event)\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( this.clampWhenFinished ) this.paused = true;\\r\\n\\t\\t\\t\\t\\telse this.enabled = false;\\r\\n\\r\\n\\t\\t\\t\\t\\ttime = deltaTime > 0 ? duration : 0;\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.time = time;\\r\\n\\r\\n\\t\\t\\t\\t\\tthis._mixer.dispatchEvent( {\\r\\n\\t\\t\\t\\t\\t\\ttype: 'finished', action: this,\\r\\n\\t\\t\\t\\t\\t\\tdirection: deltaTime > 0 ? 1 : - 1\\r\\n\\t\\t\\t\\t\\t} );\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t// keep running\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( pending === 1 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// entering the last round\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tvar atStart = deltaTime < 0;\\r\\n\\t\\t\\t\\t\\t\\tthis._setEndings( atStart, ! atStart, pingPong );\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tthis._setEndings( false, false, pingPong );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tthis._loopCount = loopCount;\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.time = time;\\r\\n\\r\\n\\t\\t\\t\\t\\tthis._mixer.dispatchEvent( {\\r\\n\\t\\t\\t\\t\\t\\ttype: 'loop', action: this, loopDelta: loopDelta\\r\\n\\t\\t\\t\\t\\t} );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tthis.time = time;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( pingPong && ( loopCount & 1 ) === 1 ) {\\r\\n\\r\\n\\t\\t\\t\\t// invert time for the \\\"pong round\\\"\\r\\n\\r\\n\\t\\t\\t\\treturn duration - time;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn time;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t_setEndings: function ( atStart, atEnd, pingPong ) {\\r\\n\\r\\n\\t\\tvar settings = this._interpolantSettings;\\r\\n\\r\\n\\t\\tif ( pingPong ) {\\r\\n\\r\\n\\t\\t\\tsettings.endingStart = ZeroSlopeEnding;\\r\\n\\t\\t\\tsettings.endingEnd = ZeroSlopeEnding;\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t// assuming for LoopOnce atStart == atEnd == true\\r\\n\\r\\n\\t\\t\\tif ( atStart ) {\\r\\n\\r\\n\\t\\t\\t\\tsettings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tsettings.endingStart = WrapAroundEnding;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( atEnd ) {\\r\\n\\r\\n\\t\\t\\t\\tsettings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tsettings.endingEnd \\t = WrapAroundEnding;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t_scheduleFading: function ( duration, weightNow, weightThen ) {\\r\\n\\r\\n\\t\\tvar mixer = this._mixer, now = mixer.time,\\r\\n\\t\\t\\tinterpolant = this._weightInterpolant;\\r\\n\\r\\n\\t\\tif ( interpolant === null ) {\\r\\n\\r\\n\\t\\t\\tinterpolant = mixer._lendControlInterpolant();\\r\\n\\t\\t\\tthis._weightInterpolant = interpolant;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar times = interpolant.parameterPositions,\\r\\n\\t\\t\\tvalues = interpolant.sampleValues;\\r\\n\\r\\n\\t\\ttimes[ 0 ] = now;\\r\\n\\t\\tvalues[ 0 ] = weightNow;\\r\\n\\t\\ttimes[ 1 ] = now + duration;\\r\\n\\t\\tvalues[ 1 ] = weightThen;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n *\\r\\n * Player for AnimationClips.\\r\\n *\\r\\n *\\r\\n * @author Ben Houston / http://clara.io/\\r\\n * @author David Sarno / http://lighthaus.us/\\r\\n * @author tschw\\r\\n */\\r\\n\\r\\nfunction AnimationMixer( root ) {\\r\\n\\r\\n\\tthis._root = root;\\r\\n\\tthis._initMemoryManager();\\r\\n\\tthis._accuIndex = 0;\\r\\n\\r\\n\\tthis.time = 0;\\r\\n\\r\\n\\tthis.timeScale = 1.0;\\r\\n\\r\\n}\\r\\n\\r\\nAnimationMixer.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\\r\\n\\r\\n\\tconstructor: AnimationMixer,\\r\\n\\r\\n\\t_bindAction: function ( action, prototypeAction ) {\\r\\n\\r\\n\\t\\tvar root = action._localRoot || this._root,\\r\\n\\t\\t\\ttracks = action._clip.tracks,\\r\\n\\t\\t\\tnTracks = tracks.length,\\r\\n\\t\\t\\tbindings = action._propertyBindings,\\r\\n\\t\\t\\tinterpolants = action._interpolants,\\r\\n\\t\\t\\trootUuid = root.uuid,\\r\\n\\t\\t\\tbindingsByRoot = this._bindingsByRootAndName,\\r\\n\\t\\t\\tbindingsByName = bindingsByRoot[ rootUuid ];\\r\\n\\r\\n\\t\\tif ( bindingsByName === undefined ) {\\r\\n\\r\\n\\t\\t\\tbindingsByName = {};\\r\\n\\t\\t\\tbindingsByRoot[ rootUuid ] = bindingsByName;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfor ( var i = 0; i !== nTracks; ++ i ) {\\r\\n\\r\\n\\t\\t\\tvar track = tracks[ i ],\\r\\n\\t\\t\\t\\ttrackName = track.name,\\r\\n\\t\\t\\t\\tbinding = bindingsByName[ trackName ];\\r\\n\\r\\n\\t\\t\\tif ( binding !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tbindings[ i ] = binding;\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tbinding = bindings[ i ];\\r\\n\\r\\n\\t\\t\\t\\tif ( binding !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// existing binding, make sure the cache knows\\r\\n\\r\\n\\t\\t\\t\\t\\tif ( binding._cacheIndex === null ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t++ binding.referenceCount;\\r\\n\\t\\t\\t\\t\\t\\tthis._addInactiveBinding( binding, rootUuid, trackName );\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tcontinue;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tvar path = prototypeAction && prototypeAction.\\r\\n\\t\\t\\t\\t\\t_propertyBindings[ i ].binding.parsedPath;\\r\\n\\r\\n\\t\\t\\t\\tbinding = new PropertyMixer(\\r\\n\\t\\t\\t\\t\\tPropertyBinding.create( root, trackName, path ),\\r\\n\\t\\t\\t\\t\\ttrack.ValueTypeName, track.getValueSize() );\\r\\n\\r\\n\\t\\t\\t\\t++ binding.referenceCount;\\r\\n\\t\\t\\t\\tthis._addInactiveBinding( binding, rootUuid, trackName );\\r\\n\\r\\n\\t\\t\\t\\tbindings[ i ] = binding;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tinterpolants[ i ].resultBuffer = binding.buffer;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t_activateAction: function ( action ) {\\r\\n\\r\\n\\t\\tif ( ! this._isActiveAction( action ) ) {\\r\\n\\r\\n\\t\\t\\tif ( action._cacheIndex === null ) {\\r\\n\\r\\n\\t\\t\\t\\t// this action has been forgotten by the cache, but the user\\r\\n\\t\\t\\t\\t// appears to be still using it -> rebind\\r\\n\\r\\n\\t\\t\\t\\tvar rootUuid = ( action._localRoot || this._root ).uuid,\\r\\n\\t\\t\\t\\t\\tclipUuid = action._clip.uuid,\\r\\n\\t\\t\\t\\t\\tactionsForClip = this._actionsByClip[ clipUuid ];\\r\\n\\r\\n\\t\\t\\t\\tthis._bindAction( action,\\r\\n\\t\\t\\t\\t\\tactionsForClip && actionsForClip.knownActions[ 0 ] );\\r\\n\\r\\n\\t\\t\\t\\tthis._addInactiveAction( action, clipUuid, rootUuid );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar bindings = action._propertyBindings;\\r\\n\\r\\n\\t\\t\\t// increment reference counts / sort out state\\r\\n\\t\\t\\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\tvar binding = bindings[ i ];\\r\\n\\r\\n\\t\\t\\t\\tif ( binding.useCount ++ === 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis._lendBinding( binding );\\r\\n\\t\\t\\t\\t\\tbinding.saveOriginalState();\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis._lendAction( action );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t_deactivateAction: function ( action ) {\\r\\n\\r\\n\\t\\tif ( this._isActiveAction( action ) ) {\\r\\n\\r\\n\\t\\t\\tvar bindings = action._propertyBindings;\\r\\n\\r\\n\\t\\t\\t// decrement reference counts / sort out state\\r\\n\\t\\t\\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\tvar binding = bindings[ i ];\\r\\n\\r\\n\\t\\t\\t\\tif ( -- binding.useCount === 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tbinding.restoreOriginalState();\\r\\n\\t\\t\\t\\t\\tthis._takeBackBinding( binding );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis._takeBackAction( action );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// Memory manager\\r\\n\\r\\n\\t_initMemoryManager: function () {\\r\\n\\r\\n\\t\\tthis._actions = []; // 'nActiveActions' followed by inactive ones\\r\\n\\t\\tthis._nActiveActions = 0;\\r\\n\\r\\n\\t\\tthis._actionsByClip = {};\\r\\n\\t\\t// inside:\\r\\n\\t\\t// {\\r\\n\\t\\t// \\tknownActions: Array< AnimationAction > - used as prototypes\\r\\n\\t\\t// \\tactionByRoot: AnimationAction - lookup\\r\\n\\t\\t// }\\r\\n\\r\\n\\r\\n\\t\\tthis._bindings = []; // 'nActiveBindings' followed by inactive ones\\r\\n\\t\\tthis._nActiveBindings = 0;\\r\\n\\r\\n\\t\\tthis._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\\r\\n\\r\\n\\r\\n\\t\\tthis._controlInterpolants = []; // same game as above\\r\\n\\t\\tthis._nActiveControlInterpolants = 0;\\r\\n\\r\\n\\t\\tvar scope = this;\\r\\n\\r\\n\\t\\tthis.stats = {\\r\\n\\r\\n\\t\\t\\tactions: {\\r\\n\\t\\t\\t\\tget total() {\\r\\n\\r\\n\\t\\t\\t\\t\\treturn scope._actions.length;\\r\\n\\r\\n\\t\\t\\t\\t},\\r\\n\\t\\t\\t\\tget inUse() {\\r\\n\\r\\n\\t\\t\\t\\t\\treturn scope._nActiveActions;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t},\\r\\n\\t\\t\\tbindings: {\\r\\n\\t\\t\\t\\tget total() {\\r\\n\\r\\n\\t\\t\\t\\t\\treturn scope._bindings.length;\\r\\n\\r\\n\\t\\t\\t\\t},\\r\\n\\t\\t\\t\\tget inUse() {\\r\\n\\r\\n\\t\\t\\t\\t\\treturn scope._nActiveBindings;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t},\\r\\n\\t\\t\\tcontrolInterpolants: {\\r\\n\\t\\t\\t\\tget total() {\\r\\n\\r\\n\\t\\t\\t\\t\\treturn scope._controlInterpolants.length;\\r\\n\\r\\n\\t\\t\\t\\t},\\r\\n\\t\\t\\t\\tget inUse() {\\r\\n\\r\\n\\t\\t\\t\\t\\treturn scope._nActiveControlInterpolants;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// Memory management for AnimationAction objects\\r\\n\\r\\n\\t_isActiveAction: function ( action ) {\\r\\n\\r\\n\\t\\tvar index = action._cacheIndex;\\r\\n\\t\\treturn index !== null && index < this._nActiveActions;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t_addInactiveAction: function ( action, clipUuid, rootUuid ) {\\r\\n\\r\\n\\t\\tvar actions = this._actions,\\r\\n\\t\\t\\tactionsByClip = this._actionsByClip,\\r\\n\\t\\t\\tactionsForClip = actionsByClip[ clipUuid ];\\r\\n\\r\\n\\t\\tif ( actionsForClip === undefined ) {\\r\\n\\r\\n\\t\\t\\tactionsForClip = {\\r\\n\\r\\n\\t\\t\\t\\tknownActions: [ action ],\\r\\n\\t\\t\\t\\tactionByRoot: {}\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\taction._byClipCacheIndex = 0;\\r\\n\\r\\n\\t\\t\\tactionsByClip[ clipUuid ] = actionsForClip;\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tvar knownActions = actionsForClip.knownActions;\\r\\n\\r\\n\\t\\t\\taction._byClipCacheIndex = knownActions.length;\\r\\n\\t\\t\\tknownActions.push( action );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\taction._cacheIndex = actions.length;\\r\\n\\t\\tactions.push( action );\\r\\n\\r\\n\\t\\tactionsForClip.actionByRoot[ rootUuid ] = action;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t_removeInactiveAction: function ( action ) {\\r\\n\\r\\n\\t\\tvar actions = this._actions,\\r\\n\\t\\t\\tlastInactiveAction = actions[ actions.length - 1 ],\\r\\n\\t\\t\\tcacheIndex = action._cacheIndex;\\r\\n\\r\\n\\t\\tlastInactiveAction._cacheIndex = cacheIndex;\\r\\n\\t\\tactions[ cacheIndex ] = lastInactiveAction;\\r\\n\\t\\tactions.pop();\\r\\n\\r\\n\\t\\taction._cacheIndex = null;\\r\\n\\r\\n\\r\\n\\t\\tvar clipUuid = action._clip.uuid,\\r\\n\\t\\t\\tactionsByClip = this._actionsByClip,\\r\\n\\t\\t\\tactionsForClip = actionsByClip[ clipUuid ],\\r\\n\\t\\t\\tknownActionsForClip = actionsForClip.knownActions,\\r\\n\\r\\n\\t\\t\\tlastKnownAction =\\r\\n\\t\\t\\t\\tknownActionsForClip[ knownActionsForClip.length - 1 ],\\r\\n\\r\\n\\t\\t\\tbyClipCacheIndex = action._byClipCacheIndex;\\r\\n\\r\\n\\t\\tlastKnownAction._byClipCacheIndex = byClipCacheIndex;\\r\\n\\t\\tknownActionsForClip[ byClipCacheIndex ] = lastKnownAction;\\r\\n\\t\\tknownActionsForClip.pop();\\r\\n\\r\\n\\t\\taction._byClipCacheIndex = null;\\r\\n\\r\\n\\r\\n\\t\\tvar actionByRoot = actionsForClip.actionByRoot,\\r\\n\\t\\t\\trootUuid = ( action._localRoot || this._root ).uuid;\\r\\n\\r\\n\\t\\tdelete actionByRoot[ rootUuid ];\\r\\n\\r\\n\\t\\tif ( knownActionsForClip.length === 0 ) {\\r\\n\\r\\n\\t\\t\\tdelete actionsByClip[ clipUuid ];\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis._removeInactiveBindingsForAction( action );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t_removeInactiveBindingsForAction: function ( action ) {\\r\\n\\r\\n\\t\\tvar bindings = action._propertyBindings;\\r\\n\\t\\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\t\\tvar binding = bindings[ i ];\\r\\n\\r\\n\\t\\t\\tif ( -- binding.referenceCount === 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tthis._removeInactiveBinding( binding );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t_lendAction: function ( action ) {\\r\\n\\r\\n\\t\\t// [ active actions |  inactive actions  ]\\r\\n\\t\\t// [  active actions >| inactive actions ]\\r\\n\\t\\t//                 s        a\\r\\n\\t\\t//                  <-swap->\\r\\n\\t\\t//                 a        s\\r\\n\\r\\n\\t\\tvar actions = this._actions,\\r\\n\\t\\t\\tprevIndex = action._cacheIndex,\\r\\n\\r\\n\\t\\t\\tlastActiveIndex = this._nActiveActions ++,\\r\\n\\r\\n\\t\\t\\tfirstInactiveAction = actions[ lastActiveIndex ];\\r\\n\\r\\n\\t\\taction._cacheIndex = lastActiveIndex;\\r\\n\\t\\tactions[ lastActiveIndex ] = action;\\r\\n\\r\\n\\t\\tfirstInactiveAction._cacheIndex = prevIndex;\\r\\n\\t\\tactions[ prevIndex ] = firstInactiveAction;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t_takeBackAction: function ( action ) {\\r\\n\\r\\n\\t\\t// [  active actions  | inactive actions ]\\r\\n\\t\\t// [ active actions |< inactive actions  ]\\r\\n\\t\\t//        a        s\\r\\n\\t\\t//         <-swap->\\r\\n\\t\\t//        s        a\\r\\n\\r\\n\\t\\tvar actions = this._actions,\\r\\n\\t\\t\\tprevIndex = action._cacheIndex,\\r\\n\\r\\n\\t\\t\\tfirstInactiveIndex = -- this._nActiveActions,\\r\\n\\r\\n\\t\\t\\tlastActiveAction = actions[ firstInactiveIndex ];\\r\\n\\r\\n\\t\\taction._cacheIndex = firstInactiveIndex;\\r\\n\\t\\tactions[ firstInactiveIndex ] = action;\\r\\n\\r\\n\\t\\tlastActiveAction._cacheIndex = prevIndex;\\r\\n\\t\\tactions[ prevIndex ] = lastActiveAction;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// Memory management for PropertyMixer objects\\r\\n\\r\\n\\t_addInactiveBinding: function ( binding, rootUuid, trackName ) {\\r\\n\\r\\n\\t\\tvar bindingsByRoot = this._bindingsByRootAndName,\\r\\n\\t\\t\\tbindingByName = bindingsByRoot[ rootUuid ],\\r\\n\\r\\n\\t\\t\\tbindings = this._bindings;\\r\\n\\r\\n\\t\\tif ( bindingByName === undefined ) {\\r\\n\\r\\n\\t\\t\\tbindingByName = {};\\r\\n\\t\\t\\tbindingsByRoot[ rootUuid ] = bindingByName;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tbindingByName[ trackName ] = binding;\\r\\n\\r\\n\\t\\tbinding._cacheIndex = bindings.length;\\r\\n\\t\\tbindings.push( binding );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t_removeInactiveBinding: function ( binding ) {\\r\\n\\r\\n\\t\\tvar bindings = this._bindings,\\r\\n\\t\\t\\tpropBinding = binding.binding,\\r\\n\\t\\t\\trootUuid = propBinding.rootNode.uuid,\\r\\n\\t\\t\\ttrackName = propBinding.path,\\r\\n\\t\\t\\tbindingsByRoot = this._bindingsByRootAndName,\\r\\n\\t\\t\\tbindingByName = bindingsByRoot[ rootUuid ],\\r\\n\\r\\n\\t\\t\\tlastInactiveBinding = bindings[ bindings.length - 1 ],\\r\\n\\t\\t\\tcacheIndex = binding._cacheIndex;\\r\\n\\r\\n\\t\\tlastInactiveBinding._cacheIndex = cacheIndex;\\r\\n\\t\\tbindings[ cacheIndex ] = lastInactiveBinding;\\r\\n\\t\\tbindings.pop();\\r\\n\\r\\n\\t\\tdelete bindingByName[ trackName ];\\r\\n\\r\\n\\t\\tif ( Object.keys( bindingByName ).length === 0 ) {\\r\\n\\r\\n\\t\\t\\tdelete bindingsByRoot[ rootUuid ];\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t_lendBinding: function ( binding ) {\\r\\n\\r\\n\\t\\tvar bindings = this._bindings,\\r\\n\\t\\t\\tprevIndex = binding._cacheIndex,\\r\\n\\r\\n\\t\\t\\tlastActiveIndex = this._nActiveBindings ++,\\r\\n\\r\\n\\t\\t\\tfirstInactiveBinding = bindings[ lastActiveIndex ];\\r\\n\\r\\n\\t\\tbinding._cacheIndex = lastActiveIndex;\\r\\n\\t\\tbindings[ lastActiveIndex ] = binding;\\r\\n\\r\\n\\t\\tfirstInactiveBinding._cacheIndex = prevIndex;\\r\\n\\t\\tbindings[ prevIndex ] = firstInactiveBinding;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t_takeBackBinding: function ( binding ) {\\r\\n\\r\\n\\t\\tvar bindings = this._bindings,\\r\\n\\t\\t\\tprevIndex = binding._cacheIndex,\\r\\n\\r\\n\\t\\t\\tfirstInactiveIndex = -- this._nActiveBindings,\\r\\n\\r\\n\\t\\t\\tlastActiveBinding = bindings[ firstInactiveIndex ];\\r\\n\\r\\n\\t\\tbinding._cacheIndex = firstInactiveIndex;\\r\\n\\t\\tbindings[ firstInactiveIndex ] = binding;\\r\\n\\r\\n\\t\\tlastActiveBinding._cacheIndex = prevIndex;\\r\\n\\t\\tbindings[ prevIndex ] = lastActiveBinding;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\r\\n\\t// Memory management of Interpolants for weight and time scale\\r\\n\\r\\n\\t_lendControlInterpolant: function () {\\r\\n\\r\\n\\t\\tvar interpolants = this._controlInterpolants,\\r\\n\\t\\t\\tlastActiveIndex = this._nActiveControlInterpolants ++,\\r\\n\\t\\t\\tinterpolant = interpolants[ lastActiveIndex ];\\r\\n\\r\\n\\t\\tif ( interpolant === undefined ) {\\r\\n\\r\\n\\t\\t\\tinterpolant = new LinearInterpolant(\\r\\n\\t\\t\\t\\tnew Float32Array( 2 ), new Float32Array( 2 ),\\r\\n\\t\\t\\t\\t1, this._controlInterpolantsResultBuffer );\\r\\n\\r\\n\\t\\t\\tinterpolant.__cacheIndex = lastActiveIndex;\\r\\n\\t\\t\\tinterpolants[ lastActiveIndex ] = interpolant;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn interpolant;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t_takeBackControlInterpolant: function ( interpolant ) {\\r\\n\\r\\n\\t\\tvar interpolants = this._controlInterpolants,\\r\\n\\t\\t\\tprevIndex = interpolant.__cacheIndex,\\r\\n\\r\\n\\t\\t\\tfirstInactiveIndex = -- this._nActiveControlInterpolants,\\r\\n\\r\\n\\t\\t\\tlastActiveInterpolant = interpolants[ firstInactiveIndex ];\\r\\n\\r\\n\\t\\tinterpolant.__cacheIndex = firstInactiveIndex;\\r\\n\\t\\tinterpolants[ firstInactiveIndex ] = interpolant;\\r\\n\\r\\n\\t\\tlastActiveInterpolant.__cacheIndex = prevIndex;\\r\\n\\t\\tinterpolants[ prevIndex ] = lastActiveInterpolant;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t_controlInterpolantsResultBuffer: new Float32Array( 1 ),\\r\\n\\r\\n\\t// return an action for a clip optionally using a custom root target\\r\\n\\t// object (this method allocates a lot of dynamic memory in case a\\r\\n\\t// previously unknown clip/root combination is specified)\\r\\n\\tclipAction: function ( clip, optionalRoot, blendMode ) {\\r\\n\\r\\n\\t\\tvar root = optionalRoot || this._root,\\r\\n\\t\\t\\trootUuid = root.uuid,\\r\\n\\r\\n\\t\\t\\tclipObject = typeof clip === 'string' ?\\r\\n\\t\\t\\t\\tAnimationClip.findByName( root, clip ) : clip,\\r\\n\\r\\n\\t\\t\\tclipUuid = clipObject !== null ? clipObject.uuid : clip,\\r\\n\\r\\n\\t\\t\\tactionsForClip = this._actionsByClip[ clipUuid ],\\r\\n\\t\\t\\tprototypeAction = null;\\r\\n\\r\\n\\t\\tif ( blendMode === undefined ) {\\r\\n\\r\\n\\t\\t\\tif ( clipObject !== null ) {\\r\\n\\r\\n\\t\\t\\t\\tblendMode = clipObject.blendMode;\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tblendMode = NormalAnimationBlendMode;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( actionsForClip !== undefined ) {\\r\\n\\r\\n\\t\\t\\tvar existingAction =\\r\\n\\t\\t\\t\\t\\tactionsForClip.actionByRoot[ rootUuid ];\\r\\n\\r\\n\\t\\t\\tif ( existingAction !== undefined && existingAction.blendMode === blendMode ) {\\r\\n\\r\\n\\t\\t\\t\\treturn existingAction;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// we know the clip, so we don't have to parse all\\r\\n\\t\\t\\t// the bindings again but can just copy\\r\\n\\t\\t\\tprototypeAction = actionsForClip.knownActions[ 0 ];\\r\\n\\r\\n\\t\\t\\t// also, take the clip from the prototype action\\r\\n\\t\\t\\tif ( clipObject === null )\\r\\n\\t\\t\\t\\tclipObject = prototypeAction._clip;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// clip must be known when specified via string\\r\\n\\t\\tif ( clipObject === null ) return null;\\r\\n\\r\\n\\t\\t// allocate all resources required to run it\\r\\n\\t\\tvar newAction = new AnimationAction( this, clipObject, optionalRoot, blendMode );\\r\\n\\r\\n\\t\\tthis._bindAction( newAction, prototypeAction );\\r\\n\\r\\n\\t\\t// and make the action known to the memory manager\\r\\n\\t\\tthis._addInactiveAction( newAction, clipUuid, rootUuid );\\r\\n\\r\\n\\t\\treturn newAction;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// get an existing action\\r\\n\\texistingAction: function ( clip, optionalRoot ) {\\r\\n\\r\\n\\t\\tvar root = optionalRoot || this._root,\\r\\n\\t\\t\\trootUuid = root.uuid,\\r\\n\\r\\n\\t\\t\\tclipObject = typeof clip === 'string' ?\\r\\n\\t\\t\\t\\tAnimationClip.findByName( root, clip ) : clip,\\r\\n\\r\\n\\t\\t\\tclipUuid = clipObject ? clipObject.uuid : clip,\\r\\n\\r\\n\\t\\t\\tactionsForClip = this._actionsByClip[ clipUuid ];\\r\\n\\r\\n\\t\\tif ( actionsForClip !== undefined ) {\\r\\n\\r\\n\\t\\t\\treturn actionsForClip.actionByRoot[ rootUuid ] || null;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn null;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// deactivates all previously scheduled actions\\r\\n\\tstopAllAction: function () {\\r\\n\\r\\n\\t\\tvar actions = this._actions,\\r\\n\\t\\t\\tnActions = this._nActiveActions;\\r\\n\\r\\n\\t\\tfor ( var i = nActions - 1; i >= 0; -- i ) {\\r\\n\\r\\n\\t\\t\\tactions[ i ].stop();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// advance the time and update apply the animation\\r\\n\\tupdate: function ( deltaTime ) {\\r\\n\\r\\n\\t\\tdeltaTime *= this.timeScale;\\r\\n\\r\\n\\t\\tvar actions = this._actions,\\r\\n\\t\\t\\tnActions = this._nActiveActions,\\r\\n\\r\\n\\t\\t\\ttime = this.time += deltaTime,\\r\\n\\t\\t\\ttimeDirection = Math.sign( deltaTime ),\\r\\n\\r\\n\\t\\t\\taccuIndex = this._accuIndex ^= 1;\\r\\n\\r\\n\\t\\t// run active actions\\r\\n\\r\\n\\t\\tfor ( var i = 0; i !== nActions; ++ i ) {\\r\\n\\r\\n\\t\\t\\tvar action = actions[ i ];\\r\\n\\r\\n\\t\\t\\taction._update( time, deltaTime, timeDirection, accuIndex );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// update scene graph\\r\\n\\r\\n\\t\\tvar bindings = this._bindings,\\r\\n\\t\\t\\tnBindings = this._nActiveBindings;\\r\\n\\r\\n\\t\\tfor ( var i = 0; i !== nBindings; ++ i ) {\\r\\n\\r\\n\\t\\t\\tbindings[ i ].apply( accuIndex );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// Allows you to seek to a specific time in an animation.\\r\\n\\tsetTime: function ( timeInSeconds ) {\\r\\n\\r\\n\\t\\tthis.time = 0; // Zero out time attribute for AnimationMixer object;\\r\\n\\t\\tfor ( var i = 0; i < this._actions.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\tthis._actions[ i ].time = 0; // Zero out time attribute for all associated AnimationAction objects.\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this.update( timeInSeconds ); // Update used to set exact time. Returns \\\"this\\\" AnimationMixer object.\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// return this mixer's root target object\\r\\n\\tgetRoot: function () {\\r\\n\\r\\n\\t\\treturn this._root;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// free all resources specific to a particular clip\\r\\n\\tuncacheClip: function ( clip ) {\\r\\n\\r\\n\\t\\tvar actions = this._actions,\\r\\n\\t\\t\\tclipUuid = clip.uuid,\\r\\n\\t\\t\\tactionsByClip = this._actionsByClip,\\r\\n\\t\\t\\tactionsForClip = actionsByClip[ clipUuid ];\\r\\n\\r\\n\\t\\tif ( actionsForClip !== undefined ) {\\r\\n\\r\\n\\t\\t\\t// note: just calling _removeInactiveAction would mess up the\\r\\n\\t\\t\\t// iteration state and also require updating the state we can\\r\\n\\t\\t\\t// just throw away\\r\\n\\r\\n\\t\\t\\tvar actionsToRemove = actionsForClip.knownActions;\\r\\n\\r\\n\\t\\t\\tfor ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {\\r\\n\\r\\n\\t\\t\\t\\tvar action = actionsToRemove[ i ];\\r\\n\\r\\n\\t\\t\\t\\tthis._deactivateAction( action );\\r\\n\\r\\n\\t\\t\\t\\tvar cacheIndex = action._cacheIndex,\\r\\n\\t\\t\\t\\t\\tlastInactiveAction = actions[ actions.length - 1 ];\\r\\n\\r\\n\\t\\t\\t\\taction._cacheIndex = null;\\r\\n\\t\\t\\t\\taction._byClipCacheIndex = null;\\r\\n\\r\\n\\t\\t\\t\\tlastInactiveAction._cacheIndex = cacheIndex;\\r\\n\\t\\t\\t\\tactions[ cacheIndex ] = lastInactiveAction;\\r\\n\\t\\t\\t\\tactions.pop();\\r\\n\\r\\n\\t\\t\\t\\tthis._removeInactiveBindingsForAction( action );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tdelete actionsByClip[ clipUuid ];\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// free all resources specific to a particular root target object\\r\\n\\tuncacheRoot: function ( root ) {\\r\\n\\r\\n\\t\\tvar rootUuid = root.uuid,\\r\\n\\t\\t\\tactionsByClip = this._actionsByClip;\\r\\n\\r\\n\\t\\tfor ( var clipUuid in actionsByClip ) {\\r\\n\\r\\n\\t\\t\\tvar actionByRoot = actionsByClip[ clipUuid ].actionByRoot,\\r\\n\\t\\t\\t\\taction = actionByRoot[ rootUuid ];\\r\\n\\r\\n\\t\\t\\tif ( action !== undefined ) {\\r\\n\\r\\n\\t\\t\\t\\tthis._deactivateAction( action );\\r\\n\\t\\t\\t\\tthis._removeInactiveAction( action );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar bindingsByRoot = this._bindingsByRootAndName,\\r\\n\\t\\t\\tbindingByName = bindingsByRoot[ rootUuid ];\\r\\n\\r\\n\\t\\tif ( bindingByName !== undefined ) {\\r\\n\\r\\n\\t\\t\\tfor ( var trackName in bindingByName ) {\\r\\n\\r\\n\\t\\t\\t\\tvar binding = bindingByName[ trackName ];\\r\\n\\t\\t\\t\\tbinding.restoreOriginalState();\\r\\n\\t\\t\\t\\tthis._removeInactiveBinding( binding );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// remove a targeted clip from the cache\\r\\n\\tuncacheAction: function ( clip, optionalRoot ) {\\r\\n\\r\\n\\t\\tvar action = this.existingAction( clip, optionalRoot );\\r\\n\\r\\n\\t\\tif ( action !== null ) {\\r\\n\\r\\n\\t\\t\\tthis._deactivateAction( action );\\r\\n\\t\\t\\tthis._removeInactiveAction( action );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nfunction Uniform( value ) {\\r\\n\\r\\n\\tif ( typeof value === 'string' ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Uniform: Type parameter is no longer needed.' );\\r\\n\\t\\tvalue = arguments[ 1 ];\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tthis.value = value;\\r\\n\\r\\n}\\r\\n\\r\\nUniform.prototype.clone = function () {\\r\\n\\r\\n\\treturn new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );\\r\\n\\r\\n};\\r\\n\\r\\n/**\\r\\n * @author benaadams / https://twitter.com/ben_a_adams\\r\\n */\\r\\n\\r\\nfunction InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {\\r\\n\\r\\n\\tInterleavedBuffer.call( this, array, stride );\\r\\n\\r\\n\\tthis.meshPerAttribute = meshPerAttribute || 1;\\r\\n\\r\\n}\\r\\n\\r\\nInstancedInterleavedBuffer.prototype = Object.assign( Object.create( InterleavedBuffer.prototype ), {\\r\\n\\r\\n\\tconstructor: InstancedInterleavedBuffer,\\r\\n\\r\\n\\tisInstancedInterleavedBuffer: true,\\r\\n\\r\\n\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\tInterleavedBuffer.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\tthis.meshPerAttribute = source.meshPerAttribute;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n * @author bhouston / http://clara.io/\\r\\n * @author stephomi / http://stephaneginier.com/\\r\\n */\\r\\n\\r\\nfunction Raycaster( origin, direction, near, far ) {\\r\\n\\r\\n\\tthis.ray = new Ray( origin, direction );\\r\\n\\t// direction is assumed to be normalized (for accurate distance calculations)\\r\\n\\r\\n\\tthis.near = near || 0;\\r\\n\\tthis.far = far || Infinity;\\r\\n\\tthis.camera = null;\\r\\n\\tthis.layers = new Layers();\\r\\n\\r\\n\\tthis.params = {\\r\\n\\t\\tMesh: {},\\r\\n\\t\\tLine: { threshold: 1 },\\r\\n\\t\\tLOD: {},\\r\\n\\t\\tPoints: { threshold: 1 },\\r\\n\\t\\tSprite: {}\\r\\n\\t};\\r\\n\\r\\n\\tObject.defineProperties( this.params, {\\r\\n\\t\\tPointCloud: {\\r\\n\\t\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\t\\tconsole.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );\\r\\n\\t\\t\\t\\treturn this.Points;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t} );\\r\\n\\r\\n}\\r\\n\\r\\nfunction ascSort( a, b ) {\\r\\n\\r\\n\\treturn a.distance - b.distance;\\r\\n\\r\\n}\\r\\n\\r\\nfunction intersectObject( object, raycaster, intersects, recursive ) {\\r\\n\\r\\n\\tif ( object.layers.test( raycaster.layers ) ) {\\r\\n\\r\\n\\t\\tobject.raycast( raycaster, intersects );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tif ( recursive === true ) {\\r\\n\\r\\n\\t\\tvar children = object.children;\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\tintersectObject( children[ i ], raycaster, intersects, true );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\\r\\nObject.assign( Raycaster.prototype, {\\r\\n\\r\\n\\tset: function ( origin, direction ) {\\r\\n\\r\\n\\t\\t// direction is assumed to be normalized (for accurate distance calculations)\\r\\n\\r\\n\\t\\tthis.ray.set( origin, direction );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetFromCamera: function ( coords, camera ) {\\r\\n\\r\\n\\t\\tif ( ( camera && camera.isPerspectiveCamera ) ) {\\r\\n\\r\\n\\t\\t\\tthis.ray.origin.setFromMatrixPosition( camera.matrixWorld );\\r\\n\\t\\t\\tthis.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();\\r\\n\\t\\t\\tthis.camera = camera;\\r\\n\\r\\n\\t\\t} else if ( ( camera && camera.isOrthographicCamera ) ) {\\r\\n\\r\\n\\t\\t\\tthis.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera\\r\\n\\t\\t\\tthis.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\\r\\n\\t\\t\\tthis.camera = camera;\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tconsole.error( 'THREE.Raycaster: Unsupported camera type.' );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tintersectObject: function ( object, recursive, optionalTarget ) {\\r\\n\\r\\n\\t\\tvar intersects = optionalTarget || [];\\r\\n\\r\\n\\t\\tintersectObject( object, this, intersects, recursive );\\r\\n\\r\\n\\t\\tintersects.sort( ascSort );\\r\\n\\r\\n\\t\\treturn intersects;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tintersectObjects: function ( objects, recursive, optionalTarget ) {\\r\\n\\r\\n\\t\\tvar intersects = optionalTarget || [];\\r\\n\\r\\n\\t\\tif ( Array.isArray( objects ) === false ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );\\r\\n\\t\\t\\treturn intersects;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = objects.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\tintersectObject( objects[ i ], this, intersects, recursive );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tintersects.sort( ascSort );\\r\\n\\r\\n\\t\\treturn intersects;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author bhouston / http://clara.io\\r\\n * @author WestLangley / http://github.com/WestLangley\\r\\n *\\r\\n * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\\r\\n *\\r\\n * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.\\r\\n * The azimuthal angle (theta) is measured from the positive z-axis.\\r\\n */\\r\\n\\r\\nfunction Spherical( radius, phi, theta ) {\\r\\n\\r\\n\\tthis.radius = ( radius !== undefined ) ? radius : 1.0;\\r\\n\\tthis.phi = ( phi !== undefined ) ? phi : 0; // polar angle\\r\\n\\tthis.theta = ( theta !== undefined ) ? theta : 0; // azimuthal angle\\r\\n\\r\\n\\treturn this;\\r\\n\\r\\n}\\r\\n\\r\\nObject.assign( Spherical.prototype, {\\r\\n\\r\\n\\tset: function ( radius, phi, theta ) {\\r\\n\\r\\n\\t\\tthis.radius = radius;\\r\\n\\t\\tthis.phi = phi;\\r\\n\\t\\tthis.theta = theta;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclone: function () {\\r\\n\\r\\n\\t\\treturn new this.constructor().copy( this );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcopy: function ( other ) {\\r\\n\\r\\n\\t\\tthis.radius = other.radius;\\r\\n\\t\\tthis.phi = other.phi;\\r\\n\\t\\tthis.theta = other.theta;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// restrict phi to be betwee EPS and PI-EPS\\r\\n\\tmakeSafe: function () {\\r\\n\\r\\n\\t\\tvar EPS = 0.000001;\\r\\n\\t\\tthis.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetFromVector3: function ( v ) {\\r\\n\\r\\n\\t\\treturn this.setFromCartesianCoords( v.x, v.y, v.z );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetFromCartesianCoords: function ( x, y, z ) {\\r\\n\\r\\n\\t\\tthis.radius = Math.sqrt( x * x + y * y + z * z );\\r\\n\\r\\n\\t\\tif ( this.radius === 0 ) {\\r\\n\\r\\n\\t\\t\\tthis.theta = 0;\\r\\n\\t\\t\\tthis.phi = 0;\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tthis.theta = Math.atan2( x, z );\\r\\n\\t\\t\\tthis.phi = Math.acos( MathUtils.clamp( y / this.radius, - 1, 1 ) );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author Mugen87 / https://github.com/Mugen87\\r\\n *\\r\\n * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system\\r\\n *\\r\\n */\\r\\n\\r\\nfunction Cylindrical( radius, theta, y ) {\\r\\n\\r\\n\\tthis.radius = ( radius !== undefined ) ? radius : 1.0; // distance from the origin to a point in the x-z plane\\r\\n\\tthis.theta = ( theta !== undefined ) ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis\\r\\n\\tthis.y = ( y !== undefined ) ? y : 0; // height above the x-z plane\\r\\n\\r\\n\\treturn this;\\r\\n\\r\\n}\\r\\n\\r\\nObject.assign( Cylindrical.prototype, {\\r\\n\\r\\n\\tset: function ( radius, theta, y ) {\\r\\n\\r\\n\\t\\tthis.radius = radius;\\r\\n\\t\\tthis.theta = theta;\\r\\n\\t\\tthis.y = y;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclone: function () {\\r\\n\\r\\n\\t\\treturn new this.constructor().copy( this );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcopy: function ( other ) {\\r\\n\\r\\n\\t\\tthis.radius = other.radius;\\r\\n\\t\\tthis.theta = other.theta;\\r\\n\\t\\tthis.y = other.y;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetFromVector3: function ( v ) {\\r\\n\\r\\n\\t\\treturn this.setFromCartesianCoords( v.x, v.y, v.z );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetFromCartesianCoords: function ( x, y, z ) {\\r\\n\\r\\n\\t\\tthis.radius = Math.sqrt( x * x + z * z );\\r\\n\\t\\tthis.theta = Math.atan2( x, z );\\r\\n\\t\\tthis.y = y;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author bhouston / http://clara.io\\r\\n */\\r\\n\\r\\nvar _vector$7 = new Vector2();\\r\\n\\r\\nfunction Box2( min, max ) {\\r\\n\\r\\n\\tthis.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity );\\r\\n\\tthis.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity );\\r\\n\\r\\n}\\r\\n\\r\\nObject.assign( Box2.prototype, {\\r\\n\\r\\n\\tset: function ( min, max ) {\\r\\n\\r\\n\\t\\tthis.min.copy( min );\\r\\n\\t\\tthis.max.copy( max );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetFromPoints: function ( points ) {\\r\\n\\r\\n\\t\\tthis.makeEmpty();\\r\\n\\r\\n\\t\\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\\r\\n\\r\\n\\t\\t\\tthis.expandByPoint( points[ i ] );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetFromCenterAndSize: function ( center, size ) {\\r\\n\\r\\n\\t\\tvar halfSize = _vector$7.copy( size ).multiplyScalar( 0.5 );\\r\\n\\t\\tthis.min.copy( center ).sub( halfSize );\\r\\n\\t\\tthis.max.copy( center ).add( halfSize );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclone: function () {\\r\\n\\r\\n\\t\\treturn new this.constructor().copy( this );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcopy: function ( box ) {\\r\\n\\r\\n\\t\\tthis.min.copy( box.min );\\r\\n\\t\\tthis.max.copy( box.max );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tmakeEmpty: function () {\\r\\n\\r\\n\\t\\tthis.min.x = this.min.y = + Infinity;\\r\\n\\t\\tthis.max.x = this.max.y = - Infinity;\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tisEmpty: function () {\\r\\n\\r\\n\\t\\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\\r\\n\\r\\n\\t\\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetCenter: function ( target ) {\\r\\n\\r\\n\\t\\tif ( target === undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Box2: .getCenter() target is now required' );\\r\\n\\t\\t\\ttarget = new Vector2();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this.isEmpty() ? target.set( 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetSize: function ( target ) {\\r\\n\\r\\n\\t\\tif ( target === undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Box2: .getSize() target is now required' );\\r\\n\\t\\t\\ttarget = new Vector2();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this.isEmpty() ? target.set( 0, 0 ) : target.subVectors( this.max, this.min );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\texpandByPoint: function ( point ) {\\r\\n\\r\\n\\t\\tthis.min.min( point );\\r\\n\\t\\tthis.max.max( point );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\texpandByVector: function ( vector ) {\\r\\n\\r\\n\\t\\tthis.min.sub( vector );\\r\\n\\t\\tthis.max.add( vector );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\texpandByScalar: function ( scalar ) {\\r\\n\\r\\n\\t\\tthis.min.addScalar( - scalar );\\r\\n\\t\\tthis.max.addScalar( scalar );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcontainsPoint: function ( point ) {\\r\\n\\r\\n\\t\\treturn point.x < this.min.x || point.x > this.max.x ||\\r\\n\\t\\t\\tpoint.y < this.min.y || point.y > this.max.y ? false : true;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcontainsBox: function ( box ) {\\r\\n\\r\\n\\t\\treturn this.min.x <= box.min.x && box.max.x <= this.max.x &&\\r\\n\\t\\t\\tthis.min.y <= box.min.y && box.max.y <= this.max.y;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetParameter: function ( point, target ) {\\r\\n\\r\\n\\t\\t// This can potentially have a divide by zero if the box\\r\\n\\t\\t// has a size dimension of 0.\\r\\n\\r\\n\\t\\tif ( target === undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Box2: .getParameter() target is now required' );\\r\\n\\t\\t\\ttarget = new Vector2();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn target.set(\\r\\n\\t\\t\\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\\r\\n\\t\\t\\t( point.y - this.min.y ) / ( this.max.y - this.min.y )\\r\\n\\t\\t);\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tintersectsBox: function ( box ) {\\r\\n\\r\\n\\t\\t// using 4 splitting planes to rule out intersections\\r\\n\\r\\n\\t\\treturn box.max.x < this.min.x || box.min.x > this.max.x ||\\r\\n\\t\\t\\tbox.max.y < this.min.y || box.min.y > this.max.y ? false : true;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclampPoint: function ( point, target ) {\\r\\n\\r\\n\\t\\tif ( target === undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Box2: .clampPoint() target is now required' );\\r\\n\\t\\t\\ttarget = new Vector2();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn target.copy( point ).clamp( this.min, this.max );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tdistanceToPoint: function ( point ) {\\r\\n\\r\\n\\t\\tvar clampedPoint = _vector$7.copy( point ).clamp( this.min, this.max );\\r\\n\\t\\treturn clampedPoint.sub( point ).length();\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tintersect: function ( box ) {\\r\\n\\r\\n\\t\\tthis.min.max( box.min );\\r\\n\\t\\tthis.max.min( box.max );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tunion: function ( box ) {\\r\\n\\r\\n\\t\\tthis.min.min( box.min );\\r\\n\\t\\tthis.max.max( box.max );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\ttranslate: function ( offset ) {\\r\\n\\r\\n\\t\\tthis.min.add( offset );\\r\\n\\t\\tthis.max.add( offset );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tequals: function ( box ) {\\r\\n\\r\\n\\t\\treturn box.min.equals( this.min ) && box.max.equals( this.max );\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author bhouston / http://clara.io\\r\\n */\\r\\n\\r\\nvar _startP = new Vector3();\\r\\nvar _startEnd = new Vector3();\\r\\n\\r\\nfunction Line3( start, end ) {\\r\\n\\r\\n\\tthis.start = ( start !== undefined ) ? start : new Vector3();\\r\\n\\tthis.end = ( end !== undefined ) ? end : new Vector3();\\r\\n\\r\\n}\\r\\n\\r\\nObject.assign( Line3.prototype, {\\r\\n\\r\\n\\tset: function ( start, end ) {\\r\\n\\r\\n\\t\\tthis.start.copy( start );\\r\\n\\t\\tthis.end.copy( end );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclone: function () {\\r\\n\\r\\n\\t\\treturn new this.constructor().copy( this );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcopy: function ( line ) {\\r\\n\\r\\n\\t\\tthis.start.copy( line.start );\\r\\n\\t\\tthis.end.copy( line.end );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tgetCenter: function ( target ) {\\r\\n\\r\\n\\t\\tif ( target === undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Line3: .getCenter() target is now required' );\\r\\n\\t\\t\\ttarget = new Vector3();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn target.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tdelta: function ( target ) {\\r\\n\\r\\n\\t\\tif ( target === undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Line3: .delta() target is now required' );\\r\\n\\t\\t\\ttarget = new Vector3();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn target.subVectors( this.end, this.start );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tdistanceSq: function () {\\r\\n\\r\\n\\t\\treturn this.start.distanceToSquared( this.end );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tdistance: function () {\\r\\n\\r\\n\\t\\treturn this.start.distanceTo( this.end );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tat: function ( t, target ) {\\r\\n\\r\\n\\t\\tif ( target === undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Line3: .at() target is now required' );\\r\\n\\t\\t\\ttarget = new Vector3();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this.delta( target ).multiplyScalar( t ).add( this.start );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclosestPointToPointParameter: function ( point, clampToLine ) {\\r\\n\\r\\n\\t\\t_startP.subVectors( point, this.start );\\r\\n\\t\\t_startEnd.subVectors( this.end, this.start );\\r\\n\\r\\n\\t\\tvar startEnd2 = _startEnd.dot( _startEnd );\\r\\n\\t\\tvar startEnd_startP = _startEnd.dot( _startP );\\r\\n\\r\\n\\t\\tvar t = startEnd_startP / startEnd2;\\r\\n\\r\\n\\t\\tif ( clampToLine ) {\\r\\n\\r\\n\\t\\t\\tt = MathUtils.clamp( t, 0, 1 );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn t;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclosestPointToPoint: function ( point, clampToLine, target ) {\\r\\n\\r\\n\\t\\tvar t = this.closestPointToPointParameter( point, clampToLine );\\r\\n\\r\\n\\t\\tif ( target === undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Line3: .closestPointToPoint() target is now required' );\\r\\n\\t\\t\\ttarget = new Vector3();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this.delta( target ).multiplyScalar( t ).add( this.start );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tapplyMatrix4: function ( matrix ) {\\r\\n\\r\\n\\t\\tthis.start.applyMatrix4( matrix );\\r\\n\\t\\tthis.end.applyMatrix4( matrix );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tequals: function ( line ) {\\r\\n\\r\\n\\t\\treturn line.start.equals( this.start ) && line.end.equals( this.end );\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n */\\r\\n\\r\\nfunction ImmediateRenderObject( material ) {\\r\\n\\r\\n\\tObject3D.call( this );\\r\\n\\r\\n\\tthis.material = material;\\r\\n\\tthis.render = function ( /* renderCallback */ ) {};\\r\\n\\r\\n\\tthis.hasPositions = false;\\r\\n\\tthis.hasNormals = false;\\r\\n\\tthis.hasColors = false;\\r\\n\\tthis.hasUvs = false;\\r\\n\\r\\n\\tthis.positionArray = null;\\r\\n\\tthis.normalArray = null;\\r\\n\\tthis.colorArray = null;\\r\\n\\tthis.uvArray = null;\\r\\n\\r\\n\\tthis.count = 0;\\r\\n\\r\\n}\\r\\n\\r\\nImmediateRenderObject.prototype = Object.create( Object3D.prototype );\\r\\nImmediateRenderObject.prototype.constructor = ImmediateRenderObject;\\r\\n\\r\\nImmediateRenderObject.prototype.isImmediateRenderObject = true;\\r\\n\\r\\n/**\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n * @author WestLangley / http://github.com/WestLangley\\r\\n */\\r\\n\\r\\nvar _vector$8 = new Vector3();\\r\\n\\r\\nfunction SpotLightHelper( light, color ) {\\r\\n\\r\\n\\tObject3D.call( this );\\r\\n\\r\\n\\tthis.light = light;\\r\\n\\tthis.light.updateMatrixWorld();\\r\\n\\r\\n\\tthis.matrix = light.matrixWorld;\\r\\n\\tthis.matrixAutoUpdate = false;\\r\\n\\r\\n\\tthis.color = color;\\r\\n\\r\\n\\tvar geometry = new BufferGeometry();\\r\\n\\r\\n\\tvar positions = [\\r\\n\\t\\t0, 0, 0, \\t0, 0, 1,\\r\\n\\t\\t0, 0, 0, \\t1, 0, 1,\\r\\n\\t\\t0, 0, 0,\\t- 1, 0, 1,\\r\\n\\t\\t0, 0, 0, \\t0, 1, 1,\\r\\n\\t\\t0, 0, 0, \\t0, - 1, 1\\r\\n\\t];\\r\\n\\r\\n\\tfor ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {\\r\\n\\r\\n\\t\\tvar p1 = ( i / l ) * Math.PI * 2;\\r\\n\\t\\tvar p2 = ( j / l ) * Math.PI * 2;\\r\\n\\r\\n\\t\\tpositions.push(\\r\\n\\t\\t\\tMath.cos( p1 ), Math.sin( p1 ), 1,\\r\\n\\t\\t\\tMath.cos( p2 ), Math.sin( p2 ), 1\\r\\n\\t\\t);\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tgeometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\\r\\n\\r\\n\\tvar material = new LineBasicMaterial( { fog: false, toneMapped: false } );\\r\\n\\r\\n\\tthis.cone = new LineSegments( geometry, material );\\r\\n\\tthis.add( this.cone );\\r\\n\\r\\n\\tthis.update();\\r\\n\\r\\n}\\r\\n\\r\\nSpotLightHelper.prototype = Object.create( Object3D.prototype );\\r\\nSpotLightHelper.prototype.constructor = SpotLightHelper;\\r\\n\\r\\nSpotLightHelper.prototype.dispose = function () {\\r\\n\\r\\n\\tthis.cone.geometry.dispose();\\r\\n\\tthis.cone.material.dispose();\\r\\n\\r\\n};\\r\\n\\r\\nSpotLightHelper.prototype.update = function () {\\r\\n\\r\\n\\tthis.light.updateMatrixWorld();\\r\\n\\r\\n\\tvar coneLength = this.light.distance ? this.light.distance : 1000;\\r\\n\\tvar coneWidth = coneLength * Math.tan( this.light.angle );\\r\\n\\r\\n\\tthis.cone.scale.set( coneWidth, coneWidth, coneLength );\\r\\n\\r\\n\\t_vector$8.setFromMatrixPosition( this.light.target.matrixWorld );\\r\\n\\r\\n\\tthis.cone.lookAt( _vector$8 );\\r\\n\\r\\n\\tif ( this.color !== undefined ) {\\r\\n\\r\\n\\t\\tthis.cone.material.color.set( this.color );\\r\\n\\r\\n\\t} else {\\r\\n\\r\\n\\t\\tthis.cone.material.color.copy( this.light.color );\\r\\n\\r\\n\\t}\\r\\n\\r\\n};\\r\\n\\r\\n/**\\r\\n * @author Sean Griffin / http://twitter.com/sgrif\\r\\n * @author Michael Guerrero / http://realitymeltdown.com\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n * @author ikerr / http://verold.com\\r\\n * @author Mugen87 / https://github.com/Mugen87\\r\\n */\\r\\n\\r\\nvar _vector$9 = new Vector3();\\r\\nvar _boneMatrix = new Matrix4();\\r\\nvar _matrixWorldInv = new Matrix4();\\r\\n\\r\\nfunction getBoneList( object ) {\\r\\n\\r\\n\\tvar boneList = [];\\r\\n\\r\\n\\tif ( object && object.isBone ) {\\r\\n\\r\\n\\t\\tboneList.push( object );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfor ( var i = 0; i < object.children.length; i ++ ) {\\r\\n\\r\\n\\t\\tboneList.push.apply( boneList, getBoneList( object.children[ i ] ) );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn boneList;\\r\\n\\r\\n}\\r\\n\\r\\nfunction SkeletonHelper( object ) {\\r\\n\\r\\n\\tvar bones = getBoneList( object );\\r\\n\\r\\n\\tvar geometry = new BufferGeometry();\\r\\n\\r\\n\\tvar vertices = [];\\r\\n\\tvar colors = [];\\r\\n\\r\\n\\tvar color1 = new Color( 0, 0, 1 );\\r\\n\\tvar color2 = new Color( 0, 1, 0 );\\r\\n\\r\\n\\tfor ( var i = 0; i < bones.length; i ++ ) {\\r\\n\\r\\n\\t\\tvar bone = bones[ i ];\\r\\n\\r\\n\\t\\tif ( bone.parent && bone.parent.isBone ) {\\r\\n\\r\\n\\t\\t\\tvertices.push( 0, 0, 0 );\\r\\n\\t\\t\\tvertices.push( 0, 0, 0 );\\r\\n\\t\\t\\tcolors.push( color1.r, color1.g, color1.b );\\r\\n\\t\\t\\tcolors.push( color2.r, color2.g, color2.b );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\r\\n\\tgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\\r\\n\\r\\n\\tvar material = new LineBasicMaterial( { vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true } );\\r\\n\\r\\n\\tLineSegments.call( this, geometry, material );\\r\\n\\r\\n\\tthis.type = 'SkeletonHelper';\\r\\n\\r\\n\\tthis.root = object;\\r\\n\\tthis.bones = bones;\\r\\n\\r\\n\\tthis.matrix = object.matrixWorld;\\r\\n\\tthis.matrixAutoUpdate = false;\\r\\n\\r\\n}\\r\\n\\r\\nSkeletonHelper.prototype = Object.create( LineSegments.prototype );\\r\\nSkeletonHelper.prototype.constructor = SkeletonHelper;\\r\\n\\r\\nSkeletonHelper.prototype.isSkeletonHelper = true;\\r\\n\\r\\nSkeletonHelper.prototype.updateMatrixWorld = function ( force ) {\\r\\n\\r\\n\\tvar bones = this.bones;\\r\\n\\r\\n\\tvar geometry = this.geometry;\\r\\n\\tvar position = geometry.getAttribute( 'position' );\\r\\n\\r\\n\\t_matrixWorldInv.getInverse( this.root.matrixWorld );\\r\\n\\r\\n\\tfor ( var i = 0, j = 0; i < bones.length; i ++ ) {\\r\\n\\r\\n\\t\\tvar bone = bones[ i ];\\r\\n\\r\\n\\t\\tif ( bone.parent && bone.parent.isBone ) {\\r\\n\\r\\n\\t\\t\\t_boneMatrix.multiplyMatrices( _matrixWorldInv, bone.matrixWorld );\\r\\n\\t\\t\\t_vector$9.setFromMatrixPosition( _boneMatrix );\\r\\n\\t\\t\\tposition.setXYZ( j, _vector$9.x, _vector$9.y, _vector$9.z );\\r\\n\\r\\n\\t\\t\\t_boneMatrix.multiplyMatrices( _matrixWorldInv, bone.parent.matrixWorld );\\r\\n\\t\\t\\t_vector$9.setFromMatrixPosition( _boneMatrix );\\r\\n\\t\\t\\tposition.setXYZ( j + 1, _vector$9.x, _vector$9.y, _vector$9.z );\\r\\n\\r\\n\\t\\t\\tj += 2;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tgeometry.getAttribute( 'position' ).needsUpdate = true;\\r\\n\\r\\n\\tObject3D.prototype.updateMatrixWorld.call( this, force );\\r\\n\\r\\n};\\r\\n\\r\\n/**\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nfunction PointLightHelper( light, sphereSize, color ) {\\r\\n\\r\\n\\tthis.light = light;\\r\\n\\tthis.light.updateMatrixWorld();\\r\\n\\r\\n\\tthis.color = color;\\r\\n\\r\\n\\tvar geometry = new SphereBufferGeometry( sphereSize, 4, 2 );\\r\\n\\tvar material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );\\r\\n\\r\\n\\tMesh.call( this, geometry, material );\\r\\n\\r\\n\\tthis.type = 'PointLightHelper';\\r\\n\\r\\n\\tthis.matrix = this.light.matrixWorld;\\r\\n\\tthis.matrixAutoUpdate = false;\\r\\n\\r\\n\\tthis.update();\\r\\n\\r\\n\\r\\n\\t/*\\r\\n\\tvar distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 );\\r\\n\\tvar distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\\r\\n\\r\\n\\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\\r\\n\\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\\r\\n\\r\\n\\tvar d = light.distance;\\r\\n\\r\\n\\tif ( d === 0.0 ) {\\r\\n\\r\\n\\t\\tthis.lightDistance.visible = false;\\r\\n\\r\\n\\t} else {\\r\\n\\r\\n\\t\\tthis.lightDistance.scale.set( d, d, d );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tthis.add( this.lightDistance );\\r\\n\\t*/\\r\\n\\r\\n}\\r\\n\\r\\nPointLightHelper.prototype = Object.create( Mesh.prototype );\\r\\nPointLightHelper.prototype.constructor = PointLightHelper;\\r\\n\\r\\nPointLightHelper.prototype.dispose = function () {\\r\\n\\r\\n\\tthis.geometry.dispose();\\r\\n\\tthis.material.dispose();\\r\\n\\r\\n};\\r\\n\\r\\nPointLightHelper.prototype.update = function () {\\r\\n\\r\\n\\tif ( this.color !== undefined ) {\\r\\n\\r\\n\\t\\tthis.material.color.set( this.color );\\r\\n\\r\\n\\t} else {\\r\\n\\r\\n\\t\\tthis.material.color.copy( this.light.color );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t/*\\r\\n\\tvar d = this.light.distance;\\r\\n\\r\\n\\tif ( d === 0.0 ) {\\r\\n\\r\\n\\t\\tthis.lightDistance.visible = false;\\r\\n\\r\\n\\t} else {\\r\\n\\r\\n\\t\\tthis.lightDistance.visible = true;\\r\\n\\t\\tthis.lightDistance.scale.set( d, d, d );\\r\\n\\r\\n\\t}\\r\\n\\t*/\\r\\n\\r\\n};\\r\\n\\r\\n/**\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n * @author Mugen87 / https://github.com/Mugen87\\r\\n */\\r\\n\\r\\nvar _vector$a = new Vector3();\\r\\nvar _color1 = new Color();\\r\\nvar _color2 = new Color();\\r\\n\\r\\nfunction HemisphereLightHelper( light, size, color ) {\\r\\n\\r\\n\\tObject3D.call( this );\\r\\n\\r\\n\\tthis.light = light;\\r\\n\\tthis.light.updateMatrixWorld();\\r\\n\\r\\n\\tthis.matrix = light.matrixWorld;\\r\\n\\tthis.matrixAutoUpdate = false;\\r\\n\\r\\n\\tthis.color = color;\\r\\n\\r\\n\\tvar geometry = new OctahedronBufferGeometry( size );\\r\\n\\tgeometry.rotateY( Math.PI * 0.5 );\\r\\n\\r\\n\\tthis.material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );\\r\\n\\tif ( this.color === undefined ) this.material.vertexColors = true;\\r\\n\\r\\n\\tvar position = geometry.getAttribute( 'position' );\\r\\n\\tvar colors = new Float32Array( position.count * 3 );\\r\\n\\r\\n\\tgeometry.setAttribute( 'color', new BufferAttribute( colors, 3 ) );\\r\\n\\r\\n\\tthis.add( new Mesh( geometry, this.material ) );\\r\\n\\r\\n\\tthis.update();\\r\\n\\r\\n}\\r\\n\\r\\nHemisphereLightHelper.prototype = Object.create( Object3D.prototype );\\r\\nHemisphereLightHelper.prototype.constructor = HemisphereLightHelper;\\r\\n\\r\\nHemisphereLightHelper.prototype.dispose = function () {\\r\\n\\r\\n\\tthis.children[ 0 ].geometry.dispose();\\r\\n\\tthis.children[ 0 ].material.dispose();\\r\\n\\r\\n};\\r\\n\\r\\nHemisphereLightHelper.prototype.update = function () {\\r\\n\\r\\n\\tvar mesh = this.children[ 0 ];\\r\\n\\r\\n\\tif ( this.color !== undefined ) {\\r\\n\\r\\n\\t\\tthis.material.color.set( this.color );\\r\\n\\r\\n\\t} else {\\r\\n\\r\\n\\t\\tvar colors = mesh.geometry.getAttribute( 'color' );\\r\\n\\r\\n\\t\\t_color1.copy( this.light.color );\\r\\n\\t\\t_color2.copy( this.light.groundColor );\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = colors.count; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar color = ( i < ( l / 2 ) ) ? _color1 : _color2;\\r\\n\\r\\n\\t\\t\\tcolors.setXYZ( i, color.r, color.g, color.b );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tcolors.needsUpdate = true;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tmesh.lookAt( _vector$a.setFromMatrixPosition( this.light.matrixWorld ).negate() );\\r\\n\\r\\n};\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nfunction GridHelper( size, divisions, color1, color2 ) {\\r\\n\\r\\n\\tsize = size || 10;\\r\\n\\tdivisions = divisions || 10;\\r\\n\\tcolor1 = new Color( color1 !== undefined ? color1 : 0x444444 );\\r\\n\\tcolor2 = new Color( color2 !== undefined ? color2 : 0x888888 );\\r\\n\\r\\n\\tvar center = divisions / 2;\\r\\n\\tvar step = size / divisions;\\r\\n\\tvar halfSize = size / 2;\\r\\n\\r\\n\\tvar vertices = [], colors = [];\\r\\n\\r\\n\\tfor ( var i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {\\r\\n\\r\\n\\t\\tvertices.push( - halfSize, 0, k, halfSize, 0, k );\\r\\n\\t\\tvertices.push( k, 0, - halfSize, k, 0, halfSize );\\r\\n\\r\\n\\t\\tvar color = i === center ? color1 : color2;\\r\\n\\r\\n\\t\\tcolor.toArray( colors, j ); j += 3;\\r\\n\\t\\tcolor.toArray( colors, j ); j += 3;\\r\\n\\t\\tcolor.toArray( colors, j ); j += 3;\\r\\n\\t\\tcolor.toArray( colors, j ); j += 3;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tvar geometry = new BufferGeometry();\\r\\n\\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\r\\n\\tgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\\r\\n\\r\\n\\tvar material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );\\r\\n\\r\\n\\tLineSegments.call( this, geometry, material );\\r\\n\\r\\n\\tthis.type = 'GridHelper';\\r\\n\\r\\n}\\r\\n\\r\\nGridHelper.prototype = Object.assign( Object.create( LineSegments.prototype ), {\\r\\n\\r\\n\\tconstructor: GridHelper,\\r\\n\\r\\n\\tcopy: function ( source ) {\\r\\n\\r\\n\\t\\tLineSegments.prototype.copy.call( this, source );\\r\\n\\r\\n\\t\\tthis.geometry.copy( source.geometry );\\r\\n\\t\\tthis.material.copy( source.material );\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tclone: function () {\\r\\n\\r\\n\\t\\treturn new this.constructor().copy( this );\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n * @author Mugen87 / http://github.com/Mugen87\\r\\n * @author Hectate / http://www.github.com/Hectate\\r\\n */\\r\\n\\r\\nfunction PolarGridHelper( radius, radials, circles, divisions, color1, color2 ) {\\r\\n\\r\\n\\tradius = radius || 10;\\r\\n\\tradials = radials || 16;\\r\\n\\tcircles = circles || 8;\\r\\n\\tdivisions = divisions || 64;\\r\\n\\tcolor1 = new Color( color1 !== undefined ? color1 : 0x444444 );\\r\\n\\tcolor2 = new Color( color2 !== undefined ? color2 : 0x888888 );\\r\\n\\r\\n\\tvar vertices = [];\\r\\n\\tvar colors = [];\\r\\n\\r\\n\\tvar x, z;\\r\\n\\tvar v, i, j, r, color;\\r\\n\\r\\n\\t// create the radials\\r\\n\\r\\n\\tfor ( i = 0; i <= radials; i ++ ) {\\r\\n\\r\\n\\t\\tv = ( i / radials ) * ( Math.PI * 2 );\\r\\n\\r\\n\\t\\tx = Math.sin( v ) * radius;\\r\\n\\t\\tz = Math.cos( v ) * radius;\\r\\n\\r\\n\\t\\tvertices.push( 0, 0, 0 );\\r\\n\\t\\tvertices.push( x, 0, z );\\r\\n\\r\\n\\t\\tcolor = ( i & 1 ) ? color1 : color2;\\r\\n\\r\\n\\t\\tcolors.push( color.r, color.g, color.b );\\r\\n\\t\\tcolors.push( color.r, color.g, color.b );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// create the circles\\r\\n\\r\\n\\tfor ( i = 0; i <= circles; i ++ ) {\\r\\n\\r\\n\\t\\tcolor = ( i & 1 ) ? color1 : color2;\\r\\n\\r\\n\\t\\tr = radius - ( radius / circles * i );\\r\\n\\r\\n\\t\\tfor ( j = 0; j < divisions; j ++ ) {\\r\\n\\r\\n\\t\\t\\t// first vertex\\r\\n\\r\\n\\t\\t\\tv = ( j / divisions ) * ( Math.PI * 2 );\\r\\n\\r\\n\\t\\t\\tx = Math.sin( v ) * r;\\r\\n\\t\\t\\tz = Math.cos( v ) * r;\\r\\n\\r\\n\\t\\t\\tvertices.push( x, 0, z );\\r\\n\\t\\t\\tcolors.push( color.r, color.g, color.b );\\r\\n\\r\\n\\t\\t\\t// second vertex\\r\\n\\r\\n\\t\\t\\tv = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );\\r\\n\\r\\n\\t\\t\\tx = Math.sin( v ) * r;\\r\\n\\t\\t\\tz = Math.cos( v ) * r;\\r\\n\\r\\n\\t\\t\\tvertices.push( x, 0, z );\\r\\n\\t\\t\\tcolors.push( color.r, color.g, color.b );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tvar geometry = new BufferGeometry();\\r\\n\\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\r\\n\\tgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\\r\\n\\r\\n\\tvar material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );\\r\\n\\r\\n\\tLineSegments.call( this, geometry, material );\\r\\n\\r\\n\\tthis.type = 'PolarGridHelper';\\r\\n\\r\\n}\\r\\n\\r\\nPolarGridHelper.prototype = Object.create( LineSegments.prototype );\\r\\nPolarGridHelper.prototype.constructor = PolarGridHelper;\\r\\n\\r\\n/**\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n * @author WestLangley / http://github.com/WestLangley\\r\\n */\\r\\n\\r\\nvar _v1$5 = new Vector3();\\r\\nvar _v2$3 = new Vector3();\\r\\nvar _v3$1 = new Vector3();\\r\\n\\r\\nfunction DirectionalLightHelper( light, size, color ) {\\r\\n\\r\\n\\tObject3D.call( this );\\r\\n\\r\\n\\tthis.light = light;\\r\\n\\tthis.light.updateMatrixWorld();\\r\\n\\r\\n\\tthis.matrix = light.matrixWorld;\\r\\n\\tthis.matrixAutoUpdate = false;\\r\\n\\r\\n\\tthis.color = color;\\r\\n\\r\\n\\tif ( size === undefined ) size = 1;\\r\\n\\r\\n\\tvar geometry = new BufferGeometry();\\r\\n\\tgeometry.setAttribute( 'position', new Float32BufferAttribute( [\\r\\n\\t\\t- size, size, 0,\\r\\n\\t\\tsize, size, 0,\\r\\n\\t\\tsize, - size, 0,\\r\\n\\t\\t- size, - size, 0,\\r\\n\\t\\t- size, size, 0\\r\\n\\t], 3 ) );\\r\\n\\r\\n\\tvar material = new LineBasicMaterial( { fog: false, toneMapped: false } );\\r\\n\\r\\n\\tthis.lightPlane = new Line( geometry, material );\\r\\n\\tthis.add( this.lightPlane );\\r\\n\\r\\n\\tgeometry = new BufferGeometry();\\r\\n\\tgeometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );\\r\\n\\r\\n\\tthis.targetLine = new Line( geometry, material );\\r\\n\\tthis.add( this.targetLine );\\r\\n\\r\\n\\tthis.update();\\r\\n\\r\\n}\\r\\n\\r\\nDirectionalLightHelper.prototype = Object.create( Object3D.prototype );\\r\\nDirectionalLightHelper.prototype.constructor = DirectionalLightHelper;\\r\\n\\r\\nDirectionalLightHelper.prototype.dispose = function () {\\r\\n\\r\\n\\tthis.lightPlane.geometry.dispose();\\r\\n\\tthis.lightPlane.material.dispose();\\r\\n\\tthis.targetLine.geometry.dispose();\\r\\n\\tthis.targetLine.material.dispose();\\r\\n\\r\\n};\\r\\n\\r\\nDirectionalLightHelper.prototype.update = function () {\\r\\n\\r\\n\\t_v1$5.setFromMatrixPosition( this.light.matrixWorld );\\r\\n\\t_v2$3.setFromMatrixPosition( this.light.target.matrixWorld );\\r\\n\\t_v3$1.subVectors( _v2$3, _v1$5 );\\r\\n\\r\\n\\tthis.lightPlane.lookAt( _v2$3 );\\r\\n\\r\\n\\tif ( this.color !== undefined ) {\\r\\n\\r\\n\\t\\tthis.lightPlane.material.color.set( this.color );\\r\\n\\t\\tthis.targetLine.material.color.set( this.color );\\r\\n\\r\\n\\t} else {\\r\\n\\r\\n\\t\\tthis.lightPlane.material.color.copy( this.light.color );\\r\\n\\t\\tthis.targetLine.material.color.copy( this.light.color );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tthis.targetLine.lookAt( _v2$3 );\\r\\n\\tthis.targetLine.scale.z = _v3$1.length();\\r\\n\\r\\n};\\r\\n\\r\\n/**\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n * @author Mugen87 / https://github.com/Mugen87\\r\\n *\\r\\n *\\t- shows frustum, line of sight and up of the camera\\r\\n *\\t- suitable for fast updates\\r\\n * \\t- based on frustum visualization in lightgl.js shadowmap example\\r\\n *\\t\\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\\r\\n */\\r\\n\\r\\nvar _vector$b = new Vector3();\\r\\nvar _camera = new Camera();\\r\\n\\r\\nfunction CameraHelper( camera ) {\\r\\n\\r\\n\\tvar geometry = new BufferGeometry();\\r\\n\\tvar material = new LineBasicMaterial( { color: 0xffffff, vertexColors: true, toneMapped: false } );\\r\\n\\r\\n\\tvar vertices = [];\\r\\n\\tvar colors = [];\\r\\n\\r\\n\\tvar pointMap = {};\\r\\n\\r\\n\\t// colors\\r\\n\\r\\n\\tvar colorFrustum = new Color( 0xffaa00 );\\r\\n\\tvar colorCone = new Color( 0xff0000 );\\r\\n\\tvar colorUp = new Color( 0x00aaff );\\r\\n\\tvar colorTarget = new Color( 0xffffff );\\r\\n\\tvar colorCross = new Color( 0x333333 );\\r\\n\\r\\n\\t// near\\r\\n\\r\\n\\taddLine( 'n1', 'n2', colorFrustum );\\r\\n\\taddLine( 'n2', 'n4', colorFrustum );\\r\\n\\taddLine( 'n4', 'n3', colorFrustum );\\r\\n\\taddLine( 'n3', 'n1', colorFrustum );\\r\\n\\r\\n\\t// far\\r\\n\\r\\n\\taddLine( 'f1', 'f2', colorFrustum );\\r\\n\\taddLine( 'f2', 'f4', colorFrustum );\\r\\n\\taddLine( 'f4', 'f3', colorFrustum );\\r\\n\\taddLine( 'f3', 'f1', colorFrustum );\\r\\n\\r\\n\\t// sides\\r\\n\\r\\n\\taddLine( 'n1', 'f1', colorFrustum );\\r\\n\\taddLine( 'n2', 'f2', colorFrustum );\\r\\n\\taddLine( 'n3', 'f3', colorFrustum );\\r\\n\\taddLine( 'n4', 'f4', colorFrustum );\\r\\n\\r\\n\\t// cone\\r\\n\\r\\n\\taddLine( 'p', 'n1', colorCone );\\r\\n\\taddLine( 'p', 'n2', colorCone );\\r\\n\\taddLine( 'p', 'n3', colorCone );\\r\\n\\taddLine( 'p', 'n4', colorCone );\\r\\n\\r\\n\\t// up\\r\\n\\r\\n\\taddLine( 'u1', 'u2', colorUp );\\r\\n\\taddLine( 'u2', 'u3', colorUp );\\r\\n\\taddLine( 'u3', 'u1', colorUp );\\r\\n\\r\\n\\t// target\\r\\n\\r\\n\\taddLine( 'c', 't', colorTarget );\\r\\n\\taddLine( 'p', 'c', colorCross );\\r\\n\\r\\n\\t// cross\\r\\n\\r\\n\\taddLine( 'cn1', 'cn2', colorCross );\\r\\n\\taddLine( 'cn3', 'cn4', colorCross );\\r\\n\\r\\n\\taddLine( 'cf1', 'cf2', colorCross );\\r\\n\\taddLine( 'cf3', 'cf4', colorCross );\\r\\n\\r\\n\\tfunction addLine( a, b, color ) {\\r\\n\\r\\n\\t\\taddPoint( a, color );\\r\\n\\t\\taddPoint( b, color );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction addPoint( id, color ) {\\r\\n\\r\\n\\t\\tvertices.push( 0, 0, 0 );\\r\\n\\t\\tcolors.push( color.r, color.g, color.b );\\r\\n\\r\\n\\t\\tif ( pointMap[ id ] === undefined ) {\\r\\n\\r\\n\\t\\t\\tpointMap[ id ] = [];\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tpointMap[ id ].push( ( vertices.length / 3 ) - 1 );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\r\\n\\tgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\\r\\n\\r\\n\\tLineSegments.call( this, geometry, material );\\r\\n\\r\\n\\tthis.type = 'CameraHelper';\\r\\n\\r\\n\\tthis.camera = camera;\\r\\n\\tif ( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();\\r\\n\\r\\n\\tthis.matrix = camera.matrixWorld;\\r\\n\\tthis.matrixAutoUpdate = false;\\r\\n\\r\\n\\tthis.pointMap = pointMap;\\r\\n\\r\\n\\tthis.update();\\r\\n\\r\\n}\\r\\n\\r\\nCameraHelper.prototype = Object.create( LineSegments.prototype );\\r\\nCameraHelper.prototype.constructor = CameraHelper;\\r\\n\\r\\nCameraHelper.prototype.update = function () {\\r\\n\\r\\n\\tvar geometry = this.geometry;\\r\\n\\tvar pointMap = this.pointMap;\\r\\n\\r\\n\\tvar w = 1, h = 1;\\r\\n\\r\\n\\t// we need just camera projection matrix inverse\\r\\n\\t// world matrix must be identity\\r\\n\\r\\n\\t_camera.projectionMatrixInverse.copy( this.camera.projectionMatrixInverse );\\r\\n\\r\\n\\t// center / target\\r\\n\\r\\n\\tsetPoint( 'c', pointMap, geometry, _camera, 0, 0, - 1 );\\r\\n\\tsetPoint( 't', pointMap, geometry, _camera, 0, 0, 1 );\\r\\n\\r\\n\\t// near\\r\\n\\r\\n\\tsetPoint( 'n1', pointMap, geometry, _camera, - w, - h, - 1 );\\r\\n\\tsetPoint( 'n2', pointMap, geometry, _camera, w, - h, - 1 );\\r\\n\\tsetPoint( 'n3', pointMap, geometry, _camera, - w, h, - 1 );\\r\\n\\tsetPoint( 'n4', pointMap, geometry, _camera, w, h, - 1 );\\r\\n\\r\\n\\t// far\\r\\n\\r\\n\\tsetPoint( 'f1', pointMap, geometry, _camera, - w, - h, 1 );\\r\\n\\tsetPoint( 'f2', pointMap, geometry, _camera, w, - h, 1 );\\r\\n\\tsetPoint( 'f3', pointMap, geometry, _camera, - w, h, 1 );\\r\\n\\tsetPoint( 'f4', pointMap, geometry, _camera, w, h, 1 );\\r\\n\\r\\n\\t// up\\r\\n\\r\\n\\tsetPoint( 'u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, - 1 );\\r\\n\\tsetPoint( 'u2', pointMap, geometry, _camera, - w * 0.7, h * 1.1, - 1 );\\r\\n\\tsetPoint( 'u3', pointMap, geometry, _camera, 0, h * 2, - 1 );\\r\\n\\r\\n\\t// cross\\r\\n\\r\\n\\tsetPoint( 'cf1', pointMap, geometry, _camera, - w, 0, 1 );\\r\\n\\tsetPoint( 'cf2', pointMap, geometry, _camera, w, 0, 1 );\\r\\n\\tsetPoint( 'cf3', pointMap, geometry, _camera, 0, - h, 1 );\\r\\n\\tsetPoint( 'cf4', pointMap, geometry, _camera, 0, h, 1 );\\r\\n\\r\\n\\tsetPoint( 'cn1', pointMap, geometry, _camera, - w, 0, - 1 );\\r\\n\\tsetPoint( 'cn2', pointMap, geometry, _camera, w, 0, - 1 );\\r\\n\\tsetPoint( 'cn3', pointMap, geometry, _camera, 0, - h, - 1 );\\r\\n\\tsetPoint( 'cn4', pointMap, geometry, _camera, 0, h, - 1 );\\r\\n\\r\\n\\tgeometry.getAttribute( 'position' ).needsUpdate = true;\\r\\n\\r\\n};\\r\\n\\r\\nfunction setPoint( point, pointMap, geometry, camera, x, y, z ) {\\r\\n\\r\\n\\t_vector$b.set( x, y, z ).unproject( camera );\\r\\n\\r\\n\\tvar points = pointMap[ point ];\\r\\n\\r\\n\\tif ( points !== undefined ) {\\r\\n\\r\\n\\t\\tvar position = geometry.getAttribute( 'position' );\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\tposition.setXYZ( points[ i ], _vector$b.x, _vector$b.y, _vector$b.z );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n * @author Mugen87 / http://github.com/Mugen87\\r\\n */\\r\\n\\r\\nvar _box$3 = new Box3();\\r\\n\\r\\nfunction BoxHelper( object, color ) {\\r\\n\\r\\n\\tthis.object = object;\\r\\n\\r\\n\\tif ( color === undefined ) color = 0xffff00;\\r\\n\\r\\n\\tvar indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\\r\\n\\tvar positions = new Float32Array( 8 * 3 );\\r\\n\\r\\n\\tvar geometry = new BufferGeometry();\\r\\n\\tgeometry.setIndex( new BufferAttribute( indices, 1 ) );\\r\\n\\tgeometry.setAttribute( 'position', new BufferAttribute( positions, 3 ) );\\r\\n\\r\\n\\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );\\r\\n\\r\\n\\tthis.type = 'BoxHelper';\\r\\n\\r\\n\\tthis.matrixAutoUpdate = false;\\r\\n\\r\\n\\tthis.update();\\r\\n\\r\\n}\\r\\n\\r\\nBoxHelper.prototype = Object.create( LineSegments.prototype );\\r\\nBoxHelper.prototype.constructor = BoxHelper;\\r\\n\\r\\nBoxHelper.prototype.update = function ( object ) {\\r\\n\\r\\n\\tif ( object !== undefined ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.BoxHelper: .update() has no longer arguments.' );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tif ( this.object !== undefined ) {\\r\\n\\r\\n\\t\\t_box$3.setFromObject( this.object );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tif ( _box$3.isEmpty() ) return;\\r\\n\\r\\n\\tvar min = _box$3.min;\\r\\n\\tvar max = _box$3.max;\\r\\n\\r\\n\\t/*\\r\\n\\t  5____4\\r\\n\\t1/___0/|\\r\\n\\t| 6__|_7\\r\\n\\t2/___3/\\r\\n\\r\\n\\t0: max.x, max.y, max.z\\r\\n\\t1: min.x, max.y, max.z\\r\\n\\t2: min.x, min.y, max.z\\r\\n\\t3: max.x, min.y, max.z\\r\\n\\t4: max.x, max.y, min.z\\r\\n\\t5: min.x, max.y, min.z\\r\\n\\t6: min.x, min.y, min.z\\r\\n\\t7: max.x, min.y, min.z\\r\\n\\t*/\\r\\n\\r\\n\\tvar position = this.geometry.attributes.position;\\r\\n\\tvar array = position.array;\\r\\n\\r\\n\\tarray[ 0 ] = max.x; array[ 1 ] = max.y; array[ 2 ] = max.z;\\r\\n\\tarray[ 3 ] = min.x; array[ 4 ] = max.y; array[ 5 ] = max.z;\\r\\n\\tarray[ 6 ] = min.x; array[ 7 ] = min.y; array[ 8 ] = max.z;\\r\\n\\tarray[ 9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;\\r\\n\\tarray[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;\\r\\n\\tarray[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;\\r\\n\\tarray[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;\\r\\n\\tarray[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;\\r\\n\\r\\n\\tposition.needsUpdate = true;\\r\\n\\r\\n\\tthis.geometry.computeBoundingSphere();\\r\\n\\r\\n\\r\\n};\\r\\n\\r\\nBoxHelper.prototype.setFromObject = function ( object ) {\\r\\n\\r\\n\\tthis.object = object;\\r\\n\\tthis.update();\\r\\n\\r\\n\\treturn this;\\r\\n\\r\\n};\\r\\n\\r\\nBoxHelper.prototype.copy = function ( source ) {\\r\\n\\r\\n\\tLineSegments.prototype.copy.call( this, source );\\r\\n\\r\\n\\tthis.object = source.object;\\r\\n\\r\\n\\treturn this;\\r\\n\\r\\n};\\r\\n\\r\\nBoxHelper.prototype.clone = function () {\\r\\n\\r\\n\\treturn new this.constructor().copy( this );\\r\\n\\r\\n};\\r\\n\\r\\n/**\\r\\n * @author WestLangley / http://github.com/WestLangley\\r\\n */\\r\\n\\r\\nfunction Box3Helper( box, color ) {\\r\\n\\r\\n\\tthis.type = 'Box3Helper';\\r\\n\\r\\n\\tthis.box = box;\\r\\n\\r\\n\\tcolor = color || 0xffff00;\\r\\n\\r\\n\\tvar indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\\r\\n\\r\\n\\tvar positions = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 1, - 1, 1, - 1, - 1 ];\\r\\n\\r\\n\\tvar geometry = new BufferGeometry();\\r\\n\\r\\n\\tgeometry.setIndex( new BufferAttribute( indices, 1 ) );\\r\\n\\r\\n\\tgeometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\\r\\n\\r\\n\\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );\\r\\n\\r\\n\\tthis.type = 'Box3Helper';\\r\\n\\r\\n\\tthis.geometry.computeBoundingSphere();\\r\\n\\r\\n}\\r\\n\\r\\nBox3Helper.prototype = Object.create( LineSegments.prototype );\\r\\nBox3Helper.prototype.constructor = Box3Helper;\\r\\n\\r\\nBox3Helper.prototype.updateMatrixWorld = function ( force ) {\\r\\n\\r\\n\\tvar box = this.box;\\r\\n\\r\\n\\tif ( box.isEmpty() ) return;\\r\\n\\r\\n\\tbox.getCenter( this.position );\\r\\n\\r\\n\\tbox.getSize( this.scale );\\r\\n\\r\\n\\tthis.scale.multiplyScalar( 0.5 );\\r\\n\\r\\n\\tObject3D.prototype.updateMatrixWorld.call( this, force );\\r\\n\\r\\n};\\r\\n\\r\\n/**\\r\\n * @author WestLangley / http://github.com/WestLangley\\r\\n */\\r\\n\\r\\nfunction PlaneHelper( plane, size, hex ) {\\r\\n\\r\\n\\tthis.plane = plane;\\r\\n\\r\\n\\tthis.size = ( size === undefined ) ? 1 : size;\\r\\n\\r\\n\\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\\r\\n\\r\\n\\tvar positions = [ 1, - 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0 ];\\r\\n\\r\\n\\tvar geometry = new BufferGeometry();\\r\\n\\tgeometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\\r\\n\\tgeometry.computeBoundingSphere();\\r\\n\\r\\n\\tLine.call( this, geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );\\r\\n\\r\\n\\tthis.type = 'PlaneHelper';\\r\\n\\r\\n\\t//\\r\\n\\r\\n\\tvar positions2 = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, - 1, 1, 1, - 1, 1 ];\\r\\n\\r\\n\\tvar geometry2 = new BufferGeometry();\\r\\n\\tgeometry2.setAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );\\r\\n\\tgeometry2.computeBoundingSphere();\\r\\n\\r\\n\\tthis.add( new Mesh( geometry2, new MeshBasicMaterial( { color: color, opacity: 0.2, transparent: true, depthWrite: false, toneMapped: false } ) ) );\\r\\n\\r\\n}\\r\\n\\r\\nPlaneHelper.prototype = Object.create( Line.prototype );\\r\\nPlaneHelper.prototype.constructor = PlaneHelper;\\r\\n\\r\\nPlaneHelper.prototype.updateMatrixWorld = function ( force ) {\\r\\n\\r\\n\\tvar scale = - this.plane.constant;\\r\\n\\r\\n\\tif ( Math.abs( scale ) < 1e-8 ) scale = 1e-8; // sign does not matter\\r\\n\\r\\n\\tthis.scale.set( 0.5 * this.size, 0.5 * this.size, scale );\\r\\n\\r\\n\\tthis.children[ 0 ].material.side = ( scale < 0 ) ? BackSide : FrontSide; // renderer flips side when determinant < 0; flipping not wanted here\\r\\n\\r\\n\\tthis.lookAt( this.plane.normal );\\r\\n\\r\\n\\tObject3D.prototype.updateMatrixWorld.call( this, force );\\r\\n\\r\\n};\\r\\n\\r\\n/**\\r\\n * @author WestLangley / http://github.com/WestLangley\\r\\n * @author zz85 / http://github.com/zz85\\r\\n * @author bhouston / http://clara.io\\r\\n *\\r\\n * Creates an arrow for visualizing directions\\r\\n *\\r\\n * Parameters:\\r\\n *  dir - Vector3\\r\\n *  origin - Vector3\\r\\n *  length - Number\\r\\n *  color - color in hex value\\r\\n *  headLength - Number\\r\\n *  headWidth - Number\\r\\n */\\r\\n\\r\\nvar _axis = new Vector3();\\r\\nvar _lineGeometry, _coneGeometry;\\r\\n\\r\\nfunction ArrowHelper( dir, origin, length, color, headLength, headWidth ) {\\r\\n\\r\\n\\t// dir is assumed to be normalized\\r\\n\\r\\n\\tObject3D.call( this );\\r\\n\\r\\n\\tthis.type = 'ArrowHelper';\\r\\n\\r\\n\\tif ( dir === undefined ) dir = new Vector3( 0, 0, 1 );\\r\\n\\tif ( origin === undefined ) origin = new Vector3( 0, 0, 0 );\\r\\n\\tif ( length === undefined ) length = 1;\\r\\n\\tif ( color === undefined ) color = 0xffff00;\\r\\n\\tif ( headLength === undefined ) headLength = 0.2 * length;\\r\\n\\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\\r\\n\\r\\n\\tif ( _lineGeometry === undefined ) {\\r\\n\\r\\n\\t\\t_lineGeometry = new BufferGeometry();\\r\\n\\t\\t_lineGeometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );\\r\\n\\r\\n\\t\\t_coneGeometry = new CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );\\r\\n\\t\\t_coneGeometry.translate( 0, - 0.5, 0 );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tthis.position.copy( origin );\\r\\n\\r\\n\\tthis.line = new Line( _lineGeometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );\\r\\n\\tthis.line.matrixAutoUpdate = false;\\r\\n\\tthis.add( this.line );\\r\\n\\r\\n\\tthis.cone = new Mesh( _coneGeometry, new MeshBasicMaterial( { color: color, toneMapped: false } ) );\\r\\n\\tthis.cone.matrixAutoUpdate = false;\\r\\n\\tthis.add( this.cone );\\r\\n\\r\\n\\tthis.setDirection( dir );\\r\\n\\tthis.setLength( length, headLength, headWidth );\\r\\n\\r\\n}\\r\\n\\r\\nArrowHelper.prototype = Object.create( Object3D.prototype );\\r\\nArrowHelper.prototype.constructor = ArrowHelper;\\r\\n\\r\\nArrowHelper.prototype.setDirection = function ( dir ) {\\r\\n\\r\\n\\t// dir is assumed to be normalized\\r\\n\\r\\n\\tif ( dir.y > 0.99999 ) {\\r\\n\\r\\n\\t\\tthis.quaternion.set( 0, 0, 0, 1 );\\r\\n\\r\\n\\t} else if ( dir.y < - 0.99999 ) {\\r\\n\\r\\n\\t\\tthis.quaternion.set( 1, 0, 0, 0 );\\r\\n\\r\\n\\t} else {\\r\\n\\r\\n\\t\\t_axis.set( dir.z, 0, - dir.x ).normalize();\\r\\n\\r\\n\\t\\tvar radians = Math.acos( dir.y );\\r\\n\\r\\n\\t\\tthis.quaternion.setFromAxisAngle( _axis, radians );\\r\\n\\r\\n\\t}\\r\\n\\r\\n};\\r\\n\\r\\nArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {\\r\\n\\r\\n\\tif ( headLength === undefined ) headLength = 0.2 * length;\\r\\n\\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\\r\\n\\r\\n\\tthis.line.scale.set( 1, Math.max( 0.0001, length - headLength ), 1 ); // see #17458\\r\\n\\tthis.line.updateMatrix();\\r\\n\\r\\n\\tthis.cone.scale.set( headWidth, headLength, headWidth );\\r\\n\\tthis.cone.position.y = length;\\r\\n\\tthis.cone.updateMatrix();\\r\\n\\r\\n};\\r\\n\\r\\nArrowHelper.prototype.setColor = function ( color ) {\\r\\n\\r\\n\\tthis.line.material.color.set( color );\\r\\n\\tthis.cone.material.color.set( color );\\r\\n\\r\\n};\\r\\n\\r\\nArrowHelper.prototype.copy = function ( source ) {\\r\\n\\r\\n\\tObject3D.prototype.copy.call( this, source, false );\\r\\n\\r\\n\\tthis.line.copy( source.line );\\r\\n\\tthis.cone.copy( source.cone );\\r\\n\\r\\n\\treturn this;\\r\\n\\r\\n};\\r\\n\\r\\nArrowHelper.prototype.clone = function () {\\r\\n\\r\\n\\treturn new this.constructor().copy( this );\\r\\n\\r\\n};\\r\\n\\r\\n/**\\r\\n * @author sroucheray / http://sroucheray.org/\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nfunction AxesHelper( size ) {\\r\\n\\r\\n\\tsize = size || 1;\\r\\n\\r\\n\\tvar vertices = [\\r\\n\\t\\t0, 0, 0,\\tsize, 0, 0,\\r\\n\\t\\t0, 0, 0,\\t0, size, 0,\\r\\n\\t\\t0, 0, 0,\\t0, 0, size\\r\\n\\t];\\r\\n\\r\\n\\tvar colors = [\\r\\n\\t\\t1, 0, 0,\\t1, 0.6, 0,\\r\\n\\t\\t0, 1, 0,\\t0.6, 1, 0,\\r\\n\\t\\t0, 0, 1,\\t0, 0.6, 1\\r\\n\\t];\\r\\n\\r\\n\\tvar geometry = new BufferGeometry();\\r\\n\\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\r\\n\\tgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\\r\\n\\r\\n\\tvar material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );\\r\\n\\r\\n\\tLineSegments.call( this, geometry, material );\\r\\n\\r\\n\\tthis.type = 'AxesHelper';\\r\\n\\r\\n}\\r\\n\\r\\nAxesHelper.prototype = Object.create( LineSegments.prototype );\\r\\nAxesHelper.prototype.constructor = AxesHelper;\\r\\n\\r\\n/**\\r\\n * @author Emmett Lalish / elalish\\r\\n *\\r\\n * This class generates a Prefiltered, Mipmapped Radiance Environment Map\\r\\n * (PMREM) from a cubeMap environment texture. This allows different levels of\\r\\n * blur to be quickly accessed based on material roughness. It is packed into a\\r\\n * special CubeUV format that allows us to perform custom interpolation so that\\r\\n * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap\\r\\n * chain, it only goes down to the LOD_MIN level (above), and then creates extra\\r\\n * even more filtered 'mips' at the same LOD_MIN resolution, associated with\\r\\n * higher roughness levels. In this way we maintain resolution to smoothly\\r\\n * interpolate diffuse lighting while limiting sampling computation.\\r\\n */\\r\\n\\r\\nvar LOD_MIN = 4;\\r\\nvar LOD_MAX = 8;\\r\\nvar SIZE_MAX = Math.pow( 2, LOD_MAX );\\r\\n\\r\\n// The standard deviations (radians) associated with the extra mips. These are\\r\\n// chosen to approximate a Trowbridge-Reitz distribution function times the\\r\\n// geometric shadowing function. These sigma values squared must match the\\r\\n// variance #defines in cube_uv_reflection_fragment.glsl.js.\\r\\nvar EXTRA_LOD_SIGMA = [ 0.125, 0.215, 0.35, 0.446, 0.526, 0.582 ];\\r\\n\\r\\nvar TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;\\r\\n\\r\\n// The maximum length of the blur for loop. Smaller sigmas will use fewer\\r\\n// samples and exit early, but not recompile the shader.\\r\\nvar MAX_SAMPLES = 20;\\r\\n\\r\\nvar ENCODINGS = {\\r\\n\\t[ LinearEncoding ]: 0,\\r\\n\\t[ sRGBEncoding ]: 1,\\r\\n\\t[ RGBEEncoding ]: 2,\\r\\n\\t[ RGBM7Encoding ]: 3,\\r\\n\\t[ RGBM16Encoding ]: 4,\\r\\n\\t[ RGBDEncoding ]: 5,\\r\\n\\t[ GammaEncoding ]: 6\\r\\n};\\r\\n\\r\\nvar _flatCamera = new OrthographicCamera();\\r\\nvar { _lodPlanes, _sizeLods, _sigmas } = _createPlanes();\\r\\nvar _oldTarget = null;\\r\\n\\r\\n// Golden Ratio\\r\\nvar PHI = ( 1 + Math.sqrt( 5 ) ) / 2;\\r\\nvar INV_PHI = 1 / PHI;\\r\\n\\r\\n// Vertices of a dodecahedron (except the opposites, which represent the\\r\\n// same axis), used as axis directions evenly spread on a sphere.\\r\\nvar _axisDirections = [\\r\\n\\tnew Vector3( 1, 1, 1 ),\\r\\n\\tnew Vector3( - 1, 1, 1 ),\\r\\n\\tnew Vector3( 1, 1, - 1 ),\\r\\n\\tnew Vector3( - 1, 1, - 1 ),\\r\\n\\tnew Vector3( 0, PHI, INV_PHI ),\\r\\n\\tnew Vector3( 0, PHI, - INV_PHI ),\\r\\n\\tnew Vector3( INV_PHI, 0, PHI ),\\r\\n\\tnew Vector3( - INV_PHI, 0, PHI ),\\r\\n\\tnew Vector3( PHI, INV_PHI, 0 ),\\r\\n\\tnew Vector3( - PHI, INV_PHI, 0 ) ];\\r\\n\\r\\nfunction PMREMGenerator( renderer ) {\\r\\n\\r\\n\\tthis._renderer = renderer;\\r\\n\\tthis._pingPongRenderTarget = null;\\r\\n\\r\\n\\tthis._blurMaterial = _getBlurShader( MAX_SAMPLES );\\r\\n\\tthis._equirectShader = null;\\r\\n\\tthis._cubemapShader = null;\\r\\n\\r\\n\\tthis._compileMaterial( this._blurMaterial );\\r\\n\\r\\n}\\r\\n\\r\\nPMREMGenerator.prototype = {\\r\\n\\r\\n\\tconstructor: PMREMGenerator,\\r\\n\\r\\n\\t/**\\r\\n\\t * Generates a PMREM from a supplied Scene, which can be faster than using an\\r\\n\\t * image if networking bandwidth is low. Optional sigma specifies a blur radius\\r\\n\\t * in radians to be applied to the scene before PMREM generation. Optional near\\r\\n\\t * and far planes ensure the scene is rendered in its entirety (the cubeCamera\\r\\n\\t * is placed at the origin).\\r\\n\\t */\\r\\n\\tfromScene: function ( scene, sigma = 0, near = 0.1, far = 100 ) {\\r\\n\\r\\n\\t\\t_oldTarget = this._renderer.getRenderTarget();\\r\\n\\t\\tvar cubeUVRenderTarget = this._allocateTargets();\\r\\n\\r\\n\\t\\tthis._sceneToCubeUV( scene, near, far, cubeUVRenderTarget );\\r\\n\\t\\tif ( sigma > 0 ) {\\r\\n\\r\\n\\t\\t\\tthis._blur( cubeUVRenderTarget, 0, 0, sigma );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis._applyPMREM( cubeUVRenderTarget );\\r\\n\\t\\tthis._cleanup( cubeUVRenderTarget );\\r\\n\\r\\n\\t\\treturn cubeUVRenderTarget;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t/**\\r\\n\\t * Generates a PMREM from an equirectangular texture, which can be either LDR\\r\\n\\t * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),\\r\\n\\t * as this matches best with the 256 x 256 cubemap output.\\r\\n\\t */\\r\\n\\tfromEquirectangular: function ( equirectangular ) {\\r\\n\\r\\n\\t\\tequirectangular.magFilter = NearestFilter;\\r\\n\\t\\tequirectangular.minFilter = NearestFilter;\\r\\n\\t\\tequirectangular.generateMipmaps = false;\\r\\n\\r\\n\\t\\treturn this.fromCubemap( equirectangular );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t/**\\r\\n\\t * Generates a PMREM from an cubemap texture, which can be either LDR\\r\\n\\t * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,\\r\\n\\t * as this matches best with the 256 x 256 cubemap output.\\r\\n\\t */\\r\\n\\tfromCubemap: function ( cubemap ) {\\r\\n\\r\\n\\t\\t_oldTarget = this._renderer.getRenderTarget();\\r\\n\\t\\tvar cubeUVRenderTarget = this._allocateTargets( cubemap );\\r\\n\\t\\tthis._textureToCubeUV( cubemap, cubeUVRenderTarget );\\r\\n\\t\\tthis._applyPMREM( cubeUVRenderTarget );\\r\\n\\t\\tthis._cleanup( cubeUVRenderTarget );\\r\\n\\r\\n\\t\\treturn cubeUVRenderTarget;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t/**\\r\\n\\t * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during\\r\\n\\t * your texture's network fetch for increased concurrency.\\r\\n\\t */\\r\\n\\tcompileCubemapShader: function () {\\r\\n\\r\\n\\t\\tif ( this._cubemapShader === null ) {\\r\\n\\r\\n\\t\\t\\tthis._cubemapShader = _getCubemapShader();\\r\\n\\t\\t\\tthis._compileMaterial( this._cubemapShader );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t/**\\r\\n\\t * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during\\r\\n\\t * your texture's network fetch for increased concurrency.\\r\\n\\t */\\r\\n\\tcompileEquirectangularShader: function () {\\r\\n\\r\\n\\t\\tif ( this._equirectShader === null ) {\\r\\n\\r\\n\\t\\t\\tthis._equirectShader = _getEquirectShader();\\r\\n\\t\\t\\tthis._compileMaterial( this._equirectShader );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t/**\\r\\n\\t * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,\\r\\n\\t * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on\\r\\n\\t * one of them will cause any others to also become unusable.\\r\\n\\t */\\r\\n\\tdispose: function () {\\r\\n\\r\\n\\t\\tthis._blurMaterial.dispose();\\r\\n\\r\\n\\t\\tif ( this._cubemapShader !== null ) this._cubemapShader.dispose();\\r\\n\\t\\tif ( this._equirectShader !== null ) this._equirectShader.dispose();\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < _lodPlanes.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\t_lodPlanes[ i ].dispose();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t// private interface\\r\\n\\r\\n\\t_cleanup: function ( outputTarget ) {\\r\\n\\r\\n\\t\\tthis._pingPongRenderTarget.dispose();\\r\\n\\t\\tthis._renderer.setRenderTarget( _oldTarget );\\r\\n\\t\\toutputTarget.scissorTest = false;\\r\\n\\t\\t// reset viewport and scissor\\r\\n\\t\\toutputTarget.setSize( outputTarget.width, outputTarget.height );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t_allocateTargets: function ( equirectangular ) {\\r\\n\\r\\n\\t\\tvar params = {\\r\\n\\t\\t\\tmagFilter: NearestFilter,\\r\\n\\t\\t\\tminFilter: NearestFilter,\\r\\n\\t\\t\\tgenerateMipmaps: false,\\r\\n\\t\\t\\ttype: UnsignedByteType,\\r\\n\\t\\t\\tformat: RGBEFormat,\\r\\n\\t\\t\\tencoding: _isLDR( equirectangular ) ? equirectangular.encoding : RGBEEncoding,\\r\\n\\t\\t\\tdepthBuffer: false,\\r\\n\\t\\t\\tstencilBuffer: false\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tvar cubeUVRenderTarget = _createRenderTarget( params );\\r\\n\\t\\tcubeUVRenderTarget.depthBuffer = equirectangular ? false : true;\\r\\n\\t\\tthis._pingPongRenderTarget = _createRenderTarget( params );\\r\\n\\t\\treturn cubeUVRenderTarget;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t_compileMaterial: function ( material ) {\\r\\n\\r\\n\\t\\tvar tmpMesh = new Mesh( _lodPlanes[ 0 ], material );\\r\\n\\t\\tthis._renderer.compile( tmpMesh, _flatCamera );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t_sceneToCubeUV: function ( scene, near, far, cubeUVRenderTarget ) {\\r\\n\\r\\n\\t\\tvar fov = 90;\\r\\n\\t\\tvar aspect = 1;\\r\\n\\t\\tvar cubeCamera = new PerspectiveCamera( fov, aspect, near, far );\\r\\n\\t\\tvar upSign = [ 1, - 1, 1, 1, 1, 1 ];\\r\\n\\t\\tvar forwardSign = [ 1, 1, 1, - 1, - 1, - 1 ];\\r\\n\\t\\tvar renderer = this._renderer;\\r\\n\\r\\n\\t\\tvar outputEncoding = renderer.outputEncoding;\\r\\n\\t\\tvar toneMapping = renderer.toneMapping;\\r\\n\\t\\tvar toneMappingExposure = renderer.toneMappingExposure;\\r\\n\\t\\tvar clearColor = renderer.getClearColor();\\r\\n\\t\\tvar clearAlpha = renderer.getClearAlpha();\\r\\n\\r\\n\\t\\trenderer.toneMapping = LinearToneMapping;\\r\\n\\t\\trenderer.toneMappingExposure = 1.0;\\r\\n\\t\\trenderer.outputEncoding = LinearEncoding;\\r\\n\\r\\n\\t\\tvar background = scene.background;\\r\\n\\t\\tif ( background && background.isColor ) {\\r\\n\\r\\n\\t\\t\\tbackground.convertSRGBToLinear();\\r\\n\\t\\t\\t// Convert linear to RGBE\\r\\n\\t\\t\\tvar maxComponent = Math.max( background.r, background.g, background.b );\\r\\n\\t\\t\\tvar fExp = Math.min( Math.max( Math.ceil( Math.log2( maxComponent ) ), - 128.0 ), 127.0 );\\r\\n\\t\\t\\tbackground = background.multiplyScalar( Math.pow( 2.0, - fExp ) );\\r\\n\\t\\t\\tvar alpha = ( fExp + 128.0 ) / 255.0;\\r\\n\\t\\t\\trenderer.setClearColor( background, alpha );\\r\\n\\t\\t\\tscene.background = null;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar col = i % 3;\\r\\n\\t\\t\\tif ( col == 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tcubeCamera.up.set( 0, upSign[ i ], 0 );\\r\\n\\t\\t\\t\\tcubeCamera.lookAt( forwardSign[ i ], 0, 0 );\\r\\n\\r\\n\\t\\t\\t} else if ( col == 1 ) {\\r\\n\\r\\n\\t\\t\\t\\tcubeCamera.up.set( 0, 0, upSign[ i ] );\\r\\n\\t\\t\\t\\tcubeCamera.lookAt( 0, forwardSign[ i ], 0 );\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tcubeCamera.up.set( 0, upSign[ i ], 0 );\\r\\n\\t\\t\\t\\tcubeCamera.lookAt( 0, 0, forwardSign[ i ] );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t_setViewport( cubeUVRenderTarget,\\r\\n\\t\\t\\t\\tcol * SIZE_MAX, i > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX );\\r\\n\\t\\t\\trenderer.setRenderTarget( cubeUVRenderTarget );\\r\\n\\t\\t\\trenderer.render( scene, cubeCamera );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\trenderer.toneMapping = toneMapping;\\r\\n\\t\\trenderer.toneMappingExposure = toneMappingExposure;\\r\\n\\t\\trenderer.outputEncoding = outputEncoding;\\r\\n\\t\\trenderer.setClearColor( clearColor, clearAlpha );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t_textureToCubeUV: function ( texture, cubeUVRenderTarget ) {\\r\\n\\r\\n\\t\\tvar renderer = this._renderer;\\r\\n\\r\\n\\t\\tif ( texture.isCubeTexture ) {\\r\\n\\r\\n\\t\\t\\tif ( this._cubemapShader == null ) {\\r\\n\\r\\n\\t\\t\\t\\tthis._cubemapShader = _getCubemapShader();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tif ( this._equirectShader == null ) {\\r\\n\\r\\n\\t\\t\\t\\tthis._equirectShader = _getEquirectShader();\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar material = texture.isCubeTexture ? this._cubemapShader : this._equirectShader;\\r\\n\\t\\tvar mesh = new Mesh( _lodPlanes[ 0 ], material );\\r\\n\\r\\n\\t\\tvar uniforms = material.uniforms;\\r\\n\\r\\n\\t\\tuniforms[ 'envMap' ].value = texture;\\r\\n\\r\\n\\t\\tif ( ! texture.isCubeTexture ) {\\r\\n\\r\\n\\t\\t\\tuniforms[ 'texelSize' ].value.set( 1.0 / texture.image.width, 1.0 / texture.image.height );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tuniforms[ 'inputEncoding' ].value = ENCODINGS[ texture.encoding ];\\r\\n\\t\\tuniforms[ 'outputEncoding' ].value = ENCODINGS[ cubeUVRenderTarget.texture.encoding ];\\r\\n\\r\\n\\t\\t_setViewport( cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX );\\r\\n\\r\\n\\t\\trenderer.setRenderTarget( cubeUVRenderTarget );\\r\\n\\t\\trenderer.render( mesh, _flatCamera );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t_applyPMREM: function ( cubeUVRenderTarget ) {\\r\\n\\r\\n\\t\\tvar renderer = this._renderer;\\r\\n\\t\\tvar autoClear = renderer.autoClear;\\r\\n\\t\\trenderer.autoClear = false;\\r\\n\\r\\n\\t\\tfor ( var i = 1; i < TOTAL_LODS; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar sigma = Math.sqrt( _sigmas[ i ] * _sigmas[ i ] - _sigmas[ i - 1 ] * _sigmas[ i - 1 ] );\\r\\n\\r\\n\\t\\t\\tvar poleAxis = _axisDirections[ ( i - 1 ) % _axisDirections.length ];\\r\\n\\r\\n\\t\\t\\tthis._blur( cubeUVRenderTarget, i - 1, i, sigma, poleAxis );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\trenderer.autoClear = autoClear;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t/**\\r\\n\\t * This is a two-pass Gaussian blur for a cubemap. Normally this is done\\r\\n\\t * vertically and horizontally, but this breaks down on a cube. Here we apply\\r\\n\\t * the blur latitudinally (around the poles), and then longitudinally (towards\\r\\n\\t * the poles) to approximate the orthogonally-separable blur. It is least\\r\\n\\t * accurate at the poles, but still does a decent job.\\r\\n\\t */\\r\\n\\t_blur: function ( cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis ) {\\r\\n\\r\\n\\t\\tvar pingPongRenderTarget = this._pingPongRenderTarget;\\r\\n\\r\\n\\t\\tthis._halfBlur(\\r\\n\\t\\t\\tcubeUVRenderTarget,\\r\\n\\t\\t\\tpingPongRenderTarget,\\r\\n\\t\\t\\tlodIn,\\r\\n\\t\\t\\tlodOut,\\r\\n\\t\\t\\tsigma,\\r\\n\\t\\t\\t'latitudinal',\\r\\n\\t\\t\\tpoleAxis );\\r\\n\\r\\n\\t\\tthis._halfBlur(\\r\\n\\t\\t\\tpingPongRenderTarget,\\r\\n\\t\\t\\tcubeUVRenderTarget,\\r\\n\\t\\t\\tlodOut,\\r\\n\\t\\t\\tlodOut,\\r\\n\\t\\t\\tsigma,\\r\\n\\t\\t\\t'longitudinal',\\r\\n\\t\\t\\tpoleAxis );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\t_halfBlur: function ( targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis ) {\\r\\n\\r\\n\\t\\tvar renderer = this._renderer;\\r\\n\\t\\tvar blurMaterial = this._blurMaterial;\\r\\n\\r\\n\\t\\tif ( direction !== 'latitudinal' && direction !== 'longitudinal' ) {\\r\\n\\r\\n\\t\\t\\tconsole.error(\\r\\n\\t\\t\\t\\t'blur direction must be either latitudinal or longitudinal!' );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Number of standard deviations at which to cut off the discrete approximation.\\r\\n\\t\\tvar STANDARD_DEVIATIONS = 3;\\r\\n\\r\\n\\t\\tvar blurMesh = new Mesh( _lodPlanes[ lodOut ], blurMaterial );\\r\\n\\t\\tvar blurUniforms = blurMaterial.uniforms;\\r\\n\\r\\n\\t\\tvar pixels = _sizeLods[ lodIn ] - 1;\\r\\n\\t\\tvar radiansPerPixel = isFinite( sigmaRadians ) ? Math.PI / ( 2 * pixels ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 );\\r\\n\\t\\tvar sigmaPixels = sigmaRadians / radiansPerPixel;\\r\\n\\t\\tvar samples = isFinite( sigmaRadians ) ? 1 + Math.floor( STANDARD_DEVIATIONS * sigmaPixels ) : MAX_SAMPLES;\\r\\n\\r\\n\\t\\tif ( samples > MAX_SAMPLES ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( `sigmaRadians, ${\\r\\n\\t\\t\\t\\tsigmaRadians}, is too large and will clip, as it requested ${\\r\\n\\t\\t\\t\\tsamples} samples when the maximum is set to ${MAX_SAMPLES}` );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar weights = [];\\r\\n\\t\\tvar sum = 0;\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < MAX_SAMPLES; ++ i ) {\\r\\n\\r\\n\\t\\t\\tvar x = i / sigmaPixels;\\r\\n\\t\\t\\tvar weight = Math.exp( - x * x / 2 );\\r\\n\\t\\t\\tweights.push( weight );\\r\\n\\r\\n\\t\\t\\tif ( i == 0 ) {\\r\\n\\r\\n\\t\\t\\t\\tsum += weight;\\r\\n\\r\\n\\t\\t\\t} else if ( i < samples ) {\\r\\n\\r\\n\\t\\t\\t\\tsum += 2 * weight;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfor ( var i = 0; i < weights.length; i ++ ) {\\r\\n\\r\\n\\t\\t\\tweights[ i ] = weights[ i ] / sum;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tblurUniforms[ 'envMap' ].value = targetIn.texture;\\r\\n\\t\\tblurUniforms[ 'samples' ].value = samples;\\r\\n\\t\\tblurUniforms[ 'weights' ].value = weights;\\r\\n\\t\\tblurUniforms[ 'latitudinal' ].value = direction === 'latitudinal';\\r\\n\\r\\n\\t\\tif ( poleAxis ) {\\r\\n\\r\\n\\t\\t\\tblurUniforms[ 'poleAxis' ].value = poleAxis;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tblurUniforms[ 'dTheta' ].value = radiansPerPixel;\\r\\n\\t\\tblurUniforms[ 'mipInt' ].value = LOD_MAX - lodIn;\\r\\n\\t\\tblurUniforms[ 'inputEncoding' ].value = ENCODINGS[ targetIn.texture.encoding ];\\r\\n\\t\\tblurUniforms[ 'outputEncoding' ].value = ENCODINGS[ targetIn.texture.encoding ];\\r\\n\\r\\n\\t\\tvar outputSize = _sizeLods[ lodOut ];\\r\\n\\t\\tvar x = 3 * Math.max( 0, SIZE_MAX - 2 * outputSize );\\r\\n\\t\\tvar y = ( lodOut === 0 ? 0 : 2 * SIZE_MAX ) + 2 * outputSize * ( lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0 );\\r\\n\\r\\n\\t\\t_setViewport( targetOut, x, y, 3 * outputSize, 2 * outputSize );\\r\\n\\t\\trenderer.setRenderTarget( targetOut );\\r\\n\\t\\trenderer.render( blurMesh, _flatCamera );\\r\\n\\r\\n\\t}\\r\\n\\r\\n};\\r\\n\\r\\nfunction _isLDR( texture ) {\\r\\n\\r\\n\\tif ( texture === undefined || texture.type !== UnsignedByteType ) return false;\\r\\n\\r\\n\\treturn texture.encoding === LinearEncoding || texture.encoding === sRGBEncoding || texture.encoding === GammaEncoding;\\r\\n\\r\\n}\\r\\n\\r\\nfunction _createPlanes() {\\r\\n\\r\\n\\tvar _lodPlanes = [];\\r\\n\\tvar _sizeLods = [];\\r\\n\\tvar _sigmas = [];\\r\\n\\r\\n\\tvar lod = LOD_MAX;\\r\\n\\r\\n\\tfor ( var i = 0; i < TOTAL_LODS; i ++ ) {\\r\\n\\r\\n\\t\\tvar sizeLod = Math.pow( 2, lod );\\r\\n\\t\\t_sizeLods.push( sizeLod );\\r\\n\\t\\tvar sigma = 1.0 / sizeLod;\\r\\n\\r\\n\\t\\tif ( i > LOD_MAX - LOD_MIN ) {\\r\\n\\r\\n\\t\\t\\tsigma = EXTRA_LOD_SIGMA[ i - LOD_MAX + LOD_MIN - 1 ];\\r\\n\\r\\n\\t\\t} else if ( i == 0 ) {\\r\\n\\r\\n\\t\\t\\tsigma = 0;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t_sigmas.push( sigma );\\r\\n\\r\\n\\t\\tvar texelSize = 1.0 / ( sizeLod - 1 );\\r\\n\\t\\tvar min = - texelSize / 2;\\r\\n\\t\\tvar max = 1 + texelSize / 2;\\r\\n\\t\\tvar uv1 = [ min, min, max, min, max, max, min, min, max, max, min, max ];\\r\\n\\r\\n\\t\\tvar cubeFaces = 6;\\r\\n\\t\\tvar vertices = 6;\\r\\n\\t\\tvar positionSize = 3;\\r\\n\\t\\tvar uvSize = 2;\\r\\n\\t\\tvar faceIndexSize = 1;\\r\\n\\r\\n\\t\\tvar position = new Float32Array( positionSize * vertices * cubeFaces );\\r\\n\\t\\tvar uv = new Float32Array( uvSize * vertices * cubeFaces );\\r\\n\\t\\tvar faceIndex = new Float32Array( faceIndexSize * vertices * cubeFaces );\\r\\n\\r\\n\\t\\tfor ( var face = 0; face < cubeFaces; face ++ ) {\\r\\n\\r\\n\\t\\t\\tvar x = ( face % 3 ) * 2 / 3 - 1;\\r\\n\\t\\t\\tvar y = face > 2 ? 0 : - 1;\\r\\n\\t\\t\\tvar coordinates = [\\r\\n\\t\\t\\t\\tx, y, 0,\\r\\n\\t\\t\\t\\tx + 2 / 3, y, 0,\\r\\n\\t\\t\\t\\tx + 2 / 3, y + 1, 0,\\r\\n\\t\\t\\t\\tx, y, 0,\\r\\n\\t\\t\\t\\tx + 2 / 3, y + 1, 0,\\r\\n\\t\\t\\t\\tx, y + 1, 0\\r\\n\\t\\t\\t];\\r\\n\\t\\t\\tposition.set( coordinates, positionSize * vertices * face );\\r\\n\\t\\t\\tuv.set( uv1, uvSize * vertices * face );\\r\\n\\t\\t\\tvar fill = [ face, face, face, face, face, face ];\\r\\n\\t\\t\\tfaceIndex.set( fill, faceIndexSize * vertices * face );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar planes = new BufferGeometry();\\r\\n\\t\\tplanes.setAttribute( 'position', new BufferAttribute( position, positionSize ) );\\r\\n\\t\\tplanes.setAttribute( 'uv', new BufferAttribute( uv, uvSize ) );\\r\\n\\t\\tplanes.setAttribute( 'faceIndex', new BufferAttribute( faceIndex, faceIndexSize ) );\\r\\n\\t\\t_lodPlanes.push( planes );\\r\\n\\r\\n\\t\\tif ( lod > LOD_MIN ) {\\r\\n\\r\\n\\t\\t\\tlod --;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\treturn { _lodPlanes, _sizeLods, _sigmas };\\r\\n\\r\\n}\\r\\n\\r\\nfunction _createRenderTarget( params ) {\\r\\n\\r\\n\\tvar cubeUVRenderTarget = new WebGLRenderTarget( 3 * SIZE_MAX, 3 * SIZE_MAX, params );\\r\\n\\tcubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;\\r\\n\\tcubeUVRenderTarget.texture.name = 'PMREM.cubeUv';\\r\\n\\tcubeUVRenderTarget.scissorTest = true;\\r\\n\\treturn cubeUVRenderTarget;\\r\\n\\r\\n}\\r\\n\\r\\nfunction _setViewport( target, x, y, width, height ) {\\r\\n\\r\\n\\ttarget.viewport.set( x, y, width, height );\\r\\n\\ttarget.scissor.set( x, y, width, height );\\r\\n\\r\\n}\\r\\n\\r\\nfunction _getBlurShader( maxSamples ) {\\r\\n\\r\\n\\tvar weights = new Float32Array( maxSamples );\\r\\n\\tvar poleAxis = new Vector3( 0, 1, 0 );\\r\\n\\tvar shaderMaterial = new RawShaderMaterial( {\\r\\n\\r\\n\\t\\tdefines: { 'n': maxSamples },\\r\\n\\r\\n\\t\\tuniforms: {\\r\\n\\t\\t\\t'envMap': { value: null },\\r\\n\\t\\t\\t'samples': { value: 1 },\\r\\n\\t\\t\\t'weights': { value: weights },\\r\\n\\t\\t\\t'latitudinal': { value: false },\\r\\n\\t\\t\\t'dTheta': { value: 0 },\\r\\n\\t\\t\\t'mipInt': { value: 0 },\\r\\n\\t\\t\\t'poleAxis': { value: poleAxis },\\r\\n\\t\\t\\t'inputEncoding': { value: ENCODINGS[ LinearEncoding ] },\\r\\n\\t\\t\\t'outputEncoding': { value: ENCODINGS[ LinearEncoding ] }\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tvertexShader: _getCommonVertexShader(),\\r\\n\\r\\n\\t\\tfragmentShader: `\\r\\nprecision mediump float;\\r\\nprecision mediump int;\\r\\nvarying vec3 vOutputDirection;\\r\\nuniform sampler2D envMap;\\r\\nuniform int samples;\\r\\nuniform float weights[n];\\r\\nuniform bool latitudinal;\\r\\nuniform float dTheta;\\r\\nuniform float mipInt;\\r\\nuniform vec3 poleAxis;\\r\\n\\r\\n${_getEncodings()}\\r\\n\\r\\n#define ENVMAP_TYPE_CUBE_UV\\r\\n#include <cube_uv_reflection_fragment>\\r\\n\\r\\nvec3 getSample(float theta, vec3 axis) {\\r\\n\\tfloat cosTheta = cos(theta);\\r\\n\\t// Rodrigues' axis-angle rotation\\r\\n\\tvec3 sampleDirection = vOutputDirection * cosTheta\\r\\n\\t\\t+ cross(axis, vOutputDirection) * sin(theta)\\r\\n\\t\\t+ axis * dot(axis, vOutputDirection) * (1.0 - cosTheta);\\r\\n\\treturn bilinearCubeUV(envMap, sampleDirection, mipInt);\\r\\n}\\r\\n\\r\\nvoid main() {\\r\\n\\tvec3 axis = latitudinal ? poleAxis : cross(poleAxis, vOutputDirection);\\r\\n\\tif (all(equal(axis, vec3(0.0))))\\r\\n\\t\\taxis = vec3(vOutputDirection.z, 0.0, - vOutputDirection.x);\\r\\n\\taxis = normalize(axis);\\r\\n\\tgl_FragColor = vec4(0.0);\\r\\n\\tgl_FragColor.rgb += weights[0] * getSample(0.0, axis);\\r\\n\\tfor (int i = 1; i < n; i++) {\\r\\n\\t\\tif (i >= samples)\\r\\n\\t\\t\\tbreak;\\r\\n\\t\\tfloat theta = dTheta * float(i);\\r\\n\\t\\tgl_FragColor.rgb += weights[i] * getSample(-1.0 * theta, axis);\\r\\n\\t\\tgl_FragColor.rgb += weights[i] * getSample(theta, axis);\\r\\n\\t}\\r\\n\\tgl_FragColor = linearToOutputTexel(gl_FragColor);\\r\\n}\\r\\n\\t\\t`,\\r\\n\\r\\n\\t\\tblending: NoBlending,\\r\\n\\t\\tdepthTest: false,\\r\\n\\t\\tdepthWrite: false\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\tshaderMaterial.type = 'SphericalGaussianBlur';\\r\\n\\r\\n\\treturn shaderMaterial;\\r\\n\\r\\n}\\r\\n\\r\\nfunction _getEquirectShader() {\\r\\n\\r\\n\\tvar texelSize = new Vector2( 1, 1 );\\r\\n\\tvar shaderMaterial = new RawShaderMaterial( {\\r\\n\\r\\n\\t\\tuniforms: {\\r\\n\\t\\t\\t'envMap': { value: null },\\r\\n\\t\\t\\t'texelSize': { value: texelSize },\\r\\n\\t\\t\\t'inputEncoding': { value: ENCODINGS[ LinearEncoding ] },\\r\\n\\t\\t\\t'outputEncoding': { value: ENCODINGS[ LinearEncoding ] }\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tvertexShader: _getCommonVertexShader(),\\r\\n\\r\\n\\t\\tfragmentShader: `\\r\\nprecision mediump float;\\r\\nprecision mediump int;\\r\\nvarying vec3 vOutputDirection;\\r\\nuniform sampler2D envMap;\\r\\nuniform vec2 texelSize;\\r\\n\\r\\n${_getEncodings()}\\r\\n\\r\\n#include <common>\\r\\n\\r\\nvoid main() {\\r\\n\\tgl_FragColor = vec4(0.0);\\r\\n\\tvec3 outputDirection = normalize(vOutputDirection);\\r\\n\\tvec2 uv = equirectUv( outputDirection );\\r\\n\\tvec2 f = fract(uv / texelSize - 0.5);\\r\\n\\tuv -= f * texelSize;\\r\\n\\tvec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\\r\\n\\tuv.x += texelSize.x;\\r\\n\\tvec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\\r\\n\\tuv.y += texelSize.y;\\r\\n\\tvec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\\r\\n\\tuv.x -= texelSize.x;\\r\\n\\tvec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\\r\\n\\tvec3 tm = mix(tl, tr, f.x);\\r\\n\\tvec3 bm = mix(bl, br, f.x);\\r\\n\\tgl_FragColor.rgb = mix(tm, bm, f.y);\\r\\n\\tgl_FragColor = linearToOutputTexel(gl_FragColor);\\r\\n}\\r\\n\\t\\t`,\\r\\n\\r\\n\\t\\tblending: NoBlending,\\r\\n\\t\\tdepthTest: false,\\r\\n\\t\\tdepthWrite: false\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\tshaderMaterial.type = 'EquirectangularToCubeUV';\\r\\n\\r\\n\\treturn shaderMaterial;\\r\\n\\r\\n}\\r\\n\\r\\nfunction _getCubemapShader() {\\r\\n\\r\\n\\tvar shaderMaterial = new RawShaderMaterial( {\\r\\n\\r\\n\\t\\tuniforms: {\\r\\n\\t\\t\\t'envMap': { value: null },\\r\\n\\t\\t\\t'inputEncoding': { value: ENCODINGS[ LinearEncoding ] },\\r\\n\\t\\t\\t'outputEncoding': { value: ENCODINGS[ LinearEncoding ] }\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tvertexShader: _getCommonVertexShader(),\\r\\n\\r\\n\\t\\tfragmentShader: `\\r\\nprecision mediump float;\\r\\nprecision mediump int;\\r\\nvarying vec3 vOutputDirection;\\r\\nuniform samplerCube envMap;\\r\\n\\r\\n${_getEncodings()}\\r\\n\\r\\nvoid main() {\\r\\n\\tgl_FragColor = vec4(0.0);\\r\\n\\tgl_FragColor.rgb = envMapTexelToLinear(textureCube(envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ))).rgb;\\r\\n\\tgl_FragColor = linearToOutputTexel(gl_FragColor);\\r\\n}\\r\\n\\t\\t`,\\r\\n\\r\\n\\t\\tblending: NoBlending,\\r\\n\\t\\tdepthTest: false,\\r\\n\\t\\tdepthWrite: false\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\tshaderMaterial.type = 'CubemapToCubeUV';\\r\\n\\r\\n\\treturn shaderMaterial;\\r\\n\\r\\n}\\r\\n\\r\\nfunction _getCommonVertexShader() {\\r\\n\\r\\n\\treturn `\\r\\nprecision mediump float;\\r\\nprecision mediump int;\\r\\nattribute vec3 position;\\r\\nattribute vec2 uv;\\r\\nattribute float faceIndex;\\r\\nvarying vec3 vOutputDirection;\\r\\n\\r\\n// RH coordinate system; PMREM face-indexing convention\\r\\nvec3 getDirection(vec2 uv, float face) {\\r\\n\\tuv = 2.0 * uv - 1.0;\\r\\n\\tvec3 direction = vec3(uv, 1.0);\\r\\n\\tif (face == 0.0) {\\r\\n\\t\\tdirection = direction.zyx; // ( 1, v, u ) pos x\\r\\n\\t} else if (face == 1.0) {\\r\\n\\t\\tdirection = direction.xzy;\\r\\n\\t\\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\\r\\n\\t} else if (face == 2.0) {\\r\\n\\t\\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\\r\\n\\t} else if (face == 3.0) {\\r\\n\\t\\tdirection = direction.zyx;\\r\\n\\t\\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\\r\\n\\t} else if (face == 4.0) {\\r\\n\\t\\tdirection = direction.xzy;\\r\\n\\t\\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\\r\\n\\t} else if (face == 5.0) {\\r\\n\\t\\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\\r\\n\\t}\\r\\n\\treturn direction;\\r\\n}\\r\\n\\r\\nvoid main() {\\r\\n\\tvOutputDirection = getDirection(uv, faceIndex);\\r\\n\\tgl_Position = vec4( position, 1.0 );\\r\\n}\\r\\n\\t`;\\r\\n\\r\\n}\\r\\n\\r\\nfunction _getEncodings() {\\r\\n\\r\\n\\treturn `\\r\\nuniform int inputEncoding;\\r\\nuniform int outputEncoding;\\r\\n\\r\\n#include <encodings_pars_fragment>\\r\\n\\r\\nvec4 inputTexelToLinear(vec4 value){\\r\\n\\tif(inputEncoding == 0){\\r\\n\\t\\treturn value;\\r\\n\\t}else if(inputEncoding == 1){\\r\\n\\t\\treturn sRGBToLinear(value);\\r\\n\\t}else if(inputEncoding == 2){\\r\\n\\t\\treturn RGBEToLinear(value);\\r\\n\\t}else if(inputEncoding == 3){\\r\\n\\t\\treturn RGBMToLinear(value, 7.0);\\r\\n\\t}else if(inputEncoding == 4){\\r\\n\\t\\treturn RGBMToLinear(value, 16.0);\\r\\n\\t}else if(inputEncoding == 5){\\r\\n\\t\\treturn RGBDToLinear(value, 256.0);\\r\\n\\t}else{\\r\\n\\t\\treturn GammaToLinear(value, 2.2);\\r\\n\\t}\\r\\n}\\r\\n\\r\\nvec4 linearToOutputTexel(vec4 value){\\r\\n\\tif(outputEncoding == 0){\\r\\n\\t\\treturn value;\\r\\n\\t}else if(outputEncoding == 1){\\r\\n\\t\\treturn LinearTosRGB(value);\\r\\n\\t}else if(outputEncoding == 2){\\r\\n\\t\\treturn LinearToRGBE(value);\\r\\n\\t}else if(outputEncoding == 3){\\r\\n\\t\\treturn LinearToRGBM(value, 7.0);\\r\\n\\t}else if(outputEncoding == 4){\\r\\n\\t\\treturn LinearToRGBM(value, 16.0);\\r\\n\\t}else if(outputEncoding == 5){\\r\\n\\t\\treturn LinearToRGBD(value, 256.0);\\r\\n\\t}else{\\r\\n\\t\\treturn LinearToGamma(value, 2.2);\\r\\n\\t}\\r\\n}\\r\\n\\r\\nvec4 envMapTexelToLinear(vec4 color) {\\r\\n\\treturn inputTexelToLinear(color);\\r\\n}\\r\\n\\t`;\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nfunction Face4( a, b, c, d, normal, color, materialIndex ) {\\r\\n\\r\\n\\tconsole.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );\\r\\n\\treturn new Face3( a, b, c, normal, color, materialIndex );\\r\\n\\r\\n}\\r\\n\\r\\nvar LineStrip = 0;\\r\\nvar LinePieces = 1;\\r\\nvar NoColors = 0;\\r\\nvar FaceColors = 1;\\r\\nvar VertexColors = 2;\\r\\n\\r\\nfunction MeshFaceMaterial( materials ) {\\r\\n\\r\\n\\tconsole.warn( 'THREE.MeshFaceMaterial has been removed. Use an Array instead.' );\\r\\n\\treturn materials;\\r\\n\\r\\n}\\r\\n\\r\\nfunction MultiMaterial( materials ) {\\r\\n\\r\\n\\tif ( materials === undefined ) materials = [];\\r\\n\\r\\n\\tconsole.warn( 'THREE.MultiMaterial has been removed. Use an Array instead.' );\\r\\n\\tmaterials.isMultiMaterial = true;\\r\\n\\tmaterials.materials = materials;\\r\\n\\tmaterials.clone = function () {\\r\\n\\r\\n\\t\\treturn materials.slice();\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\treturn materials;\\r\\n\\r\\n}\\r\\n\\r\\nfunction PointCloud( geometry, material ) {\\r\\n\\r\\n\\tconsole.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );\\r\\n\\treturn new Points( geometry, material );\\r\\n\\r\\n}\\r\\n\\r\\nfunction Particle( material ) {\\r\\n\\r\\n\\tconsole.warn( 'THREE.Particle has been renamed to THREE.Sprite.' );\\r\\n\\treturn new Sprite( material );\\r\\n\\r\\n}\\r\\n\\r\\nfunction ParticleSystem( geometry, material ) {\\r\\n\\r\\n\\tconsole.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );\\r\\n\\treturn new Points( geometry, material );\\r\\n\\r\\n}\\r\\n\\r\\nfunction PointCloudMaterial( parameters ) {\\r\\n\\r\\n\\tconsole.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );\\r\\n\\treturn new PointsMaterial( parameters );\\r\\n\\r\\n}\\r\\n\\r\\nfunction ParticleBasicMaterial( parameters ) {\\r\\n\\r\\n\\tconsole.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );\\r\\n\\treturn new PointsMaterial( parameters );\\r\\n\\r\\n}\\r\\n\\r\\nfunction ParticleSystemMaterial( parameters ) {\\r\\n\\r\\n\\tconsole.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );\\r\\n\\treturn new PointsMaterial( parameters );\\r\\n\\r\\n}\\r\\n\\r\\nfunction Vertex( x, y, z ) {\\r\\n\\r\\n\\tconsole.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );\\r\\n\\treturn new Vector3( x, y, z );\\r\\n\\r\\n}\\r\\n\\r\\n//\\r\\n\\r\\nfunction DynamicBufferAttribute( array, itemSize ) {\\r\\n\\r\\n\\tconsole.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.' );\\r\\n\\treturn new BufferAttribute( array, itemSize ).setUsage( DynamicDrawUsage );\\r\\n\\r\\n}\\r\\n\\r\\nfunction Int8Attribute( array, itemSize ) {\\r\\n\\r\\n\\tconsole.warn( 'THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.' );\\r\\n\\treturn new Int8BufferAttribute( array, itemSize );\\r\\n\\r\\n}\\r\\n\\r\\nfunction Uint8Attribute( array, itemSize ) {\\r\\n\\r\\n\\tconsole.warn( 'THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.' );\\r\\n\\treturn new Uint8BufferAttribute( array, itemSize );\\r\\n\\r\\n}\\r\\n\\r\\nfunction Uint8ClampedAttribute( array, itemSize ) {\\r\\n\\r\\n\\tconsole.warn( 'THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.' );\\r\\n\\treturn new Uint8ClampedBufferAttribute( array, itemSize );\\r\\n\\r\\n}\\r\\n\\r\\nfunction Int16Attribute( array, itemSize ) {\\r\\n\\r\\n\\tconsole.warn( 'THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.' );\\r\\n\\treturn new Int16BufferAttribute( array, itemSize );\\r\\n\\r\\n}\\r\\n\\r\\nfunction Uint16Attribute( array, itemSize ) {\\r\\n\\r\\n\\tconsole.warn( 'THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.' );\\r\\n\\treturn new Uint16BufferAttribute( array, itemSize );\\r\\n\\r\\n}\\r\\n\\r\\nfunction Int32Attribute( array, itemSize ) {\\r\\n\\r\\n\\tconsole.warn( 'THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.' );\\r\\n\\treturn new Int32BufferAttribute( array, itemSize );\\r\\n\\r\\n}\\r\\n\\r\\nfunction Uint32Attribute( array, itemSize ) {\\r\\n\\r\\n\\tconsole.warn( 'THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.' );\\r\\n\\treturn new Uint32BufferAttribute( array, itemSize );\\r\\n\\r\\n}\\r\\n\\r\\nfunction Float32Attribute( array, itemSize ) {\\r\\n\\r\\n\\tconsole.warn( 'THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.' );\\r\\n\\treturn new Float32BufferAttribute( array, itemSize );\\r\\n\\r\\n}\\r\\n\\r\\nfunction Float64Attribute( array, itemSize ) {\\r\\n\\r\\n\\tconsole.warn( 'THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.' );\\r\\n\\treturn new Float64BufferAttribute( array, itemSize );\\r\\n\\r\\n}\\r\\n\\r\\n//\\r\\n\\r\\nCurve.create = function ( construct, getPoint ) {\\r\\n\\r\\n\\tconsole.log( 'THREE.Curve.create() has been deprecated' );\\r\\n\\r\\n\\tconstruct.prototype = Object.create( Curve.prototype );\\r\\n\\tconstruct.prototype.constructor = construct;\\r\\n\\tconstruct.prototype.getPoint = getPoint;\\r\\n\\r\\n\\treturn construct;\\r\\n\\r\\n};\\r\\n\\r\\n//\\r\\n\\r\\nObject.assign( CurvePath.prototype, {\\r\\n\\r\\n\\tcreatePointsGeometry: function ( divisions ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );\\r\\n\\r\\n\\t\\t// generate geometry from path points (for Line or Points objects)\\r\\n\\r\\n\\t\\tvar pts = this.getPoints( divisions );\\r\\n\\t\\treturn this.createGeometry( pts );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcreateSpacedPointsGeometry: function ( divisions ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );\\r\\n\\r\\n\\t\\t// generate geometry from equidistant sampling along the path\\r\\n\\r\\n\\t\\tvar pts = this.getSpacedPoints( divisions );\\r\\n\\t\\treturn this.createGeometry( pts );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcreateGeometry: function ( points ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );\\r\\n\\r\\n\\t\\tvar geometry = new Geometry();\\r\\n\\r\\n\\t\\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\\r\\n\\r\\n\\t\\t\\tvar point = points[ i ];\\r\\n\\t\\t\\tgeometry.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn geometry;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n//\\r\\n\\r\\nObject.assign( Path.prototype, {\\r\\n\\r\\n\\tfromPoints: function ( points ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Path: .fromPoints() has been renamed to .setFromPoints().' );\\r\\n\\t\\treturn this.setFromPoints( points );\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n//\\r\\n\\r\\nfunction ClosedSplineCurve3( points ) {\\r\\n\\r\\n\\tconsole.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );\\r\\n\\r\\n\\tCatmullRomCurve3.call( this, points );\\r\\n\\tthis.type = 'catmullrom';\\r\\n\\tthis.closed = true;\\r\\n\\r\\n}\\r\\n\\r\\nClosedSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );\\r\\n\\r\\n//\\r\\n\\r\\nfunction SplineCurve3( points ) {\\r\\n\\r\\n\\tconsole.warn( 'THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );\\r\\n\\r\\n\\tCatmullRomCurve3.call( this, points );\\r\\n\\tthis.type = 'catmullrom';\\r\\n\\r\\n}\\r\\n\\r\\nSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );\\r\\n\\r\\n//\\r\\n\\r\\nfunction Spline( points ) {\\r\\n\\r\\n\\tconsole.warn( 'THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.' );\\r\\n\\r\\n\\tCatmullRomCurve3.call( this, points );\\r\\n\\tthis.type = 'catmullrom';\\r\\n\\r\\n}\\r\\n\\r\\nSpline.prototype = Object.create( CatmullRomCurve3.prototype );\\r\\n\\r\\nObject.assign( Spline.prototype, {\\r\\n\\r\\n\\tinitFromArray: function ( /* a */ ) {\\r\\n\\r\\n\\t\\tconsole.error( 'THREE.Spline: .initFromArray() has been removed.' );\\r\\n\\r\\n\\t},\\r\\n\\tgetControlPointsArray: function ( /* optionalTarget */ ) {\\r\\n\\r\\n\\t\\tconsole.error( 'THREE.Spline: .getControlPointsArray() has been removed.' );\\r\\n\\r\\n\\t},\\r\\n\\treparametrizeByArcLength: function ( /* samplingCoef */ ) {\\r\\n\\r\\n\\t\\tconsole.error( 'THREE.Spline: .reparametrizeByArcLength() has been removed.' );\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n//\\r\\n\\r\\nfunction AxisHelper( size ) {\\r\\n\\r\\n\\tconsole.warn( 'THREE.AxisHelper has been renamed to THREE.AxesHelper.' );\\r\\n\\treturn new AxesHelper( size );\\r\\n\\r\\n}\\r\\n\\r\\nfunction BoundingBoxHelper( object, color ) {\\r\\n\\r\\n\\tconsole.warn( 'THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.' );\\r\\n\\treturn new BoxHelper( object, color );\\r\\n\\r\\n}\\r\\n\\r\\nfunction EdgesHelper( object, hex ) {\\r\\n\\r\\n\\tconsole.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );\\r\\n\\treturn new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );\\r\\n\\r\\n}\\r\\n\\r\\nGridHelper.prototype.setColors = function () {\\r\\n\\r\\n\\tconsole.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );\\r\\n\\r\\n};\\r\\n\\r\\nSkeletonHelper.prototype.update = function () {\\r\\n\\r\\n\\tconsole.error( 'THREE.SkeletonHelper: update() no longer needs to be called.' );\\r\\n\\r\\n};\\r\\n\\r\\nfunction WireframeHelper( object, hex ) {\\r\\n\\r\\n\\tconsole.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );\\r\\n\\treturn new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );\\r\\n\\r\\n}\\r\\n\\r\\n//\\r\\n\\r\\nObject.assign( Loader.prototype, {\\r\\n\\r\\n\\textractUrlBase: function ( url ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.' );\\r\\n\\t\\treturn LoaderUtils.extractUrlBase( url );\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nLoader.Handlers = {\\r\\n\\r\\n\\tadd: function ( /* regex, loader */ ) {\\r\\n\\r\\n\\t\\tconsole.error( 'THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.' );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tget: function ( /* file */ ) {\\r\\n\\r\\n\\t\\tconsole.error( 'THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.' );\\r\\n\\r\\n\\t}\\r\\n\\r\\n};\\r\\n\\r\\nfunction XHRLoader( manager ) {\\r\\n\\r\\n\\tconsole.warn( 'THREE.XHRLoader has been renamed to THREE.FileLoader.' );\\r\\n\\treturn new FileLoader( manager );\\r\\n\\r\\n}\\r\\n\\r\\nfunction BinaryTextureLoader( manager ) {\\r\\n\\r\\n\\tconsole.warn( 'THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.' );\\r\\n\\treturn new DataTextureLoader( manager );\\r\\n\\r\\n}\\r\\n\\r\\nObject.assign( ObjectLoader.prototype, {\\r\\n\\r\\n\\tsetTexturePath: function ( value ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().' );\\r\\n\\t\\treturn this.setResourcePath( value );\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n//\\r\\n\\r\\nObject.assign( Box2.prototype, {\\r\\n\\r\\n\\tcenter: function ( optionalTarget ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );\\r\\n\\t\\treturn this.getCenter( optionalTarget );\\r\\n\\r\\n\\t},\\r\\n\\tempty: function () {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );\\r\\n\\t\\treturn this.isEmpty();\\r\\n\\r\\n\\t},\\r\\n\\tisIntersectionBox: function ( box ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );\\r\\n\\t\\treturn this.intersectsBox( box );\\r\\n\\r\\n\\t},\\r\\n\\tsize: function ( optionalTarget ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );\\r\\n\\t\\treturn this.getSize( optionalTarget );\\r\\n\\r\\n\\t}\\r\\n} );\\r\\n\\r\\nObject.assign( Box3.prototype, {\\r\\n\\r\\n\\tcenter: function ( optionalTarget ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );\\r\\n\\t\\treturn this.getCenter( optionalTarget );\\r\\n\\r\\n\\t},\\r\\n\\tempty: function () {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );\\r\\n\\t\\treturn this.isEmpty();\\r\\n\\r\\n\\t},\\r\\n\\tisIntersectionBox: function ( box ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );\\r\\n\\t\\treturn this.intersectsBox( box );\\r\\n\\r\\n\\t},\\r\\n\\tisIntersectionSphere: function ( sphere ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\\r\\n\\t\\treturn this.intersectsSphere( sphere );\\r\\n\\r\\n\\t},\\r\\n\\tsize: function ( optionalTarget ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );\\r\\n\\t\\treturn this.getSize( optionalTarget );\\r\\n\\r\\n\\t}\\r\\n} );\\r\\n\\r\\nObject.assign( Sphere.prototype, {\\r\\n\\r\\n\\tempty: function () {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Sphere: .empty() has been renamed to .isEmpty().' );\\r\\n\\t\\treturn this.isEmpty();\\r\\n\\r\\n\\t},\\r\\n\\r\\n} );\\r\\n\\r\\nFrustum.prototype.setFromMatrix = function ( m ) {\\r\\n\\r\\n\\tconsole.warn( 'THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().' );\\r\\n\\treturn this.setFromProjectionMatrix( m );\\r\\n\\r\\n};\\r\\n\\r\\nLine3.prototype.center = function ( optionalTarget ) {\\r\\n\\r\\n\\tconsole.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );\\r\\n\\treturn this.getCenter( optionalTarget );\\r\\n\\r\\n};\\r\\n\\r\\nObject.assign( MathUtils, {\\r\\n\\r\\n\\trandom16: function () {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Math: .random16() has been deprecated. Use Math.random() instead.' );\\r\\n\\t\\treturn Math.random();\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tnearestPowerOfTwo: function ( value ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().' );\\r\\n\\t\\treturn MathUtils.floorPowerOfTwo( value );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tnextPowerOfTwo: function ( value ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().' );\\r\\n\\t\\treturn MathUtils.ceilPowerOfTwo( value );\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nObject.assign( Matrix3.prototype, {\\r\\n\\r\\n\\tflattenToArrayOffset: function ( array, offset ) {\\r\\n\\r\\n\\t\\tconsole.warn( \\\"THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.\\\" );\\r\\n\\t\\treturn this.toArray( array, offset );\\r\\n\\r\\n\\t},\\r\\n\\tmultiplyVector3: function ( vector ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );\\r\\n\\t\\treturn vector.applyMatrix3( this );\\r\\n\\r\\n\\t},\\r\\n\\tmultiplyVector3Array: function ( /* a */ ) {\\r\\n\\r\\n\\t\\tconsole.error( 'THREE.Matrix3: .multiplyVector3Array() has been removed.' );\\r\\n\\r\\n\\t},\\r\\n\\tapplyToBufferAttribute: function ( attribute ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.' );\\r\\n\\t\\treturn attribute.applyMatrix3( this );\\r\\n\\r\\n\\t},\\r\\n\\tapplyToVector3Array: function ( /* array, offset, length */ ) {\\r\\n\\r\\n\\t\\tconsole.error( 'THREE.Matrix3: .applyToVector3Array() has been removed.' );\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nObject.assign( Matrix4.prototype, {\\r\\n\\r\\n\\textractPosition: function ( m ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );\\r\\n\\t\\treturn this.copyPosition( m );\\r\\n\\r\\n\\t},\\r\\n\\tflattenToArrayOffset: function ( array, offset ) {\\r\\n\\r\\n\\t\\tconsole.warn( \\\"THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.\\\" );\\r\\n\\t\\treturn this.toArray( array, offset );\\r\\n\\r\\n\\t},\\r\\n\\tgetPosition: function () {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );\\r\\n\\t\\treturn new Vector3().setFromMatrixColumn( this, 3 );\\r\\n\\r\\n\\t},\\r\\n\\tsetRotationFromQuaternion: function ( q ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );\\r\\n\\t\\treturn this.makeRotationFromQuaternion( q );\\r\\n\\r\\n\\t},\\r\\n\\tmultiplyToArray: function () {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Matrix4: .multiplyToArray() has been removed.' );\\r\\n\\r\\n\\t},\\r\\n\\tmultiplyVector3: function ( vector ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\\r\\n\\t\\treturn vector.applyMatrix4( this );\\r\\n\\r\\n\\t},\\r\\n\\tmultiplyVector4: function ( vector ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\\r\\n\\t\\treturn vector.applyMatrix4( this );\\r\\n\\r\\n\\t},\\r\\n\\tmultiplyVector3Array: function ( /* a */ ) {\\r\\n\\r\\n\\t\\tconsole.error( 'THREE.Matrix4: .multiplyVector3Array() has been removed.' );\\r\\n\\r\\n\\t},\\r\\n\\trotateAxis: function ( v ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );\\r\\n\\t\\tv.transformDirection( this );\\r\\n\\r\\n\\t},\\r\\n\\tcrossVector: function ( vector ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\\r\\n\\t\\treturn vector.applyMatrix4( this );\\r\\n\\r\\n\\t},\\r\\n\\ttranslate: function () {\\r\\n\\r\\n\\t\\tconsole.error( 'THREE.Matrix4: .translate() has been removed.' );\\r\\n\\r\\n\\t},\\r\\n\\trotateX: function () {\\r\\n\\r\\n\\t\\tconsole.error( 'THREE.Matrix4: .rotateX() has been removed.' );\\r\\n\\r\\n\\t},\\r\\n\\trotateY: function () {\\r\\n\\r\\n\\t\\tconsole.error( 'THREE.Matrix4: .rotateY() has been removed.' );\\r\\n\\r\\n\\t},\\r\\n\\trotateZ: function () {\\r\\n\\r\\n\\t\\tconsole.error( 'THREE.Matrix4: .rotateZ() has been removed.' );\\r\\n\\r\\n\\t},\\r\\n\\trotateByAxis: function () {\\r\\n\\r\\n\\t\\tconsole.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );\\r\\n\\r\\n\\t},\\r\\n\\tapplyToBufferAttribute: function ( attribute ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.' );\\r\\n\\t\\treturn attribute.applyMatrix4( this );\\r\\n\\r\\n\\t},\\r\\n\\tapplyToVector3Array: function ( /* array, offset, length */ ) {\\r\\n\\r\\n\\t\\tconsole.error( 'THREE.Matrix4: .applyToVector3Array() has been removed.' );\\r\\n\\r\\n\\t},\\r\\n\\tmakeFrustum: function ( left, right, bottom, top, near, far ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.' );\\r\\n\\t\\treturn this.makePerspective( left, right, top, bottom, near, far );\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nPlane.prototype.isIntersectionLine = function ( line ) {\\r\\n\\r\\n\\tconsole.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );\\r\\n\\treturn this.intersectsLine( line );\\r\\n\\r\\n};\\r\\n\\r\\nQuaternion.prototype.multiplyVector3 = function ( vector ) {\\r\\n\\r\\n\\tconsole.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );\\r\\n\\treturn vector.applyQuaternion( this );\\r\\n\\r\\n};\\r\\n\\r\\nObject.assign( Ray.prototype, {\\r\\n\\r\\n\\tisIntersectionBox: function ( box ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );\\r\\n\\t\\treturn this.intersectsBox( box );\\r\\n\\r\\n\\t},\\r\\n\\tisIntersectionPlane: function ( plane ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );\\r\\n\\t\\treturn this.intersectsPlane( plane );\\r\\n\\r\\n\\t},\\r\\n\\tisIntersectionSphere: function ( sphere ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\\r\\n\\t\\treturn this.intersectsSphere( sphere );\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nObject.assign( Triangle.prototype, {\\r\\n\\r\\n\\tarea: function () {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Triangle: .area() has been renamed to .getArea().' );\\r\\n\\t\\treturn this.getArea();\\r\\n\\r\\n\\t},\\r\\n\\tbarycoordFromPoint: function ( point, target ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );\\r\\n\\t\\treturn this.getBarycoord( point, target );\\r\\n\\r\\n\\t},\\r\\n\\tmidpoint: function ( target ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Triangle: .midpoint() has been renamed to .getMidpoint().' );\\r\\n\\t\\treturn this.getMidpoint( target );\\r\\n\\r\\n\\t},\\r\\n\\tnormal: function ( target ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );\\r\\n\\t\\treturn this.getNormal( target );\\r\\n\\r\\n\\t},\\r\\n\\tplane: function ( target ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Triangle: .plane() has been renamed to .getPlane().' );\\r\\n\\t\\treturn this.getPlane( target );\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nObject.assign( Triangle, {\\r\\n\\r\\n\\tbarycoordFromPoint: function ( point, a, b, c, target ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );\\r\\n\\t\\treturn Triangle.getBarycoord( point, a, b, c, target );\\r\\n\\r\\n\\t},\\r\\n\\tnormal: function ( a, b, c, target ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );\\r\\n\\t\\treturn Triangle.getNormal( a, b, c, target );\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nObject.assign( Shape.prototype, {\\r\\n\\r\\n\\textractAllPoints: function ( divisions ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.' );\\r\\n\\t\\treturn this.extractPoints( divisions );\\r\\n\\r\\n\\t},\\r\\n\\textrude: function ( options ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );\\r\\n\\t\\treturn new ExtrudeGeometry( this, options );\\r\\n\\r\\n\\t},\\r\\n\\tmakeGeometry: function ( options ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );\\r\\n\\t\\treturn new ShapeGeometry( this, options );\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nObject.assign( Vector2.prototype, {\\r\\n\\r\\n\\tfromAttribute: function ( attribute, index, offset ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().' );\\r\\n\\t\\treturn this.fromBufferAttribute( attribute, index, offset );\\r\\n\\r\\n\\t},\\r\\n\\tdistanceToManhattan: function ( v ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );\\r\\n\\t\\treturn this.manhattanDistanceTo( v );\\r\\n\\r\\n\\t},\\r\\n\\tlengthManhattan: function () {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().' );\\r\\n\\t\\treturn this.manhattanLength();\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nObject.assign( Vector3.prototype, {\\r\\n\\r\\n\\tsetEulerFromRotationMatrix: function () {\\r\\n\\r\\n\\t\\tconsole.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );\\r\\n\\r\\n\\t},\\r\\n\\tsetEulerFromQuaternion: function () {\\r\\n\\r\\n\\t\\tconsole.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );\\r\\n\\r\\n\\t},\\r\\n\\tgetPositionFromMatrix: function ( m ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );\\r\\n\\t\\treturn this.setFromMatrixPosition( m );\\r\\n\\r\\n\\t},\\r\\n\\tgetScaleFromMatrix: function ( m ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );\\r\\n\\t\\treturn this.setFromMatrixScale( m );\\r\\n\\r\\n\\t},\\r\\n\\tgetColumnFromMatrix: function ( index, matrix ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );\\r\\n\\t\\treturn this.setFromMatrixColumn( matrix, index );\\r\\n\\r\\n\\t},\\r\\n\\tapplyProjection: function ( m ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.' );\\r\\n\\t\\treturn this.applyMatrix4( m );\\r\\n\\r\\n\\t},\\r\\n\\tfromAttribute: function ( attribute, index, offset ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().' );\\r\\n\\t\\treturn this.fromBufferAttribute( attribute, index, offset );\\r\\n\\r\\n\\t},\\r\\n\\tdistanceToManhattan: function ( v ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );\\r\\n\\t\\treturn this.manhattanDistanceTo( v );\\r\\n\\r\\n\\t},\\r\\n\\tlengthManhattan: function () {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().' );\\r\\n\\t\\treturn this.manhattanLength();\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nObject.assign( Vector4.prototype, {\\r\\n\\r\\n\\tfromAttribute: function ( attribute, index, offset ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().' );\\r\\n\\t\\treturn this.fromBufferAttribute( attribute, index, offset );\\r\\n\\r\\n\\t},\\r\\n\\tlengthManhattan: function () {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().' );\\r\\n\\t\\treturn this.manhattanLength();\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n//\\r\\n\\r\\nObject.assign( Geometry.prototype, {\\r\\n\\r\\n\\tcomputeTangents: function () {\\r\\n\\r\\n\\t\\tconsole.error( 'THREE.Geometry: .computeTangents() has been removed.' );\\r\\n\\r\\n\\t},\\r\\n\\tcomputeLineDistances: function () {\\r\\n\\r\\n\\t\\tconsole.error( 'THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.' );\\r\\n\\r\\n\\t},\\r\\n\\tapplyMatrix: function ( matrix ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().' );\\r\\n\\t\\treturn this.applyMatrix4( matrix );\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nObject.assign( Object3D.prototype, {\\r\\n\\r\\n\\tgetChildByName: function ( name ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );\\r\\n\\t\\treturn this.getObjectByName( name );\\r\\n\\r\\n\\t},\\r\\n\\trenderDepth: function () {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );\\r\\n\\r\\n\\t},\\r\\n\\ttranslate: function ( distance, axis ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );\\r\\n\\t\\treturn this.translateOnAxis( axis, distance );\\r\\n\\r\\n\\t},\\r\\n\\tgetWorldRotation: function () {\\r\\n\\r\\n\\t\\tconsole.error( 'THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.' );\\r\\n\\r\\n\\t},\\r\\n\\tapplyMatrix: function ( matrix ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().' );\\r\\n\\t\\treturn this.applyMatrix4( matrix );\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nObject.defineProperties( Object3D.prototype, {\\r\\n\\r\\n\\teulerOrder: {\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\\r\\n\\t\\t\\treturn this.rotation.order;\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\\r\\n\\t\\t\\tthis.rotation.order = value;\\r\\n\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\tuseQuaternion: {\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tset: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\\r\\n\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nObject.assign( Mesh.prototype, {\\r\\n\\r\\n\\tsetDrawMode: function () {\\r\\n\\r\\n\\t\\tconsole.error( 'THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.' );\\r\\n\\r\\n\\t},\\r\\n\\r\\n} );\\r\\n\\r\\nObject.defineProperties( Mesh.prototype, {\\r\\n\\r\\n\\tdrawMode: {\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\tconsole.error( 'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.' );\\r\\n\\t\\t\\treturn TrianglesDrawMode;\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tset: function () {\\r\\n\\r\\n\\t\\t\\tconsole.error( 'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.' );\\r\\n\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nObject.defineProperties( LOD.prototype, {\\r\\n\\r\\n\\tobjects: {\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.LOD: .objects has been renamed to .levels.' );\\r\\n\\t\\t\\treturn this.levels;\\r\\n\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nObject.defineProperty( Skeleton.prototype, 'useVertexTexture', {\\r\\n\\r\\n\\tget: function () {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );\\r\\n\\r\\n\\t},\\r\\n\\tset: function () {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nSkinnedMesh.prototype.initBones = function () {\\r\\n\\r\\n\\tconsole.error( 'THREE.SkinnedMesh: initBones() has been removed.' );\\r\\n\\r\\n};\\r\\n\\r\\nObject.defineProperty( Curve.prototype, '__arcLengthDivisions', {\\r\\n\\r\\n\\tget: function () {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );\\r\\n\\t\\treturn this.arcLengthDivisions;\\r\\n\\r\\n\\t},\\r\\n\\tset: function ( value ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );\\r\\n\\t\\tthis.arcLengthDivisions = value;\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n//\\r\\n\\r\\nPerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {\\r\\n\\r\\n\\tconsole.warn( \\\"THREE.PerspectiveCamera.setLens is deprecated. \\\" +\\r\\n\\t\\t\\t\\\"Use .setFocalLength and .filmGauge for a photographic setup.\\\" );\\r\\n\\r\\n\\tif ( filmGauge !== undefined ) this.filmGauge = filmGauge;\\r\\n\\tthis.setFocalLength( focalLength );\\r\\n\\r\\n};\\r\\n\\r\\n//\\r\\n\\r\\nObject.defineProperties( Light.prototype, {\\r\\n\\tonlyShadow: {\\r\\n\\t\\tset: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Light: .onlyShadow has been removed.' );\\r\\n\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\tshadowCameraFov: {\\r\\n\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );\\r\\n\\t\\t\\tthis.shadow.camera.fov = value;\\r\\n\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\tshadowCameraLeft: {\\r\\n\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );\\r\\n\\t\\t\\tthis.shadow.camera.left = value;\\r\\n\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\tshadowCameraRight: {\\r\\n\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );\\r\\n\\t\\t\\tthis.shadow.camera.right = value;\\r\\n\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\tshadowCameraTop: {\\r\\n\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );\\r\\n\\t\\t\\tthis.shadow.camera.top = value;\\r\\n\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\tshadowCameraBottom: {\\r\\n\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );\\r\\n\\t\\t\\tthis.shadow.camera.bottom = value;\\r\\n\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\tshadowCameraNear: {\\r\\n\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );\\r\\n\\t\\t\\tthis.shadow.camera.near = value;\\r\\n\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\tshadowCameraFar: {\\r\\n\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );\\r\\n\\t\\t\\tthis.shadow.camera.far = value;\\r\\n\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\tshadowCameraVisible: {\\r\\n\\t\\tset: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );\\r\\n\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\tshadowBias: {\\r\\n\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );\\r\\n\\t\\t\\tthis.shadow.bias = value;\\r\\n\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\tshadowDarkness: {\\r\\n\\t\\tset: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Light: .shadowDarkness has been removed.' );\\r\\n\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\tshadowMapWidth: {\\r\\n\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );\\r\\n\\t\\t\\tthis.shadow.mapSize.width = value;\\r\\n\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\tshadowMapHeight: {\\r\\n\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );\\r\\n\\t\\t\\tthis.shadow.mapSize.height = value;\\r\\n\\r\\n\\t\\t}\\r\\n\\t}\\r\\n} );\\r\\n\\r\\n//\\r\\n\\r\\nObject.defineProperties( BufferAttribute.prototype, {\\r\\n\\r\\n\\tlength: {\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.BufferAttribute: .length has been deprecated. Use .count instead.' );\\r\\n\\t\\t\\treturn this.array.length;\\r\\n\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\tdynamic: {\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.' );\\r\\n\\t\\t\\treturn this.usage === DynamicDrawUsage;\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tset: function ( /* value */ ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.' );\\r\\n\\t\\t\\tthis.setUsage( DynamicDrawUsage );\\r\\n\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nObject.assign( BufferAttribute.prototype, {\\r\\n\\tsetDynamic: function ( value ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.' );\\r\\n\\t\\tthis.setUsage( value === true ? DynamicDrawUsage : StaticDrawUsage );\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\tcopyIndicesArray: function ( /* indices */ ) {\\r\\n\\r\\n\\t\\tconsole.error( 'THREE.BufferAttribute: .copyIndicesArray() has been removed.' );\\r\\n\\r\\n\\t},\\r\\n\\tsetArray: function ( /* array */ ) {\\r\\n\\r\\n\\t\\tconsole.error( 'THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers' );\\r\\n\\r\\n\\t}\\r\\n} );\\r\\n\\r\\nObject.assign( BufferGeometry.prototype, {\\r\\n\\r\\n\\taddIndex: function ( index ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );\\r\\n\\t\\tthis.setIndex( index );\\r\\n\\r\\n\\t},\\r\\n\\taddAttribute: function ( name, attribute ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().' );\\r\\n\\r\\n\\t\\tif ( ! ( attribute && attribute.isBufferAttribute ) && ! ( attribute && attribute.isInterleavedBufferAttribute ) ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );\\r\\n\\r\\n\\t\\t\\treturn this.setAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( name === 'index' ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );\\r\\n\\t\\t\\tthis.setIndex( attribute );\\r\\n\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this.setAttribute( name, attribute );\\r\\n\\r\\n\\t},\\r\\n\\taddDrawCall: function ( start, count, indexOffset ) {\\r\\n\\r\\n\\t\\tif ( indexOffset !== undefined ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );\\r\\n\\t\\tthis.addGroup( start, count );\\r\\n\\r\\n\\t},\\r\\n\\tclearDrawCalls: function () {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );\\r\\n\\t\\tthis.clearGroups();\\r\\n\\r\\n\\t},\\r\\n\\tcomputeTangents: function () {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );\\r\\n\\r\\n\\t},\\r\\n\\tcomputeOffsets: function () {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );\\r\\n\\r\\n\\t},\\r\\n\\tremoveAttribute: function ( name ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().' );\\r\\n\\r\\n\\t\\treturn this.deleteAttribute( name );\\r\\n\\r\\n\\t},\\r\\n\\tapplyMatrix: function ( matrix ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().' );\\r\\n\\t\\treturn this.applyMatrix4( matrix );\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nObject.defineProperties( BufferGeometry.prototype, {\\r\\n\\r\\n\\tdrawcalls: {\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\tconsole.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );\\r\\n\\t\\t\\treturn this.groups;\\r\\n\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\toffsets: {\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );\\r\\n\\t\\t\\treturn this.groups;\\r\\n\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nObject.defineProperties( InstancedBufferGeometry.prototype, {\\r\\n\\r\\n\\tmaxInstancedCount: {\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.' );\\r\\n\\t\\t\\treturn this.instanceCount;\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.' );\\r\\n\\t\\t\\tthis.instanceCount = value;\\r\\n\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nObject.defineProperties( Raycaster.prototype, {\\r\\n\\r\\n\\tlinePrecision: {\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.' );\\r\\n\\t\\t\\treturn this.params.Line.threshold;\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.' );\\r\\n\\t\\t\\tthis.params.Line.threshold = value;\\r\\n\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nObject.defineProperties( InterleavedBuffer.prototype, {\\r\\n\\r\\n\\tdynamic: {\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.' );\\r\\n\\t\\t\\treturn this.usage === DynamicDrawUsage;\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.' );\\r\\n\\t\\t\\tthis.setUsage( value );\\r\\n\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nObject.assign( InterleavedBuffer.prototype, {\\r\\n\\tsetDynamic: function ( value ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.' );\\r\\n\\t\\tthis.setUsage( value === true ? DynamicDrawUsage : StaticDrawUsage );\\r\\n\\t\\treturn this;\\r\\n\\r\\n\\t},\\r\\n\\tsetArray: function ( /* array */ ) {\\r\\n\\r\\n\\t\\tconsole.error( 'THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers' );\\r\\n\\r\\n\\t}\\r\\n} );\\r\\n\\r\\n//\\r\\n\\r\\nObject.assign( ExtrudeBufferGeometry.prototype, {\\r\\n\\r\\n\\tgetArrays: function () {\\r\\n\\r\\n\\t\\tconsole.error( 'THREE.ExtrudeBufferGeometry: .getArrays() has been removed.' );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\taddShapeList: function () {\\r\\n\\r\\n\\t\\tconsole.error( 'THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.' );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\taddShape: function () {\\r\\n\\r\\n\\t\\tconsole.error( 'THREE.ExtrudeBufferGeometry: .addShape() has been removed.' );\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n//\\r\\n\\r\\nObject.defineProperties( Uniform.prototype, {\\r\\n\\r\\n\\tdynamic: {\\r\\n\\t\\tset: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.' );\\r\\n\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\tonUpdate: {\\r\\n\\t\\tvalue: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n//\\r\\n\\r\\nObject.defineProperties( Material.prototype, {\\r\\n\\r\\n\\twrapAround: {\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Material: .wrapAround has been removed.' );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tset: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Material: .wrapAround has been removed.' );\\r\\n\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\r\\n\\toverdraw: {\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Material: .overdraw has been removed.' );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tset: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Material: .overdraw has been removed.' );\\r\\n\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\r\\n\\twrapRGB: {\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Material: .wrapRGB has been removed.' );\\r\\n\\t\\t\\treturn new Color();\\r\\n\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\r\\n\\tshading: {\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\tconsole.error( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );\\r\\n\\t\\t\\tthis.flatShading = ( value === FlatShading );\\r\\n\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\r\\n\\tstencilMask: {\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.' );\\r\\n\\t\\t\\treturn this.stencilFuncMask;\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.' );\\r\\n\\t\\t\\tthis.stencilFuncMask = value;\\r\\n\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nObject.defineProperties( MeshPhongMaterial.prototype, {\\r\\n\\r\\n\\tmetal: {\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );\\r\\n\\t\\t\\treturn false;\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tset: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );\\r\\n\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nObject.defineProperties( ShaderMaterial.prototype, {\\r\\n\\r\\n\\tderivatives: {\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\\r\\n\\t\\t\\treturn this.extensions.derivatives;\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\\r\\n\\t\\t\\tthis.extensions.derivatives = value;\\r\\n\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n//\\r\\n\\r\\nObject.assign( WebGLRenderer.prototype, {\\r\\n\\r\\n\\tclearTarget: function ( renderTarget, color, depth, stencil ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.' );\\r\\n\\t\\tthis.setRenderTarget( renderTarget );\\r\\n\\t\\tthis.clear( color, depth, stencil );\\r\\n\\r\\n\\t},\\r\\n\\tanimate: function ( callback ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.WebGLRenderer: .animate() is now .setAnimationLoop().' );\\r\\n\\t\\tthis.setAnimationLoop( callback );\\r\\n\\r\\n\\t},\\r\\n\\tgetCurrentRenderTarget: function () {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().' );\\r\\n\\t\\treturn this.getRenderTarget();\\r\\n\\r\\n\\t},\\r\\n\\tgetMaxAnisotropy: function () {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().' );\\r\\n\\t\\treturn this.capabilities.getMaxAnisotropy();\\r\\n\\r\\n\\t},\\r\\n\\tgetPrecision: function () {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.' );\\r\\n\\t\\treturn this.capabilities.precision;\\r\\n\\r\\n\\t},\\r\\n\\tresetGLState: function () {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.WebGLRenderer: .resetGLState() is now .state.reset().' );\\r\\n\\t\\treturn this.state.reset();\\r\\n\\r\\n\\t},\\r\\n\\tsupportsFloatTextures: function () {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \\\\'OES_texture_float\\\\' ).' );\\r\\n\\t\\treturn this.extensions.get( 'OES_texture_float' );\\r\\n\\r\\n\\t},\\r\\n\\tsupportsHalfFloatTextures: function () {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \\\\'OES_texture_half_float\\\\' ).' );\\r\\n\\t\\treturn this.extensions.get( 'OES_texture_half_float' );\\r\\n\\r\\n\\t},\\r\\n\\tsupportsStandardDerivatives: function () {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \\\\'OES_standard_derivatives\\\\' ).' );\\r\\n\\t\\treturn this.extensions.get( 'OES_standard_derivatives' );\\r\\n\\r\\n\\t},\\r\\n\\tsupportsCompressedTextureS3TC: function () {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \\\\'WEBGL_compressed_texture_s3tc\\\\' ).' );\\r\\n\\t\\treturn this.extensions.get( 'WEBGL_compressed_texture_s3tc' );\\r\\n\\r\\n\\t},\\r\\n\\tsupportsCompressedTexturePVRTC: function () {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \\\\'WEBGL_compressed_texture_pvrtc\\\\' ).' );\\r\\n\\t\\treturn this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );\\r\\n\\r\\n\\t},\\r\\n\\tsupportsBlendMinMax: function () {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \\\\'EXT_blend_minmax\\\\' ).' );\\r\\n\\t\\treturn this.extensions.get( 'EXT_blend_minmax' );\\r\\n\\r\\n\\t},\\r\\n\\tsupportsVertexTextures: function () {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.' );\\r\\n\\t\\treturn this.capabilities.vertexTextures;\\r\\n\\r\\n\\t},\\r\\n\\tsupportsInstancedArrays: function () {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \\\\'ANGLE_instanced_arrays\\\\' ).' );\\r\\n\\t\\treturn this.extensions.get( 'ANGLE_instanced_arrays' );\\r\\n\\r\\n\\t},\\r\\n\\tenableScissorTest: function ( boolean ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );\\r\\n\\t\\tthis.setScissorTest( boolean );\\r\\n\\r\\n\\t},\\r\\n\\tinitMaterial: function () {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );\\r\\n\\r\\n\\t},\\r\\n\\taddPrePlugin: function () {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );\\r\\n\\r\\n\\t},\\r\\n\\taddPostPlugin: function () {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );\\r\\n\\r\\n\\t},\\r\\n\\tupdateShadowMap: function () {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );\\r\\n\\r\\n\\t},\\r\\n\\tsetFaceCulling: function () {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.WebGLRenderer: .setFaceCulling() has been removed.' );\\r\\n\\r\\n\\t},\\r\\n\\tallocTextureUnit: function () {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.WebGLRenderer: .allocTextureUnit() has been removed.' );\\r\\n\\r\\n\\t},\\r\\n\\tsetTexture: function () {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.WebGLRenderer: .setTexture() has been removed.' );\\r\\n\\r\\n\\t},\\r\\n\\tsetTexture2D: function () {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.WebGLRenderer: .setTexture2D() has been removed.' );\\r\\n\\r\\n\\t},\\r\\n\\tsetTextureCube: function () {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.WebGLRenderer: .setTextureCube() has been removed.' );\\r\\n\\r\\n\\t},\\r\\n\\tgetActiveMipMapLevel: function () {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().' );\\r\\n\\t\\treturn this.getActiveMipmapLevel();\\r\\n\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nObject.defineProperties( WebGLRenderer.prototype, {\\r\\n\\r\\n\\tshadowMapEnabled: {\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\treturn this.shadowMap.enabled;\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );\\r\\n\\t\\t\\tthis.shadowMap.enabled = value;\\r\\n\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\tshadowMapType: {\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\treturn this.shadowMap.type;\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );\\r\\n\\t\\t\\tthis.shadowMap.type = value;\\r\\n\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\tshadowMapCullFace: {\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );\\r\\n\\t\\t\\treturn undefined;\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tset: function ( /* value */ ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );\\r\\n\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\tcontext: {\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.' );\\r\\n\\t\\t\\treturn this.getContext();\\r\\n\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\tvr: {\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .vr has been renamed to .xr' );\\r\\n\\t\\t\\treturn this.xr;\\r\\n\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\tgammaInput: {\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.' );\\r\\n\\t\\t\\treturn false;\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tset: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.' );\\r\\n\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\tgammaOutput: {\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.' );\\r\\n\\t\\t\\treturn false;\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.' );\\r\\n\\t\\t\\tthis.outputEncoding = ( value === true ) ? sRGBEncoding : LinearEncoding;\\r\\n\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nObject.defineProperties( WebGLShadowMap.prototype, {\\r\\n\\r\\n\\tcullFace: {\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );\\r\\n\\t\\t\\treturn undefined;\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tset: function ( /* cullFace */ ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );\\r\\n\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\trenderReverseSided: {\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );\\r\\n\\t\\t\\treturn undefined;\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tset: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );\\r\\n\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\trenderSingleSided: {\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );\\r\\n\\t\\t\\treturn undefined;\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tset: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );\\r\\n\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nfunction WebGLRenderTargetCube( width, height, options ) {\\r\\n\\r\\n\\tconsole.warn( 'THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).' );\\r\\n\\treturn new WebGLCubeRenderTarget( width, options );\\r\\n\\r\\n}\\r\\n\\r\\n//\\r\\n\\r\\nObject.defineProperties( WebGLRenderTarget.prototype, {\\r\\n\\r\\n\\twrapS: {\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\\r\\n\\t\\t\\treturn this.texture.wrapS;\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\\r\\n\\t\\t\\tthis.texture.wrapS = value;\\r\\n\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\twrapT: {\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\\r\\n\\t\\t\\treturn this.texture.wrapT;\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\\r\\n\\t\\t\\tthis.texture.wrapT = value;\\r\\n\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\tmagFilter: {\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\\r\\n\\t\\t\\treturn this.texture.magFilter;\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\\r\\n\\t\\t\\tthis.texture.magFilter = value;\\r\\n\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\tminFilter: {\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\\r\\n\\t\\t\\treturn this.texture.minFilter;\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\\r\\n\\t\\t\\tthis.texture.minFilter = value;\\r\\n\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\tanisotropy: {\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\\r\\n\\t\\t\\treturn this.texture.anisotropy;\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\\r\\n\\t\\t\\tthis.texture.anisotropy = value;\\r\\n\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\toffset: {\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\\r\\n\\t\\t\\treturn this.texture.offset;\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\\r\\n\\t\\t\\tthis.texture.offset = value;\\r\\n\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\trepeat: {\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\\r\\n\\t\\t\\treturn this.texture.repeat;\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\\r\\n\\t\\t\\tthis.texture.repeat = value;\\r\\n\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\tformat: {\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\\r\\n\\t\\t\\treturn this.texture.format;\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\\r\\n\\t\\t\\tthis.texture.format = value;\\r\\n\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\ttype: {\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\\r\\n\\t\\t\\treturn this.texture.type;\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\\r\\n\\t\\t\\tthis.texture.type = value;\\r\\n\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\tgenerateMipmaps: {\\r\\n\\t\\tget: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\\r\\n\\t\\t\\treturn this.texture.generateMipmaps;\\r\\n\\r\\n\\t\\t},\\r\\n\\t\\tset: function ( value ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\\r\\n\\t\\t\\tthis.texture.generateMipmaps = value;\\r\\n\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\n//\\r\\n\\r\\nObject.defineProperties( Audio.prototype, {\\r\\n\\r\\n\\tload: {\\r\\n\\t\\tvalue: function ( file ) {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.' );\\r\\n\\t\\t\\tvar scope = this;\\r\\n\\t\\t\\tvar audioLoader = new AudioLoader();\\r\\n\\t\\t\\taudioLoader.load( file, function ( buffer ) {\\r\\n\\r\\n\\t\\t\\t\\tscope.setBuffer( buffer );\\r\\n\\r\\n\\t\\t\\t} );\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\tstartTime: {\\r\\n\\t\\tset: function () {\\r\\n\\r\\n\\t\\t\\tconsole.warn( 'THREE.Audio: .startTime is now .play( delay ).' );\\r\\n\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n} );\\r\\n\\r\\nAudioAnalyser.prototype.getData = function () {\\r\\n\\r\\n\\tconsole.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );\\r\\n\\treturn this.getFrequencyData();\\r\\n\\r\\n};\\r\\n\\r\\n//\\r\\n\\r\\nCubeCamera.prototype.updateCubeMap = function ( renderer, scene ) {\\r\\n\\r\\n\\tconsole.warn( 'THREE.CubeCamera: .updateCubeMap() is now .update().' );\\r\\n\\treturn this.update( renderer, scene );\\r\\n\\r\\n};\\r\\n\\r\\n//\\r\\n\\r\\nvar GeometryUtils = {\\r\\n\\r\\n\\tmerge: function ( geometry1, geometry2, materialIndexOffset ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );\\r\\n\\t\\tvar matrix;\\r\\n\\r\\n\\t\\tif ( geometry2.isMesh ) {\\r\\n\\r\\n\\t\\t\\tgeometry2.matrixAutoUpdate && geometry2.updateMatrix();\\r\\n\\r\\n\\t\\t\\tmatrix = geometry2.matrix;\\r\\n\\t\\t\\tgeometry2 = geometry2.geometry;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tgeometry1.merge( geometry2, matrix, materialIndexOffset );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tcenter: function ( geometry ) {\\r\\n\\r\\n\\t\\tconsole.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );\\r\\n\\t\\treturn geometry.center();\\r\\n\\r\\n\\t}\\r\\n\\r\\n};\\r\\n\\r\\nImageUtils.crossOrigin = undefined;\\r\\n\\r\\nImageUtils.loadTexture = function ( url, mapping, onLoad, onError ) {\\r\\n\\r\\n\\tconsole.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );\\r\\n\\r\\n\\tvar loader = new TextureLoader();\\r\\n\\tloader.setCrossOrigin( this.crossOrigin );\\r\\n\\r\\n\\tvar texture = loader.load( url, onLoad, undefined, onError );\\r\\n\\r\\n\\tif ( mapping ) texture.mapping = mapping;\\r\\n\\r\\n\\treturn texture;\\r\\n\\r\\n};\\r\\n\\r\\nImageUtils.loadTextureCube = function ( urls, mapping, onLoad, onError ) {\\r\\n\\r\\n\\tconsole.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );\\r\\n\\r\\n\\tvar loader = new CubeTextureLoader();\\r\\n\\tloader.setCrossOrigin( this.crossOrigin );\\r\\n\\r\\n\\tvar texture = loader.load( urls, onLoad, undefined, onError );\\r\\n\\r\\n\\tif ( mapping ) texture.mapping = mapping;\\r\\n\\r\\n\\treturn texture;\\r\\n\\r\\n};\\r\\n\\r\\nImageUtils.loadCompressedTexture = function () {\\r\\n\\r\\n\\tconsole.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );\\r\\n\\r\\n};\\r\\n\\r\\nImageUtils.loadCompressedTextureCube = function () {\\r\\n\\r\\n\\tconsole.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );\\r\\n\\r\\n};\\r\\n\\r\\n//\\r\\n\\r\\nfunction CanvasRenderer() {\\r\\n\\r\\n\\tconsole.error( 'THREE.CanvasRenderer has been removed' );\\r\\n\\r\\n}\\r\\n\\r\\n//\\r\\n\\r\\nfunction JSONLoader() {\\r\\n\\r\\n\\tconsole.error( 'THREE.JSONLoader has been removed.' );\\r\\n\\r\\n}\\r\\n\\r\\n//\\r\\n\\r\\nvar SceneUtils = {\\r\\n\\r\\n\\tcreateMultiMaterialObject: function ( /* geometry, materials */ ) {\\r\\n\\r\\n\\t\\tconsole.error( 'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js' );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tdetach: function ( /* child, parent, scene */ ) {\\r\\n\\r\\n\\t\\tconsole.error( 'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js' );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tattach: function ( /* child, scene, parent */ ) {\\r\\n\\r\\n\\t\\tconsole.error( 'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js' );\\r\\n\\r\\n\\t}\\r\\n\\r\\n};\\r\\n\\r\\n//\\r\\n\\r\\nfunction LensFlare() {\\r\\n\\r\\n\\tconsole.error( 'THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js' );\\r\\n\\r\\n}\\r\\n\\r\\nif ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {\\r\\n\\r\\n\\t/* eslint-disable no-undef */\\r\\n\\t__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'register', { detail: {\\r\\n\\t\\trevision: REVISION,\\r\\n\\t} } ) );\\r\\n\\t/* eslint-enable no-undef */\\r\\n\\r\\n}\\r\\n\\r\\n\\r\\n\\n\\n//# sourceURL=webpack:///./node_modules/three/build/three.module.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/type-detect/type-detect.js\":\n/*!*************************************************!*\\\n  !*** ./node_modules/type-detect/type-detect.js ***!\n  \\*************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\neval(\"/* WEBPACK VAR INJECTION */(function(global) {(function (global, factory) {\\r\\n\\t true ? module.exports = factory() :\\r\\n\\tundefined;\\r\\n}(this, (function () { 'use strict';\\r\\n\\r\\n/* !\\r\\n * type-detect\\r\\n * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>\\r\\n * MIT Licensed\\r\\n */\\r\\nvar promiseExists = typeof Promise === 'function';\\r\\n\\r\\n/* eslint-disable no-undef */\\r\\nvar globalObject = typeof self === 'object' ? self : global; // eslint-disable-line id-blacklist\\r\\n\\r\\nvar symbolExists = typeof Symbol !== 'undefined';\\r\\nvar mapExists = typeof Map !== 'undefined';\\r\\nvar setExists = typeof Set !== 'undefined';\\r\\nvar weakMapExists = typeof WeakMap !== 'undefined';\\r\\nvar weakSetExists = typeof WeakSet !== 'undefined';\\r\\nvar dataViewExists = typeof DataView !== 'undefined';\\r\\nvar symbolIteratorExists = symbolExists && typeof Symbol.iterator !== 'undefined';\\r\\nvar symbolToStringTagExists = symbolExists && typeof Symbol.toStringTag !== 'undefined';\\r\\nvar setEntriesExists = setExists && typeof Set.prototype.entries === 'function';\\r\\nvar mapEntriesExists = mapExists && typeof Map.prototype.entries === 'function';\\r\\nvar setIteratorPrototype = setEntriesExists && Object.getPrototypeOf(new Set().entries());\\r\\nvar mapIteratorPrototype = mapEntriesExists && Object.getPrototypeOf(new Map().entries());\\r\\nvar arrayIteratorExists = symbolIteratorExists && typeof Array.prototype[Symbol.iterator] === 'function';\\r\\nvar arrayIteratorPrototype = arrayIteratorExists && Object.getPrototypeOf([][Symbol.iterator]());\\r\\nvar stringIteratorExists = symbolIteratorExists && typeof String.prototype[Symbol.iterator] === 'function';\\r\\nvar stringIteratorPrototype = stringIteratorExists && Object.getPrototypeOf(''[Symbol.iterator]());\\r\\nvar toStringLeftSliceLength = 8;\\r\\nvar toStringRightSliceLength = -1;\\r\\n/**\\r\\n * ### typeOf (obj)\\r\\n *\\r\\n * Uses `Object.prototype.toString` to determine the type of an object,\\r\\n * normalising behaviour across engine versions & well optimised.\\r\\n *\\r\\n * @param {Mixed} object\\r\\n * @return {String} object type\\r\\n * @api public\\r\\n */\\r\\nfunction typeDetect(obj) {\\r\\n  /* ! Speed optimisation\\r\\n   * Pre:\\r\\n   *   string literal     x 3,039,035 ops/sec 1.62% (78 runs sampled)\\r\\n   *   boolean literal    x 1,424,138 ops/sec 4.54% (75 runs sampled)\\r\\n   *   number literal     x 1,653,153 ops/sec 1.91% (82 runs sampled)\\r\\n   *   undefined          x 9,978,660 ops/sec 1.92% (75 runs sampled)\\r\\n   *   function           x 2,556,769 ops/sec 1.73% (77 runs sampled)\\r\\n   * Post:\\r\\n   *   string literal     x 38,564,796 ops/sec 1.15% (79 runs sampled)\\r\\n   *   boolean literal    x 31,148,940 ops/sec 1.10% (79 runs sampled)\\r\\n   *   number literal     x 32,679,330 ops/sec 1.90% (78 runs sampled)\\r\\n   *   undefined          x 32,363,368 ops/sec 1.07% (82 runs sampled)\\r\\n   *   function           x 31,296,870 ops/sec 0.96% (83 runs sampled)\\r\\n   */\\r\\n  var typeofObj = typeof obj;\\r\\n  if (typeofObj !== 'object') {\\r\\n    return typeofObj;\\r\\n  }\\r\\n\\r\\n  /* ! Speed optimisation\\r\\n   * Pre:\\r\\n   *   null               x 28,645,765 ops/sec 1.17% (82 runs sampled)\\r\\n   * Post:\\r\\n   *   null               x 36,428,962 ops/sec 1.37% (84 runs sampled)\\r\\n   */\\r\\n  if (obj === null) {\\r\\n    return 'null';\\r\\n  }\\r\\n\\r\\n  /* ! Spec Conformance\\r\\n   * Test: `Object.prototype.toString.call(window)``\\r\\n   *  - Node === \\\"[object global]\\\"\\r\\n   *  - Chrome === \\\"[object global]\\\"\\r\\n   *  - Firefox === \\\"[object Window]\\\"\\r\\n   *  - PhantomJS === \\\"[object Window]\\\"\\r\\n   *  - Safari === \\\"[object Window]\\\"\\r\\n   *  - IE 11 === \\\"[object Window]\\\"\\r\\n   *  - IE Edge === \\\"[object Window]\\\"\\r\\n   * Test: `Object.prototype.toString.call(this)``\\r\\n   *  - Chrome Worker === \\\"[object global]\\\"\\r\\n   *  - Firefox Worker === \\\"[object DedicatedWorkerGlobalScope]\\\"\\r\\n   *  - Safari Worker === \\\"[object DedicatedWorkerGlobalScope]\\\"\\r\\n   *  - IE 11 Worker === \\\"[object WorkerGlobalScope]\\\"\\r\\n   *  - IE Edge Worker === \\\"[object WorkerGlobalScope]\\\"\\r\\n   */\\r\\n  if (obj === globalObject) {\\r\\n    return 'global';\\r\\n  }\\r\\n\\r\\n  /* ! Speed optimisation\\r\\n   * Pre:\\r\\n   *   array literal      x 2,888,352 ops/sec 0.67% (82 runs sampled)\\r\\n   * Post:\\r\\n   *   array literal      x 22,479,650 ops/sec 0.96% (81 runs sampled)\\r\\n   */\\r\\n  if (\\r\\n    Array.isArray(obj) &&\\r\\n    (symbolToStringTagExists === false || !(Symbol.toStringTag in obj))\\r\\n  ) {\\r\\n    return 'Array';\\r\\n  }\\r\\n\\r\\n  // Not caching existence of `window` and related properties due to potential\\r\\n  // for `window` to be unset before tests in quasi-browser environments.\\r\\n  if (typeof window === 'object' && window !== null) {\\r\\n    /* ! Spec Conformance\\r\\n     * (https://html.spec.whatwg.org/multipage/browsers.html#location)\\r\\n     * WhatWG HTML$7.7.3 - The `Location` interface\\r\\n     * Test: `Object.prototype.toString.call(window.location)``\\r\\n     *  - IE <=11 === \\\"[object Object]\\\"\\r\\n     *  - IE Edge <=13 === \\\"[object Object]\\\"\\r\\n     */\\r\\n    if (typeof window.location === 'object' && obj === window.location) {\\r\\n      return 'Location';\\r\\n    }\\r\\n\\r\\n    /* ! Spec Conformance\\r\\n     * (https://html.spec.whatwg.org/#document)\\r\\n     * WhatWG HTML$3.1.1 - The `Document` object\\r\\n     * Note: Most browsers currently adher to the W3C DOM Level 2 spec\\r\\n     *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-26809268)\\r\\n     *       which suggests that browsers should use HTMLTableCellElement for\\r\\n     *       both TD and TH elements. WhatWG separates these.\\r\\n     *       WhatWG HTML states:\\r\\n     *         > For historical reasons, Window objects must also have a\\r\\n     *         > writable, configurable, non-enumerable property named\\r\\n     *         > HTMLDocument whose value is the Document interface object.\\r\\n     * Test: `Object.prototype.toString.call(document)``\\r\\n     *  - Chrome === \\\"[object HTMLDocument]\\\"\\r\\n     *  - Firefox === \\\"[object HTMLDocument]\\\"\\r\\n     *  - Safari === \\\"[object HTMLDocument]\\\"\\r\\n     *  - IE <=10 === \\\"[object Document]\\\"\\r\\n     *  - IE 11 === \\\"[object HTMLDocument]\\\"\\r\\n     *  - IE Edge <=13 === \\\"[object HTMLDocument]\\\"\\r\\n     */\\r\\n    if (typeof window.document === 'object' && obj === window.document) {\\r\\n      return 'Document';\\r\\n    }\\r\\n\\r\\n    if (typeof window.navigator === 'object') {\\r\\n      /* ! Spec Conformance\\r\\n       * (https://html.spec.whatwg.org/multipage/webappapis.html#mimetypearray)\\r\\n       * WhatWG HTML$8.6.1.5 - Plugins - Interface MimeTypeArray\\r\\n       * Test: `Object.prototype.toString.call(navigator.mimeTypes)``\\r\\n       *  - IE <=10 === \\\"[object MSMimeTypesCollection]\\\"\\r\\n       */\\r\\n      if (typeof window.navigator.mimeTypes === 'object' &&\\r\\n          obj === window.navigator.mimeTypes) {\\r\\n        return 'MimeTypeArray';\\r\\n      }\\r\\n\\r\\n      /* ! Spec Conformance\\r\\n       * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)\\r\\n       * WhatWG HTML$8.6.1.5 - Plugins - Interface PluginArray\\r\\n       * Test: `Object.prototype.toString.call(navigator.plugins)``\\r\\n       *  - IE <=10 === \\\"[object MSPluginsCollection]\\\"\\r\\n       */\\r\\n      if (typeof window.navigator.plugins === 'object' &&\\r\\n          obj === window.navigator.plugins) {\\r\\n        return 'PluginArray';\\r\\n      }\\r\\n    }\\r\\n\\r\\n    if ((typeof window.HTMLElement === 'function' ||\\r\\n        typeof window.HTMLElement === 'object') &&\\r\\n        obj instanceof window.HTMLElement) {\\r\\n      /* ! Spec Conformance\\r\\n      * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)\\r\\n      * WhatWG HTML$4.4.4 - The `blockquote` element - Interface `HTMLQuoteElement`\\r\\n      * Test: `Object.prototype.toString.call(document.createElement('blockquote'))``\\r\\n      *  - IE <=10 === \\\"[object HTMLBlockElement]\\\"\\r\\n      */\\r\\n      if (obj.tagName === 'BLOCKQUOTE') {\\r\\n        return 'HTMLQuoteElement';\\r\\n      }\\r\\n\\r\\n      /* ! Spec Conformance\\r\\n       * (https://html.spec.whatwg.org/#htmltabledatacellelement)\\r\\n       * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableDataCellElement`\\r\\n       * Note: Most browsers currently adher to the W3C DOM Level 2 spec\\r\\n       *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)\\r\\n       *       which suggests that browsers should use HTMLTableCellElement for\\r\\n       *       both TD and TH elements. WhatWG separates these.\\r\\n       * Test: Object.prototype.toString.call(document.createElement('td'))\\r\\n       *  - Chrome === \\\"[object HTMLTableCellElement]\\\"\\r\\n       *  - Firefox === \\\"[object HTMLTableCellElement]\\\"\\r\\n       *  - Safari === \\\"[object HTMLTableCellElement]\\\"\\r\\n       */\\r\\n      if (obj.tagName === 'TD') {\\r\\n        return 'HTMLTableDataCellElement';\\r\\n      }\\r\\n\\r\\n      /* ! Spec Conformance\\r\\n       * (https://html.spec.whatwg.org/#htmltableheadercellelement)\\r\\n       * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableHeaderCellElement`\\r\\n       * Note: Most browsers currently adher to the W3C DOM Level 2 spec\\r\\n       *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)\\r\\n       *       which suggests that browsers should use HTMLTableCellElement for\\r\\n       *       both TD and TH elements. WhatWG separates these.\\r\\n       * Test: Object.prototype.toString.call(document.createElement('th'))\\r\\n       *  - Chrome === \\\"[object HTMLTableCellElement]\\\"\\r\\n       *  - Firefox === \\\"[object HTMLTableCellElement]\\\"\\r\\n       *  - Safari === \\\"[object HTMLTableCellElement]\\\"\\r\\n       */\\r\\n      if (obj.tagName === 'TH') {\\r\\n        return 'HTMLTableHeaderCellElement';\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /* ! Speed optimisation\\r\\n  * Pre:\\r\\n  *   Float64Array       x 625,644 ops/sec 1.58% (80 runs sampled)\\r\\n  *   Float32Array       x 1,279,852 ops/sec 2.91% (77 runs sampled)\\r\\n  *   Uint32Array        x 1,178,185 ops/sec 1.95% (83 runs sampled)\\r\\n  *   Uint16Array        x 1,008,380 ops/sec 2.25% (80 runs sampled)\\r\\n  *   Uint8Array         x 1,128,040 ops/sec 2.11% (81 runs sampled)\\r\\n  *   Int32Array         x 1,170,119 ops/sec 2.88% (80 runs sampled)\\r\\n  *   Int16Array         x 1,176,348 ops/sec 5.79% (86 runs sampled)\\r\\n  *   Int8Array          x 1,058,707 ops/sec 4.94% (77 runs sampled)\\r\\n  *   Uint8ClampedArray  x 1,110,633 ops/sec 4.20% (80 runs sampled)\\r\\n  * Post:\\r\\n  *   Float64Array       x 7,105,671 ops/sec 13.47% (64 runs sampled)\\r\\n  *   Float32Array       x 5,887,912 ops/sec 1.46% (82 runs sampled)\\r\\n  *   Uint32Array        x 6,491,661 ops/sec 1.76% (79 runs sampled)\\r\\n  *   Uint16Array        x 6,559,795 ops/sec 1.67% (82 runs sampled)\\r\\n  *   Uint8Array         x 6,463,966 ops/sec 1.43% (85 runs sampled)\\r\\n  *   Int32Array         x 5,641,841 ops/sec 3.49% (81 runs sampled)\\r\\n  *   Int16Array         x 6,583,511 ops/sec 1.98% (80 runs sampled)\\r\\n  *   Int8Array          x 6,606,078 ops/sec 1.74% (81 runs sampled)\\r\\n  *   Uint8ClampedArray  x 6,602,224 ops/sec 1.77% (83 runs sampled)\\r\\n  */\\r\\n  var stringTag = (symbolToStringTagExists && obj[Symbol.toStringTag]);\\r\\n  if (typeof stringTag === 'string') {\\r\\n    return stringTag;\\r\\n  }\\r\\n\\r\\n  var objPrototype = Object.getPrototypeOf(obj);\\r\\n  /* ! Speed optimisation\\r\\n  * Pre:\\r\\n  *   regex literal      x 1,772,385 ops/sec 1.85% (77 runs sampled)\\r\\n  *   regex constructor  x 2,143,634 ops/sec 2.46% (78 runs sampled)\\r\\n  * Post:\\r\\n  *   regex literal      x 3,928,009 ops/sec 0.65% (78 runs sampled)\\r\\n  *   regex constructor  x 3,931,108 ops/sec 0.58% (84 runs sampled)\\r\\n  */\\r\\n  if (objPrototype === RegExp.prototype) {\\r\\n    return 'RegExp';\\r\\n  }\\r\\n\\r\\n  /* ! Speed optimisation\\r\\n  * Pre:\\r\\n  *   date               x 2,130,074 ops/sec 4.42% (68 runs sampled)\\r\\n  * Post:\\r\\n  *   date               x 3,953,779 ops/sec 1.35% (77 runs sampled)\\r\\n  */\\r\\n  if (objPrototype === Date.prototype) {\\r\\n    return 'Date';\\r\\n  }\\r\\n\\r\\n  /* ! Spec Conformance\\r\\n   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-promise.prototype-@@tostringtag)\\r\\n   * ES6$25.4.5.4 - Promise.prototype[@@toStringTag] should be \\\"Promise\\\":\\r\\n   * Test: `Object.prototype.toString.call(Promise.resolve())``\\r\\n   *  - Chrome <=47 === \\\"[object Object]\\\"\\r\\n   *  - Edge <=20 === \\\"[object Object]\\\"\\r\\n   *  - Firefox 29-Latest === \\\"[object Promise]\\\"\\r\\n   *  - Safari 7.1-Latest === \\\"[object Promise]\\\"\\r\\n   */\\r\\n  if (promiseExists && objPrototype === Promise.prototype) {\\r\\n    return 'Promise';\\r\\n  }\\r\\n\\r\\n  /* ! Speed optimisation\\r\\n  * Pre:\\r\\n  *   set                x 2,222,186 ops/sec 1.31% (82 runs sampled)\\r\\n  * Post:\\r\\n  *   set                x 4,545,879 ops/sec 1.13% (83 runs sampled)\\r\\n  */\\r\\n  if (setExists && objPrototype === Set.prototype) {\\r\\n    return 'Set';\\r\\n  }\\r\\n\\r\\n  /* ! Speed optimisation\\r\\n  * Pre:\\r\\n  *   map                x 2,396,842 ops/sec 1.59% (81 runs sampled)\\r\\n  * Post:\\r\\n  *   map                x 4,183,945 ops/sec 6.59% (82 runs sampled)\\r\\n  */\\r\\n  if (mapExists && objPrototype === Map.prototype) {\\r\\n    return 'Map';\\r\\n  }\\r\\n\\r\\n  /* ! Speed optimisation\\r\\n  * Pre:\\r\\n  *   weakset            x 1,323,220 ops/sec 2.17% (76 runs sampled)\\r\\n  * Post:\\r\\n  *   weakset            x 4,237,510 ops/sec 2.01% (77 runs sampled)\\r\\n  */\\r\\n  if (weakSetExists && objPrototype === WeakSet.prototype) {\\r\\n    return 'WeakSet';\\r\\n  }\\r\\n\\r\\n  /* ! Speed optimisation\\r\\n  * Pre:\\r\\n  *   weakmap            x 1,500,260 ops/sec 2.02% (78 runs sampled)\\r\\n  * Post:\\r\\n  *   weakmap            x 3,881,384 ops/sec 1.45% (82 runs sampled)\\r\\n  */\\r\\n  if (weakMapExists && objPrototype === WeakMap.prototype) {\\r\\n    return 'WeakMap';\\r\\n  }\\r\\n\\r\\n  /* ! Spec Conformance\\r\\n   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-dataview.prototype-@@tostringtag)\\r\\n   * ES6$24.2.4.21 - DataView.prototype[@@toStringTag] should be \\\"DataView\\\":\\r\\n   * Test: `Object.prototype.toString.call(new DataView(new ArrayBuffer(1)))``\\r\\n   *  - Edge <=13 === \\\"[object Object]\\\"\\r\\n   */\\r\\n  if (dataViewExists && objPrototype === DataView.prototype) {\\r\\n    return 'DataView';\\r\\n  }\\r\\n\\r\\n  /* ! Spec Conformance\\r\\n   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%mapiteratorprototype%-@@tostringtag)\\r\\n   * ES6$23.1.5.2.2 - %MapIteratorPrototype%[@@toStringTag] should be \\\"Map Iterator\\\":\\r\\n   * Test: `Object.prototype.toString.call(new Map().entries())``\\r\\n   *  - Edge <=13 === \\\"[object Object]\\\"\\r\\n   */\\r\\n  if (mapExists && objPrototype === mapIteratorPrototype) {\\r\\n    return 'Map Iterator';\\r\\n  }\\r\\n\\r\\n  /* ! Spec Conformance\\r\\n   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%setiteratorprototype%-@@tostringtag)\\r\\n   * ES6$23.2.5.2.2 - %SetIteratorPrototype%[@@toStringTag] should be \\\"Set Iterator\\\":\\r\\n   * Test: `Object.prototype.toString.call(new Set().entries())``\\r\\n   *  - Edge <=13 === \\\"[object Object]\\\"\\r\\n   */\\r\\n  if (setExists && objPrototype === setIteratorPrototype) {\\r\\n    return 'Set Iterator';\\r\\n  }\\r\\n\\r\\n  /* ! Spec Conformance\\r\\n   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%arrayiteratorprototype%-@@tostringtag)\\r\\n   * ES6$22.1.5.2.2 - %ArrayIteratorPrototype%[@@toStringTag] should be \\\"Array Iterator\\\":\\r\\n   * Test: `Object.prototype.toString.call([][Symbol.iterator]())``\\r\\n   *  - Edge <=13 === \\\"[object Object]\\\"\\r\\n   */\\r\\n  if (arrayIteratorExists && objPrototype === arrayIteratorPrototype) {\\r\\n    return 'Array Iterator';\\r\\n  }\\r\\n\\r\\n  /* ! Spec Conformance\\r\\n   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%stringiteratorprototype%-@@tostringtag)\\r\\n   * ES6$21.1.5.2.2 - %StringIteratorPrototype%[@@toStringTag] should be \\\"String Iterator\\\":\\r\\n   * Test: `Object.prototype.toString.call(''[Symbol.iterator]())``\\r\\n   *  - Edge <=13 === \\\"[object Object]\\\"\\r\\n   */\\r\\n  if (stringIteratorExists && objPrototype === stringIteratorPrototype) {\\r\\n    return 'String Iterator';\\r\\n  }\\r\\n\\r\\n  /* ! Speed optimisation\\r\\n  * Pre:\\r\\n  *   object from null   x 2,424,320 ops/sec 1.67% (76 runs sampled)\\r\\n  * Post:\\r\\n  *   object from null   x 5,838,000 ops/sec 0.99% (84 runs sampled)\\r\\n  */\\r\\n  if (objPrototype === null) {\\r\\n    return 'Object';\\r\\n  }\\r\\n\\r\\n  return Object\\r\\n    .prototype\\r\\n    .toString\\r\\n    .call(obj)\\r\\n    .slice(toStringLeftSliceLength, toStringRightSliceLength);\\r\\n}\\r\\n\\r\\nreturn typeDetect;\\r\\n\\r\\n})));\\r\\n\\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \\\"./node_modules/webpack/buildin/global.js\\\")))\\n\\n//# sourceURL=webpack:///./node_modules/type-detect/type-detect.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/webpack/buildin/global.js\":\n/*!***********************************!*\\\n  !*** (webpack)/buildin/global.js ***!\n  \\***********************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\neval(\"var g;\\r\\n\\r\\n// This works in non-strict mode\\r\\ng = (function() {\\r\\n\\treturn this;\\r\\n})();\\r\\n\\r\\ntry {\\r\\n\\t// This works if eval is allowed (see CSP)\\r\\n\\tg = g || new Function(\\\"return this\\\")();\\r\\n} catch (e) {\\r\\n\\t// This works if the window reference is available\\r\\n\\tif (typeof window === \\\"object\\\") g = window;\\r\\n}\\r\\n\\r\\n// g can still be undefined, but nothing to do about it...\\r\\n// We return undefined, instead of nothing here, so it's\\r\\n// easier to handle this case. if(!global) { ...}\\r\\n\\r\\nmodule.exports = g;\\r\\n\\n\\n//# sourceURL=webpack:///(webpack)/buildin/global.js?\");\n\n/***/ }),\n\n/***/ \"./src/operator/ApplicationService/TelubeeService.ts\":\n/*!***********************************************************!*\\\n  !*** ./src/operator/ApplicationService/TelubeeService.ts ***!\n  \\***********************************************************/\n/*! exports provided: TelubeeService */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"TelubeeService\\\", function() { return TelubeeService; });\\n/* harmony import */ var _DomainService_TelubeeDomain__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../DomainService/TelubeeDomain */ \\\"./src/operator/DomainService/TelubeeDomain.ts\\\");\\n\\r\\n//Telubee\\r\\nvar TelubeeService = /** @class */ (function () {\\r\\n    function TelubeeService(stream, connectionId) {\\r\\n        this._telubee = new _DomainService_TelubeeDomain__WEBPACK_IMPORTED_MODULE_0__[\\\"TelubeeDomain\\\"](stream, connectionId);\\r\\n    }\\r\\n    TelubeeService.prototype.open = function (senderStream, receiverStream) {\\r\\n        var _this = this;\\r\\n        if (receiverStream) {\\r\\n            this._telubee.events.on(\\\"open\\\", function () {\\r\\n                receiverStream.setStream(_this._telubee.robot.getStream());\\r\\n            });\\r\\n        }\\r\\n        this._telubee.open(senderStream.getStream());\\r\\n    };\\r\\n    TelubeeService.prototype.close = function () {\\r\\n        this._telubee.close();\\r\\n    };\\r\\n    TelubeeService.prototype.rotateHead = function (pan, tilt, row) {\\r\\n        this._telubee.rotateHead(pan, tilt, row);\\r\\n    };\\r\\n    return TelubeeService;\\r\\n}());\\r\\n\\r\\n\\n\\n//# sourceURL=webpack:///./src/operator/ApplicationService/TelubeeService.ts?\");\n\n/***/ }),\n\n/***/ \"./src/operator/DomainService/TelubeeDomain.ts\":\n/*!*****************************************************!*\\\n  !*** ./src/operator/DomainService/TelubeeDomain.ts ***!\n  \\*****************************************************/\n/*! exports provided: TelubeeDomain */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"TelubeeDomain\\\", function() { return TelubeeDomain; });\\n/* harmony import */ var _Entity_User__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Entity/User */ \\\"./src/operator/Entity/User.ts\\\");\\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! events */ \\\"./node_modules/events/events.js\\\");\\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_1__);\\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \\\"./node_modules/three/build/three.module.js\\\");\\n/* harmony import */ var _Event_TelubeeEventList__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Event/TelubeeEventList */ \\\"./src/operator/Event/TelubeeEventList.ts\\\");\\n\\r\\n\\r\\n\\r\\n\\r\\nvar TelubeeDomain = /** @class */ (function () {\\r\\n    function TelubeeDomain(stream, connectionId) {\\r\\n        this._operator = new _Entity_User__WEBPACK_IMPORTED_MODULE_0__[\\\"User\\\"](connectionId + TelubeeDomain.OPERATOR_TAG);\\r\\n        this._robot = new _Entity_User__WEBPACK_IMPORTED_MODULE_0__[\\\"User\\\"](connectionId + TelubeeDomain.ROBOT_TAG);\\r\\n        this._events = new events__WEBPACK_IMPORTED_MODULE_1__[\\\"EventEmitter\\\"]();\\r\\n        this._stream = stream;\\r\\n        this._oldRotate = new three__WEBPACK_IMPORTED_MODULE_2__[\\\"Euler\\\"]();\\r\\n    }\\r\\n    TelubeeDomain.prototype.open = function (localStream) {\\r\\n        var _this = this;\\r\\n        this._operator.setStream(localStream);\\r\\n        this._stream.getEvents().on(_Event_TelubeeEventList__WEBPACK_IMPORTED_MODULE_3__[\\\"TelubeeEventList\\\"].STREAM_OPEN, function (mediaStream) {\\r\\n            _this._robot.setStream(mediaStream);\\r\\n            _this._events.emit(_Event_TelubeeEventList__WEBPACK_IMPORTED_MODULE_3__[\\\"TelubeeEventList\\\"].DOMAIN_OPEN);\\r\\n        });\\r\\n        this._stream.getEvents().on(_Event_TelubeeEventList__WEBPACK_IMPORTED_MODULE_3__[\\\"TelubeeEventList\\\"].STREAM_ERROR, function (error) { return _this._events.emit(_Event_TelubeeEventList__WEBPACK_IMPORTED_MODULE_3__[\\\"TelubeeEventList\\\"].STREAM_OPEN, error); });\\r\\n        this._stream.open(this._operator.getID(), this._operator.getStream(), this._robot.getID());\\r\\n    };\\r\\n    TelubeeDomain.prototype.close = function () {\\r\\n        this._events.removeAllListeners();\\r\\n    };\\r\\n    TelubeeDomain.prototype.rotateHead = function (pan, tilt, roll) {\\r\\n        //HMD\\r\\n        var vecX = Math.abs(this._oldRotate.x - tilt);\\r\\n        var vecY = Math.abs(this._oldRotate.y - pan);\\r\\n        var vecZ = Math.abs(this._oldRotate.z - roll);\\r\\n        //\\r\\n        if (vecX + vecY + vecZ < TelubeeDomain.ROTATE_THR) {\\r\\n            return;\\r\\n        }\\r\\n        this._oldRotate.x = tilt;\\r\\n        this._oldRotate.y = pan;\\r\\n        this._oldRotate.z = roll;\\r\\n        //(raddeg*100)\\r\\n        this._stream.send({\\r\\n            HeadPan: Math.floor(pan * TelubeeDomain.CMD_ROTATE_COEF),\\r\\n            HeadTilt: Math.floor(tilt * TelubeeDomain.CMD_ROTATE_COEF),\\r\\n            HeadRoll: Math.floor(roll * TelubeeDomain.CMD_ROTATE_COEF)\\r\\n        });\\r\\n    };\\r\\n    Object.defineProperty(TelubeeDomain.prototype, \\\"operator\\\", {\\r\\n        get: function () {\\r\\n            return this._operator;\\r\\n        },\\r\\n        enumerable: false,\\r\\n        configurable: true\\r\\n    });\\r\\n    Object.defineProperty(TelubeeDomain.prototype, \\\"robot\\\", {\\r\\n        get: function () {\\r\\n            return this._robot;\\r\\n        },\\r\\n        enumerable: false,\\r\\n        configurable: true\\r\\n    });\\r\\n    Object.defineProperty(TelubeeDomain.prototype, \\\"events\\\", {\\r\\n        get: function () {\\r\\n            return this._events;\\r\\n        },\\r\\n        enumerable: false,\\r\\n        configurable: true\\r\\n    });\\r\\n    TelubeeDomain.ROTATE_THR = Math.PI / 90;\\r\\n    TelubeeDomain.CMD_ROTATE_COEF = (180.0 * 100.0) / Math.PI;\\r\\n    TelubeeDomain.OPERATOR_TAG = \\\"_Operator\\\";\\r\\n    TelubeeDomain.ROBOT_TAG = \\\"_Robot\\\";\\r\\n    return TelubeeDomain;\\r\\n}());\\r\\n\\r\\n\\n\\n//# sourceURL=webpack:///./src/operator/DomainService/TelubeeDomain.ts?\");\n\n/***/ }),\n\n/***/ \"./src/operator/Entity/User.ts\":\n/*!*************************************!*\\\n  !*** ./src/operator/Entity/User.ts ***!\n  \\*************************************/\n/*! exports provided: User */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"User\\\", function() { return User; });\\nvar User = /** @class */ (function () {\\r\\n    function User(id) {\\r\\n        this._stream = null;\\r\\n        this._id = id;\\r\\n    }\\r\\n    User.prototype.getID = function () {\\r\\n        return this._id;\\r\\n    };\\r\\n    User.prototype.setStream = function (stream) {\\r\\n        this._stream = stream;\\r\\n    };\\r\\n    User.prototype.getStream = function () {\\r\\n        return this._stream;\\r\\n    };\\r\\n    return User;\\r\\n}());\\r\\n\\r\\n\\n\\n//# sourceURL=webpack:///./src/operator/Entity/User.ts?\");\n\n/***/ }),\n\n/***/ \"./src/operator/Event/TelubeeEventList.ts\":\n/*!************************************************!*\\\n  !*** ./src/operator/Event/TelubeeEventList.ts ***!\n  \\************************************************/\n/*! exports provided: TelubeeEventList */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"TelubeeEventList\\\", function() { return TelubeeEventList; });\\nvar TelubeeEventList = /** @class */ (function () {\\r\\n    function TelubeeEventList() {\\r\\n    }\\r\\n    TelubeeEventList.STREAM_OPEN = \\\"stream-open\\\";\\r\\n    TelubeeEventList.STREAM_CLOSE = \\\"stream-close\\\";\\r\\n    TelubeeEventList.STREAM_ERROR = \\\"stream-error\\\";\\r\\n    TelubeeEventList.DOMAIN_OPEN = \\\"open\\\";\\r\\n    return TelubeeEventList;\\r\\n}());\\r\\n\\r\\n\\n\\n//# sourceURL=webpack:///./src/operator/Event/TelubeeEventList.ts?\");\n\n/***/ }),\n\n/***/ \"./src/operator/Test.ts\":\n/*!******************************!*\\\n  !*** ./src/operator/Test.ts ***!\n  \\******************************/\n/*! no exports provided */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony import */ var _ApplicationService_TelubeeService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ApplicationService/TelubeeService */ \\\"./src/operator/ApplicationService/TelubeeService.ts\\\");\\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! events */ \\\"./node_modules/events/events.js\\\");\\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_1__);\\n/* harmony import */ var chai__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! chai */ \\\"./node_modules/chai/index.js\\\");\\n/* harmony import */ var chai__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(chai__WEBPACK_IMPORTED_MODULE_2__);\\n\\r\\n\\r\\n\\r\\nfunction main() {\\r\\n    var TestSenderStreamAdapter = /** @class */ (function () {\\r\\n        function TestSenderStreamAdapter() {\\r\\n        }\\r\\n        TestSenderStreamAdapter.prototype.getStream = function () {\\r\\n            return null;\\r\\n        };\\r\\n        return TestSenderStreamAdapter;\\r\\n    }());\\r\\n    var TestReceiverStreamAdapter = /** @class */ (function () {\\r\\n        function TestReceiverStreamAdapter() {\\r\\n        }\\r\\n        TestReceiverStreamAdapter.prototype.setStream = function (stream) { };\\r\\n        return TestReceiverStreamAdapter;\\r\\n    }());\\r\\n    var TestStream = /** @class */ (function () {\\r\\n        function TestStream() {\\r\\n        }\\r\\n        TestStream.prototype.open = function (localId, localStream, remoteId) {\\r\\n            Object(chai__WEBPACK_IMPORTED_MODULE_2__[\\\"expect\\\"])(localId).to.equal(\\\"test_Operator\\\");\\r\\n            Object(chai__WEBPACK_IMPORTED_MODULE_2__[\\\"expect\\\"])(remoteId).to.equal(\\\"test_Robot\\\");\\r\\n        };\\r\\n        TestStream.prototype.close = function () {\\r\\n        };\\r\\n        TestStream.prototype.send = function (object) {\\r\\n            Object(chai__WEBPACK_IMPORTED_MODULE_2__[\\\"expect\\\"])(object.HeadTilt).to.equal(18000);\\r\\n            Object(chai__WEBPACK_IMPORTED_MODULE_2__[\\\"expect\\\"])(object.HeadPan).to.equal(36000);\\r\\n            Object(chai__WEBPACK_IMPORTED_MODULE_2__[\\\"expect\\\"])(object.HeadRoll).to.equal(300);\\r\\n        };\\r\\n        TestStream.prototype.getEvents = function () {\\r\\n            return new events__WEBPACK_IMPORTED_MODULE_1__[\\\"EventEmitter\\\"]();\\r\\n        };\\r\\n        return TestStream;\\r\\n    }());\\r\\n    var telubee = new _ApplicationService_TelubeeService__WEBPACK_IMPORTED_MODULE_0__[\\\"TelubeeService\\\"](new TestStream(), \\\"test\\\");\\r\\n    telubee.open(new TestSenderStreamAdapter(), new TestReceiverStreamAdapter());\\r\\n    telubee.rotateHead(0, Math.PI, Math.PI * 2);\\r\\n    telubee.rotateHead(Math.PI / 180, Math.PI, Math.PI * 2);\\r\\n    telubee.rotateHead(0, Math.PI + Math.PI / 180, Math.PI * 2);\\r\\n    telubee.rotateHead(0, Math.PI, Math.PI * 2 + Math.PI / 180);\\r\\n    telubee.close();\\r\\n}\\r\\nmain();\\r\\n\\n\\n//# sourceURL=webpack:///./src/operator/Test.ts?\");\n\n/***/ })\n\n/******/ });\n\n//# sourceURL=webpack:///./docs/test.js?");

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nexports.byteLength = byteLength\r\nexports.toByteArray = toByteArray\r\nexports.fromByteArray = fromByteArray\r\n\r\nvar lookup = []\r\nvar revLookup = []\r\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\r\n\r\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\r\nfor (var i = 0, len = code.length; i < len; ++i) {\r\n  lookup[i] = code[i]\r\n  revLookup[code.charCodeAt(i)] = i\r\n}\r\n\r\n// Support decoding URL-safe base64 strings, as Node.js does.\r\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\r\nrevLookup['-'.charCodeAt(0)] = 62\r\nrevLookup['_'.charCodeAt(0)] = 63\r\n\r\nfunction getLens (b64) {\r\n  var len = b64.length\r\n\r\n  if (len % 4 > 0) {\r\n    throw new Error('Invalid string. Length must be a multiple of 4')\r\n  }\r\n\r\n  // Trim off extra bytes after placeholder bytes are found\r\n  // See: https://github.com/beatgammit/base64-js/issues/42\r\n  var validLen = b64.indexOf('=')\r\n  if (validLen === -1) validLen = len\r\n\r\n  var placeHoldersLen = validLen === len\r\n    ? 0\r\n    : 4 - (validLen % 4)\r\n\r\n  return [validLen, placeHoldersLen]\r\n}\r\n\r\n// base64 is 4/3 + up to two characters of the original data\r\nfunction byteLength (b64) {\r\n  var lens = getLens(b64)\r\n  var validLen = lens[0]\r\n  var placeHoldersLen = lens[1]\r\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\r\n}\r\n\r\nfunction _byteLength (b64, validLen, placeHoldersLen) {\r\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\r\n}\r\n\r\nfunction toByteArray (b64) {\r\n  var tmp\r\n  var lens = getLens(b64)\r\n  var validLen = lens[0]\r\n  var placeHoldersLen = lens[1]\r\n\r\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\r\n\r\n  var curByte = 0\r\n\r\n  // if there are placeholders, only get up to the last complete 4 chars\r\n  var len = placeHoldersLen > 0\r\n    ? validLen - 4\r\n    : validLen\r\n\r\n  var i\r\n  for (i = 0; i < len; i += 4) {\r\n    tmp =\r\n      (revLookup[b64.charCodeAt(i)] << 18) |\r\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\r\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\r\n      revLookup[b64.charCodeAt(i + 3)]\r\n    arr[curByte++] = (tmp >> 16) & 0xFF\r\n    arr[curByte++] = (tmp >> 8) & 0xFF\r\n    arr[curByte++] = tmp & 0xFF\r\n  }\r\n\r\n  if (placeHoldersLen === 2) {\r\n    tmp =\r\n      (revLookup[b64.charCodeAt(i)] << 2) |\r\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\r\n    arr[curByte++] = tmp & 0xFF\r\n  }\r\n\r\n  if (placeHoldersLen === 1) {\r\n    tmp =\r\n      (revLookup[b64.charCodeAt(i)] << 10) |\r\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\r\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\r\n    arr[curByte++] = (tmp >> 8) & 0xFF\r\n    arr[curByte++] = tmp & 0xFF\r\n  }\r\n\r\n  return arr\r\n}\r\n\r\nfunction tripletToBase64 (num) {\r\n  return lookup[num >> 18 & 0x3F] +\r\n    lookup[num >> 12 & 0x3F] +\r\n    lookup[num >> 6 & 0x3F] +\r\n    lookup[num & 0x3F]\r\n}\r\n\r\nfunction encodeChunk (uint8, start, end) {\r\n  var tmp\r\n  var output = []\r\n  for (var i = start; i < end; i += 3) {\r\n    tmp =\r\n      ((uint8[i] << 16) & 0xFF0000) +\r\n      ((uint8[i + 1] << 8) & 0xFF00) +\r\n      (uint8[i + 2] & 0xFF)\r\n    output.push(tripletToBase64(tmp))\r\n  }\r\n  return output.join('')\r\n}\r\n\r\nfunction fromByteArray (uint8) {\r\n  var tmp\r\n  var len = uint8.length\r\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\r\n  var parts = []\r\n  var maxChunkLength = 16383 // must be multiple of 3\r\n\r\n  // go through the array every three bytes, we'll deal with trailing stuff later\r\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\r\n    parts.push(encodeChunk(\r\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\r\n    ))\r\n  }\r\n\r\n  // pad the end with zeros, but make sure to not forget the extra bytes\r\n  if (extraBytes === 1) {\r\n    tmp = uint8[len - 1]\r\n    parts.push(\r\n      lookup[tmp >> 2] +\r\n      lookup[(tmp << 4) & 0x3F] +\r\n      '=='\r\n    )\r\n  } else if (extraBytes === 2) {\r\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\r\n    parts.push(\r\n      lookup[tmp >> 10] +\r\n      lookup[(tmp >> 4) & 0x3F] +\r\n      lookup[(tmp << 2) & 0x3F] +\r\n      '='\r\n    )\r\n  }\r\n\r\n  return parts.join('')\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/base64-js/index.js?");

/***/ }),

/***/ "./node_modules/browser-stdout/index.js":
/*!**********************************************!*\
  !*** ./node_modules/browser-stdout/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {var WritableStream = __webpack_require__(/*! stream */ \"./node_modules/stream-browserify/index.js\").Writable\r\nvar inherits = __webpack_require__(/*! util */ \"./node_modules/util/util.js\").inherits\r\n\r\nmodule.exports = BrowserStdout\r\n\r\n\r\ninherits(BrowserStdout, WritableStream)\r\n\r\nfunction BrowserStdout(opts) {\r\n  if (!(this instanceof BrowserStdout)) return new BrowserStdout(opts)\r\n\r\n  opts = opts || {}\r\n  WritableStream.call(this, opts)\r\n  this.label = (opts.label !== undefined) ? opts.label : 'stdout'\r\n}\r\n\r\nBrowserStdout.prototype._write = function(chunks, encoding, cb) {\r\n  var output = chunks.toString ? chunks.toString() : chunks\r\n  if (this.label === false) {\r\n    console.log(output)\r\n  } else {\r\n    console.log(this.label+':', output)\r\n  }\r\n  process.nextTick(cb)\r\n}\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/browser-stdout/index.js?");

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\r\n * The buffer module from node.js, for the browser.\r\n *\r\n * @author   Feross Aboukhadijeh <http://feross.org>\r\n * @license  MIT\r\n */\r\n/* eslint-disable no-proto */\r\n\r\n\r\n\r\nvar base64 = __webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\")\r\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\")\r\nvar isArray = __webpack_require__(/*! isarray */ \"./node_modules/isarray/index.js\")\r\n\r\nexports.Buffer = Buffer\r\nexports.SlowBuffer = SlowBuffer\r\nexports.INSPECT_MAX_BYTES = 50\r\n\r\n/**\r\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\r\n *   === true    Use Uint8Array implementation (fastest)\r\n *   === false   Use Object implementation (most compatible, even IE6)\r\n *\r\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\r\n * Opera 11.6+, iOS 4.2+.\r\n *\r\n * Due to various browser bugs, sometimes the Object implementation will be used even\r\n * when the browser supports typed arrays.\r\n *\r\n * Note:\r\n *\r\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\r\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\r\n *\r\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\r\n *\r\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\r\n *     incorrect length in some situations.\r\n\r\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\r\n * get the Object implementation, which is slower but behaves correctly.\r\n */\r\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\r\n  ? global.TYPED_ARRAY_SUPPORT\r\n  : typedArraySupport()\r\n\r\n/*\r\n * Export kMaxLength after typed array support is determined.\r\n */\r\nexports.kMaxLength = kMaxLength()\r\n\r\nfunction typedArraySupport () {\r\n  try {\r\n    var arr = new Uint8Array(1)\r\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\r\n    return arr.foo() === 42 && // typed array instances can be augmented\r\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\r\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\r\n  } catch (e) {\r\n    return false\r\n  }\r\n}\r\n\r\nfunction kMaxLength () {\r\n  return Buffer.TYPED_ARRAY_SUPPORT\r\n    ? 0x7fffffff\r\n    : 0x3fffffff\r\n}\r\n\r\nfunction createBuffer (that, length) {\r\n  if (kMaxLength() < length) {\r\n    throw new RangeError('Invalid typed array length')\r\n  }\r\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\r\n    // Return an augmented `Uint8Array` instance, for best performance\r\n    that = new Uint8Array(length)\r\n    that.__proto__ = Buffer.prototype\r\n  } else {\r\n    // Fallback: Return an object instance of the Buffer class\r\n    if (that === null) {\r\n      that = new Buffer(length)\r\n    }\r\n    that.length = length\r\n  }\r\n\r\n  return that\r\n}\r\n\r\n/**\r\n * The Buffer constructor returns instances of `Uint8Array` that have their\r\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\r\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\r\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\r\n * returns a single octet.\r\n *\r\n * The `Uint8Array` prototype remains unmodified.\r\n */\r\n\r\nfunction Buffer (arg, encodingOrOffset, length) {\r\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\r\n    return new Buffer(arg, encodingOrOffset, length)\r\n  }\r\n\r\n  // Common case.\r\n  if (typeof arg === 'number') {\r\n    if (typeof encodingOrOffset === 'string') {\r\n      throw new Error(\r\n        'If encoding is specified then the first argument must be a string'\r\n      )\r\n    }\r\n    return allocUnsafe(this, arg)\r\n  }\r\n  return from(this, arg, encodingOrOffset, length)\r\n}\r\n\r\nBuffer.poolSize = 8192 // not used by this implementation\r\n\r\n// TODO: Legacy, not needed anymore. Remove in next major version.\r\nBuffer._augment = function (arr) {\r\n  arr.__proto__ = Buffer.prototype\r\n  return arr\r\n}\r\n\r\nfunction from (that, value, encodingOrOffset, length) {\r\n  if (typeof value === 'number') {\r\n    throw new TypeError('\"value\" argument must not be a number')\r\n  }\r\n\r\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\r\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\r\n  }\r\n\r\n  if (typeof value === 'string') {\r\n    return fromString(that, value, encodingOrOffset)\r\n  }\r\n\r\n  return fromObject(that, value)\r\n}\r\n\r\n/**\r\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\r\n * if value is a number.\r\n * Buffer.from(str[, encoding])\r\n * Buffer.from(array)\r\n * Buffer.from(buffer)\r\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\r\n **/\r\nBuffer.from = function (value, encodingOrOffset, length) {\r\n  return from(null, value, encodingOrOffset, length)\r\n}\r\n\r\nif (Buffer.TYPED_ARRAY_SUPPORT) {\r\n  Buffer.prototype.__proto__ = Uint8Array.prototype\r\n  Buffer.__proto__ = Uint8Array\r\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\r\n      Buffer[Symbol.species] === Buffer) {\r\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\r\n    Object.defineProperty(Buffer, Symbol.species, {\r\n      value: null,\r\n      configurable: true\r\n    })\r\n  }\r\n}\r\n\r\nfunction assertSize (size) {\r\n  if (typeof size !== 'number') {\r\n    throw new TypeError('\"size\" argument must be a number')\r\n  } else if (size < 0) {\r\n    throw new RangeError('\"size\" argument must not be negative')\r\n  }\r\n}\r\n\r\nfunction alloc (that, size, fill, encoding) {\r\n  assertSize(size)\r\n  if (size <= 0) {\r\n    return createBuffer(that, size)\r\n  }\r\n  if (fill !== undefined) {\r\n    // Only pay attention to encoding if it's a string. This\r\n    // prevents accidentally sending in a number that would\r\n    // be interpretted as a start offset.\r\n    return typeof encoding === 'string'\r\n      ? createBuffer(that, size).fill(fill, encoding)\r\n      : createBuffer(that, size).fill(fill)\r\n  }\r\n  return createBuffer(that, size)\r\n}\r\n\r\n/**\r\n * Creates a new filled Buffer instance.\r\n * alloc(size[, fill[, encoding]])\r\n **/\r\nBuffer.alloc = function (size, fill, encoding) {\r\n  return alloc(null, size, fill, encoding)\r\n}\r\n\r\nfunction allocUnsafe (that, size) {\r\n  assertSize(size)\r\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\r\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\r\n    for (var i = 0; i < size; ++i) {\r\n      that[i] = 0\r\n    }\r\n  }\r\n  return that\r\n}\r\n\r\n/**\r\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\r\n * */\r\nBuffer.allocUnsafe = function (size) {\r\n  return allocUnsafe(null, size)\r\n}\r\n/**\r\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\r\n */\r\nBuffer.allocUnsafeSlow = function (size) {\r\n  return allocUnsafe(null, size)\r\n}\r\n\r\nfunction fromString (that, string, encoding) {\r\n  if (typeof encoding !== 'string' || encoding === '') {\r\n    encoding = 'utf8'\r\n  }\r\n\r\n  if (!Buffer.isEncoding(encoding)) {\r\n    throw new TypeError('\"encoding\" must be a valid string encoding')\r\n  }\r\n\r\n  var length = byteLength(string, encoding) | 0\r\n  that = createBuffer(that, length)\r\n\r\n  var actual = that.write(string, encoding)\r\n\r\n  if (actual !== length) {\r\n    // Writing a hex string, for example, that contains invalid characters will\r\n    // cause everything after the first invalid character to be ignored. (e.g.\r\n    // 'abxxcd' will be treated as 'ab')\r\n    that = that.slice(0, actual)\r\n  }\r\n\r\n  return that\r\n}\r\n\r\nfunction fromArrayLike (that, array) {\r\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\r\n  that = createBuffer(that, length)\r\n  for (var i = 0; i < length; i += 1) {\r\n    that[i] = array[i] & 255\r\n  }\r\n  return that\r\n}\r\n\r\nfunction fromArrayBuffer (that, array, byteOffset, length) {\r\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\r\n\r\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\r\n    throw new RangeError('\\'offset\\' is out of bounds')\r\n  }\r\n\r\n  if (array.byteLength < byteOffset + (length || 0)) {\r\n    throw new RangeError('\\'length\\' is out of bounds')\r\n  }\r\n\r\n  if (byteOffset === undefined && length === undefined) {\r\n    array = new Uint8Array(array)\r\n  } else if (length === undefined) {\r\n    array = new Uint8Array(array, byteOffset)\r\n  } else {\r\n    array = new Uint8Array(array, byteOffset, length)\r\n  }\r\n\r\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\r\n    // Return an augmented `Uint8Array` instance, for best performance\r\n    that = array\r\n    that.__proto__ = Buffer.prototype\r\n  } else {\r\n    // Fallback: Return an object instance of the Buffer class\r\n    that = fromArrayLike(that, array)\r\n  }\r\n  return that\r\n}\r\n\r\nfunction fromObject (that, obj) {\r\n  if (Buffer.isBuffer(obj)) {\r\n    var len = checked(obj.length) | 0\r\n    that = createBuffer(that, len)\r\n\r\n    if (that.length === 0) {\r\n      return that\r\n    }\r\n\r\n    obj.copy(that, 0, 0, len)\r\n    return that\r\n  }\r\n\r\n  if (obj) {\r\n    if ((typeof ArrayBuffer !== 'undefined' &&\r\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\r\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\r\n        return createBuffer(that, 0)\r\n      }\r\n      return fromArrayLike(that, obj)\r\n    }\r\n\r\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\r\n      return fromArrayLike(that, obj.data)\r\n    }\r\n  }\r\n\r\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\r\n}\r\n\r\nfunction checked (length) {\r\n  // Note: cannot use `length < kMaxLength()` here because that fails when\r\n  // length is NaN (which is otherwise coerced to zero.)\r\n  if (length >= kMaxLength()) {\r\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\r\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\r\n  }\r\n  return length | 0\r\n}\r\n\r\nfunction SlowBuffer (length) {\r\n  if (+length != length) { // eslint-disable-line eqeqeq\r\n    length = 0\r\n  }\r\n  return Buffer.alloc(+length)\r\n}\r\n\r\nBuffer.isBuffer = function isBuffer (b) {\r\n  return !!(b != null && b._isBuffer)\r\n}\r\n\r\nBuffer.compare = function compare (a, b) {\r\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\r\n    throw new TypeError('Arguments must be Buffers')\r\n  }\r\n\r\n  if (a === b) return 0\r\n\r\n  var x = a.length\r\n  var y = b.length\r\n\r\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\r\n    if (a[i] !== b[i]) {\r\n      x = a[i]\r\n      y = b[i]\r\n      break\r\n    }\r\n  }\r\n\r\n  if (x < y) return -1\r\n  if (y < x) return 1\r\n  return 0\r\n}\r\n\r\nBuffer.isEncoding = function isEncoding (encoding) {\r\n  switch (String(encoding).toLowerCase()) {\r\n    case 'hex':\r\n    case 'utf8':\r\n    case 'utf-8':\r\n    case 'ascii':\r\n    case 'latin1':\r\n    case 'binary':\r\n    case 'base64':\r\n    case 'ucs2':\r\n    case 'ucs-2':\r\n    case 'utf16le':\r\n    case 'utf-16le':\r\n      return true\r\n    default:\r\n      return false\r\n  }\r\n}\r\n\r\nBuffer.concat = function concat (list, length) {\r\n  if (!isArray(list)) {\r\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\r\n  }\r\n\r\n  if (list.length === 0) {\r\n    return Buffer.alloc(0)\r\n  }\r\n\r\n  var i\r\n  if (length === undefined) {\r\n    length = 0\r\n    for (i = 0; i < list.length; ++i) {\r\n      length += list[i].length\r\n    }\r\n  }\r\n\r\n  var buffer = Buffer.allocUnsafe(length)\r\n  var pos = 0\r\n  for (i = 0; i < list.length; ++i) {\r\n    var buf = list[i]\r\n    if (!Buffer.isBuffer(buf)) {\r\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\r\n    }\r\n    buf.copy(buffer, pos)\r\n    pos += buf.length\r\n  }\r\n  return buffer\r\n}\r\n\r\nfunction byteLength (string, encoding) {\r\n  if (Buffer.isBuffer(string)) {\r\n    return string.length\r\n  }\r\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\r\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\r\n    return string.byteLength\r\n  }\r\n  if (typeof string !== 'string') {\r\n    string = '' + string\r\n  }\r\n\r\n  var len = string.length\r\n  if (len === 0) return 0\r\n\r\n  // Use a for loop to avoid recursion\r\n  var loweredCase = false\r\n  for (;;) {\r\n    switch (encoding) {\r\n      case 'ascii':\r\n      case 'latin1':\r\n      case 'binary':\r\n        return len\r\n      case 'utf8':\r\n      case 'utf-8':\r\n      case undefined:\r\n        return utf8ToBytes(string).length\r\n      case 'ucs2':\r\n      case 'ucs-2':\r\n      case 'utf16le':\r\n      case 'utf-16le':\r\n        return len * 2\r\n      case 'hex':\r\n        return len >>> 1\r\n      case 'base64':\r\n        return base64ToBytes(string).length\r\n      default:\r\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\r\n        encoding = ('' + encoding).toLowerCase()\r\n        loweredCase = true\r\n    }\r\n  }\r\n}\r\nBuffer.byteLength = byteLength\r\n\r\nfunction slowToString (encoding, start, end) {\r\n  var loweredCase = false\r\n\r\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\r\n  // property of a typed array.\r\n\r\n  // This behaves neither like String nor Uint8Array in that we set start/end\r\n  // to their upper/lower bounds if the value passed is out of range.\r\n  // undefined is handled specially as per ECMA-262 6th Edition,\r\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\r\n  if (start === undefined || start < 0) {\r\n    start = 0\r\n  }\r\n  // Return early if start > this.length. Done here to prevent potential uint32\r\n  // coercion fail below.\r\n  if (start > this.length) {\r\n    return ''\r\n  }\r\n\r\n  if (end === undefined || end > this.length) {\r\n    end = this.length\r\n  }\r\n\r\n  if (end <= 0) {\r\n    return ''\r\n  }\r\n\r\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\r\n  end >>>= 0\r\n  start >>>= 0\r\n\r\n  if (end <= start) {\r\n    return ''\r\n  }\r\n\r\n  if (!encoding) encoding = 'utf8'\r\n\r\n  while (true) {\r\n    switch (encoding) {\r\n      case 'hex':\r\n        return hexSlice(this, start, end)\r\n\r\n      case 'utf8':\r\n      case 'utf-8':\r\n        return utf8Slice(this, start, end)\r\n\r\n      case 'ascii':\r\n        return asciiSlice(this, start, end)\r\n\r\n      case 'latin1':\r\n      case 'binary':\r\n        return latin1Slice(this, start, end)\r\n\r\n      case 'base64':\r\n        return base64Slice(this, start, end)\r\n\r\n      case 'ucs2':\r\n      case 'ucs-2':\r\n      case 'utf16le':\r\n      case 'utf-16le':\r\n        return utf16leSlice(this, start, end)\r\n\r\n      default:\r\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\r\n        encoding = (encoding + '').toLowerCase()\r\n        loweredCase = true\r\n    }\r\n  }\r\n}\r\n\r\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\r\n// Buffer instances.\r\nBuffer.prototype._isBuffer = true\r\n\r\nfunction swap (b, n, m) {\r\n  var i = b[n]\r\n  b[n] = b[m]\r\n  b[m] = i\r\n}\r\n\r\nBuffer.prototype.swap16 = function swap16 () {\r\n  var len = this.length\r\n  if (len % 2 !== 0) {\r\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\r\n  }\r\n  for (var i = 0; i < len; i += 2) {\r\n    swap(this, i, i + 1)\r\n  }\r\n  return this\r\n}\r\n\r\nBuffer.prototype.swap32 = function swap32 () {\r\n  var len = this.length\r\n  if (len % 4 !== 0) {\r\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\r\n  }\r\n  for (var i = 0; i < len; i += 4) {\r\n    swap(this, i, i + 3)\r\n    swap(this, i + 1, i + 2)\r\n  }\r\n  return this\r\n}\r\n\r\nBuffer.prototype.swap64 = function swap64 () {\r\n  var len = this.length\r\n  if (len % 8 !== 0) {\r\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\r\n  }\r\n  for (var i = 0; i < len; i += 8) {\r\n    swap(this, i, i + 7)\r\n    swap(this, i + 1, i + 6)\r\n    swap(this, i + 2, i + 5)\r\n    swap(this, i + 3, i + 4)\r\n  }\r\n  return this\r\n}\r\n\r\nBuffer.prototype.toString = function toString () {\r\n  var length = this.length | 0\r\n  if (length === 0) return ''\r\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\r\n  return slowToString.apply(this, arguments)\r\n}\r\n\r\nBuffer.prototype.equals = function equals (b) {\r\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\r\n  if (this === b) return true\r\n  return Buffer.compare(this, b) === 0\r\n}\r\n\r\nBuffer.prototype.inspect = function inspect () {\r\n  var str = ''\r\n  var max = exports.INSPECT_MAX_BYTES\r\n  if (this.length > 0) {\r\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\r\n    if (this.length > max) str += ' ... '\r\n  }\r\n  return '<Buffer ' + str + '>'\r\n}\r\n\r\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\r\n  if (!Buffer.isBuffer(target)) {\r\n    throw new TypeError('Argument must be a Buffer')\r\n  }\r\n\r\n  if (start === undefined) {\r\n    start = 0\r\n  }\r\n  if (end === undefined) {\r\n    end = target ? target.length : 0\r\n  }\r\n  if (thisStart === undefined) {\r\n    thisStart = 0\r\n  }\r\n  if (thisEnd === undefined) {\r\n    thisEnd = this.length\r\n  }\r\n\r\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\r\n    throw new RangeError('out of range index')\r\n  }\r\n\r\n  if (thisStart >= thisEnd && start >= end) {\r\n    return 0\r\n  }\r\n  if (thisStart >= thisEnd) {\r\n    return -1\r\n  }\r\n  if (start >= end) {\r\n    return 1\r\n  }\r\n\r\n  start >>>= 0\r\n  end >>>= 0\r\n  thisStart >>>= 0\r\n  thisEnd >>>= 0\r\n\r\n  if (this === target) return 0\r\n\r\n  var x = thisEnd - thisStart\r\n  var y = end - start\r\n  var len = Math.min(x, y)\r\n\r\n  var thisCopy = this.slice(thisStart, thisEnd)\r\n  var targetCopy = target.slice(start, end)\r\n\r\n  for (var i = 0; i < len; ++i) {\r\n    if (thisCopy[i] !== targetCopy[i]) {\r\n      x = thisCopy[i]\r\n      y = targetCopy[i]\r\n      break\r\n    }\r\n  }\r\n\r\n  if (x < y) return -1\r\n  if (y < x) return 1\r\n  return 0\r\n}\r\n\r\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\r\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\r\n//\r\n// Arguments:\r\n// - buffer - a Buffer to search\r\n// - val - a string, Buffer, or number\r\n// - byteOffset - an index into `buffer`; will be clamped to an int32\r\n// - encoding - an optional encoding, relevant is val is a string\r\n// - dir - true for indexOf, false for lastIndexOf\r\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\r\n  // Empty buffer means no match\r\n  if (buffer.length === 0) return -1\r\n\r\n  // Normalize byteOffset\r\n  if (typeof byteOffset === 'string') {\r\n    encoding = byteOffset\r\n    byteOffset = 0\r\n  } else if (byteOffset > 0x7fffffff) {\r\n    byteOffset = 0x7fffffff\r\n  } else if (byteOffset < -0x80000000) {\r\n    byteOffset = -0x80000000\r\n  }\r\n  byteOffset = +byteOffset  // Coerce to Number.\r\n  if (isNaN(byteOffset)) {\r\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\r\n    byteOffset = dir ? 0 : (buffer.length - 1)\r\n  }\r\n\r\n  // Normalize byteOffset: negative offsets start from the end of the buffer\r\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\r\n  if (byteOffset >= buffer.length) {\r\n    if (dir) return -1\r\n    else byteOffset = buffer.length - 1\r\n  } else if (byteOffset < 0) {\r\n    if (dir) byteOffset = 0\r\n    else return -1\r\n  }\r\n\r\n  // Normalize val\r\n  if (typeof val === 'string') {\r\n    val = Buffer.from(val, encoding)\r\n  }\r\n\r\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\r\n  if (Buffer.isBuffer(val)) {\r\n    // Special case: looking for empty string/buffer always fails\r\n    if (val.length === 0) {\r\n      return -1\r\n    }\r\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\r\n  } else if (typeof val === 'number') {\r\n    val = val & 0xFF // Search for a byte value [0-255]\r\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\r\n        typeof Uint8Array.prototype.indexOf === 'function') {\r\n      if (dir) {\r\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\r\n      } else {\r\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\r\n      }\r\n    }\r\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\r\n  }\r\n\r\n  throw new TypeError('val must be string, number or Buffer')\r\n}\r\n\r\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\r\n  var indexSize = 1\r\n  var arrLength = arr.length\r\n  var valLength = val.length\r\n\r\n  if (encoding !== undefined) {\r\n    encoding = String(encoding).toLowerCase()\r\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\r\n        encoding === 'utf16le' || encoding === 'utf-16le') {\r\n      if (arr.length < 2 || val.length < 2) {\r\n        return -1\r\n      }\r\n      indexSize = 2\r\n      arrLength /= 2\r\n      valLength /= 2\r\n      byteOffset /= 2\r\n    }\r\n  }\r\n\r\n  function read (buf, i) {\r\n    if (indexSize === 1) {\r\n      return buf[i]\r\n    } else {\r\n      return buf.readUInt16BE(i * indexSize)\r\n    }\r\n  }\r\n\r\n  var i\r\n  if (dir) {\r\n    var foundIndex = -1\r\n    for (i = byteOffset; i < arrLength; i++) {\r\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\r\n        if (foundIndex === -1) foundIndex = i\r\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\r\n      } else {\r\n        if (foundIndex !== -1) i -= i - foundIndex\r\n        foundIndex = -1\r\n      }\r\n    }\r\n  } else {\r\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\r\n    for (i = byteOffset; i >= 0; i--) {\r\n      var found = true\r\n      for (var j = 0; j < valLength; j++) {\r\n        if (read(arr, i + j) !== read(val, j)) {\r\n          found = false\r\n          break\r\n        }\r\n      }\r\n      if (found) return i\r\n    }\r\n  }\r\n\r\n  return -1\r\n}\r\n\r\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\r\n  return this.indexOf(val, byteOffset, encoding) !== -1\r\n}\r\n\r\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\r\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\r\n}\r\n\r\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\r\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\r\n}\r\n\r\nfunction hexWrite (buf, string, offset, length) {\r\n  offset = Number(offset) || 0\r\n  var remaining = buf.length - offset\r\n  if (!length) {\r\n    length = remaining\r\n  } else {\r\n    length = Number(length)\r\n    if (length > remaining) {\r\n      length = remaining\r\n    }\r\n  }\r\n\r\n  // must be an even number of digits\r\n  var strLen = string.length\r\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\r\n\r\n  if (length > strLen / 2) {\r\n    length = strLen / 2\r\n  }\r\n  for (var i = 0; i < length; ++i) {\r\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\r\n    if (isNaN(parsed)) return i\r\n    buf[offset + i] = parsed\r\n  }\r\n  return i\r\n}\r\n\r\nfunction utf8Write (buf, string, offset, length) {\r\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\r\n}\r\n\r\nfunction asciiWrite (buf, string, offset, length) {\r\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\r\n}\r\n\r\nfunction latin1Write (buf, string, offset, length) {\r\n  return asciiWrite(buf, string, offset, length)\r\n}\r\n\r\nfunction base64Write (buf, string, offset, length) {\r\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\r\n}\r\n\r\nfunction ucs2Write (buf, string, offset, length) {\r\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\r\n}\r\n\r\nBuffer.prototype.write = function write (string, offset, length, encoding) {\r\n  // Buffer#write(string)\r\n  if (offset === undefined) {\r\n    encoding = 'utf8'\r\n    length = this.length\r\n    offset = 0\r\n  // Buffer#write(string, encoding)\r\n  } else if (length === undefined && typeof offset === 'string') {\r\n    encoding = offset\r\n    length = this.length\r\n    offset = 0\r\n  // Buffer#write(string, offset[, length][, encoding])\r\n  } else if (isFinite(offset)) {\r\n    offset = offset | 0\r\n    if (isFinite(length)) {\r\n      length = length | 0\r\n      if (encoding === undefined) encoding = 'utf8'\r\n    } else {\r\n      encoding = length\r\n      length = undefined\r\n    }\r\n  // legacy write(string, encoding, offset, length) - remove in v0.13\r\n  } else {\r\n    throw new Error(\r\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\r\n    )\r\n  }\r\n\r\n  var remaining = this.length - offset\r\n  if (length === undefined || length > remaining) length = remaining\r\n\r\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\r\n    throw new RangeError('Attempt to write outside buffer bounds')\r\n  }\r\n\r\n  if (!encoding) encoding = 'utf8'\r\n\r\n  var loweredCase = false\r\n  for (;;) {\r\n    switch (encoding) {\r\n      case 'hex':\r\n        return hexWrite(this, string, offset, length)\r\n\r\n      case 'utf8':\r\n      case 'utf-8':\r\n        return utf8Write(this, string, offset, length)\r\n\r\n      case 'ascii':\r\n        return asciiWrite(this, string, offset, length)\r\n\r\n      case 'latin1':\r\n      case 'binary':\r\n        return latin1Write(this, string, offset, length)\r\n\r\n      case 'base64':\r\n        // Warning: maxLength not taken into account in base64Write\r\n        return base64Write(this, string, offset, length)\r\n\r\n      case 'ucs2':\r\n      case 'ucs-2':\r\n      case 'utf16le':\r\n      case 'utf-16le':\r\n        return ucs2Write(this, string, offset, length)\r\n\r\n      default:\r\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\r\n        encoding = ('' + encoding).toLowerCase()\r\n        loweredCase = true\r\n    }\r\n  }\r\n}\r\n\r\nBuffer.prototype.toJSON = function toJSON () {\r\n  return {\r\n    type: 'Buffer',\r\n    data: Array.prototype.slice.call(this._arr || this, 0)\r\n  }\r\n}\r\n\r\nfunction base64Slice (buf, start, end) {\r\n  if (start === 0 && end === buf.length) {\r\n    return base64.fromByteArray(buf)\r\n  } else {\r\n    return base64.fromByteArray(buf.slice(start, end))\r\n  }\r\n}\r\n\r\nfunction utf8Slice (buf, start, end) {\r\n  end = Math.min(buf.length, end)\r\n  var res = []\r\n\r\n  var i = start\r\n  while (i < end) {\r\n    var firstByte = buf[i]\r\n    var codePoint = null\r\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\r\n      : (firstByte > 0xDF) ? 3\r\n      : (firstByte > 0xBF) ? 2\r\n      : 1\r\n\r\n    if (i + bytesPerSequence <= end) {\r\n      var secondByte, thirdByte, fourthByte, tempCodePoint\r\n\r\n      switch (bytesPerSequence) {\r\n        case 1:\r\n          if (firstByte < 0x80) {\r\n            codePoint = firstByte\r\n          }\r\n          break\r\n        case 2:\r\n          secondByte = buf[i + 1]\r\n          if ((secondByte & 0xC0) === 0x80) {\r\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\r\n            if (tempCodePoint > 0x7F) {\r\n              codePoint = tempCodePoint\r\n            }\r\n          }\r\n          break\r\n        case 3:\r\n          secondByte = buf[i + 1]\r\n          thirdByte = buf[i + 2]\r\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\r\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\r\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\r\n              codePoint = tempCodePoint\r\n            }\r\n          }\r\n          break\r\n        case 4:\r\n          secondByte = buf[i + 1]\r\n          thirdByte = buf[i + 2]\r\n          fourthByte = buf[i + 3]\r\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\r\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\r\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\r\n              codePoint = tempCodePoint\r\n            }\r\n          }\r\n      }\r\n    }\r\n\r\n    if (codePoint === null) {\r\n      // we did not generate a valid codePoint so insert a\r\n      // replacement char (U+FFFD) and advance only 1 byte\r\n      codePoint = 0xFFFD\r\n      bytesPerSequence = 1\r\n    } else if (codePoint > 0xFFFF) {\r\n      // encode to utf16 (surrogate pair dance)\r\n      codePoint -= 0x10000\r\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\r\n      codePoint = 0xDC00 | codePoint & 0x3FF\r\n    }\r\n\r\n    res.push(codePoint)\r\n    i += bytesPerSequence\r\n  }\r\n\r\n  return decodeCodePointsArray(res)\r\n}\r\n\r\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\r\n// the lowest limit is Chrome, with 0x10000 args.\r\n// We go 1 magnitude less, for safety\r\nvar MAX_ARGUMENTS_LENGTH = 0x1000\r\n\r\nfunction decodeCodePointsArray (codePoints) {\r\n  var len = codePoints.length\r\n  if (len <= MAX_ARGUMENTS_LENGTH) {\r\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\r\n  }\r\n\r\n  // Decode in chunks to avoid \"call stack size exceeded\".\r\n  var res = ''\r\n  var i = 0\r\n  while (i < len) {\r\n    res += String.fromCharCode.apply(\r\n      String,\r\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\r\n    )\r\n  }\r\n  return res\r\n}\r\n\r\nfunction asciiSlice (buf, start, end) {\r\n  var ret = ''\r\n  end = Math.min(buf.length, end)\r\n\r\n  for (var i = start; i < end; ++i) {\r\n    ret += String.fromCharCode(buf[i] & 0x7F)\r\n  }\r\n  return ret\r\n}\r\n\r\nfunction latin1Slice (buf, start, end) {\r\n  var ret = ''\r\n  end = Math.min(buf.length, end)\r\n\r\n  for (var i = start; i < end; ++i) {\r\n    ret += String.fromCharCode(buf[i])\r\n  }\r\n  return ret\r\n}\r\n\r\nfunction hexSlice (buf, start, end) {\r\n  var len = buf.length\r\n\r\n  if (!start || start < 0) start = 0\r\n  if (!end || end < 0 || end > len) end = len\r\n\r\n  var out = ''\r\n  for (var i = start; i < end; ++i) {\r\n    out += toHex(buf[i])\r\n  }\r\n  return out\r\n}\r\n\r\nfunction utf16leSlice (buf, start, end) {\r\n  var bytes = buf.slice(start, end)\r\n  var res = ''\r\n  for (var i = 0; i < bytes.length; i += 2) {\r\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\r\n  }\r\n  return res\r\n}\r\n\r\nBuffer.prototype.slice = function slice (start, end) {\r\n  var len = this.length\r\n  start = ~~start\r\n  end = end === undefined ? len : ~~end\r\n\r\n  if (start < 0) {\r\n    start += len\r\n    if (start < 0) start = 0\r\n  } else if (start > len) {\r\n    start = len\r\n  }\r\n\r\n  if (end < 0) {\r\n    end += len\r\n    if (end < 0) end = 0\r\n  } else if (end > len) {\r\n    end = len\r\n  }\r\n\r\n  if (end < start) end = start\r\n\r\n  var newBuf\r\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\r\n    newBuf = this.subarray(start, end)\r\n    newBuf.__proto__ = Buffer.prototype\r\n  } else {\r\n    var sliceLen = end - start\r\n    newBuf = new Buffer(sliceLen, undefined)\r\n    for (var i = 0; i < sliceLen; ++i) {\r\n      newBuf[i] = this[i + start]\r\n    }\r\n  }\r\n\r\n  return newBuf\r\n}\r\n\r\n/*\r\n * Need to make sure that buffer isn't trying to write out of bounds.\r\n */\r\nfunction checkOffset (offset, ext, length) {\r\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\r\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\r\n}\r\n\r\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\r\n  offset = offset | 0\r\n  byteLength = byteLength | 0\r\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\r\n\r\n  var val = this[offset]\r\n  var mul = 1\r\n  var i = 0\r\n  while (++i < byteLength && (mul *= 0x100)) {\r\n    val += this[offset + i] * mul\r\n  }\r\n\r\n  return val\r\n}\r\n\r\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\r\n  offset = offset | 0\r\n  byteLength = byteLength | 0\r\n  if (!noAssert) {\r\n    checkOffset(offset, byteLength, this.length)\r\n  }\r\n\r\n  var val = this[offset + --byteLength]\r\n  var mul = 1\r\n  while (byteLength > 0 && (mul *= 0x100)) {\r\n    val += this[offset + --byteLength] * mul\r\n  }\r\n\r\n  return val\r\n}\r\n\r\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 1, this.length)\r\n  return this[offset]\r\n}\r\n\r\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 2, this.length)\r\n  return this[offset] | (this[offset + 1] << 8)\r\n}\r\n\r\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 2, this.length)\r\n  return (this[offset] << 8) | this[offset + 1]\r\n}\r\n\r\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 4, this.length)\r\n\r\n  return ((this[offset]) |\r\n      (this[offset + 1] << 8) |\r\n      (this[offset + 2] << 16)) +\r\n      (this[offset + 3] * 0x1000000)\r\n}\r\n\r\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 4, this.length)\r\n\r\n  return (this[offset] * 0x1000000) +\r\n    ((this[offset + 1] << 16) |\r\n    (this[offset + 2] << 8) |\r\n    this[offset + 3])\r\n}\r\n\r\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\r\n  offset = offset | 0\r\n  byteLength = byteLength | 0\r\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\r\n\r\n  var val = this[offset]\r\n  var mul = 1\r\n  var i = 0\r\n  while (++i < byteLength && (mul *= 0x100)) {\r\n    val += this[offset + i] * mul\r\n  }\r\n  mul *= 0x80\r\n\r\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\r\n\r\n  return val\r\n}\r\n\r\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\r\n  offset = offset | 0\r\n  byteLength = byteLength | 0\r\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\r\n\r\n  var i = byteLength\r\n  var mul = 1\r\n  var val = this[offset + --i]\r\n  while (i > 0 && (mul *= 0x100)) {\r\n    val += this[offset + --i] * mul\r\n  }\r\n  mul *= 0x80\r\n\r\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\r\n\r\n  return val\r\n}\r\n\r\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 1, this.length)\r\n  if (!(this[offset] & 0x80)) return (this[offset])\r\n  return ((0xff - this[offset] + 1) * -1)\r\n}\r\n\r\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 2, this.length)\r\n  var val = this[offset] | (this[offset + 1] << 8)\r\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\r\n}\r\n\r\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 2, this.length)\r\n  var val = this[offset + 1] | (this[offset] << 8)\r\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\r\n}\r\n\r\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 4, this.length)\r\n\r\n  return (this[offset]) |\r\n    (this[offset + 1] << 8) |\r\n    (this[offset + 2] << 16) |\r\n    (this[offset + 3] << 24)\r\n}\r\n\r\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 4, this.length)\r\n\r\n  return (this[offset] << 24) |\r\n    (this[offset + 1] << 16) |\r\n    (this[offset + 2] << 8) |\r\n    (this[offset + 3])\r\n}\r\n\r\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 4, this.length)\r\n  return ieee754.read(this, offset, true, 23, 4)\r\n}\r\n\r\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 4, this.length)\r\n  return ieee754.read(this, offset, false, 23, 4)\r\n}\r\n\r\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 8, this.length)\r\n  return ieee754.read(this, offset, true, 52, 8)\r\n}\r\n\r\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 8, this.length)\r\n  return ieee754.read(this, offset, false, 52, 8)\r\n}\r\n\r\nfunction checkInt (buf, value, offset, ext, max, min) {\r\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\r\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\r\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\r\n}\r\n\r\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  byteLength = byteLength | 0\r\n  if (!noAssert) {\r\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\r\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\r\n  }\r\n\r\n  var mul = 1\r\n  var i = 0\r\n  this[offset] = value & 0xFF\r\n  while (++i < byteLength && (mul *= 0x100)) {\r\n    this[offset + i] = (value / mul) & 0xFF\r\n  }\r\n\r\n  return offset + byteLength\r\n}\r\n\r\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  byteLength = byteLength | 0\r\n  if (!noAssert) {\r\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\r\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\r\n  }\r\n\r\n  var i = byteLength - 1\r\n  var mul = 1\r\n  this[offset + i] = value & 0xFF\r\n  while (--i >= 0 && (mul *= 0x100)) {\r\n    this[offset + i] = (value / mul) & 0xFF\r\n  }\r\n\r\n  return offset + byteLength\r\n}\r\n\r\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\r\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\r\n  this[offset] = (value & 0xff)\r\n  return offset + 1\r\n}\r\n\r\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\r\n  if (value < 0) value = 0xffff + value + 1\r\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\r\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\r\n      (littleEndian ? i : 1 - i) * 8\r\n  }\r\n}\r\n\r\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\r\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\r\n    this[offset] = (value & 0xff)\r\n    this[offset + 1] = (value >>> 8)\r\n  } else {\r\n    objectWriteUInt16(this, value, offset, true)\r\n  }\r\n  return offset + 2\r\n}\r\n\r\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\r\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\r\n    this[offset] = (value >>> 8)\r\n    this[offset + 1] = (value & 0xff)\r\n  } else {\r\n    objectWriteUInt16(this, value, offset, false)\r\n  }\r\n  return offset + 2\r\n}\r\n\r\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\r\n  if (value < 0) value = 0xffffffff + value + 1\r\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\r\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\r\n  }\r\n}\r\n\r\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\r\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\r\n    this[offset + 3] = (value >>> 24)\r\n    this[offset + 2] = (value >>> 16)\r\n    this[offset + 1] = (value >>> 8)\r\n    this[offset] = (value & 0xff)\r\n  } else {\r\n    objectWriteUInt32(this, value, offset, true)\r\n  }\r\n  return offset + 4\r\n}\r\n\r\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\r\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\r\n    this[offset] = (value >>> 24)\r\n    this[offset + 1] = (value >>> 16)\r\n    this[offset + 2] = (value >>> 8)\r\n    this[offset + 3] = (value & 0xff)\r\n  } else {\r\n    objectWriteUInt32(this, value, offset, false)\r\n  }\r\n  return offset + 4\r\n}\r\n\r\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  if (!noAssert) {\r\n    var limit = Math.pow(2, 8 * byteLength - 1)\r\n\r\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\r\n  }\r\n\r\n  var i = 0\r\n  var mul = 1\r\n  var sub = 0\r\n  this[offset] = value & 0xFF\r\n  while (++i < byteLength && (mul *= 0x100)) {\r\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\r\n      sub = 1\r\n    }\r\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\r\n  }\r\n\r\n  return offset + byteLength\r\n}\r\n\r\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  if (!noAssert) {\r\n    var limit = Math.pow(2, 8 * byteLength - 1)\r\n\r\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\r\n  }\r\n\r\n  var i = byteLength - 1\r\n  var mul = 1\r\n  var sub = 0\r\n  this[offset + i] = value & 0xFF\r\n  while (--i >= 0 && (mul *= 0x100)) {\r\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\r\n      sub = 1\r\n    }\r\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\r\n  }\r\n\r\n  return offset + byteLength\r\n}\r\n\r\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\r\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\r\n  if (value < 0) value = 0xff + value + 1\r\n  this[offset] = (value & 0xff)\r\n  return offset + 1\r\n}\r\n\r\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\r\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\r\n    this[offset] = (value & 0xff)\r\n    this[offset + 1] = (value >>> 8)\r\n  } else {\r\n    objectWriteUInt16(this, value, offset, true)\r\n  }\r\n  return offset + 2\r\n}\r\n\r\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\r\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\r\n    this[offset] = (value >>> 8)\r\n    this[offset + 1] = (value & 0xff)\r\n  } else {\r\n    objectWriteUInt16(this, value, offset, false)\r\n  }\r\n  return offset + 2\r\n}\r\n\r\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\r\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\r\n    this[offset] = (value & 0xff)\r\n    this[offset + 1] = (value >>> 8)\r\n    this[offset + 2] = (value >>> 16)\r\n    this[offset + 3] = (value >>> 24)\r\n  } else {\r\n    objectWriteUInt32(this, value, offset, true)\r\n  }\r\n  return offset + 4\r\n}\r\n\r\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\r\n  if (value < 0) value = 0xffffffff + value + 1\r\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\r\n    this[offset] = (value >>> 24)\r\n    this[offset + 1] = (value >>> 16)\r\n    this[offset + 2] = (value >>> 8)\r\n    this[offset + 3] = (value & 0xff)\r\n  } else {\r\n    objectWriteUInt32(this, value, offset, false)\r\n  }\r\n  return offset + 4\r\n}\r\n\r\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\r\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\r\n  if (offset < 0) throw new RangeError('Index out of range')\r\n}\r\n\r\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\r\n  if (!noAssert) {\r\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\r\n  }\r\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\r\n  return offset + 4\r\n}\r\n\r\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\r\n  return writeFloat(this, value, offset, true, noAssert)\r\n}\r\n\r\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\r\n  return writeFloat(this, value, offset, false, noAssert)\r\n}\r\n\r\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\r\n  if (!noAssert) {\r\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\r\n  }\r\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\r\n  return offset + 8\r\n}\r\n\r\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\r\n  return writeDouble(this, value, offset, true, noAssert)\r\n}\r\n\r\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\r\n  return writeDouble(this, value, offset, false, noAssert)\r\n}\r\n\r\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\r\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\r\n  if (!start) start = 0\r\n  if (!end && end !== 0) end = this.length\r\n  if (targetStart >= target.length) targetStart = target.length\r\n  if (!targetStart) targetStart = 0\r\n  if (end > 0 && end < start) end = start\r\n\r\n  // Copy 0 bytes; we're done\r\n  if (end === start) return 0\r\n  if (target.length === 0 || this.length === 0) return 0\r\n\r\n  // Fatal error conditions\r\n  if (targetStart < 0) {\r\n    throw new RangeError('targetStart out of bounds')\r\n  }\r\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\r\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\r\n\r\n  // Are we oob?\r\n  if (end > this.length) end = this.length\r\n  if (target.length - targetStart < end - start) {\r\n    end = target.length - targetStart + start\r\n  }\r\n\r\n  var len = end - start\r\n  var i\r\n\r\n  if (this === target && start < targetStart && targetStart < end) {\r\n    // descending copy from end\r\n    for (i = len - 1; i >= 0; --i) {\r\n      target[i + targetStart] = this[i + start]\r\n    }\r\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\r\n    // ascending copy from start\r\n    for (i = 0; i < len; ++i) {\r\n      target[i + targetStart] = this[i + start]\r\n    }\r\n  } else {\r\n    Uint8Array.prototype.set.call(\r\n      target,\r\n      this.subarray(start, start + len),\r\n      targetStart\r\n    )\r\n  }\r\n\r\n  return len\r\n}\r\n\r\n// Usage:\r\n//    buffer.fill(number[, offset[, end]])\r\n//    buffer.fill(buffer[, offset[, end]])\r\n//    buffer.fill(string[, offset[, end]][, encoding])\r\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\r\n  // Handle string cases:\r\n  if (typeof val === 'string') {\r\n    if (typeof start === 'string') {\r\n      encoding = start\r\n      start = 0\r\n      end = this.length\r\n    } else if (typeof end === 'string') {\r\n      encoding = end\r\n      end = this.length\r\n    }\r\n    if (val.length === 1) {\r\n      var code = val.charCodeAt(0)\r\n      if (code < 256) {\r\n        val = code\r\n      }\r\n    }\r\n    if (encoding !== undefined && typeof encoding !== 'string') {\r\n      throw new TypeError('encoding must be a string')\r\n    }\r\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\r\n      throw new TypeError('Unknown encoding: ' + encoding)\r\n    }\r\n  } else if (typeof val === 'number') {\r\n    val = val & 255\r\n  }\r\n\r\n  // Invalid ranges are not set to a default, so can range check early.\r\n  if (start < 0 || this.length < start || this.length < end) {\r\n    throw new RangeError('Out of range index')\r\n  }\r\n\r\n  if (end <= start) {\r\n    return this\r\n  }\r\n\r\n  start = start >>> 0\r\n  end = end === undefined ? this.length : end >>> 0\r\n\r\n  if (!val) val = 0\r\n\r\n  var i\r\n  if (typeof val === 'number') {\r\n    for (i = start; i < end; ++i) {\r\n      this[i] = val\r\n    }\r\n  } else {\r\n    var bytes = Buffer.isBuffer(val)\r\n      ? val\r\n      : utf8ToBytes(new Buffer(val, encoding).toString())\r\n    var len = bytes.length\r\n    for (i = 0; i < end - start; ++i) {\r\n      this[i + start] = bytes[i % len]\r\n    }\r\n  }\r\n\r\n  return this\r\n}\r\n\r\n// HELPER FUNCTIONS\r\n// ================\r\n\r\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\r\n\r\nfunction base64clean (str) {\r\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\r\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\r\n  // Node converts strings with length < 2 to ''\r\n  if (str.length < 2) return ''\r\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\r\n  while (str.length % 4 !== 0) {\r\n    str = str + '='\r\n  }\r\n  return str\r\n}\r\n\r\nfunction stringtrim (str) {\r\n  if (str.trim) return str.trim()\r\n  return str.replace(/^\\s+|\\s+$/g, '')\r\n}\r\n\r\nfunction toHex (n) {\r\n  if (n < 16) return '0' + n.toString(16)\r\n  return n.toString(16)\r\n}\r\n\r\nfunction utf8ToBytes (string, units) {\r\n  units = units || Infinity\r\n  var codePoint\r\n  var length = string.length\r\n  var leadSurrogate = null\r\n  var bytes = []\r\n\r\n  for (var i = 0; i < length; ++i) {\r\n    codePoint = string.charCodeAt(i)\r\n\r\n    // is surrogate component\r\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\r\n      // last char was a lead\r\n      if (!leadSurrogate) {\r\n        // no lead yet\r\n        if (codePoint > 0xDBFF) {\r\n          // unexpected trail\r\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\r\n          continue\r\n        } else if (i + 1 === length) {\r\n          // unpaired lead\r\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\r\n          continue\r\n        }\r\n\r\n        // valid lead\r\n        leadSurrogate = codePoint\r\n\r\n        continue\r\n      }\r\n\r\n      // 2 leads in a row\r\n      if (codePoint < 0xDC00) {\r\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\r\n        leadSurrogate = codePoint\r\n        continue\r\n      }\r\n\r\n      // valid surrogate pair\r\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\r\n    } else if (leadSurrogate) {\r\n      // valid bmp char, but last char was a lead\r\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\r\n    }\r\n\r\n    leadSurrogate = null\r\n\r\n    // encode utf8\r\n    if (codePoint < 0x80) {\r\n      if ((units -= 1) < 0) break\r\n      bytes.push(codePoint)\r\n    } else if (codePoint < 0x800) {\r\n      if ((units -= 2) < 0) break\r\n      bytes.push(\r\n        codePoint >> 0x6 | 0xC0,\r\n        codePoint & 0x3F | 0x80\r\n      )\r\n    } else if (codePoint < 0x10000) {\r\n      if ((units -= 3) < 0) break\r\n      bytes.push(\r\n        codePoint >> 0xC | 0xE0,\r\n        codePoint >> 0x6 & 0x3F | 0x80,\r\n        codePoint & 0x3F | 0x80\r\n      )\r\n    } else if (codePoint < 0x110000) {\r\n      if ((units -= 4) < 0) break\r\n      bytes.push(\r\n        codePoint >> 0x12 | 0xF0,\r\n        codePoint >> 0xC & 0x3F | 0x80,\r\n        codePoint >> 0x6 & 0x3F | 0x80,\r\n        codePoint & 0x3F | 0x80\r\n      )\r\n    } else {\r\n      throw new Error('Invalid code point')\r\n    }\r\n  }\r\n\r\n  return bytes\r\n}\r\n\r\nfunction asciiToBytes (str) {\r\n  var byteArray = []\r\n  for (var i = 0; i < str.length; ++i) {\r\n    // Node's code seems to be doing this and not & 0x7F..\r\n    byteArray.push(str.charCodeAt(i) & 0xFF)\r\n  }\r\n  return byteArray\r\n}\r\n\r\nfunction utf16leToBytes (str, units) {\r\n  var c, hi, lo\r\n  var byteArray = []\r\n  for (var i = 0; i < str.length; ++i) {\r\n    if ((units -= 2) < 0) break\r\n\r\n    c = str.charCodeAt(i)\r\n    hi = c >> 8\r\n    lo = c % 256\r\n    byteArray.push(lo)\r\n    byteArray.push(hi)\r\n  }\r\n\r\n  return byteArray\r\n}\r\n\r\nfunction base64ToBytes (str) {\r\n  return base64.toByteArray(base64clean(str))\r\n}\r\n\r\nfunction blitBuffer (src, dst, offset, length) {\r\n  for (var i = 0; i < length; ++i) {\r\n    if ((i + offset >= dst.length) || (i >= src.length)) break\r\n    dst[i + offset] = src[i]\r\n  }\r\n  return i\r\n}\r\n\r\nfunction isnan (val) {\r\n  return val !== val // eslint-disable-line no-self-compare\r\n}\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/buffer/index.js?");

/***/ }),

/***/ "./node_modules/core-util-is/lib/util.js":
/*!***********************************************!*\
  !*** ./node_modules/core-util-is/lib/util.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the\r\n// \"Software\"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n// persons to whom the Software is furnished to do so, subject to the\r\n// following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n// NOTE: These type checking functions intentionally don't use `instanceof`\r\n// because it is fragile and can be easily faked with `Object.create()`.\r\n\r\nfunction isArray(arg) {\r\n  if (Array.isArray) {\r\n    return Array.isArray(arg);\r\n  }\r\n  return objectToString(arg) === '[object Array]';\r\n}\r\nexports.isArray = isArray;\r\n\r\nfunction isBoolean(arg) {\r\n  return typeof arg === 'boolean';\r\n}\r\nexports.isBoolean = isBoolean;\r\n\r\nfunction isNull(arg) {\r\n  return arg === null;\r\n}\r\nexports.isNull = isNull;\r\n\r\nfunction isNullOrUndefined(arg) {\r\n  return arg == null;\r\n}\r\nexports.isNullOrUndefined = isNullOrUndefined;\r\n\r\nfunction isNumber(arg) {\r\n  return typeof arg === 'number';\r\n}\r\nexports.isNumber = isNumber;\r\n\r\nfunction isString(arg) {\r\n  return typeof arg === 'string';\r\n}\r\nexports.isString = isString;\r\n\r\nfunction isSymbol(arg) {\r\n  return typeof arg === 'symbol';\r\n}\r\nexports.isSymbol = isSymbol;\r\n\r\nfunction isUndefined(arg) {\r\n  return arg === void 0;\r\n}\r\nexports.isUndefined = isUndefined;\r\n\r\nfunction isRegExp(re) {\r\n  return objectToString(re) === '[object RegExp]';\r\n}\r\nexports.isRegExp = isRegExp;\r\n\r\nfunction isObject(arg) {\r\n  return typeof arg === 'object' && arg !== null;\r\n}\r\nexports.isObject = isObject;\r\n\r\nfunction isDate(d) {\r\n  return objectToString(d) === '[object Date]';\r\n}\r\nexports.isDate = isDate;\r\n\r\nfunction isError(e) {\r\n  return (objectToString(e) === '[object Error]' || e instanceof Error);\r\n}\r\nexports.isError = isError;\r\n\r\nfunction isFunction(arg) {\r\n  return typeof arg === 'function';\r\n}\r\nexports.isFunction = isFunction;\r\n\r\nfunction isPrimitive(arg) {\r\n  return arg === null ||\r\n         typeof arg === 'boolean' ||\r\n         typeof arg === 'number' ||\r\n         typeof arg === 'string' ||\r\n         typeof arg === 'symbol' ||  // ES6 symbol\r\n         typeof arg === 'undefined';\r\n}\r\nexports.isPrimitive = isPrimitive;\r\n\r\nexports.isBuffer = Buffer.isBuffer;\r\n\r\nfunction objectToString(o) {\r\n  return Object.prototype.toString.call(o);\r\n}\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/core-util-is/lib/util.js?");

/***/ }),

/***/ "./node_modules/define-properties/index.js":
/*!*************************************************!*\
  !*** ./node_modules/define-properties/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar keys = __webpack_require__(/*! object-keys */ \"./node_modules/object-keys/index.js\");\r\nvar hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';\r\n\r\nvar toStr = Object.prototype.toString;\r\nvar concat = Array.prototype.concat;\r\nvar origDefineProperty = Object.defineProperty;\r\n\r\nvar isFunction = function (fn) {\r\n\treturn typeof fn === 'function' && toStr.call(fn) === '[object Function]';\r\n};\r\n\r\nvar arePropertyDescriptorsSupported = function () {\r\n\tvar obj = {};\r\n\ttry {\r\n\t\torigDefineProperty(obj, 'x', { enumerable: false, value: obj });\r\n\t\t// eslint-disable-next-line no-unused-vars, no-restricted-syntax\r\n\t\tfor (var _ in obj) { // jscs:ignore disallowUnusedVariables\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\treturn obj.x === obj;\r\n\t} catch (e) { /* this is IE 8. */\r\n\t\treturn false;\r\n\t}\r\n};\r\nvar supportsDescriptors = origDefineProperty && arePropertyDescriptorsSupported();\r\n\r\nvar defineProperty = function (object, name, value, predicate) {\r\n\tif (name in object && (!isFunction(predicate) || !predicate())) {\r\n\t\treturn;\r\n\t}\r\n\tif (supportsDescriptors) {\r\n\t\torigDefineProperty(object, name, {\r\n\t\t\tconfigurable: true,\r\n\t\t\tenumerable: false,\r\n\t\t\tvalue: value,\r\n\t\t\twritable: true\r\n\t\t});\r\n\t} else {\r\n\t\tobject[name] = value;\r\n\t}\r\n};\r\n\r\nvar defineProperties = function (object, map) {\r\n\tvar predicates = arguments.length > 2 ? arguments[2] : {};\r\n\tvar props = keys(map);\r\n\tif (hasSymbols) {\r\n\t\tprops = concat.call(props, Object.getOwnPropertySymbols(map));\r\n\t}\r\n\tfor (var i = 0; i < props.length; i += 1) {\r\n\t\tdefineProperty(object, props[i], map[props[i]], predicates[props[i]]);\r\n\t}\r\n};\r\n\r\ndefineProperties.supportsDescriptors = !!supportsDescriptors;\r\n\r\nmodule.exports = defineProperties;\r\n\n\n//# sourceURL=webpack:///./node_modules/define-properties/index.js?");

/***/ }),

/***/ "./node_modules/diff/dist/diff.js":
/*!****************************************!*\
  !*** ./node_modules/diff/dist/diff.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\r\n\r\n diff v3.5.0\r\n\r\nSoftware License Agreement (BSD License)\r\n\r\nCopyright (c) 2009-2015, Kevin Decker <kpdecker@gmail.com>\r\n\r\nAll rights reserved.\r\n\r\nRedistribution and use of this software in source and binary forms, with or without modification,\r\nare permitted provided that the following conditions are met:\r\n\r\n* Redistributions of source code must retain the above\r\n  copyright notice, this list of conditions and the\r\n  following disclaimer.\r\n\r\n* Redistributions in binary form must reproduce the above\r\n  copyright notice, this list of conditions and the\r\n  following disclaimer in the documentation and/or other\r\n  materials provided with the distribution.\r\n\r\n* Neither the name of Kevin Decker nor the names of its\r\n  contributors may be used to endorse or promote products\r\n  derived from this software without specific prior\r\n  written permission.\r\n\r\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\r\nIMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\r\nFITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\r\nCONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\nIN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\r\nOF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n@license\r\n*/\r\n(function webpackUniversalModuleDefinition(root, factory) {\r\n\tif(true)\r\n\t\tmodule.exports = factory();\r\n\telse {}\r\n})(this, function() {\r\nreturn /******/ (function(modules) { // webpackBootstrap\r\n/******/ \t// The module cache\r\n/******/ \tvar installedModules = {};\r\n\r\n/******/ \t// The require function\r\n/******/ \tfunction __webpack_require__(moduleId) {\r\n\r\n/******/ \t\t// Check if module is in cache\r\n/******/ \t\tif(installedModules[moduleId])\r\n/******/ \t\t\treturn installedModules[moduleId].exports;\r\n\r\n/******/ \t\t// Create a new module (and put it into the cache)\r\n/******/ \t\tvar module = installedModules[moduleId] = {\r\n/******/ \t\t\texports: {},\r\n/******/ \t\t\tid: moduleId,\r\n/******/ \t\t\tloaded: false\r\n/******/ \t\t};\r\n\r\n/******/ \t\t// Execute the module function\r\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\r\n\r\n/******/ \t\t// Flag the module as loaded\r\n/******/ \t\tmodule.loaded = true;\r\n\r\n/******/ \t\t// Return the exports of the module\r\n/******/ \t\treturn module.exports;\r\n/******/ \t}\r\n\r\n\r\n/******/ \t// expose the modules object (__webpack_modules__)\r\n/******/ \t__webpack_require__.m = modules;\r\n\r\n/******/ \t// expose the module cache\r\n/******/ \t__webpack_require__.c = installedModules;\r\n\r\n/******/ \t// __webpack_public_path__\r\n/******/ \t__webpack_require__.p = \"\";\r\n\r\n/******/ \t// Load entry module and return exports\r\n/******/ \treturn __webpack_require__(0);\r\n/******/ })\r\n/************************************************************************/\r\n/******/ ([\r\n/* 0 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\t/*istanbul ignore start*/'use strict';\r\n\r\n\texports.__esModule = true;\r\n\texports.canonicalize = exports.convertChangesToXML = exports.convertChangesToDMP = exports.merge = exports.parsePatch = exports.applyPatches = exports.applyPatch = exports.createPatch = exports.createTwoFilesPatch = exports.structuredPatch = exports.diffArrays = exports.diffJson = exports.diffCss = exports.diffSentences = exports.diffTrimmedLines = exports.diffLines = exports.diffWordsWithSpace = exports.diffWords = exports.diffChars = exports.Diff = undefined;\r\n\r\n\t/*istanbul ignore end*/var /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;\r\n\r\n\t/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);\r\n\r\n\t/*istanbul ignore end*/var /*istanbul ignore start*/_character = __webpack_require__(2) /*istanbul ignore end*/;\r\n\r\n\tvar /*istanbul ignore start*/_word = __webpack_require__(3) /*istanbul ignore end*/;\r\n\r\n\tvar /*istanbul ignore start*/_line = __webpack_require__(5) /*istanbul ignore end*/;\r\n\r\n\tvar /*istanbul ignore start*/_sentence = __webpack_require__(6) /*istanbul ignore end*/;\r\n\r\n\tvar /*istanbul ignore start*/_css = __webpack_require__(7) /*istanbul ignore end*/;\r\n\r\n\tvar /*istanbul ignore start*/_json = __webpack_require__(8) /*istanbul ignore end*/;\r\n\r\n\tvar /*istanbul ignore start*/_array = __webpack_require__(9) /*istanbul ignore end*/;\r\n\r\n\tvar /*istanbul ignore start*/_apply = __webpack_require__(10) /*istanbul ignore end*/;\r\n\r\n\tvar /*istanbul ignore start*/_parse = __webpack_require__(11) /*istanbul ignore end*/;\r\n\r\n\tvar /*istanbul ignore start*/_merge = __webpack_require__(13) /*istanbul ignore end*/;\r\n\r\n\tvar /*istanbul ignore start*/_create = __webpack_require__(14) /*istanbul ignore end*/;\r\n\r\n\tvar /*istanbul ignore start*/_dmp = __webpack_require__(16) /*istanbul ignore end*/;\r\n\r\n\tvar /*istanbul ignore start*/_xml = __webpack_require__(17) /*istanbul ignore end*/;\r\n\r\n\t/*istanbul ignore start*/function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\r\n\r\n\t/* See LICENSE file for terms of use */\r\n\r\n\t/*\r\n\t * Text diff implementation.\r\n\t *\r\n\t * This library supports the following APIS:\r\n\t * JsDiff.diffChars: Character by character diff\r\n\t * JsDiff.diffWords: Word (as defined by \\b regex) diff which ignores whitespace\r\n\t * JsDiff.diffLines: Line based diff\r\n\t *\r\n\t * JsDiff.diffCss: Diff targeted at CSS content\r\n\t *\r\n\t * These methods are based on the implementation proposed in\r\n\t * \"An O(ND) Difference Algorithm and its Variations\" (Myers, 1986).\r\n\t * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.6927\r\n\t */\r\n\texports. /*istanbul ignore end*/Diff = _base2['default'];\r\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffChars = _character.diffChars;\r\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffWords = _word.diffWords;\r\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffWordsWithSpace = _word.diffWordsWithSpace;\r\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffLines = _line.diffLines;\r\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffTrimmedLines = _line.diffTrimmedLines;\r\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffSentences = _sentence.diffSentences;\r\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffCss = _css.diffCss;\r\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffJson = _json.diffJson;\r\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffArrays = _array.diffArrays;\r\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/structuredPatch = _create.structuredPatch;\r\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/createTwoFilesPatch = _create.createTwoFilesPatch;\r\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/createPatch = _create.createPatch;\r\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/applyPatch = _apply.applyPatch;\r\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/applyPatches = _apply.applyPatches;\r\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/parsePatch = _parse.parsePatch;\r\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/merge = _merge.merge;\r\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/convertChangesToDMP = _dmp.convertChangesToDMP;\r\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/convertChangesToXML = _xml.convertChangesToXML;\r\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/canonicalize = _json.canonicalize;\r\n\t//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC5qcyJdLCJuYW1lcyI6WyJEaWZmIiwiZGlmZkNoYXJzIiwiZGlmZldvcmRzIiwiZGlmZldvcmRzV2l0aFNwYWNlIiwiZGlmZkxpbmVzIiwiZGlmZlRyaW1tZWRMaW5lcyIsImRpZmZTZW50ZW5jZXMiLCJkaWZmQ3NzIiwiZGlmZkpzb24iLCJkaWZmQXJyYXlzIiwic3RydWN0dXJlZFBhdGNoIiwiY3JlYXRlVHdvRmlsZXNQYXRjaCIsImNyZWF0ZVBhdGNoIiwiYXBwbHlQYXRjaCIsImFwcGx5UGF0Y2hlcyIsInBhcnNlUGF0Y2giLCJtZXJnZSIsImNvbnZlcnRDaGFuZ2VzVG9ETVAiLCJjb252ZXJ0Q2hhbmdlc1RvWE1MIiwiY2Fub25pY2FsaXplIl0sIm1hcHBpbmdzIjoiOzs7Ozt1QkFnQkE7Ozs7dUJBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBRUE7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBQ0E7Ozs7QUFqQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7O2dDQWtDRUEsSTt5REFFQUMsUzt5REFDQUMsUzt5REFDQUMsa0I7eURBQ0FDLFM7eURBQ0FDLGdCO3lEQUNBQyxhO3lEQUVBQyxPO3lEQUNBQyxRO3lEQUVBQyxVO3lEQUVBQyxlO3lEQUNBQyxtQjt5REFDQUMsVzt5REFDQUMsVTt5REFDQUMsWTt5REFDQUMsVTt5REFDQUMsSzt5REFDQUMsbUI7eURBQ0FDLG1CO3lEQUNBQyxZIiwiZmlsZSI6ImluZGV4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogU2VlIExJQ0VOU0UgZmlsZSBmb3IgdGVybXMgb2YgdXNlICovXG5cbi8qXG4gKiBUZXh0IGRpZmYgaW1wbGVtZW50YXRpb24uXG4gKlxuICogVGhpcyBsaWJyYXJ5IHN1cHBvcnRzIHRoZSBmb2xsb3dpbmcgQVBJUzpcbiAqIEpzRGlmZi5kaWZmQ2hhcnM6IENoYXJhY3RlciBieSBjaGFyYWN0ZXIgZGlmZlxuICogSnNEaWZmLmRpZmZXb3JkczogV29yZCAoYXMgZGVmaW5lZCBieSBcXGIgcmVnZXgpIGRpZmYgd2hpY2ggaWdub3JlcyB3aGl0ZXNwYWNlXG4gKiBKc0RpZmYuZGlmZkxpbmVzOiBMaW5lIGJhc2VkIGRpZmZcbiAqXG4gKiBKc0RpZmYuZGlmZkNzczogRGlmZiB0YXJnZXRlZCBhdCBDU1MgY29udGVudFxuICpcbiAqIFRoZXNlIG1ldGhvZHMgYXJlIGJhc2VkIG9uIHRoZSBpbXBsZW1lbnRhdGlvbiBwcm9wb3NlZCBpblxuICogXCJBbiBPKE5EKSBEaWZmZXJlbmNlIEFsZ29yaXRobSBhbmQgaXRzIFZhcmlhdGlvbnNcIiAoTXllcnMsIDE5ODYpLlxuICogaHR0cDovL2NpdGVzZWVyeC5pc3QucHN1LmVkdS92aWV3ZG9jL3N1bW1hcnk/ZG9pPTEwLjEuMS40LjY5MjdcbiAqL1xuaW1wb3J0IERpZmYgZnJvbSAnLi9kaWZmL2Jhc2UnO1xuaW1wb3J0IHtkaWZmQ2hhcnN9IGZyb20gJy4vZGlmZi9jaGFyYWN0ZXInO1xuaW1wb3J0IHtkaWZmV29yZHMsIGRpZmZXb3Jkc1dpdGhTcGFjZX0gZnJvbSAnLi9kaWZmL3dvcmQnO1xuaW1wb3J0IHtkaWZmTGluZXMsIGRpZmZUcmltbWVkTGluZXN9IGZyb20gJy4vZGlmZi9saW5lJztcbmltcG9ydCB7ZGlmZlNlbnRlbmNlc30gZnJvbSAnLi9kaWZmL3NlbnRlbmNlJztcblxuaW1wb3J0IHtkaWZmQ3NzfSBmcm9tICcuL2RpZmYvY3NzJztcbmltcG9ydCB7ZGlmZkpzb24sIGNhbm9uaWNhbGl6ZX0gZnJvbSAnLi9kaWZmL2pzb24nO1xuXG5pbXBvcnQge2RpZmZBcnJheXN9IGZyb20gJy4vZGlmZi9hcnJheSc7XG5cbmltcG9ydCB7YXBwbHlQYXRjaCwgYXBwbHlQYXRjaGVzfSBmcm9tICcuL3BhdGNoL2FwcGx5JztcbmltcG9ydCB7cGFyc2VQYXRjaH0gZnJvbSAnLi9wYXRjaC9wYXJzZSc7XG5pbXBvcnQge21lcmdlfSBmcm9tICcuL3BhdGNoL21lcmdlJztcbmltcG9ydCB7c3RydWN0dXJlZFBhdGNoLCBjcmVhdGVUd29GaWxlc1BhdGNoLCBjcmVhdGVQYXRjaH0gZnJvbSAnLi9wYXRjaC9jcmVhdGUnO1xuXG5pbXBvcnQge2NvbnZlcnRDaGFuZ2VzVG9ETVB9IGZyb20gJy4vY29udmVydC9kbXAnO1xuaW1wb3J0IHtjb252ZXJ0Q2hhbmdlc1RvWE1MfSBmcm9tICcuL2NvbnZlcnQveG1sJztcblxuZXhwb3J0IHtcbiAgRGlmZixcblxuICBkaWZmQ2hhcnMsXG4gIGRpZmZXb3JkcyxcbiAgZGlmZldvcmRzV2l0aFNwYWNlLFxuICBkaWZmTGluZXMsXG4gIGRpZmZUcmltbWVkTGluZXMsXG4gIGRpZmZTZW50ZW5jZXMsXG5cbiAgZGlmZkNzcyxcbiAgZGlmZkpzb24sXG5cbiAgZGlmZkFycmF5cyxcblxuICBzdHJ1Y3R1cmVkUGF0Y2gsXG4gIGNyZWF0ZVR3b0ZpbGVzUGF0Y2gsXG4gIGNyZWF0ZVBhdGNoLFxuICBhcHBseVBhdGNoLFxuICBhcHBseVBhdGNoZXMsXG4gIHBhcnNlUGF0Y2gsXG4gIG1lcmdlLFxuICBjb252ZXJ0Q2hhbmdlc1RvRE1QLFxuICBjb252ZXJ0Q2hhbmdlc1RvWE1MLFxuICBjYW5vbmljYWxpemVcbn07XG4iXX0=\r\n\r\n\r\n/***/ }),\r\n/* 1 */\r\n/***/ (function(module, exports) {\r\n\r\n\t/*istanbul ignore start*/'use strict';\r\n\r\n\texports.__esModule = true;\r\n\texports['default'] = /*istanbul ignore end*/Diff;\r\n\tfunction Diff() {}\r\n\r\n\tDiff.prototype = {\r\n\t  /*istanbul ignore start*/ /*istanbul ignore end*/diff: function diff(oldString, newString) {\r\n\t    /*istanbul ignore start*/var /*istanbul ignore end*/options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\r\n\r\n\t    var callback = options.callback;\r\n\t    if (typeof options === 'function') {\r\n\t      callback = options;\r\n\t      options = {};\r\n\t    }\r\n\t    this.options = options;\r\n\r\n\t    var self = this;\r\n\r\n\t    function done(value) {\r\n\t      if (callback) {\r\n\t        setTimeout(function () {\r\n\t          callback(undefined, value);\r\n\t        }, 0);\r\n\t        return true;\r\n\t      } else {\r\n\t        return value;\r\n\t      }\r\n\t    }\r\n\r\n\t    // Allow subclasses to massage the input prior to running\r\n\t    oldString = this.castInput(oldString);\r\n\t    newString = this.castInput(newString);\r\n\r\n\t    oldString = this.removeEmpty(this.tokenize(oldString));\r\n\t    newString = this.removeEmpty(this.tokenize(newString));\r\n\r\n\t    var newLen = newString.length,\r\n\t        oldLen = oldString.length;\r\n\t    var editLength = 1;\r\n\t    var maxEditLength = newLen + oldLen;\r\n\t    var bestPath = [{ newPos: -1, components: [] }];\r\n\r\n\t    // Seed editLength = 0, i.e. the content starts with the same values\r\n\t    var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\r\n\t    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\r\n\t      // Identity per the equality and tokenizer\r\n\t      return done([{ value: this.join(newString), count: newString.length }]);\r\n\t    }\r\n\r\n\t    // Main worker method. checks all permutations of a given edit length for acceptance.\r\n\t    function execEditLength() {\r\n\t      for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\r\n\t        var basePath = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;\r\n\t        var addPath = bestPath[diagonalPath - 1],\r\n\t            removePath = bestPath[diagonalPath + 1],\r\n\t            _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\r\n\t        if (addPath) {\r\n\t          // No one else is going to attempt to use this value, clear it\r\n\t          bestPath[diagonalPath - 1] = undefined;\r\n\t        }\r\n\r\n\t        var canAdd = addPath && addPath.newPos + 1 < newLen,\r\n\t            canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;\r\n\t        if (!canAdd && !canRemove) {\r\n\t          // If this path is a terminal then prune\r\n\t          bestPath[diagonalPath] = undefined;\r\n\t          continue;\r\n\t        }\r\n\r\n\t        // Select the diagonal that we want to branch from. We select the prior\r\n\t        // path whose position in the new string is the farthest from the origin\r\n\t        // and does not pass the bounds of the diff graph\r\n\t        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {\r\n\t          basePath = clonePath(removePath);\r\n\t          self.pushComponent(basePath.components, undefined, true);\r\n\t        } else {\r\n\t          basePath = addPath; // No need to clone, we've pulled it from the list\r\n\t          basePath.newPos++;\r\n\t          self.pushComponent(basePath.components, true, undefined);\r\n\t        }\r\n\r\n\t        _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath);\r\n\r\n\t        // If we have hit the end of both strings, then we are done\r\n\t        if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {\r\n\t          return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));\r\n\t        } else {\r\n\t          // Otherwise track this path as a potential candidate and continue.\r\n\t          bestPath[diagonalPath] = basePath;\r\n\t        }\r\n\t      }\r\n\r\n\t      editLength++;\r\n\t    }\r\n\r\n\t    // Performs the length of edit iteration. Is a bit fugly as this has to support the\r\n\t    // sync and async mode which is never fun. Loops over execEditLength until a value\r\n\t    // is produced.\r\n\t    if (callback) {\r\n\t      (function exec() {\r\n\t        setTimeout(function () {\r\n\t          // This should not happen, but we want to be safe.\r\n\t          /* istanbul ignore next */\r\n\t          if (editLength > maxEditLength) {\r\n\t            return callback();\r\n\t          }\r\n\r\n\t          if (!execEditLength()) {\r\n\t            exec();\r\n\t          }\r\n\t        }, 0);\r\n\t      })();\r\n\t    } else {\r\n\t      while (editLength <= maxEditLength) {\r\n\t        var ret = execEditLength();\r\n\t        if (ret) {\r\n\t          return ret;\r\n\t        }\r\n\t      }\r\n\t    }\r\n\t  },\r\n\t  /*istanbul ignore start*/ /*istanbul ignore end*/pushComponent: function pushComponent(components, added, removed) {\r\n\t    var last = components[components.length - 1];\r\n\t    if (last && last.added === added && last.removed === removed) {\r\n\t      // We need to clone here as the component clone operation is just\r\n\t      // as shallow array clone\r\n\t      components[components.length - 1] = { count: last.count + 1, added: added, removed: removed };\r\n\t    } else {\r\n\t      components.push({ count: 1, added: added, removed: removed });\r\n\t    }\r\n\t  },\r\n\t  /*istanbul ignore start*/ /*istanbul ignore end*/extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {\r\n\t    var newLen = newString.length,\r\n\t        oldLen = oldString.length,\r\n\t        newPos = basePath.newPos,\r\n\t        oldPos = newPos - diagonalPath,\r\n\t        commonCount = 0;\r\n\t    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\r\n\t      newPos++;\r\n\t      oldPos++;\r\n\t      commonCount++;\r\n\t    }\r\n\r\n\t    if (commonCount) {\r\n\t      basePath.components.push({ count: commonCount });\r\n\t    }\r\n\r\n\t    basePath.newPos = newPos;\r\n\t    return oldPos;\r\n\t  },\r\n\t  /*istanbul ignore start*/ /*istanbul ignore end*/equals: function equals(left, right) {\r\n\t    if (this.options.comparator) {\r\n\t      return this.options.comparator(left, right);\r\n\t    } else {\r\n\t      return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();\r\n\t    }\r\n\t  },\r\n\t  /*istanbul ignore start*/ /*istanbul ignore end*/removeEmpty: function removeEmpty(array) {\r\n\t    var ret = [];\r\n\t    for (var i = 0; i < array.length; i++) {\r\n\t      if (array[i]) {\r\n\t        ret.push(array[i]);\r\n\t      }\r\n\t    }\r\n\t    return ret;\r\n\t  },\r\n\t  /*istanbul ignore start*/ /*istanbul ignore end*/castInput: function castInput(value) {\r\n\t    return value;\r\n\t  },\r\n\t  /*istanbul ignore start*/ /*istanbul ignore end*/tokenize: function tokenize(value) {\r\n\t    return value.split('');\r\n\t  },\r\n\t  /*istanbul ignore start*/ /*istanbul ignore end*/join: function join(chars) {\r\n\t    return chars.join('');\r\n\t  }\r\n\t};\r\n\r\n\tfunction buildValues(diff, components, newString, oldString, useLongestToken) {\r\n\t  var componentPos = 0,\r\n\t      componentLen = components.length,\r\n\t      newPos = 0,\r\n\t      oldPos = 0;\r\n\r\n\t  for (; componentPos < componentLen; componentPos++) {\r\n\t    var component = components[componentPos];\r\n\t    if (!component.removed) {\r\n\t      if (!component.added && useLongestToken) {\r\n\t        var value = newString.slice(newPos, newPos + component.count);\r\n\t        value = value.map(function (value, i) {\r\n\t          var oldValue = oldString[oldPos + i];\r\n\t          return oldValue.length > value.length ? oldValue : value;\r\n\t        });\r\n\r\n\t        component.value = diff.join(value);\r\n\t      } else {\r\n\t        component.value = diff.join(newString.slice(newPos, newPos + component.count));\r\n\t      }\r\n\t      newPos += component.count;\r\n\r\n\t      // Common case\r\n\t      if (!component.added) {\r\n\t        oldPos += component.count;\r\n\t      }\r\n\t    } else {\r\n\t      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));\r\n\t      oldPos += component.count;\r\n\r\n\t      // Reverse add and remove so removes are output first to match common convention\r\n\t      // The diffing algorithm is tied to add then remove output and this is the simplest\r\n\t      // route to get the desired output with minimal overhead.\r\n\t      if (componentPos && components[componentPos - 1].added) {\r\n\t        var tmp = components[componentPos - 1];\r\n\t        components[componentPos - 1] = components[componentPos];\r\n\t        components[componentPos] = tmp;\r\n\t      }\r\n\t    }\r\n\t  }\r\n\r\n\t  // Special case handle for when one terminal is ignored (i.e. whitespace).\r\n\t  // For this case we merge the terminal into the prior string and drop the change.\r\n\t  // This is only available for string mode.\r\n\t  var lastComponent = components[componentLen - 1];\r\n\t  if (componentLen > 1 && typeof lastComponent.value === 'string' && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {\r\n\t    components[componentLen - 2].value += lastComponent.value;\r\n\t    components.pop();\r\n\t  }\r\n\r\n\t  return components;\r\n\t}\r\n\r\n\tfunction clonePath(path) {\r\n\t  return { newPos: path.newPos, components: path.components.slice(0) };\r\n\t}\r\n\t//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kaWZmL2Jhc2UuanMiXSwibmFtZXMiOlsiRGlmZiIsInByb3RvdHlwZSIsImRpZmYiLCJvbGRTdHJpbmciLCJuZXdTdHJpbmciLCJvcHRpb25zIiwiY2FsbGJhY2siLCJzZWxmIiwiZG9uZSIsInZhbHVlIiwic2V0VGltZW91dCIsInVuZGVmaW5lZCIsImNhc3RJbnB1dCIsInJlbW92ZUVtcHR5IiwidG9rZW5pemUiLCJuZXdMZW4iLCJsZW5ndGgiLCJvbGRMZW4iLCJlZGl0TGVuZ3RoIiwibWF4RWRpdExlbmd0aCIsImJlc3RQYXRoIiwibmV3UG9zIiwiY29tcG9uZW50cyIsIm9sZFBvcyIsImV4dHJhY3RDb21tb24iLCJqb2luIiwiY291bnQiLCJleGVjRWRpdExlbmd0aCIsImRpYWdvbmFsUGF0aCIsImJhc2VQYXRoIiwiYWRkUGF0aCIsInJlbW92ZVBhdGgiLCJjYW5BZGQiLCJjYW5SZW1vdmUiLCJjbG9uZVBhdGgiLCJwdXNoQ29tcG9uZW50IiwiYnVpbGRWYWx1ZXMiLCJ1c2VMb25nZXN0VG9rZW4iLCJleGVjIiwicmV0IiwiYWRkZWQiLCJyZW1vdmVkIiwibGFzdCIsInB1c2giLCJjb21tb25Db3VudCIsImVxdWFscyIsImxlZnQiLCJyaWdodCIsImNvbXBhcmF0b3IiLCJpZ25vcmVDYXNlIiwidG9Mb3dlckNhc2UiLCJhcnJheSIsImkiLCJzcGxpdCIsImNoYXJzIiwiY29tcG9uZW50UG9zIiwiY29tcG9uZW50TGVuIiwiY29tcG9uZW50Iiwic2xpY2UiLCJtYXAiLCJvbGRWYWx1ZSIsInRtcCIsImxhc3RDb21wb25lbnQiLCJwb3AiLCJwYXRoIl0sIm1hcHBpbmdzIjoiOzs7NENBQXdCQSxJO0FBQVQsU0FBU0EsSUFBVCxHQUFnQixDQUFFOztBQUVqQ0EsS0FBS0MsU0FBTCxHQUFpQjtBQUFBLG1EQUNmQyxJQURlLGdCQUNWQyxTQURVLEVBQ0NDLFNBREQsRUFDMEI7QUFBQSx3REFBZEMsT0FBYyx1RUFBSixFQUFJOztBQUN2QyxRQUFJQyxXQUFXRCxRQUFRQyxRQUF2QjtBQUNBLFFBQUksT0FBT0QsT0FBUCxLQUFtQixVQUF2QixFQUFtQztBQUNqQ0MsaUJBQVdELE9BQVg7QUFDQUEsZ0JBQVUsRUFBVjtBQUNEO0FBQ0QsU0FBS0EsT0FBTCxHQUFlQSxPQUFmOztBQUVBLFFBQUlFLE9BQU8sSUFBWDs7QUFFQSxhQUFTQyxJQUFULENBQWNDLEtBQWQsRUFBcUI7QUFDbkIsVUFBSUgsUUFBSixFQUFjO0FBQ1pJLG1CQUFXLFlBQVc7QUFBRUosbUJBQVNLLFNBQVQsRUFBb0JGLEtBQXBCO0FBQTZCLFNBQXJELEVBQXVELENBQXZEO0FBQ0EsZUFBTyxJQUFQO0FBQ0QsT0FIRCxNQUdPO0FBQ0wsZUFBT0EsS0FBUDtBQUNEO0FBQ0Y7O0FBRUQ7QUFDQU4sZ0JBQVksS0FBS1MsU0FBTCxDQUFlVCxTQUFmLENBQVo7QUFDQUMsZ0JBQVksS0FBS1EsU0FBTCxDQUFlUixTQUFmLENBQVo7O0FBRUFELGdCQUFZLEtBQUtVLFdBQUwsQ0FBaUIsS0FBS0MsUUFBTCxDQUFjWCxTQUFkLENBQWpCLENBQVo7QUFDQUMsZ0JBQVksS0FBS1MsV0FBTCxDQUFpQixLQUFLQyxRQUFMLENBQWNWLFNBQWQsQ0FBakIsQ0FBWjs7QUFFQSxRQUFJVyxTQUFTWCxVQUFVWSxNQUF2QjtBQUFBLFFBQStCQyxTQUFTZCxVQUFVYSxNQUFsRDtBQUNBLFFBQUlFLGFBQWEsQ0FBakI7QUFDQSxRQUFJQyxnQkFBZ0JKLFNBQVNFLE1BQTdCO0FBQ0EsUUFBSUcsV0FBVyxDQUFDLEVBQUVDLFFBQVEsQ0FBQyxDQUFYLEVBQWNDLFlBQVksRUFBMUIsRUFBRCxDQUFmOztBQUVBO0FBQ0EsUUFBSUMsU0FBUyxLQUFLQyxhQUFMLENBQW1CSixTQUFTLENBQVQsQ0FBbkIsRUFBZ0NoQixTQUFoQyxFQUEyQ0QsU0FBM0MsRUFBc0QsQ0FBdEQsQ0FBYjtBQUNBLFFBQUlpQixTQUFTLENBQVQsRUFBWUMsTUFBWixHQUFxQixDQUFyQixJQUEwQk4sTUFBMUIsSUFBb0NRLFNBQVMsQ0FBVCxJQUFjTixNQUF0RCxFQUE4RDtBQUM1RDtBQUNBLGFBQU9ULEtBQUssQ0FBQyxFQUFDQyxPQUFPLEtBQUtnQixJQUFMLENBQVVyQixTQUFWLENBQVIsRUFBOEJzQixPQUFPdEIsVUFBVVksTUFBL0MsRUFBRCxDQUFMLENBQVA7QUFDRDs7QUFFRDtBQUNBLGFBQVNXLGNBQVQsR0FBMEI7QUFDeEIsV0FBSyxJQUFJQyxlQUFlLENBQUMsQ0FBRCxHQUFLVixVQUE3QixFQUF5Q1UsZ0JBQWdCVixVQUF6RCxFQUFxRVUsZ0JBQWdCLENBQXJGLEVBQXdGO0FBQ3RGLFlBQUlDLDBDQUFKO0FBQ0EsWUFBSUMsVUFBVVYsU0FBU1EsZUFBZSxDQUF4QixDQUFkO0FBQUEsWUFDSUcsYUFBYVgsU0FBU1EsZUFBZSxDQUF4QixDQURqQjtBQUFBLFlBRUlMLFVBQVMsQ0FBQ1EsYUFBYUEsV0FBV1YsTUFBeEIsR0FBaUMsQ0FBbEMsSUFBdUNPLFlBRnBEO0FBR0EsWUFBSUUsT0FBSixFQUFhO0FBQ1g7QUFDQVYsbUJBQVNRLGVBQWUsQ0FBeEIsSUFBNkJqQixTQUE3QjtBQUNEOztBQUVELFlBQUlxQixTQUFTRixXQUFXQSxRQUFRVCxNQUFSLEdBQWlCLENBQWpCLEdBQXFCTixNQUE3QztBQUFBLFlBQ0lrQixZQUFZRixjQUFjLEtBQUtSLE9BQW5CLElBQTZCQSxVQUFTTixNQUR0RDtBQUVBLFlBQUksQ0FBQ2UsTUFBRCxJQUFXLENBQUNDLFNBQWhCLEVBQTJCO0FBQ3pCO0FBQ0FiLG1CQUFTUSxZQUFULElBQXlCakIsU0FBekI7QUFDQTtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBLFlBQUksQ0FBQ3FCLE1BQUQsSUFBWUMsYUFBYUgsUUFBUVQsTUFBUixHQUFpQlUsV0FBV1YsTUFBekQsRUFBa0U7QUFDaEVRLHFCQUFXSyxVQUFVSCxVQUFWLENBQVg7QUFDQXhCLGVBQUs0QixhQUFMLENBQW1CTixTQUFTUCxVQUE1QixFQUF3Q1gsU0FBeEMsRUFBbUQsSUFBbkQ7QUFDRCxTQUhELE1BR087QUFDTGtCLHFCQUFXQyxPQUFYLENBREssQ0FDaUI7QUFDdEJELG1CQUFTUixNQUFUO0FBQ0FkLGVBQUs0QixhQUFMLENBQW1CTixTQUFTUCxVQUE1QixFQUF3QyxJQUF4QyxFQUE4Q1gsU0FBOUM7QUFDRDs7QUFFRFksa0JBQVNoQixLQUFLaUIsYUFBTCxDQUFtQkssUUFBbkIsRUFBNkJ6QixTQUE3QixFQUF3Q0QsU0FBeEMsRUFBbUR5QixZQUFuRCxDQUFUOztBQUVBO0FBQ0EsWUFBSUMsU0FBU1IsTUFBVCxHQUFrQixDQUFsQixJQUF1Qk4sTUFBdkIsSUFBaUNRLFVBQVMsQ0FBVCxJQUFjTixNQUFuRCxFQUEyRDtBQUN6RCxpQkFBT1QsS0FBSzRCLFlBQVk3QixJQUFaLEVBQWtCc0IsU0FBU1AsVUFBM0IsRUFBdUNsQixTQUF2QyxFQUFrREQsU0FBbEQsRUFBNkRJLEtBQUs4QixlQUFsRSxDQUFMLENBQVA7QUFDRCxTQUZELE1BRU87QUFDTDtBQUNBakIsbUJBQVNRLFlBQVQsSUFBeUJDLFFBQXpCO0FBQ0Q7QUFDRjs7QUFFRFg7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxRQUFJWixRQUFKLEVBQWM7QUFDWCxnQkFBU2dDLElBQVQsR0FBZ0I7QUFDZjVCLG1CQUFXLFlBQVc7QUFDcEI7QUFDQTtBQUNBLGNBQUlRLGFBQWFDLGFBQWpCLEVBQWdDO0FBQzlCLG1CQUFPYixVQUFQO0FBQ0Q7O0FBRUQsY0FBSSxDQUFDcUIsZ0JBQUwsRUFBdUI7QUFDckJXO0FBQ0Q7QUFDRixTQVZELEVBVUcsQ0FWSDtBQVdELE9BWkEsR0FBRDtBQWFELEtBZEQsTUFjTztBQUNMLGFBQU9wQixjQUFjQyxhQUFyQixFQUFvQztBQUNsQyxZQUFJb0IsTUFBTVosZ0JBQVY7QUFDQSxZQUFJWSxHQUFKLEVBQVM7QUFDUCxpQkFBT0EsR0FBUDtBQUNEO0FBQ0Y7QUFDRjtBQUNGLEdBOUdjO0FBQUEsbURBZ0hmSixhQWhIZSx5QkFnSERiLFVBaEhDLEVBZ0hXa0IsS0FoSFgsRUFnSGtCQyxPQWhIbEIsRUFnSDJCO0FBQ3hDLFFBQUlDLE9BQU9wQixXQUFXQSxXQUFXTixNQUFYLEdBQW9CLENBQS9CLENBQVg7QUFDQSxRQUFJMEIsUUFBUUEsS0FBS0YsS0FBTCxLQUFlQSxLQUF2QixJQUFnQ0UsS0FBS0QsT0FBTCxLQUFpQkEsT0FBckQsRUFBOEQ7QUFDNUQ7QUFDQTtBQUNBbkIsaUJBQVdBLFdBQVdOLE1BQVgsR0FBb0IsQ0FBL0IsSUFBb0MsRUFBQ1UsT0FBT2dCLEtBQUtoQixLQUFMLEdBQWEsQ0FBckIsRUFBd0JjLE9BQU9BLEtBQS9CLEVBQXNDQyxTQUFTQSxPQUEvQyxFQUFwQztBQUNELEtBSkQsTUFJTztBQUNMbkIsaUJBQVdxQixJQUFYLENBQWdCLEVBQUNqQixPQUFPLENBQVIsRUFBV2MsT0FBT0EsS0FBbEIsRUFBeUJDLFNBQVNBLE9BQWxDLEVBQWhCO0FBQ0Q7QUFDRixHQXpIYztBQUFBLG1EQTBIZmpCLGFBMUhlLHlCQTBIREssUUExSEMsRUEwSFN6QixTQTFIVCxFQTBIb0JELFNBMUhwQixFQTBIK0J5QixZQTFIL0IsRUEwSDZDO0FBQzFELFFBQUliLFNBQVNYLFVBQVVZLE1BQXZCO0FBQUEsUUFDSUMsU0FBU2QsVUFBVWEsTUFEdkI7QUFBQSxRQUVJSyxTQUFTUSxTQUFTUixNQUZ0QjtBQUFBLFFBR0lFLFNBQVNGLFNBQVNPLFlBSHRCO0FBQUEsUUFLSWdCLGNBQWMsQ0FMbEI7QUFNQSxXQUFPdkIsU0FBUyxDQUFULEdBQWFOLE1BQWIsSUFBdUJRLFNBQVMsQ0FBVCxHQUFhTixNQUFwQyxJQUE4QyxLQUFLNEIsTUFBTCxDQUFZekMsVUFBVWlCLFNBQVMsQ0FBbkIsQ0FBWixFQUFtQ2xCLFVBQVVvQixTQUFTLENBQW5CLENBQW5DLENBQXJELEVBQWdIO0FBQzlHRjtBQUNBRTtBQUNBcUI7QUFDRDs7QUFFRCxRQUFJQSxXQUFKLEVBQWlCO0FBQ2ZmLGVBQVNQLFVBQVQsQ0FBb0JxQixJQUFwQixDQUF5QixFQUFDakIsT0FBT2tCLFdBQVIsRUFBekI7QUFDRDs7QUFFRGYsYUFBU1IsTUFBVCxHQUFrQkEsTUFBbEI7QUFDQSxXQUFPRSxNQUFQO0FBQ0QsR0E3SWM7QUFBQSxtREErSWZzQixNQS9JZSxrQkErSVJDLElBL0lRLEVBK0lGQyxLQS9JRSxFQStJSztBQUNsQixRQUFJLEtBQUsxQyxPQUFMLENBQWEyQyxVQUFqQixFQUE2QjtBQUMzQixhQUFPLEtBQUszQyxPQUFMLENBQWEyQyxVQUFiLENBQXdCRixJQUF4QixFQUE4QkMsS0FBOUIsQ0FBUDtBQUNELEtBRkQsTUFFTztBQUNMLGFBQU9ELFNBQVNDLEtBQVQsSUFDRCxLQUFLMUMsT0FBTCxDQUFhNEMsVUFBYixJQUEyQkgsS0FBS0ksV0FBTCxPQUF1QkgsTUFBTUcsV0FBTixFQUR4RDtBQUVEO0FBQ0YsR0F0SmM7QUFBQSxtREF1SmZyQyxXQXZKZSx1QkF1SkhzQyxLQXZKRyxFQXVKSTtBQUNqQixRQUFJWixNQUFNLEVBQVY7QUFDQSxTQUFLLElBQUlhLElBQUksQ0FBYixFQUFnQkEsSUFBSUQsTUFBTW5DLE1BQTFCLEVBQWtDb0MsR0FBbEMsRUFBdUM7QUFDckMsVUFBSUQsTUFBTUMsQ0FBTixDQUFKLEVBQWM7QUFDWmIsWUFBSUksSUFBSixDQUFTUSxNQUFNQyxDQUFOLENBQVQ7QUFDRDtBQUNGO0FBQ0QsV0FBT2IsR0FBUDtBQUNELEdBL0pjO0FBQUEsbURBZ0tmM0IsU0FoS2UscUJBZ0tMSCxLQWhLSyxFQWdLRTtBQUNmLFdBQU9BLEtBQVA7QUFDRCxHQWxLYztBQUFBLG1EQW1LZkssUUFuS2Usb0JBbUtOTCxLQW5LTSxFQW1LQztBQUNkLFdBQU9BLE1BQU00QyxLQUFOLENBQVksRUFBWixDQUFQO0FBQ0QsR0FyS2M7QUFBQSxtREFzS2Y1QixJQXRLZSxnQkFzS1Y2QixLQXRLVSxFQXNLSDtBQUNWLFdBQU9BLE1BQU03QixJQUFOLENBQVcsRUFBWCxDQUFQO0FBQ0Q7QUF4S2MsQ0FBakI7O0FBMktBLFNBQVNXLFdBQVQsQ0FBcUJsQyxJQUFyQixFQUEyQm9CLFVBQTNCLEVBQXVDbEIsU0FBdkMsRUFBa0RELFNBQWxELEVBQTZEa0MsZUFBN0QsRUFBOEU7QUFDNUUsTUFBSWtCLGVBQWUsQ0FBbkI7QUFBQSxNQUNJQyxlQUFlbEMsV0FBV04sTUFEOUI7QUFBQSxNQUVJSyxTQUFTLENBRmI7QUFBQSxNQUdJRSxTQUFTLENBSGI7O0FBS0EsU0FBT2dDLGVBQWVDLFlBQXRCLEVBQW9DRCxjQUFwQyxFQUFvRDtBQUNsRCxRQUFJRSxZQUFZbkMsV0FBV2lDLFlBQVgsQ0FBaEI7QUFDQSxRQUFJLENBQUNFLFVBQVVoQixPQUFmLEVBQXdCO0FBQ3RCLFVBQUksQ0FBQ2dCLFVBQVVqQixLQUFYLElBQW9CSCxlQUF4QixFQUF5QztBQUN2QyxZQUFJNUIsUUFBUUwsVUFBVXNELEtBQVYsQ0FBZ0JyQyxNQUFoQixFQUF3QkEsU0FBU29DLFVBQVUvQixLQUEzQyxDQUFaO0FBQ0FqQixnQkFBUUEsTUFBTWtELEdBQU4sQ0FBVSxVQUFTbEQsS0FBVCxFQUFnQjJDLENBQWhCLEVBQW1CO0FBQ25DLGNBQUlRLFdBQVd6RCxVQUFVb0IsU0FBUzZCLENBQW5CLENBQWY7QUFDQSxpQkFBT1EsU0FBUzVDLE1BQVQsR0FBa0JQLE1BQU1PLE1BQXhCLEdBQWlDNEMsUUFBakMsR0FBNENuRCxLQUFuRDtBQUNELFNBSE8sQ0FBUjs7QUFLQWdELGtCQUFVaEQsS0FBVixHQUFrQlAsS0FBS3VCLElBQUwsQ0FBVWhCLEtBQVYsQ0FBbEI7QUFDRCxPQVJELE1BUU87QUFDTGdELGtCQUFVaEQsS0FBVixHQUFrQlAsS0FBS3VCLElBQUwsQ0FBVXJCLFVBQVVzRCxLQUFWLENBQWdCckMsTUFBaEIsRUFBd0JBLFNBQVNvQyxVQUFVL0IsS0FBM0MsQ0FBVixDQUFsQjtBQUNEO0FBQ0RMLGdCQUFVb0MsVUFBVS9CLEtBQXBCOztBQUVBO0FBQ0EsVUFBSSxDQUFDK0IsVUFBVWpCLEtBQWYsRUFBc0I7QUFDcEJqQixrQkFBVWtDLFVBQVUvQixLQUFwQjtBQUNEO0FBQ0YsS0FsQkQsTUFrQk87QUFDTCtCLGdCQUFVaEQsS0FBVixHQUFrQlAsS0FBS3VCLElBQUwsQ0FBVXRCLFVBQVV1RCxLQUFWLENBQWdCbkMsTUFBaEIsRUFBd0JBLFNBQVNrQyxVQUFVL0IsS0FBM0MsQ0FBVixDQUFsQjtBQUNBSCxnQkFBVWtDLFVBQVUvQixLQUFwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFJNkIsZ0JBQWdCakMsV0FBV2lDLGVBQWUsQ0FBMUIsRUFBNkJmLEtBQWpELEVBQXdEO0FBQ3RELFlBQUlxQixNQUFNdkMsV0FBV2lDLGVBQWUsQ0FBMUIsQ0FBVjtBQUNBakMsbUJBQVdpQyxlQUFlLENBQTFCLElBQStCakMsV0FBV2lDLFlBQVgsQ0FBL0I7QUFDQWpDLG1CQUFXaUMsWUFBWCxJQUEyQk0sR0FBM0I7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsTUFBSUMsZ0JBQWdCeEMsV0FBV2tDLGVBQWUsQ0FBMUIsQ0FBcEI7QUFDQSxNQUFJQSxlQUFlLENBQWYsSUFDRyxPQUFPTSxjQUFjckQsS0FBckIsS0FBK0IsUUFEbEMsS0FFSXFELGNBQWN0QixLQUFkLElBQXVCc0IsY0FBY3JCLE9BRnpDLEtBR0d2QyxLQUFLMkMsTUFBTCxDQUFZLEVBQVosRUFBZ0JpQixjQUFjckQsS0FBOUIsQ0FIUCxFQUc2QztBQUMzQ2EsZUFBV2tDLGVBQWUsQ0FBMUIsRUFBNkIvQyxLQUE3QixJQUFzQ3FELGNBQWNyRCxLQUFwRDtBQUNBYSxlQUFXeUMsR0FBWDtBQUNEOztBQUVELFNBQU96QyxVQUFQO0FBQ0Q7O0FBRUQsU0FBU1ksU0FBVCxDQUFtQjhCLElBQW5CLEVBQXlCO0FBQ3ZCLFNBQU8sRUFBRTNDLFFBQVEyQyxLQUFLM0MsTUFBZixFQUF1QkMsWUFBWTBDLEtBQUsxQyxVQUFMLENBQWdCb0MsS0FBaEIsQ0FBc0IsQ0FBdEIsQ0FBbkMsRUFBUDtBQUNEIiwiZmlsZSI6ImJhc2UuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEaWZmKCkge31cblxuRGlmZi5wcm90b3R5cGUgPSB7XG4gIGRpZmYob2xkU3RyaW5nLCBuZXdTdHJpbmcsIG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2s7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgICBsZXQgc2VsZiA9IHRoaXM7XG5cbiAgICBmdW5jdGlvbiBkb25lKHZhbHVlKSB7XG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgY2FsbGJhY2sodW5kZWZpbmVkLCB2YWx1ZSk7IH0sIDApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBbGxvdyBzdWJjbGFzc2VzIHRvIG1hc3NhZ2UgdGhlIGlucHV0IHByaW9yIHRvIHJ1bm5pbmdcbiAgICBvbGRTdHJpbmcgPSB0aGlzLmNhc3RJbnB1dChvbGRTdHJpbmcpO1xuICAgIG5ld1N0cmluZyA9IHRoaXMuY2FzdElucHV0KG5ld1N0cmluZyk7XG5cbiAgICBvbGRTdHJpbmcgPSB0aGlzLnJlbW92ZUVtcHR5KHRoaXMudG9rZW5pemUob2xkU3RyaW5nKSk7XG4gICAgbmV3U3RyaW5nID0gdGhpcy5yZW1vdmVFbXB0eSh0aGlzLnRva2VuaXplKG5ld1N0cmluZykpO1xuXG4gICAgbGV0IG5ld0xlbiA9IG5ld1N0cmluZy5sZW5ndGgsIG9sZExlbiA9IG9sZFN0cmluZy5sZW5ndGg7XG4gICAgbGV0IGVkaXRMZW5ndGggPSAxO1xuICAgIGxldCBtYXhFZGl0TGVuZ3RoID0gbmV3TGVuICsgb2xkTGVuO1xuICAgIGxldCBiZXN0UGF0aCA9IFt7IG5ld1BvczogLTEsIGNvbXBvbmVudHM6IFtdIH1dO1xuXG4gICAgLy8gU2VlZCBlZGl0TGVuZ3RoID0gMCwgaS5lLiB0aGUgY29udGVudCBzdGFydHMgd2l0aCB0aGUgc2FtZSB2YWx1ZXNcbiAgICBsZXQgb2xkUG9zID0gdGhpcy5leHRyYWN0Q29tbW9uKGJlc3RQYXRoWzBdLCBuZXdTdHJpbmcsIG9sZFN0cmluZywgMCk7XG4gICAgaWYgKGJlc3RQYXRoWzBdLm5ld1BvcyArIDEgPj0gbmV3TGVuICYmIG9sZFBvcyArIDEgPj0gb2xkTGVuKSB7XG4gICAgICAvLyBJZGVudGl0eSBwZXIgdGhlIGVxdWFsaXR5IGFuZCB0b2tlbml6ZXJcbiAgICAgIHJldHVybiBkb25lKFt7dmFsdWU6IHRoaXMuam9pbihuZXdTdHJpbmcpLCBjb3VudDogbmV3U3RyaW5nLmxlbmd0aH1dKTtcbiAgICB9XG5cbiAgICAvLyBNYWluIHdvcmtlciBtZXRob2QuIGNoZWNrcyBhbGwgcGVybXV0YXRpb25zIG9mIGEgZ2l2ZW4gZWRpdCBsZW5ndGggZm9yIGFjY2VwdGFuY2UuXG4gICAgZnVuY3Rpb24gZXhlY0VkaXRMZW5ndGgoKSB7XG4gICAgICBmb3IgKGxldCBkaWFnb25hbFBhdGggPSAtMSAqIGVkaXRMZW5ndGg7IGRpYWdvbmFsUGF0aCA8PSBlZGl0TGVuZ3RoOyBkaWFnb25hbFBhdGggKz0gMikge1xuICAgICAgICBsZXQgYmFzZVBhdGg7XG4gICAgICAgIGxldCBhZGRQYXRoID0gYmVzdFBhdGhbZGlhZ29uYWxQYXRoIC0gMV0sXG4gICAgICAgICAgICByZW1vdmVQYXRoID0gYmVzdFBhdGhbZGlhZ29uYWxQYXRoICsgMV0sXG4gICAgICAgICAgICBvbGRQb3MgPSAocmVtb3ZlUGF0aCA/IHJlbW92ZVBhdGgubmV3UG9zIDogMCkgLSBkaWFnb25hbFBhdGg7XG4gICAgICAgIGlmIChhZGRQYXRoKSB7XG4gICAgICAgICAgLy8gTm8gb25lIGVsc2UgaXMgZ29pbmcgdG8gYXR0ZW1wdCB0byB1c2UgdGhpcyB2YWx1ZSwgY2xlYXIgaXRcbiAgICAgICAgICBiZXN0UGF0aFtkaWFnb25hbFBhdGggLSAxXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjYW5BZGQgPSBhZGRQYXRoICYmIGFkZFBhdGgubmV3UG9zICsgMSA8IG5ld0xlbixcbiAgICAgICAgICAgIGNhblJlbW92ZSA9IHJlbW92ZVBhdGggJiYgMCA8PSBvbGRQb3MgJiYgb2xkUG9zIDwgb2xkTGVuO1xuICAgICAgICBpZiAoIWNhbkFkZCAmJiAhY2FuUmVtb3ZlKSB7XG4gICAgICAgICAgLy8gSWYgdGhpcyBwYXRoIGlzIGEgdGVybWluYWwgdGhlbiBwcnVuZVxuICAgICAgICAgIGJlc3RQYXRoW2RpYWdvbmFsUGF0aF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZWxlY3QgdGhlIGRpYWdvbmFsIHRoYXQgd2Ugd2FudCB0byBicmFuY2ggZnJvbS4gV2Ugc2VsZWN0IHRoZSBwcmlvclxuICAgICAgICAvLyBwYXRoIHdob3NlIHBvc2l0aW9uIGluIHRoZSBuZXcgc3RyaW5nIGlzIHRoZSBmYXJ0aGVzdCBmcm9tIHRoZSBvcmlnaW5cbiAgICAgICAgLy8gYW5kIGRvZXMgbm90IHBhc3MgdGhlIGJvdW5kcyBvZiB0aGUgZGlmZiBncmFwaFxuICAgICAgICBpZiAoIWNhbkFkZCB8fCAoY2FuUmVtb3ZlICYmIGFkZFBhdGgubmV3UG9zIDwgcmVtb3ZlUGF0aC5uZXdQb3MpKSB7XG4gICAgICAgICAgYmFzZVBhdGggPSBjbG9uZVBhdGgocmVtb3ZlUGF0aCk7XG4gICAgICAgICAgc2VsZi5wdXNoQ29tcG9uZW50KGJhc2VQYXRoLmNvbXBvbmVudHMsIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmFzZVBhdGggPSBhZGRQYXRoOyAgIC8vIE5vIG5lZWQgdG8gY2xvbmUsIHdlJ3ZlIHB1bGxlZCBpdCBmcm9tIHRoZSBsaXN0XG4gICAgICAgICAgYmFzZVBhdGgubmV3UG9zKys7XG4gICAgICAgICAgc2VsZi5wdXNoQ29tcG9uZW50KGJhc2VQYXRoLmNvbXBvbmVudHMsIHRydWUsIHVuZGVmaW5lZCk7XG4gICAgICAgIH1cblxuICAgICAgICBvbGRQb3MgPSBzZWxmLmV4dHJhY3RDb21tb24oYmFzZVBhdGgsIG5ld1N0cmluZywgb2xkU3RyaW5nLCBkaWFnb25hbFBhdGgpO1xuXG4gICAgICAgIC8vIElmIHdlIGhhdmUgaGl0IHRoZSBlbmQgb2YgYm90aCBzdHJpbmdzLCB0aGVuIHdlIGFyZSBkb25lXG4gICAgICAgIGlmIChiYXNlUGF0aC5uZXdQb3MgKyAxID49IG5ld0xlbiAmJiBvbGRQb3MgKyAxID49IG9sZExlbikge1xuICAgICAgICAgIHJldHVybiBkb25lKGJ1aWxkVmFsdWVzKHNlbGYsIGJhc2VQYXRoLmNvbXBvbmVudHMsIG5ld1N0cmluZywgb2xkU3RyaW5nLCBzZWxmLnVzZUxvbmdlc3RUb2tlbikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE90aGVyd2lzZSB0cmFjayB0aGlzIHBhdGggYXMgYSBwb3RlbnRpYWwgY2FuZGlkYXRlIGFuZCBjb250aW51ZS5cbiAgICAgICAgICBiZXN0UGF0aFtkaWFnb25hbFBhdGhdID0gYmFzZVBhdGg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZWRpdExlbmd0aCsrO1xuICAgIH1cblxuICAgIC8vIFBlcmZvcm1zIHRoZSBsZW5ndGggb2YgZWRpdCBpdGVyYXRpb24uIElzIGEgYml0IGZ1Z2x5IGFzIHRoaXMgaGFzIHRvIHN1cHBvcnQgdGhlXG4gICAgLy8gc3luYyBhbmQgYXN5bmMgbW9kZSB3aGljaCBpcyBuZXZlciBmdW4uIExvb3BzIG92ZXIgZXhlY0VkaXRMZW5ndGggdW50aWwgYSB2YWx1ZVxuICAgIC8vIGlzIHByb2R1Y2VkLlxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgKGZ1bmN0aW9uIGV4ZWMoKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgLy8gVGhpcyBzaG91bGQgbm90IGhhcHBlbiwgYnV0IHdlIHdhbnQgdG8gYmUgc2FmZS5cbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgIGlmIChlZGl0TGVuZ3RoID4gbWF4RWRpdExlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFleGVjRWRpdExlbmd0aCgpKSB7XG4gICAgICAgICAgICBleGVjKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAwKTtcbiAgICAgIH0oKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlIChlZGl0TGVuZ3RoIDw9IG1heEVkaXRMZW5ndGgpIHtcbiAgICAgICAgbGV0IHJldCA9IGV4ZWNFZGl0TGVuZ3RoKCk7XG4gICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHB1c2hDb21wb25lbnQoY29tcG9uZW50cywgYWRkZWQsIHJlbW92ZWQpIHtcbiAgICBsZXQgbGFzdCA9IGNvbXBvbmVudHNbY29tcG9uZW50cy5sZW5ndGggLSAxXTtcbiAgICBpZiAobGFzdCAmJiBsYXN0LmFkZGVkID09PSBhZGRlZCAmJiBsYXN0LnJlbW92ZWQgPT09IHJlbW92ZWQpIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gY2xvbmUgaGVyZSBhcyB0aGUgY29tcG9uZW50IGNsb25lIG9wZXJhdGlvbiBpcyBqdXN0XG4gICAgICAvLyBhcyBzaGFsbG93IGFycmF5IGNsb25lXG4gICAgICBjb21wb25lbnRzW2NvbXBvbmVudHMubGVuZ3RoIC0gMV0gPSB7Y291bnQ6IGxhc3QuY291bnQgKyAxLCBhZGRlZDogYWRkZWQsIHJlbW92ZWQ6IHJlbW92ZWQgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tcG9uZW50cy5wdXNoKHtjb3VudDogMSwgYWRkZWQ6IGFkZGVkLCByZW1vdmVkOiByZW1vdmVkIH0pO1xuICAgIH1cbiAgfSxcbiAgZXh0cmFjdENvbW1vbihiYXNlUGF0aCwgbmV3U3RyaW5nLCBvbGRTdHJpbmcsIGRpYWdvbmFsUGF0aCkge1xuICAgIGxldCBuZXdMZW4gPSBuZXdTdHJpbmcubGVuZ3RoLFxuICAgICAgICBvbGRMZW4gPSBvbGRTdHJpbmcubGVuZ3RoLFxuICAgICAgICBuZXdQb3MgPSBiYXNlUGF0aC5uZXdQb3MsXG4gICAgICAgIG9sZFBvcyA9IG5ld1BvcyAtIGRpYWdvbmFsUGF0aCxcblxuICAgICAgICBjb21tb25Db3VudCA9IDA7XG4gICAgd2hpbGUgKG5ld1BvcyArIDEgPCBuZXdMZW4gJiYgb2xkUG9zICsgMSA8IG9sZExlbiAmJiB0aGlzLmVxdWFscyhuZXdTdHJpbmdbbmV3UG9zICsgMV0sIG9sZFN0cmluZ1tvbGRQb3MgKyAxXSkpIHtcbiAgICAgIG5ld1BvcysrO1xuICAgICAgb2xkUG9zKys7XG4gICAgICBjb21tb25Db3VudCsrO1xuICAgIH1cblxuICAgIGlmIChjb21tb25Db3VudCkge1xuICAgICAgYmFzZVBhdGguY29tcG9uZW50cy5wdXNoKHtjb3VudDogY29tbW9uQ291bnR9KTtcbiAgICB9XG5cbiAgICBiYXNlUGF0aC5uZXdQb3MgPSBuZXdQb3M7XG4gICAgcmV0dXJuIG9sZFBvcztcbiAgfSxcblxuICBlcXVhbHMobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmNvbXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuY29tcGFyYXRvcihsZWZ0LCByaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBsZWZ0ID09PSByaWdodFxuICAgICAgICB8fCAodGhpcy5vcHRpb25zLmlnbm9yZUNhc2UgJiYgbGVmdC50b0xvd2VyQ2FzZSgpID09PSByaWdodC50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG4gIH0sXG4gIHJlbW92ZUVtcHR5KGFycmF5KSB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhcnJheVtpXSkge1xuICAgICAgICByZXQucHVzaChhcnJheVtpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH0sXG4gIGNhc3RJbnB1dCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcbiAgdG9rZW5pemUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUuc3BsaXQoJycpO1xuICB9LFxuICBqb2luKGNoYXJzKSB7XG4gICAgcmV0dXJuIGNoYXJzLmpvaW4oJycpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBidWlsZFZhbHVlcyhkaWZmLCBjb21wb25lbnRzLCBuZXdTdHJpbmcsIG9sZFN0cmluZywgdXNlTG9uZ2VzdFRva2VuKSB7XG4gIGxldCBjb21wb25lbnRQb3MgPSAwLFxuICAgICAgY29tcG9uZW50TGVuID0gY29tcG9uZW50cy5sZW5ndGgsXG4gICAgICBuZXdQb3MgPSAwLFxuICAgICAgb2xkUG9zID0gMDtcblxuICBmb3IgKDsgY29tcG9uZW50UG9zIDwgY29tcG9uZW50TGVuOyBjb21wb25lbnRQb3MrKykge1xuICAgIGxldCBjb21wb25lbnQgPSBjb21wb25lbnRzW2NvbXBvbmVudFBvc107XG4gICAgaWYgKCFjb21wb25lbnQucmVtb3ZlZCkge1xuICAgICAgaWYgKCFjb21wb25lbnQuYWRkZWQgJiYgdXNlTG9uZ2VzdFRva2VuKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IG5ld1N0cmluZy5zbGljZShuZXdQb3MsIG5ld1BvcyArIGNvbXBvbmVudC5jb3VudCk7XG4gICAgICAgIHZhbHVlID0gdmFsdWUubWFwKGZ1bmN0aW9uKHZhbHVlLCBpKSB7XG4gICAgICAgICAgbGV0IG9sZFZhbHVlID0gb2xkU3RyaW5nW29sZFBvcyArIGldO1xuICAgICAgICAgIHJldHVybiBvbGRWYWx1ZS5sZW5ndGggPiB2YWx1ZS5sZW5ndGggPyBvbGRWYWx1ZSA6IHZhbHVlO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb21wb25lbnQudmFsdWUgPSBkaWZmLmpvaW4odmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tcG9uZW50LnZhbHVlID0gZGlmZi5qb2luKG5ld1N0cmluZy5zbGljZShuZXdQb3MsIG5ld1BvcyArIGNvbXBvbmVudC5jb3VudCkpO1xuICAgICAgfVxuICAgICAgbmV3UG9zICs9IGNvbXBvbmVudC5jb3VudDtcblxuICAgICAgLy8gQ29tbW9uIGNhc2VcbiAgICAgIGlmICghY29tcG9uZW50LmFkZGVkKSB7XG4gICAgICAgIG9sZFBvcyArPSBjb21wb25lbnQuY291bnQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBvbmVudC52YWx1ZSA9IGRpZmYuam9pbihvbGRTdHJpbmcuc2xpY2Uob2xkUG9zLCBvbGRQb3MgKyBjb21wb25lbnQuY291bnQpKTtcbiAgICAgIG9sZFBvcyArPSBjb21wb25lbnQuY291bnQ7XG5cbiAgICAgIC8vIFJldmVyc2UgYWRkIGFuZCByZW1vdmUgc28gcmVtb3ZlcyBhcmUgb3V0cHV0IGZpcnN0IHRvIG1hdGNoIGNvbW1vbiBjb252ZW50aW9uXG4gICAgICAvLyBUaGUgZGlmZmluZyBhbGdvcml0aG0gaXMgdGllZCB0byBhZGQgdGhlbiByZW1vdmUgb3V0cHV0IGFuZCB0aGlzIGlzIHRoZSBzaW1wbGVzdFxuICAgICAgLy8gcm91dGUgdG8gZ2V0IHRoZSBkZXNpcmVkIG91dHB1dCB3aXRoIG1pbmltYWwgb3ZlcmhlYWQuXG4gICAgICBpZiAoY29tcG9uZW50UG9zICYmIGNvbXBvbmVudHNbY29tcG9uZW50UG9zIC0gMV0uYWRkZWQpIHtcbiAgICAgICAgbGV0IHRtcCA9IGNvbXBvbmVudHNbY29tcG9uZW50UG9zIC0gMV07XG4gICAgICAgIGNvbXBvbmVudHNbY29tcG9uZW50UG9zIC0gMV0gPSBjb21wb25lbnRzW2NvbXBvbmVudFBvc107XG4gICAgICAgIGNvbXBvbmVudHNbY29tcG9uZW50UG9zXSA9IHRtcDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBTcGVjaWFsIGNhc2UgaGFuZGxlIGZvciB3aGVuIG9uZSB0ZXJtaW5hbCBpcyBpZ25vcmVkIChpLmUuIHdoaXRlc3BhY2UpLlxuICAvLyBGb3IgdGhpcyBjYXNlIHdlIG1lcmdlIHRoZSB0ZXJtaW5hbCBpbnRvIHRoZSBwcmlvciBzdHJpbmcgYW5kIGRyb3AgdGhlIGNoYW5nZS5cbiAgLy8gVGhpcyBpcyBvbmx5IGF2YWlsYWJsZSBmb3Igc3RyaW5nIG1vZGUuXG4gIGxldCBsYXN0Q29tcG9uZW50ID0gY29tcG9uZW50c1tjb21wb25lbnRMZW4gLSAxXTtcbiAgaWYgKGNvbXBvbmVudExlbiA+IDFcbiAgICAgICYmIHR5cGVvZiBsYXN0Q29tcG9uZW50LnZhbHVlID09PSAnc3RyaW5nJ1xuICAgICAgJiYgKGxhc3RDb21wb25lbnQuYWRkZWQgfHwgbGFzdENvbXBvbmVudC5yZW1vdmVkKVxuICAgICAgJiYgZGlmZi5lcXVhbHMoJycsIGxhc3RDb21wb25lbnQudmFsdWUpKSB7XG4gICAgY29tcG9uZW50c1tjb21wb25lbnRMZW4gLSAyXS52YWx1ZSArPSBsYXN0Q29tcG9uZW50LnZhbHVlO1xuICAgIGNvbXBvbmVudHMucG9wKCk7XG4gIH1cblxuICByZXR1cm4gY29tcG9uZW50cztcbn1cblxuZnVuY3Rpb24gY2xvbmVQYXRoKHBhdGgpIHtcbiAgcmV0dXJuIHsgbmV3UG9zOiBwYXRoLm5ld1BvcywgY29tcG9uZW50czogcGF0aC5jb21wb25lbnRzLnNsaWNlKDApIH07XG59XG4iXX0=\r\n\r\n\r\n/***/ }),\r\n/* 2 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\t/*istanbul ignore start*/'use strict';\r\n\r\n\texports.__esModule = true;\r\n\texports.characterDiff = undefined;\r\n\texports. /*istanbul ignore end*/diffChars = diffChars;\r\n\r\n\tvar /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;\r\n\r\n\t/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);\r\n\r\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\r\n\r\n\t/*istanbul ignore end*/var characterDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/characterDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();\r\n\tfunction diffChars(oldStr, newStr, options) {\r\n\t  return characterDiff.diff(oldStr, newStr, options);\r\n\t}\r\n\t//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kaWZmL2NoYXJhY3Rlci5qcyJdLCJuYW1lcyI6WyJkaWZmQ2hhcnMiLCJjaGFyYWN0ZXJEaWZmIiwib2xkU3RyIiwibmV3U3RyIiwib3B0aW9ucyIsImRpZmYiXSwibWFwcGluZ3MiOiI7Ozs7Z0NBR2dCQSxTLEdBQUFBLFM7O0FBSGhCOzs7Ozs7dUJBRU8sSUFBTUMseUZBQWdCLHdFQUF0QjtBQUNBLFNBQVNELFNBQVQsQ0FBbUJFLE1BQW5CLEVBQTJCQyxNQUEzQixFQUFtQ0MsT0FBbkMsRUFBNEM7QUFBRSxTQUFPSCxjQUFjSSxJQUFkLENBQW1CSCxNQUFuQixFQUEyQkMsTUFBM0IsRUFBbUNDLE9BQW5DLENBQVA7QUFBcUQiLCJmaWxlIjoiY2hhcmFjdGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IERpZmYgZnJvbSAnLi9iYXNlJztcblxuZXhwb3J0IGNvbnN0IGNoYXJhY3RlckRpZmYgPSBuZXcgRGlmZigpO1xuZXhwb3J0IGZ1bmN0aW9uIGRpZmZDaGFycyhvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucykgeyByZXR1cm4gY2hhcmFjdGVyRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKTsgfVxuIl19\r\n\r\n\r\n/***/ }),\r\n/* 3 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\t/*istanbul ignore start*/'use strict';\r\n\r\n\texports.__esModule = true;\r\n\texports.wordDiff = undefined;\r\n\texports. /*istanbul ignore end*/diffWords = diffWords;\r\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffWordsWithSpace = diffWordsWithSpace;\r\n\r\n\tvar /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;\r\n\r\n\t/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);\r\n\r\n\t/*istanbul ignore end*/var /*istanbul ignore start*/_params = __webpack_require__(4) /*istanbul ignore end*/;\r\n\r\n\t/*istanbul ignore start*/function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\r\n\r\n\t/*istanbul ignore end*/ // Based on https://en.wikipedia.org/wiki/Latin_script_in_Unicode\r\n\t//\r\n\t// Ranges and exceptions:\r\n\t// Latin-1 Supplement, 008000FF\r\n\t//  - U+00D7   Multiplication sign\r\n\t//  - U+00F7   Division sign\r\n\t// Latin Extended-A, 0100017F\r\n\t// Latin Extended-B, 0180024F\r\n\t// IPA Extensions, 025002AF\r\n\t// Spacing Modifier Letters, 02B002FF\r\n\t//  - U+02C7   &#711;  Caron\r\n\t//  - U+02D8   &#728;  Breve\r\n\t//  - U+02D9   &#729;  Dot Above\r\n\t//  - U+02DA   &#730;  Ring Above\r\n\t//  - U+02DB   &#731;  Ogonek\r\n\t//  - U+02DC   &#732;  Small Tilde\r\n\t//  - U+02DD   &#733;  Double Acute Accent\r\n\t// Latin Extended Additional, 1E001EFF\r\n\tvar extendedWordChars = /^[A-Za-z\\xC0-\\u02C6\\u02C8-\\u02D7\\u02DE-\\u02FF\\u1E00-\\u1EFF]+$/;\r\n\r\n\tvar reWhitespace = /\\S/;\r\n\r\n\tvar wordDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/wordDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();\r\n\twordDiff.equals = function (left, right) {\r\n\t  if (this.options.ignoreCase) {\r\n\t    left = left.toLowerCase();\r\n\t    right = right.toLowerCase();\r\n\t  }\r\n\t  return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);\r\n\t};\r\n\twordDiff.tokenize = function (value) {\r\n\t  var tokens = value.split(/(\\s+|\\b)/);\r\n\r\n\t  // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.\r\n\t  for (var i = 0; i < tokens.length - 1; i++) {\r\n\t    // If we have an empty string in the next field and we have only word chars before and after, merge\r\n\t    if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {\r\n\t      tokens[i] += tokens[i + 2];\r\n\t      tokens.splice(i + 1, 2);\r\n\t      i--;\r\n\t    }\r\n\t  }\r\n\r\n\t  return tokens;\r\n\t};\r\n\r\n\tfunction diffWords(oldStr, newStr, options) {\r\n\t  options = /*istanbul ignore start*/(0, _params.generateOptions) /*istanbul ignore end*/(options, { ignoreWhitespace: true });\r\n\t  return wordDiff.diff(oldStr, newStr, options);\r\n\t}\r\n\r\n\tfunction diffWordsWithSpace(oldStr, newStr, options) {\r\n\t  return wordDiff.diff(oldStr, newStr, options);\r\n\t}\r\n\t//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kaWZmL3dvcmQuanMiXSwibmFtZXMiOlsiZGlmZldvcmRzIiwiZGlmZldvcmRzV2l0aFNwYWNlIiwiZXh0ZW5kZWRXb3JkQ2hhcnMiLCJyZVdoaXRlc3BhY2UiLCJ3b3JkRGlmZiIsImVxdWFscyIsImxlZnQiLCJyaWdodCIsIm9wdGlvbnMiLCJpZ25vcmVDYXNlIiwidG9Mb3dlckNhc2UiLCJpZ25vcmVXaGl0ZXNwYWNlIiwidGVzdCIsInRva2VuaXplIiwidmFsdWUiLCJ0b2tlbnMiLCJzcGxpdCIsImkiLCJsZW5ndGgiLCJzcGxpY2UiLCJvbGRTdHIiLCJuZXdTdHIiLCJkaWZmIl0sIm1hcHBpbmdzIjoiOzs7O2dDQW1EZ0JBLFMsR0FBQUEsUzt5REFLQUMsa0IsR0FBQUEsa0I7O0FBeERoQjs7Ozt1QkFDQTs7Ozt3QkFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFNQyxvQkFBb0IsK0RBQTFCOztBQUVBLElBQU1DLGVBQWUsSUFBckI7O0FBRU8sSUFBTUMsK0VBQVcsd0VBQWpCO0FBQ1BBLFNBQVNDLE1BQVQsR0FBa0IsVUFBU0MsSUFBVCxFQUFlQyxLQUFmLEVBQXNCO0FBQ3RDLE1BQUksS0FBS0MsT0FBTCxDQUFhQyxVQUFqQixFQUE2QjtBQUMzQkgsV0FBT0EsS0FBS0ksV0FBTCxFQUFQO0FBQ0FILFlBQVFBLE1BQU1HLFdBQU4sRUFBUjtBQUNEO0FBQ0QsU0FBT0osU0FBU0MsS0FBVCxJQUFtQixLQUFLQyxPQUFMLENBQWFHLGdCQUFiLElBQWlDLENBQUNSLGFBQWFTLElBQWIsQ0FBa0JOLElBQWxCLENBQWxDLElBQTZELENBQUNILGFBQWFTLElBQWIsQ0FBa0JMLEtBQWxCLENBQXhGO0FBQ0QsQ0FORDtBQU9BSCxTQUFTUyxRQUFULEdBQW9CLFVBQVNDLEtBQVQsRUFBZ0I7QUFDbEMsTUFBSUMsU0FBU0QsTUFBTUUsS0FBTixDQUFZLFVBQVosQ0FBYjs7QUFFQTtBQUNBLE9BQUssSUFBSUMsSUFBSSxDQUFiLEVBQWdCQSxJQUFJRixPQUFPRyxNQUFQLEdBQWdCLENBQXBDLEVBQXVDRCxHQUF2QyxFQUE0QztBQUMxQztBQUNBLFFBQUksQ0FBQ0YsT0FBT0UsSUFBSSxDQUFYLENBQUQsSUFBa0JGLE9BQU9FLElBQUksQ0FBWCxDQUFsQixJQUNLZixrQkFBa0JVLElBQWxCLENBQXVCRyxPQUFPRSxDQUFQLENBQXZCLENBREwsSUFFS2Ysa0JBQWtCVSxJQUFsQixDQUF1QkcsT0FBT0UsSUFBSSxDQUFYLENBQXZCLENBRlQsRUFFZ0Q7QUFDOUNGLGFBQU9FLENBQVAsS0FBYUYsT0FBT0UsSUFBSSxDQUFYLENBQWI7QUFDQUYsYUFBT0ksTUFBUCxDQUFjRixJQUFJLENBQWxCLEVBQXFCLENBQXJCO0FBQ0FBO0FBQ0Q7QUFDRjs7QUFFRCxTQUFPRixNQUFQO0FBQ0QsQ0FoQkQ7O0FBa0JPLFNBQVNmLFNBQVQsQ0FBbUJvQixNQUFuQixFQUEyQkMsTUFBM0IsRUFBbUNiLE9BQW5DLEVBQTRDO0FBQ2pEQSxZQUFVLDhFQUFnQkEsT0FBaEIsRUFBeUIsRUFBQ0csa0JBQWtCLElBQW5CLEVBQXpCLENBQVY7QUFDQSxTQUFPUCxTQUFTa0IsSUFBVCxDQUFjRixNQUFkLEVBQXNCQyxNQUF0QixFQUE4QmIsT0FBOUIsQ0FBUDtBQUNEOztBQUVNLFNBQVNQLGtCQUFULENBQTRCbUIsTUFBNUIsRUFBb0NDLE1BQXBDLEVBQTRDYixPQUE1QyxFQUFxRDtBQUMxRCxTQUFPSixTQUFTa0IsSUFBVCxDQUFjRixNQUFkLEVBQXNCQyxNQUF0QixFQUE4QmIsT0FBOUIsQ0FBUDtBQUNEIiwiZmlsZSI6IndvcmQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRGlmZiBmcm9tICcuL2Jhc2UnO1xuaW1wb3J0IHtnZW5lcmF0ZU9wdGlvbnN9IGZyb20gJy4uL3V0aWwvcGFyYW1zJztcblxuLy8gQmFzZWQgb24gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGF0aW5fc2NyaXB0X2luX1VuaWNvZGVcbi8vXG4vLyBSYW5nZXMgYW5kIGV4Y2VwdGlvbnM6XG4vLyBMYXRpbi0xIFN1cHBsZW1lbnQsIDAwODDigJMwMEZGXG4vLyAgLSBVKzAwRDcgIMOXIE11bHRpcGxpY2F0aW9uIHNpZ25cbi8vICAtIFUrMDBGNyAgw7cgRGl2aXNpb24gc2lnblxuLy8gTGF0aW4gRXh0ZW5kZWQtQSwgMDEwMOKAkzAxN0Zcbi8vIExhdGluIEV4dGVuZGVkLUIsIDAxODDigJMwMjRGXG4vLyBJUEEgRXh0ZW5zaW9ucywgMDI1MOKAkzAyQUZcbi8vIFNwYWNpbmcgTW9kaWZpZXIgTGV0dGVycywgMDJCMOKAkzAyRkZcbi8vICAtIFUrMDJDNyAgy4cgJiM3MTE7ICBDYXJvblxuLy8gIC0gVSswMkQ4ICDLmCAmIzcyODsgIEJyZXZlXG4vLyAgLSBVKzAyRDkgIMuZICYjNzI5OyAgRG90IEFib3ZlXG4vLyAgLSBVKzAyREEgIMuaICYjNzMwOyAgUmluZyBBYm92ZVxuLy8gIC0gVSswMkRCICDLmyAmIzczMTsgIE9nb25la1xuLy8gIC0gVSswMkRDICDLnCAmIzczMjsgIFNtYWxsIFRpbGRlXG4vLyAgLSBVKzAyREQgIMudICYjNzMzOyAgRG91YmxlIEFjdXRlIEFjY2VudFxuLy8gTGF0aW4gRXh0ZW5kZWQgQWRkaXRpb25hbCwgMUUwMOKAkzFFRkZcbmNvbnN0IGV4dGVuZGVkV29yZENoYXJzID0gL15bYS16QS1aXFx1e0MwfS1cXHV7RkZ9XFx1e0Q4fS1cXHV7RjZ9XFx1e0Y4fS1cXHV7MkM2fVxcdXsyQzh9LVxcdXsyRDd9XFx1ezJERX0tXFx1ezJGRn1cXHV7MUUwMH0tXFx1ezFFRkZ9XSskL3U7XG5cbmNvbnN0IHJlV2hpdGVzcGFjZSA9IC9cXFMvO1xuXG5leHBvcnQgY29uc3Qgd29yZERpZmYgPSBuZXcgRGlmZigpO1xud29yZERpZmYuZXF1YWxzID0gZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5pZ25vcmVDYXNlKSB7XG4gICAgbGVmdCA9IGxlZnQudG9Mb3dlckNhc2UoKTtcbiAgICByaWdodCA9IHJpZ2h0LnRvTG93ZXJDYXNlKCk7XG4gIH1cbiAgcmV0dXJuIGxlZnQgPT09IHJpZ2h0IHx8ICh0aGlzLm9wdGlvbnMuaWdub3JlV2hpdGVzcGFjZSAmJiAhcmVXaGl0ZXNwYWNlLnRlc3QobGVmdCkgJiYgIXJlV2hpdGVzcGFjZS50ZXN0KHJpZ2h0KSk7XG59O1xud29yZERpZmYudG9rZW5pemUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICBsZXQgdG9rZW5zID0gdmFsdWUuc3BsaXQoLyhcXHMrfFxcYikvKTtcblxuICAvLyBKb2luIHRoZSBib3VuZGFyeSBzcGxpdHMgdGhhdCB3ZSBkbyBub3QgY29uc2lkZXIgdG8gYmUgYm91bmRhcmllcy4gVGhpcyBpcyBwcmltYXJpbHkgdGhlIGV4dGVuZGVkIExhdGluIGNoYXJhY3RlciBzZXQuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIC8vIElmIHdlIGhhdmUgYW4gZW1wdHkgc3RyaW5nIGluIHRoZSBuZXh0IGZpZWxkIGFuZCB3ZSBoYXZlIG9ubHkgd29yZCBjaGFycyBiZWZvcmUgYW5kIGFmdGVyLCBtZXJnZVxuICAgIGlmICghdG9rZW5zW2kgKyAxXSAmJiB0b2tlbnNbaSArIDJdXG4gICAgICAgICAgJiYgZXh0ZW5kZWRXb3JkQ2hhcnMudGVzdCh0b2tlbnNbaV0pXG4gICAgICAgICAgJiYgZXh0ZW5kZWRXb3JkQ2hhcnMudGVzdCh0b2tlbnNbaSArIDJdKSkge1xuICAgICAgdG9rZW5zW2ldICs9IHRva2Vuc1tpICsgMl07XG4gICAgICB0b2tlbnMuc3BsaWNlKGkgKyAxLCAyKTtcbiAgICAgIGktLTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdG9rZW5zO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGRpZmZXb3JkcyhvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucykge1xuICBvcHRpb25zID0gZ2VuZXJhdGVPcHRpb25zKG9wdGlvbnMsIHtpZ25vcmVXaGl0ZXNwYWNlOiB0cnVlfSk7XG4gIHJldHVybiB3b3JkRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpZmZXb3Jkc1dpdGhTcGFjZShvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucykge1xuICByZXR1cm4gd29yZERpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucyk7XG59XG4iXX0=\r\n\r\n\r\n/***/ }),\r\n/* 4 */\r\n/***/ (function(module, exports) {\r\n\r\n\t/*istanbul ignore start*/'use strict';\r\n\r\n\texports.__esModule = true;\r\n\texports. /*istanbul ignore end*/generateOptions = generateOptions;\r\n\tfunction generateOptions(options, defaults) {\r\n\t  if (typeof options === 'function') {\r\n\t    defaults.callback = options;\r\n\t  } else if (options) {\r\n\t    for (var name in options) {\r\n\t      /* istanbul ignore else */\r\n\t      if (options.hasOwnProperty(name)) {\r\n\t        defaults[name] = options[name];\r\n\t      }\r\n\t    }\r\n\t  }\r\n\t  return defaults;\r\n\t}\r\n\t//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsL3BhcmFtcy5qcyJdLCJuYW1lcyI6WyJnZW5lcmF0ZU9wdGlvbnMiLCJvcHRpb25zIiwiZGVmYXVsdHMiLCJjYWxsYmFjayIsIm5hbWUiLCJoYXNPd25Qcm9wZXJ0eSJdLCJtYXBwaW5ncyI6Ijs7O2dDQUFnQkEsZSxHQUFBQSxlO0FBQVQsU0FBU0EsZUFBVCxDQUF5QkMsT0FBekIsRUFBa0NDLFFBQWxDLEVBQTRDO0FBQ2pELE1BQUksT0FBT0QsT0FBUCxLQUFtQixVQUF2QixFQUFtQztBQUNqQ0MsYUFBU0MsUUFBVCxHQUFvQkYsT0FBcEI7QUFDRCxHQUZELE1BRU8sSUFBSUEsT0FBSixFQUFhO0FBQ2xCLFNBQUssSUFBSUcsSUFBVCxJQUFpQkgsT0FBakIsRUFBMEI7QUFDeEI7QUFDQSxVQUFJQSxRQUFRSSxjQUFSLENBQXVCRCxJQUF2QixDQUFKLEVBQWtDO0FBQ2hDRixpQkFBU0UsSUFBVCxJQUFpQkgsUUFBUUcsSUFBUixDQUFqQjtBQUNEO0FBQ0Y7QUFDRjtBQUNELFNBQU9GLFFBQVA7QUFDRCIsImZpbGUiOiJwYXJhbXMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVPcHRpb25zKG9wdGlvbnMsIGRlZmF1bHRzKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGRlZmF1bHRzLmNhbGxiYWNrID0gb3B0aW9ucztcbiAgfSBlbHNlIGlmIChvcHRpb25zKSB7XG4gICAgZm9yIChsZXQgbmFtZSBpbiBvcHRpb25zKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgZGVmYXVsdHNbbmFtZV0gPSBvcHRpb25zW25hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGVmYXVsdHM7XG59XG4iXX0=\r\n\r\n\r\n/***/ }),\r\n/* 5 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\t/*istanbul ignore start*/'use strict';\r\n\r\n\texports.__esModule = true;\r\n\texports.lineDiff = undefined;\r\n\texports. /*istanbul ignore end*/diffLines = diffLines;\r\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffTrimmedLines = diffTrimmedLines;\r\n\r\n\tvar /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;\r\n\r\n\t/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);\r\n\r\n\t/*istanbul ignore end*/var /*istanbul ignore start*/_params = __webpack_require__(4) /*istanbul ignore end*/;\r\n\r\n\t/*istanbul ignore start*/function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\r\n\r\n\t/*istanbul ignore end*/var lineDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/lineDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();\r\n\tlineDiff.tokenize = function (value) {\r\n\t  var retLines = [],\r\n\t      linesAndNewlines = value.split(/(\\n|\\r\\n)/);\r\n\r\n\t  // Ignore the final empty token that occurs if the string ends with a new line\r\n\t  if (!linesAndNewlines[linesAndNewlines.length - 1]) {\r\n\t    linesAndNewlines.pop();\r\n\t  }\r\n\r\n\t  // Merge the content and line separators into single tokens\r\n\t  for (var i = 0; i < linesAndNewlines.length; i++) {\r\n\t    var line = linesAndNewlines[i];\r\n\r\n\t    if (i % 2 && !this.options.newlineIsToken) {\r\n\t      retLines[retLines.length - 1] += line;\r\n\t    } else {\r\n\t      if (this.options.ignoreWhitespace) {\r\n\t        line = line.trim();\r\n\t      }\r\n\t      retLines.push(line);\r\n\t    }\r\n\t  }\r\n\r\n\t  return retLines;\r\n\t};\r\n\r\n\tfunction diffLines(oldStr, newStr, callback) {\r\n\t  return lineDiff.diff(oldStr, newStr, callback);\r\n\t}\r\n\tfunction diffTrimmedLines(oldStr, newStr, callback) {\r\n\t  var options = /*istanbul ignore start*/(0, _params.generateOptions) /*istanbul ignore end*/(callback, { ignoreWhitespace: true });\r\n\t  return lineDiff.diff(oldStr, newStr, options);\r\n\t}\r\n\t//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kaWZmL2xpbmUuanMiXSwibmFtZXMiOlsiZGlmZkxpbmVzIiwiZGlmZlRyaW1tZWRMaW5lcyIsImxpbmVEaWZmIiwidG9rZW5pemUiLCJ2YWx1ZSIsInJldExpbmVzIiwibGluZXNBbmROZXdsaW5lcyIsInNwbGl0IiwibGVuZ3RoIiwicG9wIiwiaSIsImxpbmUiLCJvcHRpb25zIiwibmV3bGluZUlzVG9rZW4iLCJpZ25vcmVXaGl0ZXNwYWNlIiwidHJpbSIsInB1c2giLCJvbGRTdHIiLCJuZXdTdHIiLCJjYWxsYmFjayIsImRpZmYiXSwibWFwcGluZ3MiOiI7Ozs7Z0NBOEJnQkEsUyxHQUFBQSxTO3lEQUNBQyxnQixHQUFBQSxnQjs7QUEvQmhCOzs7O3VCQUNBOzs7O3VCQUVPLElBQU1DLCtFQUFXLHdFQUFqQjtBQUNQQSxTQUFTQyxRQUFULEdBQW9CLFVBQVNDLEtBQVQsRUFBZ0I7QUFDbEMsTUFBSUMsV0FBVyxFQUFmO0FBQUEsTUFDSUMsbUJBQW1CRixNQUFNRyxLQUFOLENBQVksV0FBWixDQUR2Qjs7QUFHQTtBQUNBLE1BQUksQ0FBQ0QsaUJBQWlCQSxpQkFBaUJFLE1BQWpCLEdBQTBCLENBQTNDLENBQUwsRUFBb0Q7QUFDbERGLHFCQUFpQkcsR0FBakI7QUFDRDs7QUFFRDtBQUNBLE9BQUssSUFBSUMsSUFBSSxDQUFiLEVBQWdCQSxJQUFJSixpQkFBaUJFLE1BQXJDLEVBQTZDRSxHQUE3QyxFQUFrRDtBQUNoRCxRQUFJQyxPQUFPTCxpQkFBaUJJLENBQWpCLENBQVg7O0FBRUEsUUFBSUEsSUFBSSxDQUFKLElBQVMsQ0FBQyxLQUFLRSxPQUFMLENBQWFDLGNBQTNCLEVBQTJDO0FBQ3pDUixlQUFTQSxTQUFTRyxNQUFULEdBQWtCLENBQTNCLEtBQWlDRyxJQUFqQztBQUNELEtBRkQsTUFFTztBQUNMLFVBQUksS0FBS0MsT0FBTCxDQUFhRSxnQkFBakIsRUFBbUM7QUFDakNILGVBQU9BLEtBQUtJLElBQUwsRUFBUDtBQUNEO0FBQ0RWLGVBQVNXLElBQVQsQ0FBY0wsSUFBZDtBQUNEO0FBQ0Y7O0FBRUQsU0FBT04sUUFBUDtBQUNELENBeEJEOztBQTBCTyxTQUFTTCxTQUFULENBQW1CaUIsTUFBbkIsRUFBMkJDLE1BQTNCLEVBQW1DQyxRQUFuQyxFQUE2QztBQUFFLFNBQU9qQixTQUFTa0IsSUFBVCxDQUFjSCxNQUFkLEVBQXNCQyxNQUF0QixFQUE4QkMsUUFBOUIsQ0FBUDtBQUFpRDtBQUNoRyxTQUFTbEIsZ0JBQVQsQ0FBMEJnQixNQUExQixFQUFrQ0MsTUFBbEMsRUFBMENDLFFBQTFDLEVBQW9EO0FBQ3pELE1BQUlQLFVBQVUsOEVBQWdCTyxRQUFoQixFQUEwQixFQUFDTCxrQkFBa0IsSUFBbkIsRUFBMUIsQ0FBZDtBQUNBLFNBQU9aLFNBQVNrQixJQUFULENBQWNILE1BQWQsRUFBc0JDLE1BQXRCLEVBQThCTixPQUE5QixDQUFQO0FBQ0QiLCJmaWxlIjoibGluZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBEaWZmIGZyb20gJy4vYmFzZSc7XG5pbXBvcnQge2dlbmVyYXRlT3B0aW9uc30gZnJvbSAnLi4vdXRpbC9wYXJhbXMnO1xuXG5leHBvcnQgY29uc3QgbGluZURpZmYgPSBuZXcgRGlmZigpO1xubGluZURpZmYudG9rZW5pemUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICBsZXQgcmV0TGluZXMgPSBbXSxcbiAgICAgIGxpbmVzQW5kTmV3bGluZXMgPSB2YWx1ZS5zcGxpdCgvKFxcbnxcXHJcXG4pLyk7XG5cbiAgLy8gSWdub3JlIHRoZSBmaW5hbCBlbXB0eSB0b2tlbiB0aGF0IG9jY3VycyBpZiB0aGUgc3RyaW5nIGVuZHMgd2l0aCBhIG5ldyBsaW5lXG4gIGlmICghbGluZXNBbmROZXdsaW5lc1tsaW5lc0FuZE5ld2xpbmVzLmxlbmd0aCAtIDFdKSB7XG4gICAgbGluZXNBbmROZXdsaW5lcy5wb3AoKTtcbiAgfVxuXG4gIC8vIE1lcmdlIHRoZSBjb250ZW50IGFuZCBsaW5lIHNlcGFyYXRvcnMgaW50byBzaW5nbGUgdG9rZW5zXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXNBbmROZXdsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBsaW5lID0gbGluZXNBbmROZXdsaW5lc1tpXTtcblxuICAgIGlmIChpICUgMiAmJiAhdGhpcy5vcHRpb25zLm5ld2xpbmVJc1Rva2VuKSB7XG4gICAgICByZXRMaW5lc1tyZXRMaW5lcy5sZW5ndGggLSAxXSArPSBsaW5lO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmlnbm9yZVdoaXRlc3BhY2UpIHtcbiAgICAgICAgbGluZSA9IGxpbmUudHJpbSgpO1xuICAgICAgfVxuICAgICAgcmV0TGluZXMucHVzaChsaW5lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0TGluZXM7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZGlmZkxpbmVzKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjaykgeyByZXR1cm4gbGluZURpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spOyB9XG5leHBvcnQgZnVuY3Rpb24gZGlmZlRyaW1tZWRMaW5lcyhvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spIHtcbiAgbGV0IG9wdGlvbnMgPSBnZW5lcmF0ZU9wdGlvbnMoY2FsbGJhY2ssIHtpZ25vcmVXaGl0ZXNwYWNlOiB0cnVlfSk7XG4gIHJldHVybiBsaW5lRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKTtcbn1cbiJdfQ==\r\n\r\n\r\n/***/ }),\r\n/* 6 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\t/*istanbul ignore start*/'use strict';\r\n\r\n\texports.__esModule = true;\r\n\texports.sentenceDiff = undefined;\r\n\texports. /*istanbul ignore end*/diffSentences = diffSentences;\r\n\r\n\tvar /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;\r\n\r\n\t/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);\r\n\r\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\r\n\r\n\t/*istanbul ignore end*/var sentenceDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/sentenceDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();\r\n\tsentenceDiff.tokenize = function (value) {\r\n\t  return value.split(/(\\S.+?[.!?])(?=\\s+|$)/);\r\n\t};\r\n\r\n\tfunction diffSentences(oldStr, newStr, callback) {\r\n\t  return sentenceDiff.diff(oldStr, newStr, callback);\r\n\t}\r\n\t//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kaWZmL3NlbnRlbmNlLmpzIl0sIm5hbWVzIjpbImRpZmZTZW50ZW5jZXMiLCJzZW50ZW5jZURpZmYiLCJ0b2tlbml6ZSIsInZhbHVlIiwic3BsaXQiLCJvbGRTdHIiLCJuZXdTdHIiLCJjYWxsYmFjayIsImRpZmYiXSwibWFwcGluZ3MiOiI7Ozs7Z0NBUWdCQSxhLEdBQUFBLGE7O0FBUmhCOzs7Ozs7dUJBR08sSUFBTUMsdUZBQWUsd0VBQXJCO0FBQ1BBLGFBQWFDLFFBQWIsR0FBd0IsVUFBU0MsS0FBVCxFQUFnQjtBQUN0QyxTQUFPQSxNQUFNQyxLQUFOLENBQVksdUJBQVosQ0FBUDtBQUNELENBRkQ7O0FBSU8sU0FBU0osYUFBVCxDQUF1QkssTUFBdkIsRUFBK0JDLE1BQS9CLEVBQXVDQyxRQUF2QyxFQUFpRDtBQUFFLFNBQU9OLGFBQWFPLElBQWIsQ0FBa0JILE1BQWxCLEVBQTBCQyxNQUExQixFQUFrQ0MsUUFBbEMsQ0FBUDtBQUFxRCIsImZpbGUiOiJzZW50ZW5jZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBEaWZmIGZyb20gJy4vYmFzZSc7XG5cblxuZXhwb3J0IGNvbnN0IHNlbnRlbmNlRGlmZiA9IG5ldyBEaWZmKCk7XG5zZW50ZW5jZURpZmYudG9rZW5pemUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUuc3BsaXQoLyhcXFMuKz9bLiE/XSkoPz1cXHMrfCQpLyk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZGlmZlNlbnRlbmNlcyhvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spIHsgcmV0dXJuIHNlbnRlbmNlRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjayk7IH1cbiJdfQ==\r\n\r\n\r\n/***/ }),\r\n/* 7 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\t/*istanbul ignore start*/'use strict';\r\n\r\n\texports.__esModule = true;\r\n\texports.cssDiff = undefined;\r\n\texports. /*istanbul ignore end*/diffCss = diffCss;\r\n\r\n\tvar /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;\r\n\r\n\t/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);\r\n\r\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\r\n\r\n\t/*istanbul ignore end*/var cssDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/cssDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();\r\n\tcssDiff.tokenize = function (value) {\r\n\t  return value.split(/([{}:;,]|\\s+)/);\r\n\t};\r\n\r\n\tfunction diffCss(oldStr, newStr, callback) {\r\n\t  return cssDiff.diff(oldStr, newStr, callback);\r\n\t}\r\n\t//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kaWZmL2Nzcy5qcyJdLCJuYW1lcyI6WyJkaWZmQ3NzIiwiY3NzRGlmZiIsInRva2VuaXplIiwidmFsdWUiLCJzcGxpdCIsIm9sZFN0ciIsIm5ld1N0ciIsImNhbGxiYWNrIiwiZGlmZiJdLCJtYXBwaW5ncyI6Ijs7OztnQ0FPZ0JBLE8sR0FBQUEsTzs7QUFQaEI7Ozs7Ozt1QkFFTyxJQUFNQyw2RUFBVSx3RUFBaEI7QUFDUEEsUUFBUUMsUUFBUixHQUFtQixVQUFTQyxLQUFULEVBQWdCO0FBQ2pDLFNBQU9BLE1BQU1DLEtBQU4sQ0FBWSxlQUFaLENBQVA7QUFDRCxDQUZEOztBQUlPLFNBQVNKLE9BQVQsQ0FBaUJLLE1BQWpCLEVBQXlCQyxNQUF6QixFQUFpQ0MsUUFBakMsRUFBMkM7QUFBRSxTQUFPTixRQUFRTyxJQUFSLENBQWFILE1BQWIsRUFBcUJDLE1BQXJCLEVBQTZCQyxRQUE3QixDQUFQO0FBQWdEIiwiZmlsZSI6ImNzcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBEaWZmIGZyb20gJy4vYmFzZSc7XG5cbmV4cG9ydCBjb25zdCBjc3NEaWZmID0gbmV3IERpZmYoKTtcbmNzc0RpZmYudG9rZW5pemUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUuc3BsaXQoLyhbe306OyxdfFxccyspLyk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZGlmZkNzcyhvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spIHsgcmV0dXJuIGNzc0RpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spOyB9XG4iXX0=\r\n\r\n\r\n/***/ }),\r\n/* 8 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\t/*istanbul ignore start*/'use strict';\r\n\r\n\texports.__esModule = true;\r\n\texports.jsonDiff = undefined;\r\n\r\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\r\n\r\n\texports. /*istanbul ignore end*/diffJson = diffJson;\r\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/canonicalize = canonicalize;\r\n\r\n\tvar /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;\r\n\r\n\t/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);\r\n\r\n\t/*istanbul ignore end*/var /*istanbul ignore start*/_line = __webpack_require__(5) /*istanbul ignore end*/;\r\n\r\n\t/*istanbul ignore start*/function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\r\n\r\n\t/*istanbul ignore end*/var objectPrototypeToString = Object.prototype.toString;\r\n\r\n\tvar jsonDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/jsonDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();\r\n\t// Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\r\n\t// dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\r\n\tjsonDiff.useLongestToken = true;\r\n\r\n\tjsonDiff.tokenize = /*istanbul ignore start*/_line.lineDiff /*istanbul ignore end*/.tokenize;\r\n\tjsonDiff.castInput = function (value) {\r\n\t  /*istanbul ignore start*/var _options = /*istanbul ignore end*/this.options,\r\n\t      undefinedReplacement = _options.undefinedReplacement,\r\n\t      _options$stringifyRep = _options.stringifyReplacer,\r\n\t      stringifyReplacer = _options$stringifyRep === undefined ? function (k, v) /*istanbul ignore start*/{\r\n\t    return (/*istanbul ignore end*/typeof v === 'undefined' ? undefinedReplacement : v\r\n\t    );\r\n\t  } : _options$stringifyRep;\r\n\r\n\r\n\t  return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');\r\n\t};\r\n\tjsonDiff.equals = function (left, right) {\r\n\t  return (/*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/.prototype.equals.call(jsonDiff, left.replace(/,([\\r\\n])/g, '$1'), right.replace(/,([\\r\\n])/g, '$1'))\r\n\t  );\r\n\t};\r\n\r\n\tfunction diffJson(oldObj, newObj, options) {\r\n\t  return jsonDiff.diff(oldObj, newObj, options);\r\n\t}\r\n\r\n\t// This function handles the presence of circular references by bailing out when encountering an\r\n\t// object that is already on the \"stack\" of items being processed. Accepts an optional replacer\r\n\tfunction canonicalize(obj, stack, replacementStack, replacer, key) {\r\n\t  stack = stack || [];\r\n\t  replacementStack = replacementStack || [];\r\n\r\n\t  if (replacer) {\r\n\t    obj = replacer(key, obj);\r\n\t  }\r\n\r\n\t  var i = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;\r\n\r\n\t  for (i = 0; i < stack.length; i += 1) {\r\n\t    if (stack[i] === obj) {\r\n\t      return replacementStack[i];\r\n\t    }\r\n\t  }\r\n\r\n\t  var canonicalizedObj = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;\r\n\r\n\t  if ('[object Array]' === objectPrototypeToString.call(obj)) {\r\n\t    stack.push(obj);\r\n\t    canonicalizedObj = new Array(obj.length);\r\n\t    replacementStack.push(canonicalizedObj);\r\n\t    for (i = 0; i < obj.length; i += 1) {\r\n\t      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);\r\n\t    }\r\n\t    stack.pop();\r\n\t    replacementStack.pop();\r\n\t    return canonicalizedObj;\r\n\t  }\r\n\r\n\t  if (obj && obj.toJSON) {\r\n\t    obj = obj.toJSON();\r\n\t  }\r\n\r\n\t  if ( /*istanbul ignore start*/(typeof /*istanbul ignore end*/obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && obj !== null) {\r\n\t    stack.push(obj);\r\n\t    canonicalizedObj = {};\r\n\t    replacementStack.push(canonicalizedObj);\r\n\t    var sortedKeys = [],\r\n\t        _key = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;\r\n\t    for (_key in obj) {\r\n\t      /* istanbul ignore else */\r\n\t      if (obj.hasOwnProperty(_key)) {\r\n\t        sortedKeys.push(_key);\r\n\t      }\r\n\t    }\r\n\t    sortedKeys.sort();\r\n\t    for (i = 0; i < sortedKeys.length; i += 1) {\r\n\t      _key = sortedKeys[i];\r\n\t      canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);\r\n\t    }\r\n\t    stack.pop();\r\n\t    replacementStack.pop();\r\n\t  } else {\r\n\t    canonicalizedObj = obj;\r\n\t  }\r\n\t  return canonicalizedObj;\r\n\t}\r\n\t//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kaWZmL2pzb24uanMiXSwibmFtZXMiOlsiZGlmZkpzb24iLCJjYW5vbmljYWxpemUiLCJvYmplY3RQcm90b3R5cGVUb1N0cmluZyIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwianNvbkRpZmYiLCJ1c2VMb25nZXN0VG9rZW4iLCJ0b2tlbml6ZSIsImNhc3RJbnB1dCIsInZhbHVlIiwib3B0aW9ucyIsInVuZGVmaW5lZFJlcGxhY2VtZW50Iiwic3RyaW5naWZ5UmVwbGFjZXIiLCJrIiwidiIsIkpTT04iLCJzdHJpbmdpZnkiLCJlcXVhbHMiLCJsZWZ0IiwicmlnaHQiLCJjYWxsIiwicmVwbGFjZSIsIm9sZE9iaiIsIm5ld09iaiIsImRpZmYiLCJvYmoiLCJzdGFjayIsInJlcGxhY2VtZW50U3RhY2siLCJyZXBsYWNlciIsImtleSIsImkiLCJsZW5ndGgiLCJjYW5vbmljYWxpemVkT2JqIiwicHVzaCIsIkFycmF5IiwicG9wIiwidG9KU09OIiwic29ydGVkS2V5cyIsImhhc093blByb3BlcnR5Iiwic29ydCJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztnQ0FxQmdCQSxRLEdBQUFBLFE7eURBSUFDLFksR0FBQUEsWTs7QUF6QmhCOzs7O3VCQUNBOzs7O3VCQUVBLElBQU1DLDBCQUEwQkMsT0FBT0MsU0FBUCxDQUFpQkMsUUFBakQ7O0FBR08sSUFBTUMsK0VBQVcsd0VBQWpCO0FBQ1A7QUFDQTtBQUNBQSxTQUFTQyxlQUFULEdBQTJCLElBQTNCOztBQUVBRCxTQUFTRSxRQUFULEdBQW9CLGdFQUFTQSxRQUE3QjtBQUNBRixTQUFTRyxTQUFULEdBQXFCLFVBQVNDLEtBQVQsRUFBZ0I7QUFBQSxpRUFDK0UsS0FBS0MsT0FEcEY7QUFBQSxNQUM1QkMsb0JBRDRCLFlBQzVCQSxvQkFENEI7QUFBQSx1Q0FDTkMsaUJBRE07QUFBQSxNQUNOQSxpQkFETSx5Q0FDYyxVQUFDQyxDQUFELEVBQUlDLENBQUo7QUFBQSxtQ0FBVSxPQUFPQSxDQUFQLEtBQWEsV0FBYixHQUEyQkgsb0JBQTNCLEdBQWtERztBQUE1RDtBQUFBLEdBRGQ7OztBQUduQyxTQUFPLE9BQU9MLEtBQVAsS0FBaUIsUUFBakIsR0FBNEJBLEtBQTVCLEdBQW9DTSxLQUFLQyxTQUFMLENBQWVoQixhQUFhUyxLQUFiLEVBQW9CLElBQXBCLEVBQTBCLElBQTFCLEVBQWdDRyxpQkFBaEMsQ0FBZixFQUFtRUEsaUJBQW5FLEVBQXNGLElBQXRGLENBQTNDO0FBQ0QsQ0FKRDtBQUtBUCxTQUFTWSxNQUFULEdBQWtCLFVBQVNDLElBQVQsRUFBZUMsS0FBZixFQUFzQjtBQUN0QyxTQUFPLG9FQUFLaEIsU0FBTCxDQUFlYyxNQUFmLENBQXNCRyxJQUF0QixDQUEyQmYsUUFBM0IsRUFBcUNhLEtBQUtHLE9BQUwsQ0FBYSxZQUFiLEVBQTJCLElBQTNCLENBQXJDLEVBQXVFRixNQUFNRSxPQUFOLENBQWMsWUFBZCxFQUE0QixJQUE1QixDQUF2RTtBQUFQO0FBQ0QsQ0FGRDs7QUFJTyxTQUFTdEIsUUFBVCxDQUFrQnVCLE1BQWxCLEVBQTBCQyxNQUExQixFQUFrQ2IsT0FBbEMsRUFBMkM7QUFBRSxTQUFPTCxTQUFTbUIsSUFBVCxDQUFjRixNQUFkLEVBQXNCQyxNQUF0QixFQUE4QmIsT0FBOUIsQ0FBUDtBQUFnRDs7QUFFcEc7QUFDQTtBQUNPLFNBQVNWLFlBQVQsQ0FBc0J5QixHQUF0QixFQUEyQkMsS0FBM0IsRUFBa0NDLGdCQUFsQyxFQUFvREMsUUFBcEQsRUFBOERDLEdBQTlELEVBQW1FO0FBQ3hFSCxVQUFRQSxTQUFTLEVBQWpCO0FBQ0FDLHFCQUFtQkEsb0JBQW9CLEVBQXZDOztBQUVBLE1BQUlDLFFBQUosRUFBYztBQUNaSCxVQUFNRyxTQUFTQyxHQUFULEVBQWNKLEdBQWQsQ0FBTjtBQUNEOztBQUVELE1BQUlLLG1DQUFKOztBQUVBLE9BQUtBLElBQUksQ0FBVCxFQUFZQSxJQUFJSixNQUFNSyxNQUF0QixFQUE4QkQsS0FBSyxDQUFuQyxFQUFzQztBQUNwQyxRQUFJSixNQUFNSSxDQUFOLE1BQWFMLEdBQWpCLEVBQXNCO0FBQ3BCLGFBQU9FLGlCQUFpQkcsQ0FBakIsQ0FBUDtBQUNEO0FBQ0Y7O0FBRUQsTUFBSUUsa0RBQUo7O0FBRUEsTUFBSSxxQkFBcUIvQix3QkFBd0JtQixJQUF4QixDQUE2QkssR0FBN0IsQ0FBekIsRUFBNEQ7QUFDMURDLFVBQU1PLElBQU4sQ0FBV1IsR0FBWDtBQUNBTyx1QkFBbUIsSUFBSUUsS0FBSixDQUFVVCxJQUFJTSxNQUFkLENBQW5CO0FBQ0FKLHFCQUFpQk0sSUFBakIsQ0FBc0JELGdCQUF0QjtBQUNBLFNBQUtGLElBQUksQ0FBVCxFQUFZQSxJQUFJTCxJQUFJTSxNQUFwQixFQUE0QkQsS0FBSyxDQUFqQyxFQUFvQztBQUNsQ0UsdUJBQWlCRixDQUFqQixJQUFzQjlCLGFBQWF5QixJQUFJSyxDQUFKLENBQWIsRUFBcUJKLEtBQXJCLEVBQTRCQyxnQkFBNUIsRUFBOENDLFFBQTlDLEVBQXdEQyxHQUF4RCxDQUF0QjtBQUNEO0FBQ0RILFVBQU1TLEdBQU47QUFDQVIscUJBQWlCUSxHQUFqQjtBQUNBLFdBQU9ILGdCQUFQO0FBQ0Q7O0FBRUQsTUFBSVAsT0FBT0EsSUFBSVcsTUFBZixFQUF1QjtBQUNyQlgsVUFBTUEsSUFBSVcsTUFBSixFQUFOO0FBQ0Q7O0FBRUQsTUFBSSx5REFBT1gsR0FBUCx5Q0FBT0EsR0FBUCxPQUFlLFFBQWYsSUFBMkJBLFFBQVEsSUFBdkMsRUFBNkM7QUFDM0NDLFVBQU1PLElBQU4sQ0FBV1IsR0FBWDtBQUNBTyx1QkFBbUIsRUFBbkI7QUFDQUwscUJBQWlCTSxJQUFqQixDQUFzQkQsZ0JBQXRCO0FBQ0EsUUFBSUssYUFBYSxFQUFqQjtBQUFBLFFBQ0lSLHNDQURKO0FBRUEsU0FBS0EsSUFBTCxJQUFZSixHQUFaLEVBQWlCO0FBQ2Y7QUFDQSxVQUFJQSxJQUFJYSxjQUFKLENBQW1CVCxJQUFuQixDQUFKLEVBQTZCO0FBQzNCUSxtQkFBV0osSUFBWCxDQUFnQkosSUFBaEI7QUFDRDtBQUNGO0FBQ0RRLGVBQVdFLElBQVg7QUFDQSxTQUFLVCxJQUFJLENBQVQsRUFBWUEsSUFBSU8sV0FBV04sTUFBM0IsRUFBbUNELEtBQUssQ0FBeEMsRUFBMkM7QUFDekNELGFBQU1RLFdBQVdQLENBQVgsQ0FBTjtBQUNBRSx1QkFBaUJILElBQWpCLElBQXdCN0IsYUFBYXlCLElBQUlJLElBQUosQ0FBYixFQUF1QkgsS0FBdkIsRUFBOEJDLGdCQUE5QixFQUFnREMsUUFBaEQsRUFBMERDLElBQTFELENBQXhCO0FBQ0Q7QUFDREgsVUFBTVMsR0FBTjtBQUNBUixxQkFBaUJRLEdBQWpCO0FBQ0QsR0FuQkQsTUFtQk87QUFDTEgsdUJBQW1CUCxHQUFuQjtBQUNEO0FBQ0QsU0FBT08sZ0JBQVA7QUFDRCIsImZpbGUiOiJqc29uLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IERpZmYgZnJvbSAnLi9iYXNlJztcbmltcG9ydCB7bGluZURpZmZ9IGZyb20gJy4vbGluZSc7XG5cbmNvbnN0IG9iamVjdFByb3RvdHlwZVRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuXG5leHBvcnQgY29uc3QganNvbkRpZmYgPSBuZXcgRGlmZigpO1xuLy8gRGlzY3JpbWluYXRlIGJldHdlZW4gdHdvIGxpbmVzIG9mIHByZXR0eS1wcmludGVkLCBzZXJpYWxpemVkIEpTT04gd2hlcmUgb25lIG9mIHRoZW0gaGFzIGFcbi8vIGRhbmdsaW5nIGNvbW1hIGFuZCB0aGUgb3RoZXIgZG9lc24ndC4gVHVybnMgb3V0IGluY2x1ZGluZyB0aGUgZGFuZ2xpbmcgY29tbWEgeWllbGRzIHRoZSBuaWNlc3Qgb3V0cHV0OlxuanNvbkRpZmYudXNlTG9uZ2VzdFRva2VuID0gdHJ1ZTtcblxuanNvbkRpZmYudG9rZW5pemUgPSBsaW5lRGlmZi50b2tlbml6ZTtcbmpzb25EaWZmLmNhc3RJbnB1dCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIGNvbnN0IHt1bmRlZmluZWRSZXBsYWNlbWVudCwgc3RyaW5naWZ5UmVwbGFjZXIgPSAoaywgdikgPT4gdHlwZW9mIHYgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkUmVwbGFjZW1lbnQgOiB2fSA9IHRoaXMub3B0aW9ucztcblxuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHZhbHVlIDogSlNPTi5zdHJpbmdpZnkoY2Fub25pY2FsaXplKHZhbHVlLCBudWxsLCBudWxsLCBzdHJpbmdpZnlSZXBsYWNlciksIHN0cmluZ2lmeVJlcGxhY2VyLCAnICAnKTtcbn07XG5qc29uRGlmZi5lcXVhbHMgPSBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICByZXR1cm4gRGlmZi5wcm90b3R5cGUuZXF1YWxzLmNhbGwoanNvbkRpZmYsIGxlZnQucmVwbGFjZSgvLChbXFxyXFxuXSkvZywgJyQxJyksIHJpZ2h0LnJlcGxhY2UoLywoW1xcclxcbl0pL2csICckMScpKTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBkaWZmSnNvbihvbGRPYmosIG5ld09iaiwgb3B0aW9ucykgeyByZXR1cm4ganNvbkRpZmYuZGlmZihvbGRPYmosIG5ld09iaiwgb3B0aW9ucyk7IH1cblxuLy8gVGhpcyBmdW5jdGlvbiBoYW5kbGVzIHRoZSBwcmVzZW5jZSBvZiBjaXJjdWxhciByZWZlcmVuY2VzIGJ5IGJhaWxpbmcgb3V0IHdoZW4gZW5jb3VudGVyaW5nIGFuXG4vLyBvYmplY3QgdGhhdCBpcyBhbHJlYWR5IG9uIHRoZSBcInN0YWNrXCIgb2YgaXRlbXMgYmVpbmcgcHJvY2Vzc2VkLiBBY2NlcHRzIGFuIG9wdGlvbmFsIHJlcGxhY2VyXG5leHBvcnQgZnVuY3Rpb24gY2Fub25pY2FsaXplKG9iaiwgc3RhY2ssIHJlcGxhY2VtZW50U3RhY2ssIHJlcGxhY2VyLCBrZXkpIHtcbiAgc3RhY2sgPSBzdGFjayB8fCBbXTtcbiAgcmVwbGFjZW1lbnRTdGFjayA9IHJlcGxhY2VtZW50U3RhY2sgfHwgW107XG5cbiAgaWYgKHJlcGxhY2VyKSB7XG4gICAgb2JqID0gcmVwbGFjZXIoa2V5LCBvYmopO1xuICB9XG5cbiAgbGV0IGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKHN0YWNrW2ldID09PSBvYmopIHtcbiAgICAgIHJldHVybiByZXBsYWNlbWVudFN0YWNrW2ldO1xuICAgIH1cbiAgfVxuXG4gIGxldCBjYW5vbmljYWxpemVkT2JqO1xuXG4gIGlmICgnW29iamVjdCBBcnJheV0nID09PSBvYmplY3RQcm90b3R5cGVUb1N0cmluZy5jYWxsKG9iaikpIHtcbiAgICBzdGFjay5wdXNoKG9iaik7XG4gICAgY2Fub25pY2FsaXplZE9iaiA9IG5ldyBBcnJheShvYmoubGVuZ3RoKTtcbiAgICByZXBsYWNlbWVudFN0YWNrLnB1c2goY2Fub25pY2FsaXplZE9iaik7XG4gICAgZm9yIChpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgY2Fub25pY2FsaXplZE9ialtpXSA9IGNhbm9uaWNhbGl6ZShvYmpbaV0sIHN0YWNrLCByZXBsYWNlbWVudFN0YWNrLCByZXBsYWNlciwga2V5KTtcbiAgICB9XG4gICAgc3RhY2sucG9wKCk7XG4gICAgcmVwbGFjZW1lbnRTdGFjay5wb3AoKTtcbiAgICByZXR1cm4gY2Fub25pY2FsaXplZE9iajtcbiAgfVxuXG4gIGlmIChvYmogJiYgb2JqLnRvSlNPTikge1xuICAgIG9iaiA9IG9iai50b0pTT04oKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmogIT09IG51bGwpIHtcbiAgICBzdGFjay5wdXNoKG9iaik7XG4gICAgY2Fub25pY2FsaXplZE9iaiA9IHt9O1xuICAgIHJlcGxhY2VtZW50U3RhY2sucHVzaChjYW5vbmljYWxpemVkT2JqKTtcbiAgICBsZXQgc29ydGVkS2V5cyA9IFtdLFxuICAgICAgICBrZXk7XG4gICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHNvcnRlZEtleXMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBzb3J0ZWRLZXlzLnNvcnQoKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc29ydGVkS2V5cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAga2V5ID0gc29ydGVkS2V5c1tpXTtcbiAgICAgIGNhbm9uaWNhbGl6ZWRPYmpba2V5XSA9IGNhbm9uaWNhbGl6ZShvYmpba2V5XSwgc3RhY2ssIHJlcGxhY2VtZW50U3RhY2ssIHJlcGxhY2VyLCBrZXkpO1xuICAgIH1cbiAgICBzdGFjay5wb3AoKTtcbiAgICByZXBsYWNlbWVudFN0YWNrLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIGNhbm9uaWNhbGl6ZWRPYmogPSBvYmo7XG4gIH1cbiAgcmV0dXJuIGNhbm9uaWNhbGl6ZWRPYmo7XG59XG4iXX0=\r\n\r\n\r\n/***/ }),\r\n/* 9 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\t/*istanbul ignore start*/'use strict';\r\n\r\n\texports.__esModule = true;\r\n\texports.arrayDiff = undefined;\r\n\texports. /*istanbul ignore end*/diffArrays = diffArrays;\r\n\r\n\tvar /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;\r\n\r\n\t/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);\r\n\r\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\r\n\r\n\t/*istanbul ignore end*/var arrayDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/arrayDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();\r\n\tarrayDiff.tokenize = function (value) {\r\n\t  return value.slice();\r\n\t};\r\n\tarrayDiff.join = arrayDiff.removeEmpty = function (value) {\r\n\t  return value;\r\n\t};\r\n\r\n\tfunction diffArrays(oldArr, newArr, callback) {\r\n\t  return arrayDiff.diff(oldArr, newArr, callback);\r\n\t}\r\n\t//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kaWZmL2FycmF5LmpzIl0sIm5hbWVzIjpbImRpZmZBcnJheXMiLCJhcnJheURpZmYiLCJ0b2tlbml6ZSIsInZhbHVlIiwic2xpY2UiLCJqb2luIiwicmVtb3ZlRW1wdHkiLCJvbGRBcnIiLCJuZXdBcnIiLCJjYWxsYmFjayIsImRpZmYiXSwibWFwcGluZ3MiOiI7Ozs7Z0NBVWdCQSxVLEdBQUFBLFU7O0FBVmhCOzs7Ozs7dUJBRU8sSUFBTUMsaUZBQVksd0VBQWxCO0FBQ1BBLFVBQVVDLFFBQVYsR0FBcUIsVUFBU0MsS0FBVCxFQUFnQjtBQUNuQyxTQUFPQSxNQUFNQyxLQUFOLEVBQVA7QUFDRCxDQUZEO0FBR0FILFVBQVVJLElBQVYsR0FBaUJKLFVBQVVLLFdBQVYsR0FBd0IsVUFBU0gsS0FBVCxFQUFnQjtBQUN2RCxTQUFPQSxLQUFQO0FBQ0QsQ0FGRDs7QUFJTyxTQUFTSCxVQUFULENBQW9CTyxNQUFwQixFQUE0QkMsTUFBNUIsRUFBb0NDLFFBQXBDLEVBQThDO0FBQUUsU0FBT1IsVUFBVVMsSUFBVixDQUFlSCxNQUFmLEVBQXVCQyxNQUF2QixFQUErQkMsUUFBL0IsQ0FBUDtBQUFrRCIsImZpbGUiOiJhcnJheS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBEaWZmIGZyb20gJy4vYmFzZSc7XG5cbmV4cG9ydCBjb25zdCBhcnJheURpZmYgPSBuZXcgRGlmZigpO1xuYXJyYXlEaWZmLnRva2VuaXplID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLnNsaWNlKCk7XG59O1xuYXJyYXlEaWZmLmpvaW4gPSBhcnJheURpZmYucmVtb3ZlRW1wdHkgPSBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZGlmZkFycmF5cyhvbGRBcnIsIG5ld0FyciwgY2FsbGJhY2spIHsgcmV0dXJuIGFycmF5RGlmZi5kaWZmKG9sZEFyciwgbmV3QXJyLCBjYWxsYmFjayk7IH1cbiJdfQ==\r\n\r\n\r\n/***/ }),\r\n/* 10 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\t/*istanbul ignore start*/'use strict';\r\n\r\n\texports.__esModule = true;\r\n\texports. /*istanbul ignore end*/applyPatch = applyPatch;\r\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/applyPatches = applyPatches;\r\n\r\n\tvar /*istanbul ignore start*/_parse = __webpack_require__(11) /*istanbul ignore end*/;\r\n\r\n\tvar /*istanbul ignore start*/_distanceIterator = __webpack_require__(12) /*istanbul ignore end*/;\r\n\r\n\t/*istanbul ignore start*/var _distanceIterator2 = _interopRequireDefault(_distanceIterator);\r\n\r\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\r\n\r\n\t/*istanbul ignore end*/function applyPatch(source, uniDiff) {\r\n\t  /*istanbul ignore start*/var /*istanbul ignore end*/options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\r\n\r\n\t  if (typeof uniDiff === 'string') {\r\n\t    uniDiff = /*istanbul ignore start*/(0, _parse.parsePatch) /*istanbul ignore end*/(uniDiff);\r\n\t  }\r\n\r\n\t  if (Array.isArray(uniDiff)) {\r\n\t    if (uniDiff.length > 1) {\r\n\t      throw new Error('applyPatch only works with a single input.');\r\n\t    }\r\n\r\n\t    uniDiff = uniDiff[0];\r\n\t  }\r\n\r\n\t  // Apply the diff to the input\r\n\t  var lines = source.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\r\n\t      delimiters = source.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\r\n\t      hunks = uniDiff.hunks,\r\n\t      compareLine = options.compareLine || function (lineNumber, line, operation, patchContent) /*istanbul ignore start*/{\r\n\t    return (/*istanbul ignore end*/line === patchContent\r\n\t    );\r\n\t  },\r\n\t      errorCount = 0,\r\n\t      fuzzFactor = options.fuzzFactor || 0,\r\n\t      minLine = 0,\r\n\t      offset = 0,\r\n\t      removeEOFNL = /*istanbul ignore start*/void 0 /*istanbul ignore end*/,\r\n\t      addEOFNL = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;\r\n\r\n\t  /**\r\n\t   * Checks if the hunk exactly fits on the provided location\r\n\t   */\r\n\t  function hunkFits(hunk, toPos) {\r\n\t    for (var j = 0; j < hunk.lines.length; j++) {\r\n\t      var line = hunk.lines[j],\r\n\t          operation = line.length > 0 ? line[0] : ' ',\r\n\t          content = line.length > 0 ? line.substr(1) : line;\r\n\r\n\t      if (operation === ' ' || operation === '-') {\r\n\t        // Context sanity check\r\n\t        if (!compareLine(toPos + 1, lines[toPos], operation, content)) {\r\n\t          errorCount++;\r\n\r\n\t          if (errorCount > fuzzFactor) {\r\n\t            return false;\r\n\t          }\r\n\t        }\r\n\t        toPos++;\r\n\t      }\r\n\t    }\r\n\r\n\t    return true;\r\n\t  }\r\n\r\n\t  // Search best fit offsets for each hunk based on the previous ones\r\n\t  for (var i = 0; i < hunks.length; i++) {\r\n\t    var hunk = hunks[i],\r\n\t        maxLine = lines.length - hunk.oldLines,\r\n\t        localOffset = 0,\r\n\t        toPos = offset + hunk.oldStart - 1;\r\n\r\n\t    var iterator = /*istanbul ignore start*/(0, _distanceIterator2['default']) /*istanbul ignore end*/(toPos, minLine, maxLine);\r\n\r\n\t    for (; localOffset !== undefined; localOffset = iterator()) {\r\n\t      if (hunkFits(hunk, toPos + localOffset)) {\r\n\t        hunk.offset = offset += localOffset;\r\n\t        break;\r\n\t      }\r\n\t    }\r\n\r\n\t    if (localOffset === undefined) {\r\n\t      return false;\r\n\t    }\r\n\r\n\t    // Set lower text limit to end of the current hunk, so next ones don't try\r\n\t    // to fit over already patched text\r\n\t    minLine = hunk.offset + hunk.oldStart + hunk.oldLines;\r\n\t  }\r\n\r\n\t  // Apply patch hunks\r\n\t  var diffOffset = 0;\r\n\t  for (var _i = 0; _i < hunks.length; _i++) {\r\n\t    var _hunk = hunks[_i],\r\n\t        _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;\r\n\t    diffOffset += _hunk.newLines - _hunk.oldLines;\r\n\r\n\t    if (_toPos < 0) {\r\n\t      // Creating a new file\r\n\t      _toPos = 0;\r\n\t    }\r\n\r\n\t    for (var j = 0; j < _hunk.lines.length; j++) {\r\n\t      var line = _hunk.lines[j],\r\n\t          operation = line.length > 0 ? line[0] : ' ',\r\n\t          content = line.length > 0 ? line.substr(1) : line,\r\n\t          delimiter = _hunk.linedelimiters[j];\r\n\r\n\t      if (operation === ' ') {\r\n\t        _toPos++;\r\n\t      } else if (operation === '-') {\r\n\t        lines.splice(_toPos, 1);\r\n\t        delimiters.splice(_toPos, 1);\r\n\t        /* istanbul ignore else */\r\n\t      } else if (operation === '+') {\r\n\t        lines.splice(_toPos, 0, content);\r\n\t        delimiters.splice(_toPos, 0, delimiter);\r\n\t        _toPos++;\r\n\t      } else if (operation === '\\\\') {\r\n\t        var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;\r\n\t        if (previousOperation === '+') {\r\n\t          removeEOFNL = true;\r\n\t        } else if (previousOperation === '-') {\r\n\t          addEOFNL = true;\r\n\t        }\r\n\t      }\r\n\t    }\r\n\t  }\r\n\r\n\t  // Handle EOFNL insertion/removal\r\n\t  if (removeEOFNL) {\r\n\t    while (!lines[lines.length - 1]) {\r\n\t      lines.pop();\r\n\t      delimiters.pop();\r\n\t    }\r\n\t  } else if (addEOFNL) {\r\n\t    lines.push('');\r\n\t    delimiters.push('\\n');\r\n\t  }\r\n\t  for (var _k = 0; _k < lines.length - 1; _k++) {\r\n\t    lines[_k] = lines[_k] + delimiters[_k];\r\n\t  }\r\n\t  return lines.join('');\r\n\t}\r\n\r\n\t// Wrapper that supports multiple file patches via callbacks.\r\n\tfunction applyPatches(uniDiff, options) {\r\n\t  if (typeof uniDiff === 'string') {\r\n\t    uniDiff = /*istanbul ignore start*/(0, _parse.parsePatch) /*istanbul ignore end*/(uniDiff);\r\n\t  }\r\n\r\n\t  var currentIndex = 0;\r\n\t  function processIndex() {\r\n\t    var index = uniDiff[currentIndex++];\r\n\t    if (!index) {\r\n\t      return options.complete();\r\n\t    }\r\n\r\n\t    options.loadFile(index, function (err, data) {\r\n\t      if (err) {\r\n\t        return options.complete(err);\r\n\t      }\r\n\r\n\t      var updatedContent = applyPatch(data, index, options);\r\n\t      options.patched(index, updatedContent, function (err) {\r\n\t        if (err) {\r\n\t          return options.complete(err);\r\n\t        }\r\n\r\n\t        processIndex();\r\n\t      });\r\n\t    });\r\n\t  }\r\n\t  processIndex();\r\n\t}\r\n\t//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wYXRjaC9hcHBseS5qcyJdLCJuYW1lcyI6WyJhcHBseVBhdGNoIiwiYXBwbHlQYXRjaGVzIiwic291cmNlIiwidW5pRGlmZiIsIm9wdGlvbnMiLCJBcnJheSIsImlzQXJyYXkiLCJsZW5ndGgiLCJFcnJvciIsImxpbmVzIiwic3BsaXQiLCJkZWxpbWl0ZXJzIiwibWF0Y2giLCJodW5rcyIsImNvbXBhcmVMaW5lIiwibGluZU51bWJlciIsImxpbmUiLCJvcGVyYXRpb24iLCJwYXRjaENvbnRlbnQiLCJlcnJvckNvdW50IiwiZnV6ekZhY3RvciIsIm1pbkxpbmUiLCJvZmZzZXQiLCJyZW1vdmVFT0ZOTCIsImFkZEVPRk5MIiwiaHVua0ZpdHMiLCJodW5rIiwidG9Qb3MiLCJqIiwiY29udGVudCIsInN1YnN0ciIsImkiLCJtYXhMaW5lIiwib2xkTGluZXMiLCJsb2NhbE9mZnNldCIsIm9sZFN0YXJ0IiwiaXRlcmF0b3IiLCJ1bmRlZmluZWQiLCJkaWZmT2Zmc2V0IiwibmV3TGluZXMiLCJkZWxpbWl0ZXIiLCJsaW5lZGVsaW1pdGVycyIsInNwbGljZSIsInByZXZpb3VzT3BlcmF0aW9uIiwicG9wIiwicHVzaCIsIl9rIiwiam9pbiIsImN1cnJlbnRJbmRleCIsInByb2Nlc3NJbmRleCIsImluZGV4IiwiY29tcGxldGUiLCJsb2FkRmlsZSIsImVyciIsImRhdGEiLCJ1cGRhdGVkQ29udGVudCIsInBhdGNoZWQiXSwibWFwcGluZ3MiOiI7OztnQ0FHZ0JBLFUsR0FBQUEsVTt5REFvSUFDLFksR0FBQUEsWTs7QUF2SWhCOztBQUNBOzs7Ozs7dUJBRU8sU0FBU0QsVUFBVCxDQUFvQkUsTUFBcEIsRUFBNEJDLE9BQTVCLEVBQW1EO0FBQUEsc0RBQWRDLE9BQWMsdUVBQUosRUFBSTs7QUFDeEQsTUFBSSxPQUFPRCxPQUFQLEtBQW1CLFFBQXZCLEVBQWlDO0FBQy9CQSxjQUFVLHdFQUFXQSxPQUFYLENBQVY7QUFDRDs7QUFFRCxNQUFJRSxNQUFNQyxPQUFOLENBQWNILE9BQWQsQ0FBSixFQUE0QjtBQUMxQixRQUFJQSxRQUFRSSxNQUFSLEdBQWlCLENBQXJCLEVBQXdCO0FBQ3RCLFlBQU0sSUFBSUMsS0FBSixDQUFVLDRDQUFWLENBQU47QUFDRDs7QUFFREwsY0FBVUEsUUFBUSxDQUFSLENBQVY7QUFDRDs7QUFFRDtBQUNBLE1BQUlNLFFBQVFQLE9BQU9RLEtBQVAsQ0FBYSxxQkFBYixDQUFaO0FBQUEsTUFDSUMsYUFBYVQsT0FBT1UsS0FBUCxDQUFhLHNCQUFiLEtBQXdDLEVBRHpEO0FBQUEsTUFFSUMsUUFBUVYsUUFBUVUsS0FGcEI7QUFBQSxNQUlJQyxjQUFjVixRQUFRVSxXQUFSLElBQXdCLFVBQUNDLFVBQUQsRUFBYUMsSUFBYixFQUFtQkMsU0FBbkIsRUFBOEJDLFlBQTlCO0FBQUEsbUNBQStDRixTQUFTRTtBQUF4RDtBQUFBLEdBSjFDO0FBQUEsTUFLSUMsYUFBYSxDQUxqQjtBQUFBLE1BTUlDLGFBQWFoQixRQUFRZ0IsVUFBUixJQUFzQixDQU52QztBQUFBLE1BT0lDLFVBQVUsQ0FQZDtBQUFBLE1BUUlDLFNBQVMsQ0FSYjtBQUFBLE1BVUlDLDZDQVZKO0FBQUEsTUFXSUMsMENBWEo7O0FBYUE7OztBQUdBLFdBQVNDLFFBQVQsQ0FBa0JDLElBQWxCLEVBQXdCQyxLQUF4QixFQUErQjtBQUM3QixTQUFLLElBQUlDLElBQUksQ0FBYixFQUFnQkEsSUFBSUYsS0FBS2pCLEtBQUwsQ0FBV0YsTUFBL0IsRUFBdUNxQixHQUF2QyxFQUE0QztBQUMxQyxVQUFJWixPQUFPVSxLQUFLakIsS0FBTCxDQUFXbUIsQ0FBWCxDQUFYO0FBQUEsVUFDSVgsWUFBYUQsS0FBS1QsTUFBTCxHQUFjLENBQWQsR0FBa0JTLEtBQUssQ0FBTCxDQUFsQixHQUE0QixHQUQ3QztBQUFBLFVBRUlhLFVBQVdiLEtBQUtULE1BQUwsR0FBYyxDQUFkLEdBQWtCUyxLQUFLYyxNQUFMLENBQVksQ0FBWixDQUFsQixHQUFtQ2QsSUFGbEQ7O0FBSUEsVUFBSUMsY0FBYyxHQUFkLElBQXFCQSxjQUFjLEdBQXZDLEVBQTRDO0FBQzFDO0FBQ0EsWUFBSSxDQUFDSCxZQUFZYSxRQUFRLENBQXBCLEVBQXVCbEIsTUFBTWtCLEtBQU4sQ0FBdkIsRUFBcUNWLFNBQXJDLEVBQWdEWSxPQUFoRCxDQUFMLEVBQStEO0FBQzdEVjs7QUFFQSxjQUFJQSxhQUFhQyxVQUFqQixFQUE2QjtBQUMzQixtQkFBTyxLQUFQO0FBQ0Q7QUFDRjtBQUNETztBQUNEO0FBQ0Y7O0FBRUQsV0FBTyxJQUFQO0FBQ0Q7O0FBRUQ7QUFDQSxPQUFLLElBQUlJLElBQUksQ0FBYixFQUFnQkEsSUFBSWxCLE1BQU1OLE1BQTFCLEVBQWtDd0IsR0FBbEMsRUFBdUM7QUFDckMsUUFBSUwsT0FBT2IsTUFBTWtCLENBQU4sQ0FBWDtBQUFBLFFBQ0lDLFVBQVV2QixNQUFNRixNQUFOLEdBQWVtQixLQUFLTyxRQURsQztBQUFBLFFBRUlDLGNBQWMsQ0FGbEI7QUFBQSxRQUdJUCxRQUFRTCxTQUFTSSxLQUFLUyxRQUFkLEdBQXlCLENBSHJDOztBQUtBLFFBQUlDLFdBQVcsb0ZBQWlCVCxLQUFqQixFQUF3Qk4sT0FBeEIsRUFBaUNXLE9BQWpDLENBQWY7O0FBRUEsV0FBT0UsZ0JBQWdCRyxTQUF2QixFQUFrQ0gsY0FBY0UsVUFBaEQsRUFBNEQ7QUFDMUQsVUFBSVgsU0FBU0MsSUFBVCxFQUFlQyxRQUFRTyxXQUF2QixDQUFKLEVBQXlDO0FBQ3ZDUixhQUFLSixNQUFMLEdBQWNBLFVBQVVZLFdBQXhCO0FBQ0E7QUFDRDtBQUNGOztBQUVELFFBQUlBLGdCQUFnQkcsU0FBcEIsRUFBK0I7QUFDN0IsYUFBTyxLQUFQO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBaEIsY0FBVUssS0FBS0osTUFBTCxHQUFjSSxLQUFLUyxRQUFuQixHQUE4QlQsS0FBS08sUUFBN0M7QUFDRDs7QUFFRDtBQUNBLE1BQUlLLGFBQWEsQ0FBakI7QUFDQSxPQUFLLElBQUlQLEtBQUksQ0FBYixFQUFnQkEsS0FBSWxCLE1BQU1OLE1BQTFCLEVBQWtDd0IsSUFBbEMsRUFBdUM7QUFDckMsUUFBSUwsUUFBT2IsTUFBTWtCLEVBQU4sQ0FBWDtBQUFBLFFBQ0lKLFNBQVFELE1BQUtTLFFBQUwsR0FBZ0JULE1BQUtKLE1BQXJCLEdBQThCZ0IsVUFBOUIsR0FBMkMsQ0FEdkQ7QUFFQUEsa0JBQWNaLE1BQUthLFFBQUwsR0FBZ0JiLE1BQUtPLFFBQW5DOztBQUVBLFFBQUlOLFNBQVEsQ0FBWixFQUFlO0FBQUU7QUFDZkEsZUFBUSxDQUFSO0FBQ0Q7O0FBRUQsU0FBSyxJQUFJQyxJQUFJLENBQWIsRUFBZ0JBLElBQUlGLE1BQUtqQixLQUFMLENBQVdGLE1BQS9CLEVBQXVDcUIsR0FBdkMsRUFBNEM7QUFDMUMsVUFBSVosT0FBT1UsTUFBS2pCLEtBQUwsQ0FBV21CLENBQVgsQ0FBWDtBQUFBLFVBQ0lYLFlBQWFELEtBQUtULE1BQUwsR0FBYyxDQUFkLEdBQWtCUyxLQUFLLENBQUwsQ0FBbEIsR0FBNEIsR0FEN0M7QUFBQSxVQUVJYSxVQUFXYixLQUFLVCxNQUFMLEdBQWMsQ0FBZCxHQUFrQlMsS0FBS2MsTUFBTCxDQUFZLENBQVosQ0FBbEIsR0FBbUNkLElBRmxEO0FBQUEsVUFHSXdCLFlBQVlkLE1BQUtlLGNBQUwsQ0FBb0JiLENBQXBCLENBSGhCOztBQUtBLFVBQUlYLGNBQWMsR0FBbEIsRUFBdUI7QUFDckJVO0FBQ0QsT0FGRCxNQUVPLElBQUlWLGNBQWMsR0FBbEIsRUFBdUI7QUFDNUJSLGNBQU1pQyxNQUFOLENBQWFmLE1BQWIsRUFBb0IsQ0FBcEI7QUFDQWhCLG1CQUFXK0IsTUFBWCxDQUFrQmYsTUFBbEIsRUFBeUIsQ0FBekI7QUFDRjtBQUNDLE9BSk0sTUFJQSxJQUFJVixjQUFjLEdBQWxCLEVBQXVCO0FBQzVCUixjQUFNaUMsTUFBTixDQUFhZixNQUFiLEVBQW9CLENBQXBCLEVBQXVCRSxPQUF2QjtBQUNBbEIsbUJBQVcrQixNQUFYLENBQWtCZixNQUFsQixFQUF5QixDQUF6QixFQUE0QmEsU0FBNUI7QUFDQWI7QUFDRCxPQUpNLE1BSUEsSUFBSVYsY0FBYyxJQUFsQixFQUF3QjtBQUM3QixZQUFJMEIsb0JBQW9CakIsTUFBS2pCLEtBQUwsQ0FBV21CLElBQUksQ0FBZixJQUFvQkYsTUFBS2pCLEtBQUwsQ0FBV21CLElBQUksQ0FBZixFQUFrQixDQUFsQixDQUFwQixHQUEyQyxJQUFuRTtBQUNBLFlBQUllLHNCQUFzQixHQUExQixFQUErQjtBQUM3QnBCLHdCQUFjLElBQWQ7QUFDRCxTQUZELE1BRU8sSUFBSW9CLHNCQUFzQixHQUExQixFQUErQjtBQUNwQ25CLHFCQUFXLElBQVg7QUFDRDtBQUNGO0FBQ0Y7QUFDRjs7QUFFRDtBQUNBLE1BQUlELFdBQUosRUFBaUI7QUFDZixXQUFPLENBQUNkLE1BQU1BLE1BQU1GLE1BQU4sR0FBZSxDQUFyQixDQUFSLEVBQWlDO0FBQy9CRSxZQUFNbUMsR0FBTjtBQUNBakMsaUJBQVdpQyxHQUFYO0FBQ0Q7QUFDRixHQUxELE1BS08sSUFBSXBCLFFBQUosRUFBYztBQUNuQmYsVUFBTW9DLElBQU4sQ0FBVyxFQUFYO0FBQ0FsQyxlQUFXa0MsSUFBWCxDQUFnQixJQUFoQjtBQUNEO0FBQ0QsT0FBSyxJQUFJQyxLQUFLLENBQWQsRUFBaUJBLEtBQUtyQyxNQUFNRixNQUFOLEdBQWUsQ0FBckMsRUFBd0N1QyxJQUF4QyxFQUE4QztBQUM1Q3JDLFVBQU1xQyxFQUFOLElBQVlyQyxNQUFNcUMsRUFBTixJQUFZbkMsV0FBV21DLEVBQVgsQ0FBeEI7QUFDRDtBQUNELFNBQU9yQyxNQUFNc0MsSUFBTixDQUFXLEVBQVgsQ0FBUDtBQUNEOztBQUVEO0FBQ08sU0FBUzlDLFlBQVQsQ0FBc0JFLE9BQXRCLEVBQStCQyxPQUEvQixFQUF3QztBQUM3QyxNQUFJLE9BQU9ELE9BQVAsS0FBbUIsUUFBdkIsRUFBaUM7QUFDL0JBLGNBQVUsd0VBQVdBLE9BQVgsQ0FBVjtBQUNEOztBQUVELE1BQUk2QyxlQUFlLENBQW5CO0FBQ0EsV0FBU0MsWUFBVCxHQUF3QjtBQUN0QixRQUFJQyxRQUFRL0MsUUFBUTZDLGNBQVIsQ0FBWjtBQUNBLFFBQUksQ0FBQ0UsS0FBTCxFQUFZO0FBQ1YsYUFBTzlDLFFBQVErQyxRQUFSLEVBQVA7QUFDRDs7QUFFRC9DLFlBQVFnRCxRQUFSLENBQWlCRixLQUFqQixFQUF3QixVQUFTRyxHQUFULEVBQWNDLElBQWQsRUFBb0I7QUFDMUMsVUFBSUQsR0FBSixFQUFTO0FBQ1AsZUFBT2pELFFBQVErQyxRQUFSLENBQWlCRSxHQUFqQixDQUFQO0FBQ0Q7O0FBRUQsVUFBSUUsaUJBQWlCdkQsV0FBV3NELElBQVgsRUFBaUJKLEtBQWpCLEVBQXdCOUMsT0FBeEIsQ0FBckI7QUFDQUEsY0FBUW9ELE9BQVIsQ0FBZ0JOLEtBQWhCLEVBQXVCSyxjQUF2QixFQUF1QyxVQUFTRixHQUFULEVBQWM7QUFDbkQsWUFBSUEsR0FBSixFQUFTO0FBQ1AsaUJBQU9qRCxRQUFRK0MsUUFBUixDQUFpQkUsR0FBakIsQ0FBUDtBQUNEOztBQUVESjtBQUNELE9BTkQ7QUFPRCxLQWJEO0FBY0Q7QUFDREE7QUFDRCIsImZpbGUiOiJhcHBseS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7cGFyc2VQYXRjaH0gZnJvbSAnLi9wYXJzZSc7XG5pbXBvcnQgZGlzdGFuY2VJdGVyYXRvciBmcm9tICcuLi91dGlsL2Rpc3RhbmNlLWl0ZXJhdG9yJztcblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5UGF0Y2goc291cmNlLCB1bmlEaWZmLCBvcHRpb25zID0ge30pIHtcbiAgaWYgKHR5cGVvZiB1bmlEaWZmID09PSAnc3RyaW5nJykge1xuICAgIHVuaURpZmYgPSBwYXJzZVBhdGNoKHVuaURpZmYpO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodW5pRGlmZikpIHtcbiAgICBpZiAodW5pRGlmZi5sZW5ndGggPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FwcGx5UGF0Y2ggb25seSB3b3JrcyB3aXRoIGEgc2luZ2xlIGlucHV0LicpO1xuICAgIH1cblxuICAgIHVuaURpZmYgPSB1bmlEaWZmWzBdO1xuICB9XG5cbiAgLy8gQXBwbHkgdGhlIGRpZmYgdG8gdGhlIGlucHV0XG4gIGxldCBsaW5lcyA9IHNvdXJjZS5zcGxpdCgvXFxyXFxufFtcXG5cXHZcXGZcXHJcXHg4NV0vKSxcbiAgICAgIGRlbGltaXRlcnMgPSBzb3VyY2UubWF0Y2goL1xcclxcbnxbXFxuXFx2XFxmXFxyXFx4ODVdL2cpIHx8IFtdLFxuICAgICAgaHVua3MgPSB1bmlEaWZmLmh1bmtzLFxuXG4gICAgICBjb21wYXJlTGluZSA9IG9wdGlvbnMuY29tcGFyZUxpbmUgfHwgKChsaW5lTnVtYmVyLCBsaW5lLCBvcGVyYXRpb24sIHBhdGNoQ29udGVudCkgPT4gbGluZSA9PT0gcGF0Y2hDb250ZW50KSxcbiAgICAgIGVycm9yQ291bnQgPSAwLFxuICAgICAgZnV6ekZhY3RvciA9IG9wdGlvbnMuZnV6ekZhY3RvciB8fCAwLFxuICAgICAgbWluTGluZSA9IDAsXG4gICAgICBvZmZzZXQgPSAwLFxuXG4gICAgICByZW1vdmVFT0ZOTCxcbiAgICAgIGFkZEVPRk5MO1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGh1bmsgZXhhY3RseSBmaXRzIG9uIHRoZSBwcm92aWRlZCBsb2NhdGlvblxuICAgKi9cbiAgZnVuY3Rpb24gaHVua0ZpdHMoaHVuaywgdG9Qb3MpIHtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGh1bmsubGluZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGxldCBsaW5lID0gaHVuay5saW5lc1tqXSxcbiAgICAgICAgICBvcGVyYXRpb24gPSAobGluZS5sZW5ndGggPiAwID8gbGluZVswXSA6ICcgJyksXG4gICAgICAgICAgY29udGVudCA9IChsaW5lLmxlbmd0aCA+IDAgPyBsaW5lLnN1YnN0cigxKSA6IGxpbmUpO1xuXG4gICAgICBpZiAob3BlcmF0aW9uID09PSAnICcgfHwgb3BlcmF0aW9uID09PSAnLScpIHtcbiAgICAgICAgLy8gQ29udGV4dCBzYW5pdHkgY2hlY2tcbiAgICAgICAgaWYgKCFjb21wYXJlTGluZSh0b1BvcyArIDEsIGxpbmVzW3RvUG9zXSwgb3BlcmF0aW9uLCBjb250ZW50KSkge1xuICAgICAgICAgIGVycm9yQ291bnQrKztcblxuICAgICAgICAgIGlmIChlcnJvckNvdW50ID4gZnV6ekZhY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0b1BvcysrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gU2VhcmNoIGJlc3QgZml0IG9mZnNldHMgZm9yIGVhY2ggaHVuayBiYXNlZCBvbiB0aGUgcHJldmlvdXMgb25lc1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGh1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGh1bmsgPSBodW5rc1tpXSxcbiAgICAgICAgbWF4TGluZSA9IGxpbmVzLmxlbmd0aCAtIGh1bmsub2xkTGluZXMsXG4gICAgICAgIGxvY2FsT2Zmc2V0ID0gMCxcbiAgICAgICAgdG9Qb3MgPSBvZmZzZXQgKyBodW5rLm9sZFN0YXJ0IC0gMTtcblxuICAgIGxldCBpdGVyYXRvciA9IGRpc3RhbmNlSXRlcmF0b3IodG9Qb3MsIG1pbkxpbmUsIG1heExpbmUpO1xuXG4gICAgZm9yICg7IGxvY2FsT2Zmc2V0ICE9PSB1bmRlZmluZWQ7IGxvY2FsT2Zmc2V0ID0gaXRlcmF0b3IoKSkge1xuICAgICAgaWYgKGh1bmtGaXRzKGh1bmssIHRvUG9zICsgbG9jYWxPZmZzZXQpKSB7XG4gICAgICAgIGh1bmsub2Zmc2V0ID0gb2Zmc2V0ICs9IGxvY2FsT2Zmc2V0O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobG9jYWxPZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFNldCBsb3dlciB0ZXh0IGxpbWl0IHRvIGVuZCBvZiB0aGUgY3VycmVudCBodW5rLCBzbyBuZXh0IG9uZXMgZG9uJ3QgdHJ5XG4gICAgLy8gdG8gZml0IG92ZXIgYWxyZWFkeSBwYXRjaGVkIHRleHRcbiAgICBtaW5MaW5lID0gaHVuay5vZmZzZXQgKyBodW5rLm9sZFN0YXJ0ICsgaHVuay5vbGRMaW5lcztcbiAgfVxuXG4gIC8vIEFwcGx5IHBhdGNoIGh1bmtzXG4gIGxldCBkaWZmT2Zmc2V0ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBodW5rcy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBodW5rID0gaHVua3NbaV0sXG4gICAgICAgIHRvUG9zID0gaHVuay5vbGRTdGFydCArIGh1bmsub2Zmc2V0ICsgZGlmZk9mZnNldCAtIDE7XG4gICAgZGlmZk9mZnNldCArPSBodW5rLm5ld0xpbmVzIC0gaHVuay5vbGRMaW5lcztcblxuICAgIGlmICh0b1BvcyA8IDApIHsgLy8gQ3JlYXRpbmcgYSBuZXcgZmlsZVxuICAgICAgdG9Qb3MgPSAwO1xuICAgIH1cblxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgaHVuay5saW5lcy5sZW5ndGg7IGorKykge1xuICAgICAgbGV0IGxpbmUgPSBodW5rLmxpbmVzW2pdLFxuICAgICAgICAgIG9wZXJhdGlvbiA9IChsaW5lLmxlbmd0aCA+IDAgPyBsaW5lWzBdIDogJyAnKSxcbiAgICAgICAgICBjb250ZW50ID0gKGxpbmUubGVuZ3RoID4gMCA/IGxpbmUuc3Vic3RyKDEpIDogbGluZSksXG4gICAgICAgICAgZGVsaW1pdGVyID0gaHVuay5saW5lZGVsaW1pdGVyc1tqXTtcblxuICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gJyAnKSB7XG4gICAgICAgIHRvUG9zKys7XG4gICAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbiA9PT0gJy0nKSB7XG4gICAgICAgIGxpbmVzLnNwbGljZSh0b1BvcywgMSk7XG4gICAgICAgIGRlbGltaXRlcnMuc3BsaWNlKHRvUG9zLCAxKTtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbiA9PT0gJysnKSB7XG4gICAgICAgIGxpbmVzLnNwbGljZSh0b1BvcywgMCwgY29udGVudCk7XG4gICAgICAgIGRlbGltaXRlcnMuc3BsaWNlKHRvUG9zLCAwLCBkZWxpbWl0ZXIpO1xuICAgICAgICB0b1BvcysrO1xuICAgICAgfSBlbHNlIGlmIChvcGVyYXRpb24gPT09ICdcXFxcJykge1xuICAgICAgICBsZXQgcHJldmlvdXNPcGVyYXRpb24gPSBodW5rLmxpbmVzW2ogLSAxXSA/IGh1bmsubGluZXNbaiAtIDFdWzBdIDogbnVsbDtcbiAgICAgICAgaWYgKHByZXZpb3VzT3BlcmF0aW9uID09PSAnKycpIHtcbiAgICAgICAgICByZW1vdmVFT0ZOTCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAocHJldmlvdXNPcGVyYXRpb24gPT09ICctJykge1xuICAgICAgICAgIGFkZEVPRk5MID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEhhbmRsZSBFT0ZOTCBpbnNlcnRpb24vcmVtb3ZhbFxuICBpZiAocmVtb3ZlRU9GTkwpIHtcbiAgICB3aGlsZSAoIWxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdKSB7XG4gICAgICBsaW5lcy5wb3AoKTtcbiAgICAgIGRlbGltaXRlcnMucG9wKCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGFkZEVPRk5MKSB7XG4gICAgbGluZXMucHVzaCgnJyk7XG4gICAgZGVsaW1pdGVycy5wdXNoKCdcXG4nKTtcbiAgfVxuICBmb3IgKGxldCBfayA9IDA7IF9rIDwgbGluZXMubGVuZ3RoIC0gMTsgX2srKykge1xuICAgIGxpbmVzW19rXSA9IGxpbmVzW19rXSArIGRlbGltaXRlcnNbX2tdO1xuICB9XG4gIHJldHVybiBsaW5lcy5qb2luKCcnKTtcbn1cblxuLy8gV3JhcHBlciB0aGF0IHN1cHBvcnRzIG11bHRpcGxlIGZpbGUgcGF0Y2hlcyB2aWEgY2FsbGJhY2tzLlxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5UGF0Y2hlcyh1bmlEaWZmLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgdW5pRGlmZiA9PT0gJ3N0cmluZycpIHtcbiAgICB1bmlEaWZmID0gcGFyc2VQYXRjaCh1bmlEaWZmKTtcbiAgfVxuXG4gIGxldCBjdXJyZW50SW5kZXggPSAwO1xuICBmdW5jdGlvbiBwcm9jZXNzSW5kZXgoKSB7XG4gICAgbGV0IGluZGV4ID0gdW5pRGlmZltjdXJyZW50SW5kZXgrK107XG4gICAgaWYgKCFpbmRleCkge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICBvcHRpb25zLmxvYWRGaWxlKGluZGV4LCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuY29tcGxldGUoZXJyKTtcbiAgICAgIH1cblxuICAgICAgbGV0IHVwZGF0ZWRDb250ZW50ID0gYXBwbHlQYXRjaChkYXRhLCBpbmRleCwgb3B0aW9ucyk7XG4gICAgICBvcHRpb25zLnBhdGNoZWQoaW5kZXgsIHVwZGF0ZWRDb250ZW50LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiBvcHRpb25zLmNvbXBsZXRlKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICBwcm9jZXNzSW5kZXgoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHByb2Nlc3NJbmRleCgpO1xufVxuIl19\r\n\r\n\r\n/***/ }),\r\n/* 11 */\r\n/***/ (function(module, exports) {\r\n\r\n\t/*istanbul ignore start*/'use strict';\r\n\r\n\texports.__esModule = true;\r\n\texports. /*istanbul ignore end*/parsePatch = parsePatch;\r\n\tfunction parsePatch(uniDiff) {\r\n\t  /*istanbul ignore start*/var /*istanbul ignore end*/options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\r\n\r\n\t  var diffstr = uniDiff.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\r\n\t      delimiters = uniDiff.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\r\n\t      list = [],\r\n\t      i = 0;\r\n\r\n\t  function parseIndex() {\r\n\t    var index = {};\r\n\t    list.push(index);\r\n\r\n\t    // Parse diff metadata\r\n\t    while (i < diffstr.length) {\r\n\t      var line = diffstr[i];\r\n\r\n\t      // File header found, end parsing diff metadata\r\n\t      if (/^(\\-\\-\\-|\\+\\+\\+|@@)\\s/.test(line)) {\r\n\t        break;\r\n\t      }\r\n\r\n\t      // Diff index\r\n\t      var header = /^(?:Index:|diff(?: -r \\w+)+)\\s+(.+?)\\s*$/.exec(line);\r\n\t      if (header) {\r\n\t        index.index = header[1];\r\n\t      }\r\n\r\n\t      i++;\r\n\t    }\r\n\r\n\t    // Parse file headers if they are defined. Unified diff requires them, but\r\n\t    // there's no technical issues to have an isolated hunk without file header\r\n\t    parseFileHeader(index);\r\n\t    parseFileHeader(index);\r\n\r\n\t    // Parse hunks\r\n\t    index.hunks = [];\r\n\r\n\t    while (i < diffstr.length) {\r\n\t      var _line = diffstr[i];\r\n\r\n\t      if (/^(Index:|diff|\\-\\-\\-|\\+\\+\\+)\\s/.test(_line)) {\r\n\t        break;\r\n\t      } else if (/^@@/.test(_line)) {\r\n\t        index.hunks.push(parseHunk());\r\n\t      } else if (_line && options.strict) {\r\n\t        // Ignore unexpected content unless in strict mode\r\n\t        throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));\r\n\t      } else {\r\n\t        i++;\r\n\t      }\r\n\t    }\r\n\t  }\r\n\r\n\t  // Parses the --- and +++ headers, if none are found, no lines\r\n\t  // are consumed.\r\n\t  function parseFileHeader(index) {\r\n\t    var fileHeader = /^(---|\\+\\+\\+)\\s+(.*)$/.exec(diffstr[i]);\r\n\t    if (fileHeader) {\r\n\t      var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';\r\n\t      var data = fileHeader[2].split('\\t', 2);\r\n\t      var fileName = data[0].replace(/\\\\\\\\/g, '\\\\');\r\n\t      if (/^\".*\"$/.test(fileName)) {\r\n\t        fileName = fileName.substr(1, fileName.length - 2);\r\n\t      }\r\n\t      index[keyPrefix + 'FileName'] = fileName;\r\n\t      index[keyPrefix + 'Header'] = (data[1] || '').trim();\r\n\r\n\t      i++;\r\n\t    }\r\n\t  }\r\n\r\n\t  // Parses a hunk\r\n\t  // This assumes that we are at the start of a hunk.\r\n\t  function parseHunk() {\r\n\t    var chunkHeaderIndex = i,\r\n\t        chunkHeaderLine = diffstr[i++],\r\n\t        chunkHeader = chunkHeaderLine.split(/@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/);\r\n\r\n\t    var hunk = {\r\n\t      oldStart: +chunkHeader[1],\r\n\t      oldLines: +chunkHeader[2] || 1,\r\n\t      newStart: +chunkHeader[3],\r\n\t      newLines: +chunkHeader[4] || 1,\r\n\t      lines: [],\r\n\t      linedelimiters: []\r\n\t    };\r\n\r\n\t    var addCount = 0,\r\n\t        removeCount = 0;\r\n\t    for (; i < diffstr.length; i++) {\r\n\t      // Lines starting with '---' could be mistaken for the \"remove line\" operation\r\n\t      // But they could be the header for the next file. Therefore prune such cases out.\r\n\t      if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {\r\n\t        break;\r\n\t      }\r\n\t      var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? ' ' : diffstr[i][0];\r\n\r\n\t      if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\\\') {\r\n\t        hunk.lines.push(diffstr[i]);\r\n\t        hunk.linedelimiters.push(delimiters[i] || '\\n');\r\n\r\n\t        if (operation === '+') {\r\n\t          addCount++;\r\n\t        } else if (operation === '-') {\r\n\t          removeCount++;\r\n\t        } else if (operation === ' ') {\r\n\t          addCount++;\r\n\t          removeCount++;\r\n\t        }\r\n\t      } else {\r\n\t        break;\r\n\t      }\r\n\t    }\r\n\r\n\t    // Handle the empty block count case\r\n\t    if (!addCount && hunk.newLines === 1) {\r\n\t      hunk.newLines = 0;\r\n\t    }\r\n\t    if (!removeCount && hunk.oldLines === 1) {\r\n\t      hunk.oldLines = 0;\r\n\t    }\r\n\r\n\t    // Perform optional sanity checking\r\n\t    if (options.strict) {\r\n\t      if (addCount !== hunk.newLines) {\r\n\t        throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\r\n\t      }\r\n\t      if (removeCount !== hunk.oldLines) {\r\n\t        throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\r\n\t      }\r\n\t    }\r\n\r\n\t    return hunk;\r\n\t  }\r\n\r\n\t  while (i < diffstr.length) {\r\n\t    parseIndex();\r\n\t  }\r\n\r\n\t  return list;\r\n\t}\r\n\t//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wYXRjaC9wYXJzZS5qcyJdLCJuYW1lcyI6WyJwYXJzZVBhdGNoIiwidW5pRGlmZiIsIm9wdGlvbnMiLCJkaWZmc3RyIiwic3BsaXQiLCJkZWxpbWl0ZXJzIiwibWF0Y2giLCJsaXN0IiwiaSIsInBhcnNlSW5kZXgiLCJpbmRleCIsInB1c2giLCJsZW5ndGgiLCJsaW5lIiwidGVzdCIsImhlYWRlciIsImV4ZWMiLCJwYXJzZUZpbGVIZWFkZXIiLCJodW5rcyIsInBhcnNlSHVuayIsInN0cmljdCIsIkVycm9yIiwiSlNPTiIsInN0cmluZ2lmeSIsImZpbGVIZWFkZXIiLCJrZXlQcmVmaXgiLCJkYXRhIiwiZmlsZU5hbWUiLCJyZXBsYWNlIiwic3Vic3RyIiwidHJpbSIsImNodW5rSGVhZGVySW5kZXgiLCJjaHVua0hlYWRlckxpbmUiLCJjaHVua0hlYWRlciIsImh1bmsiLCJvbGRTdGFydCIsIm9sZExpbmVzIiwibmV3U3RhcnQiLCJuZXdMaW5lcyIsImxpbmVzIiwibGluZWRlbGltaXRlcnMiLCJhZGRDb3VudCIsInJlbW92ZUNvdW50IiwiaW5kZXhPZiIsIm9wZXJhdGlvbiJdLCJtYXBwaW5ncyI6Ijs7O2dDQUFnQkEsVSxHQUFBQSxVO0FBQVQsU0FBU0EsVUFBVCxDQUFvQkMsT0FBcEIsRUFBMkM7QUFBQSxzREFBZEMsT0FBYyx1RUFBSixFQUFJOztBQUNoRCxNQUFJQyxVQUFVRixRQUFRRyxLQUFSLENBQWMscUJBQWQsQ0FBZDtBQUFBLE1BQ0lDLGFBQWFKLFFBQVFLLEtBQVIsQ0FBYyxzQkFBZCxLQUF5QyxFQUQxRDtBQUFBLE1BRUlDLE9BQU8sRUFGWDtBQUFBLE1BR0lDLElBQUksQ0FIUjs7QUFLQSxXQUFTQyxVQUFULEdBQXNCO0FBQ3BCLFFBQUlDLFFBQVEsRUFBWjtBQUNBSCxTQUFLSSxJQUFMLENBQVVELEtBQVY7O0FBRUE7QUFDQSxXQUFPRixJQUFJTCxRQUFRUyxNQUFuQixFQUEyQjtBQUN6QixVQUFJQyxPQUFPVixRQUFRSyxDQUFSLENBQVg7O0FBRUE7QUFDQSxVQUFJLHdCQUF3Qk0sSUFBeEIsQ0FBNkJELElBQTdCLENBQUosRUFBd0M7QUFDdEM7QUFDRDs7QUFFRDtBQUNBLFVBQUlFLFNBQVUsMENBQUQsQ0FBNkNDLElBQTdDLENBQWtESCxJQUFsRCxDQUFiO0FBQ0EsVUFBSUUsTUFBSixFQUFZO0FBQ1ZMLGNBQU1BLEtBQU4sR0FBY0ssT0FBTyxDQUFQLENBQWQ7QUFDRDs7QUFFRFA7QUFDRDs7QUFFRDtBQUNBO0FBQ0FTLG9CQUFnQlAsS0FBaEI7QUFDQU8sb0JBQWdCUCxLQUFoQjs7QUFFQTtBQUNBQSxVQUFNUSxLQUFOLEdBQWMsRUFBZDs7QUFFQSxXQUFPVixJQUFJTCxRQUFRUyxNQUFuQixFQUEyQjtBQUN6QixVQUFJQyxRQUFPVixRQUFRSyxDQUFSLENBQVg7O0FBRUEsVUFBSSxpQ0FBaUNNLElBQWpDLENBQXNDRCxLQUF0QyxDQUFKLEVBQWlEO0FBQy9DO0FBQ0QsT0FGRCxNQUVPLElBQUksTUFBTUMsSUFBTixDQUFXRCxLQUFYLENBQUosRUFBc0I7QUFDM0JILGNBQU1RLEtBQU4sQ0FBWVAsSUFBWixDQUFpQlEsV0FBakI7QUFDRCxPQUZNLE1BRUEsSUFBSU4sU0FBUVgsUUFBUWtCLE1BQXBCLEVBQTRCO0FBQ2pDO0FBQ0EsY0FBTSxJQUFJQyxLQUFKLENBQVUsbUJBQW1CYixJQUFJLENBQXZCLElBQTRCLEdBQTVCLEdBQWtDYyxLQUFLQyxTQUFMLENBQWVWLEtBQWYsQ0FBNUMsQ0FBTjtBQUNELE9BSE0sTUFHQTtBQUNMTDtBQUNEO0FBQ0Y7QUFDRjs7QUFFRDtBQUNBO0FBQ0EsV0FBU1MsZUFBVCxDQUF5QlAsS0FBekIsRUFBZ0M7QUFDOUIsUUFBTWMsYUFBYyx1QkFBRCxDQUEwQlIsSUFBMUIsQ0FBK0JiLFFBQVFLLENBQVIsQ0FBL0IsQ0FBbkI7QUFDQSxRQUFJZ0IsVUFBSixFQUFnQjtBQUNkLFVBQUlDLFlBQVlELFdBQVcsQ0FBWCxNQUFrQixLQUFsQixHQUEwQixLQUExQixHQUFrQyxLQUFsRDtBQUNBLFVBQU1FLE9BQU9GLFdBQVcsQ0FBWCxFQUFjcEIsS0FBZCxDQUFvQixJQUFwQixFQUEwQixDQUExQixDQUFiO0FBQ0EsVUFBSXVCLFdBQVdELEtBQUssQ0FBTCxFQUFRRSxPQUFSLENBQWdCLE9BQWhCLEVBQXlCLElBQXpCLENBQWY7QUFDQSxVQUFJLFNBQVNkLElBQVQsQ0FBY2EsUUFBZCxDQUFKLEVBQTZCO0FBQzNCQSxtQkFBV0EsU0FBU0UsTUFBVCxDQUFnQixDQUFoQixFQUFtQkYsU0FBU2YsTUFBVCxHQUFrQixDQUFyQyxDQUFYO0FBQ0Q7QUFDREYsWUFBTWUsWUFBWSxVQUFsQixJQUFnQ0UsUUFBaEM7QUFDQWpCLFlBQU1lLFlBQVksUUFBbEIsSUFBOEIsQ0FBQ0MsS0FBSyxDQUFMLEtBQVcsRUFBWixFQUFnQkksSUFBaEIsRUFBOUI7O0FBRUF0QjtBQUNEO0FBQ0Y7O0FBRUQ7QUFDQTtBQUNBLFdBQVNXLFNBQVQsR0FBcUI7QUFDbkIsUUFBSVksbUJBQW1CdkIsQ0FBdkI7QUFBQSxRQUNJd0Isa0JBQWtCN0IsUUFBUUssR0FBUixDQUR0QjtBQUFBLFFBRUl5QixjQUFjRCxnQkFBZ0I1QixLQUFoQixDQUFzQiw0Q0FBdEIsQ0FGbEI7O0FBSUEsUUFBSThCLE9BQU87QUFDVEMsZ0JBQVUsQ0FBQ0YsWUFBWSxDQUFaLENBREY7QUFFVEcsZ0JBQVUsQ0FBQ0gsWUFBWSxDQUFaLENBQUQsSUFBbUIsQ0FGcEI7QUFHVEksZ0JBQVUsQ0FBQ0osWUFBWSxDQUFaLENBSEY7QUFJVEssZ0JBQVUsQ0FBQ0wsWUFBWSxDQUFaLENBQUQsSUFBbUIsQ0FKcEI7QUFLVE0sYUFBTyxFQUxFO0FBTVRDLHNCQUFnQjtBQU5QLEtBQVg7O0FBU0EsUUFBSUMsV0FBVyxDQUFmO0FBQUEsUUFDSUMsY0FBYyxDQURsQjtBQUVBLFdBQU9sQyxJQUFJTCxRQUFRUyxNQUFuQixFQUEyQkosR0FBM0IsRUFBZ0M7QUFDOUI7QUFDQTtBQUNBLFVBQUlMLFFBQVFLLENBQVIsRUFBV21DLE9BQVgsQ0FBbUIsTUFBbkIsTUFBK0IsQ0FBL0IsSUFDTW5DLElBQUksQ0FBSixHQUFRTCxRQUFRUyxNQUR0QixJQUVLVCxRQUFRSyxJQUFJLENBQVosRUFBZW1DLE9BQWYsQ0FBdUIsTUFBdkIsTUFBbUMsQ0FGeEMsSUFHS3hDLFFBQVFLLElBQUksQ0FBWixFQUFlbUMsT0FBZixDQUF1QixJQUF2QixNQUFpQyxDQUgxQyxFQUc2QztBQUN6QztBQUNIO0FBQ0QsVUFBSUMsWUFBYXpDLFFBQVFLLENBQVIsRUFBV0ksTUFBWCxJQUFxQixDQUFyQixJQUEwQkosS0FBTUwsUUFBUVMsTUFBUixHQUFpQixDQUFsRCxHQUF3RCxHQUF4RCxHQUE4RFQsUUFBUUssQ0FBUixFQUFXLENBQVgsQ0FBOUU7O0FBRUEsVUFBSW9DLGNBQWMsR0FBZCxJQUFxQkEsY0FBYyxHQUFuQyxJQUEwQ0EsY0FBYyxHQUF4RCxJQUErREEsY0FBYyxJQUFqRixFQUF1RjtBQUNyRlYsYUFBS0ssS0FBTCxDQUFXNUIsSUFBWCxDQUFnQlIsUUFBUUssQ0FBUixDQUFoQjtBQUNBMEIsYUFBS00sY0FBTCxDQUFvQjdCLElBQXBCLENBQXlCTixXQUFXRyxDQUFYLEtBQWlCLElBQTFDOztBQUVBLFlBQUlvQyxjQUFjLEdBQWxCLEVBQXVCO0FBQ3JCSDtBQUNELFNBRkQsTUFFTyxJQUFJRyxjQUFjLEdBQWxCLEVBQXVCO0FBQzVCRjtBQUNELFNBRk0sTUFFQSxJQUFJRSxjQUFjLEdBQWxCLEVBQXVCO0FBQzVCSDtBQUNBQztBQUNEO0FBQ0YsT0FaRCxNQVlPO0FBQ0w7QUFDRDtBQUNGOztBQUVEO0FBQ0EsUUFBSSxDQUFDRCxRQUFELElBQWFQLEtBQUtJLFFBQUwsS0FBa0IsQ0FBbkMsRUFBc0M7QUFDcENKLFdBQUtJLFFBQUwsR0FBZ0IsQ0FBaEI7QUFDRDtBQUNELFFBQUksQ0FBQ0ksV0FBRCxJQUFnQlIsS0FBS0UsUUFBTCxLQUFrQixDQUF0QyxFQUF5QztBQUN2Q0YsV0FBS0UsUUFBTCxHQUFnQixDQUFoQjtBQUNEOztBQUVEO0FBQ0EsUUFBSWxDLFFBQVFrQixNQUFaLEVBQW9CO0FBQ2xCLFVBQUlxQixhQUFhUCxLQUFLSSxRQUF0QixFQUFnQztBQUM5QixjQUFNLElBQUlqQixLQUFKLENBQVUsc0RBQXNEVSxtQkFBbUIsQ0FBekUsQ0FBVixDQUFOO0FBQ0Q7QUFDRCxVQUFJVyxnQkFBZ0JSLEtBQUtFLFFBQXpCLEVBQW1DO0FBQ2pDLGNBQU0sSUFBSWYsS0FBSixDQUFVLHdEQUF3RFUsbUJBQW1CLENBQTNFLENBQVYsQ0FBTjtBQUNEO0FBQ0Y7O0FBRUQsV0FBT0csSUFBUDtBQUNEOztBQUVELFNBQU8xQixJQUFJTCxRQUFRUyxNQUFuQixFQUEyQjtBQUN6Qkg7QUFDRDs7QUFFRCxTQUFPRixJQUFQO0FBQ0QiLCJmaWxlIjoicGFyc2UuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gcGFyc2VQYXRjaCh1bmlEaWZmLCBvcHRpb25zID0ge30pIHtcbiAgbGV0IGRpZmZzdHIgPSB1bmlEaWZmLnNwbGl0KC9cXHJcXG58W1xcblxcdlxcZlxcclxceDg1XS8pLFxuICAgICAgZGVsaW1pdGVycyA9IHVuaURpZmYubWF0Y2goL1xcclxcbnxbXFxuXFx2XFxmXFxyXFx4ODVdL2cpIHx8IFtdLFxuICAgICAgbGlzdCA9IFtdLFxuICAgICAgaSA9IDA7XG5cbiAgZnVuY3Rpb24gcGFyc2VJbmRleCgpIHtcbiAgICBsZXQgaW5kZXggPSB7fTtcbiAgICBsaXN0LnB1c2goaW5kZXgpO1xuXG4gICAgLy8gUGFyc2UgZGlmZiBtZXRhZGF0YVxuICAgIHdoaWxlIChpIDwgZGlmZnN0ci5sZW5ndGgpIHtcbiAgICAgIGxldCBsaW5lID0gZGlmZnN0cltpXTtcblxuICAgICAgLy8gRmlsZSBoZWFkZXIgZm91bmQsIGVuZCBwYXJzaW5nIGRpZmYgbWV0YWRhdGFcbiAgICAgIGlmICgvXihcXC1cXC1cXC18XFwrXFwrXFwrfEBAKVxccy8udGVzdChsaW5lKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gRGlmZiBpbmRleFxuICAgICAgbGV0IGhlYWRlciA9ICgvXig/OkluZGV4OnxkaWZmKD86IC1yIFxcdyspKylcXHMrKC4rPylcXHMqJC8pLmV4ZWMobGluZSk7XG4gICAgICBpZiAoaGVhZGVyKSB7XG4gICAgICAgIGluZGV4LmluZGV4ID0gaGVhZGVyWzFdO1xuICAgICAgfVxuXG4gICAgICBpKys7XG4gICAgfVxuXG4gICAgLy8gUGFyc2UgZmlsZSBoZWFkZXJzIGlmIHRoZXkgYXJlIGRlZmluZWQuIFVuaWZpZWQgZGlmZiByZXF1aXJlcyB0aGVtLCBidXRcbiAgICAvLyB0aGVyZSdzIG5vIHRlY2huaWNhbCBpc3N1ZXMgdG8gaGF2ZSBhbiBpc29sYXRlZCBodW5rIHdpdGhvdXQgZmlsZSBoZWFkZXJcbiAgICBwYXJzZUZpbGVIZWFkZXIoaW5kZXgpO1xuICAgIHBhcnNlRmlsZUhlYWRlcihpbmRleCk7XG5cbiAgICAvLyBQYXJzZSBodW5rc1xuICAgIGluZGV4Lmh1bmtzID0gW107XG5cbiAgICB3aGlsZSAoaSA8IGRpZmZzdHIubGVuZ3RoKSB7XG4gICAgICBsZXQgbGluZSA9IGRpZmZzdHJbaV07XG5cbiAgICAgIGlmICgvXihJbmRleDp8ZGlmZnxcXC1cXC1cXC18XFwrXFwrXFwrKVxccy8udGVzdChsaW5lKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAoL15AQC8udGVzdChsaW5lKSkge1xuICAgICAgICBpbmRleC5odW5rcy5wdXNoKHBhcnNlSHVuaygpKTtcbiAgICAgIH0gZWxzZSBpZiAobGluZSAmJiBvcHRpb25zLnN0cmljdCkge1xuICAgICAgICAvLyBJZ25vcmUgdW5leHBlY3RlZCBjb250ZW50IHVubGVzcyBpbiBzdHJpY3QgbW9kZVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbGluZSAnICsgKGkgKyAxKSArICcgJyArIEpTT04uc3RyaW5naWZ5KGxpbmUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBQYXJzZXMgdGhlIC0tLSBhbmQgKysrIGhlYWRlcnMsIGlmIG5vbmUgYXJlIGZvdW5kLCBubyBsaW5lc1xuICAvLyBhcmUgY29uc3VtZWQuXG4gIGZ1bmN0aW9uIHBhcnNlRmlsZUhlYWRlcihpbmRleCkge1xuICAgIGNvbnN0IGZpbGVIZWFkZXIgPSAoL14oLS0tfFxcK1xcK1xcKylcXHMrKC4qKSQvKS5leGVjKGRpZmZzdHJbaV0pO1xuICAgIGlmIChmaWxlSGVhZGVyKSB7XG4gICAgICBsZXQga2V5UHJlZml4ID0gZmlsZUhlYWRlclsxXSA9PT0gJy0tLScgPyAnb2xkJyA6ICduZXcnO1xuICAgICAgY29uc3QgZGF0YSA9IGZpbGVIZWFkZXJbMl0uc3BsaXQoJ1xcdCcsIDIpO1xuICAgICAgbGV0IGZpbGVOYW1lID0gZGF0YVswXS5yZXBsYWNlKC9cXFxcXFxcXC9nLCAnXFxcXCcpO1xuICAgICAgaWYgKC9eXCIuKlwiJC8udGVzdChmaWxlTmFtZSkpIHtcbiAgICAgICAgZmlsZU5hbWUgPSBmaWxlTmFtZS5zdWJzdHIoMSwgZmlsZU5hbWUubGVuZ3RoIC0gMik7XG4gICAgICB9XG4gICAgICBpbmRleFtrZXlQcmVmaXggKyAnRmlsZU5hbWUnXSA9IGZpbGVOYW1lO1xuICAgICAgaW5kZXhba2V5UHJlZml4ICsgJ0hlYWRlciddID0gKGRhdGFbMV0gfHwgJycpLnRyaW0oKTtcblxuICAgICAgaSsrO1xuICAgIH1cbiAgfVxuXG4gIC8vIFBhcnNlcyBhIGh1bmtcbiAgLy8gVGhpcyBhc3N1bWVzIHRoYXQgd2UgYXJlIGF0IHRoZSBzdGFydCBvZiBhIGh1bmsuXG4gIGZ1bmN0aW9uIHBhcnNlSHVuaygpIHtcbiAgICBsZXQgY2h1bmtIZWFkZXJJbmRleCA9IGksXG4gICAgICAgIGNodW5rSGVhZGVyTGluZSA9IGRpZmZzdHJbaSsrXSxcbiAgICAgICAgY2h1bmtIZWFkZXIgPSBjaHVua0hlYWRlckxpbmUuc3BsaXQoL0BAIC0oXFxkKykoPzosKFxcZCspKT8gXFwrKFxcZCspKD86LChcXGQrKSk/IEBALyk7XG5cbiAgICBsZXQgaHVuayA9IHtcbiAgICAgIG9sZFN0YXJ0OiArY2h1bmtIZWFkZXJbMV0sXG4gICAgICBvbGRMaW5lczogK2NodW5rSGVhZGVyWzJdIHx8IDEsXG4gICAgICBuZXdTdGFydDogK2NodW5rSGVhZGVyWzNdLFxuICAgICAgbmV3TGluZXM6ICtjaHVua0hlYWRlcls0XSB8fCAxLFxuICAgICAgbGluZXM6IFtdLFxuICAgICAgbGluZWRlbGltaXRlcnM6IFtdXG4gICAgfTtcblxuICAgIGxldCBhZGRDb3VudCA9IDAsXG4gICAgICAgIHJlbW92ZUNvdW50ID0gMDtcbiAgICBmb3IgKDsgaSA8IGRpZmZzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIExpbmVzIHN0YXJ0aW5nIHdpdGggJy0tLScgY291bGQgYmUgbWlzdGFrZW4gZm9yIHRoZSBcInJlbW92ZSBsaW5lXCIgb3BlcmF0aW9uXG4gICAgICAvLyBCdXQgdGhleSBjb3VsZCBiZSB0aGUgaGVhZGVyIGZvciB0aGUgbmV4dCBmaWxlLiBUaGVyZWZvcmUgcHJ1bmUgc3VjaCBjYXNlcyBvdXQuXG4gICAgICBpZiAoZGlmZnN0cltpXS5pbmRleE9mKCctLS0gJykgPT09IDBcbiAgICAgICAgICAgICYmIChpICsgMiA8IGRpZmZzdHIubGVuZ3RoKVxuICAgICAgICAgICAgJiYgZGlmZnN0cltpICsgMV0uaW5kZXhPZignKysrICcpID09PSAwXG4gICAgICAgICAgICAmJiBkaWZmc3RyW2kgKyAyXS5pbmRleE9mKCdAQCcpID09PSAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBsZXQgb3BlcmF0aW9uID0gKGRpZmZzdHJbaV0ubGVuZ3RoID09IDAgJiYgaSAhPSAoZGlmZnN0ci5sZW5ndGggLSAxKSkgPyAnICcgOiBkaWZmc3RyW2ldWzBdO1xuXG4gICAgICBpZiAob3BlcmF0aW9uID09PSAnKycgfHwgb3BlcmF0aW9uID09PSAnLScgfHwgb3BlcmF0aW9uID09PSAnICcgfHwgb3BlcmF0aW9uID09PSAnXFxcXCcpIHtcbiAgICAgICAgaHVuay5saW5lcy5wdXNoKGRpZmZzdHJbaV0pO1xuICAgICAgICBodW5rLmxpbmVkZWxpbWl0ZXJzLnB1c2goZGVsaW1pdGVyc1tpXSB8fCAnXFxuJyk7XG5cbiAgICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gJysnKSB7XG4gICAgICAgICAgYWRkQ291bnQrKztcbiAgICAgICAgfSBlbHNlIGlmIChvcGVyYXRpb24gPT09ICctJykge1xuICAgICAgICAgIHJlbW92ZUNvdW50Kys7XG4gICAgICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uID09PSAnICcpIHtcbiAgICAgICAgICBhZGRDb3VudCsrO1xuICAgICAgICAgIHJlbW92ZUNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEhhbmRsZSB0aGUgZW1wdHkgYmxvY2sgY291bnQgY2FzZVxuICAgIGlmICghYWRkQ291bnQgJiYgaHVuay5uZXdMaW5lcyA9PT0gMSkge1xuICAgICAgaHVuay5uZXdMaW5lcyA9IDA7XG4gICAgfVxuICAgIGlmICghcmVtb3ZlQ291bnQgJiYgaHVuay5vbGRMaW5lcyA9PT0gMSkge1xuICAgICAgaHVuay5vbGRMaW5lcyA9IDA7XG4gICAgfVxuXG4gICAgLy8gUGVyZm9ybSBvcHRpb25hbCBzYW5pdHkgY2hlY2tpbmdcbiAgICBpZiAob3B0aW9ucy5zdHJpY3QpIHtcbiAgICAgIGlmIChhZGRDb3VudCAhPT0gaHVuay5uZXdMaW5lcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FkZGVkIGxpbmUgY291bnQgZGlkIG5vdCBtYXRjaCBmb3IgaHVuayBhdCBsaW5lICcgKyAoY2h1bmtIZWFkZXJJbmRleCArIDEpKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZW1vdmVDb3VudCAhPT0gaHVuay5vbGRMaW5lcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlbW92ZWQgbGluZSBjb3VudCBkaWQgbm90IG1hdGNoIGZvciBodW5rIGF0IGxpbmUgJyArIChjaHVua0hlYWRlckluZGV4ICsgMSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBodW5rO1xuICB9XG5cbiAgd2hpbGUgKGkgPCBkaWZmc3RyLmxlbmd0aCkge1xuICAgIHBhcnNlSW5kZXgoKTtcbiAgfVxuXG4gIHJldHVybiBsaXN0O1xufVxuIl19\r\n\r\n\r\n/***/ }),\r\n/* 12 */\r\n/***/ (function(module, exports) {\r\n\r\n\t/*istanbul ignore start*/\"use strict\";\r\n\r\n\texports.__esModule = true;\r\n\r\n\texports[\"default\"] = /*istanbul ignore end*/function (start, minLine, maxLine) {\r\n\t  var wantForward = true,\r\n\t      backwardExhausted = false,\r\n\t      forwardExhausted = false,\r\n\t      localOffset = 1;\r\n\r\n\t  return function iterator() {\r\n\t    if (wantForward && !forwardExhausted) {\r\n\t      if (backwardExhausted) {\r\n\t        localOffset++;\r\n\t      } else {\r\n\t        wantForward = false;\r\n\t      }\r\n\r\n\t      // Check if trying to fit beyond text length, and if not, check it fits\r\n\t      // after offset location (or desired location on first iteration)\r\n\t      if (start + localOffset <= maxLine) {\r\n\t        return localOffset;\r\n\t      }\r\n\r\n\t      forwardExhausted = true;\r\n\t    }\r\n\r\n\t    if (!backwardExhausted) {\r\n\t      if (!forwardExhausted) {\r\n\t        wantForward = true;\r\n\t      }\r\n\r\n\t      // Check if trying to fit before text beginning, and if not, check it fits\r\n\t      // before offset location\r\n\t      if (minLine <= start - localOffset) {\r\n\t        return -localOffset++;\r\n\t      }\r\n\r\n\t      backwardExhausted = true;\r\n\t      return iterator();\r\n\t    }\r\n\r\n\t    // We tried to fit hunk before text beginning and beyond text length, then\r\n\t    // hunk can't fit on the text. Return undefined\r\n\t  };\r\n\t};\r\n\t//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsL2Rpc3RhbmNlLWl0ZXJhdG9yLmpzIl0sIm5hbWVzIjpbInN0YXJ0IiwibWluTGluZSIsIm1heExpbmUiLCJ3YW50Rm9yd2FyZCIsImJhY2t3YXJkRXhoYXVzdGVkIiwiZm9yd2FyZEV4aGF1c3RlZCIsImxvY2FsT2Zmc2V0IiwiaXRlcmF0b3IiXSwibWFwcGluZ3MiOiI7Ozs7NENBR2UsVUFBU0EsS0FBVCxFQUFnQkMsT0FBaEIsRUFBeUJDLE9BQXpCLEVBQWtDO0FBQy9DLE1BQUlDLGNBQWMsSUFBbEI7QUFBQSxNQUNJQyxvQkFBb0IsS0FEeEI7QUFBQSxNQUVJQyxtQkFBbUIsS0FGdkI7QUFBQSxNQUdJQyxjQUFjLENBSGxCOztBQUtBLFNBQU8sU0FBU0MsUUFBVCxHQUFvQjtBQUN6QixRQUFJSixlQUFlLENBQUNFLGdCQUFwQixFQUFzQztBQUNwQyxVQUFJRCxpQkFBSixFQUF1QjtBQUNyQkU7QUFDRCxPQUZELE1BRU87QUFDTEgsc0JBQWMsS0FBZDtBQUNEOztBQUVEO0FBQ0E7QUFDQSxVQUFJSCxRQUFRTSxXQUFSLElBQXVCSixPQUEzQixFQUFvQztBQUNsQyxlQUFPSSxXQUFQO0FBQ0Q7O0FBRURELHlCQUFtQixJQUFuQjtBQUNEOztBQUVELFFBQUksQ0FBQ0QsaUJBQUwsRUFBd0I7QUFDdEIsVUFBSSxDQUFDQyxnQkFBTCxFQUF1QjtBQUNyQkYsc0JBQWMsSUFBZDtBQUNEOztBQUVEO0FBQ0E7QUFDQSxVQUFJRixXQUFXRCxRQUFRTSxXQUF2QixFQUFvQztBQUNsQyxlQUFPLENBQUNBLGFBQVI7QUFDRDs7QUFFREYsMEJBQW9CLElBQXBCO0FBQ0EsYUFBT0csVUFBUDtBQUNEOztBQUVEO0FBQ0E7QUFDRCxHQWxDRDtBQW1DRCxDIiwiZmlsZSI6ImRpc3RhbmNlLWl0ZXJhdG9yLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gSXRlcmF0b3IgdGhhdCB0cmF2ZXJzZXMgaW4gdGhlIHJhbmdlIG9mIFttaW4sIG1heF0sIHN0ZXBwaW5nXG4vLyBieSBkaXN0YW5jZSBmcm9tIGEgZ2l2ZW4gc3RhcnQgcG9zaXRpb24uIEkuZS4gZm9yIFswLCA0XSwgd2l0aFxuLy8gc3RhcnQgb2YgMiwgdGhpcyB3aWxsIGl0ZXJhdGUgMiwgMywgMSwgNCwgMC5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHN0YXJ0LCBtaW5MaW5lLCBtYXhMaW5lKSB7XG4gIGxldCB3YW50Rm9yd2FyZCA9IHRydWUsXG4gICAgICBiYWNrd2FyZEV4aGF1c3RlZCA9IGZhbHNlLFxuICAgICAgZm9yd2FyZEV4aGF1c3RlZCA9IGZhbHNlLFxuICAgICAgbG9jYWxPZmZzZXQgPSAxO1xuXG4gIHJldHVybiBmdW5jdGlvbiBpdGVyYXRvcigpIHtcbiAgICBpZiAod2FudEZvcndhcmQgJiYgIWZvcndhcmRFeGhhdXN0ZWQpIHtcbiAgICAgIGlmIChiYWNrd2FyZEV4aGF1c3RlZCkge1xuICAgICAgICBsb2NhbE9mZnNldCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FudEZvcndhcmQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgdHJ5aW5nIHRvIGZpdCBiZXlvbmQgdGV4dCBsZW5ndGgsIGFuZCBpZiBub3QsIGNoZWNrIGl0IGZpdHNcbiAgICAgIC8vIGFmdGVyIG9mZnNldCBsb2NhdGlvbiAob3IgZGVzaXJlZCBsb2NhdGlvbiBvbiBmaXJzdCBpdGVyYXRpb24pXG4gICAgICBpZiAoc3RhcnQgKyBsb2NhbE9mZnNldCA8PSBtYXhMaW5lKSB7XG4gICAgICAgIHJldHVybiBsb2NhbE9mZnNldDtcbiAgICAgIH1cblxuICAgICAgZm9yd2FyZEV4aGF1c3RlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCFiYWNrd2FyZEV4aGF1c3RlZCkge1xuICAgICAgaWYgKCFmb3J3YXJkRXhoYXVzdGVkKSB7XG4gICAgICAgIHdhbnRGb3J3YXJkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgdHJ5aW5nIHRvIGZpdCBiZWZvcmUgdGV4dCBiZWdpbm5pbmcsIGFuZCBpZiBub3QsIGNoZWNrIGl0IGZpdHNcbiAgICAgIC8vIGJlZm9yZSBvZmZzZXQgbG9jYXRpb25cbiAgICAgIGlmIChtaW5MaW5lIDw9IHN0YXJ0IC0gbG9jYWxPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIC1sb2NhbE9mZnNldCsrO1xuICAgICAgfVxuXG4gICAgICBiYWNrd2FyZEV4aGF1c3RlZCA9IHRydWU7XG4gICAgICByZXR1cm4gaXRlcmF0b3IoKTtcbiAgICB9XG5cbiAgICAvLyBXZSB0cmllZCB0byBmaXQgaHVuayBiZWZvcmUgdGV4dCBiZWdpbm5pbmcgYW5kIGJleW9uZCB0ZXh0IGxlbmd0aCwgdGhlblxuICAgIC8vIGh1bmsgY2FuJ3QgZml0IG9uIHRoZSB0ZXh0LiBSZXR1cm4gdW5kZWZpbmVkXG4gIH07XG59XG4iXX0=\r\n\r\n\r\n/***/ }),\r\n/* 13 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\t/*istanbul ignore start*/'use strict';\r\n\r\n\texports.__esModule = true;\r\n\texports. /*istanbul ignore end*/calcLineCount = calcLineCount;\r\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/merge = merge;\r\n\r\n\tvar /*istanbul ignore start*/_create = __webpack_require__(14) /*istanbul ignore end*/;\r\n\r\n\tvar /*istanbul ignore start*/_parse = __webpack_require__(11) /*istanbul ignore end*/;\r\n\r\n\tvar /*istanbul ignore start*/_array = __webpack_require__(15) /*istanbul ignore end*/;\r\n\r\n\t/*istanbul ignore start*/function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\r\n\r\n\t/*istanbul ignore end*/function calcLineCount(hunk) {\r\n\t  /*istanbul ignore start*/var _calcOldNewLineCount = /*istanbul ignore end*/calcOldNewLineCount(hunk.lines),\r\n\t      oldLines = _calcOldNewLineCount.oldLines,\r\n\t      newLines = _calcOldNewLineCount.newLines;\r\n\r\n\t  if (oldLines !== undefined) {\r\n\t    hunk.oldLines = oldLines;\r\n\t  } else {\r\n\t    delete hunk.oldLines;\r\n\t  }\r\n\r\n\t  if (newLines !== undefined) {\r\n\t    hunk.newLines = newLines;\r\n\t  } else {\r\n\t    delete hunk.newLines;\r\n\t  }\r\n\t}\r\n\r\n\tfunction merge(mine, theirs, base) {\r\n\t  mine = loadPatch(mine, base);\r\n\t  theirs = loadPatch(theirs, base);\r\n\r\n\t  var ret = {};\r\n\r\n\t  // For index we just let it pass through as it doesn't have any necessary meaning.\r\n\t  // Leaving sanity checks on this to the API consumer that may know more about the\r\n\t  // meaning in their own context.\r\n\t  if (mine.index || theirs.index) {\r\n\t    ret.index = mine.index || theirs.index;\r\n\t  }\r\n\r\n\t  if (mine.newFileName || theirs.newFileName) {\r\n\t    if (!fileNameChanged(mine)) {\r\n\t      // No header or no change in ours, use theirs (and ours if theirs does not exist)\r\n\t      ret.oldFileName = theirs.oldFileName || mine.oldFileName;\r\n\t      ret.newFileName = theirs.newFileName || mine.newFileName;\r\n\t      ret.oldHeader = theirs.oldHeader || mine.oldHeader;\r\n\t      ret.newHeader = theirs.newHeader || mine.newHeader;\r\n\t    } else if (!fileNameChanged(theirs)) {\r\n\t      // No header or no change in theirs, use ours\r\n\t      ret.oldFileName = mine.oldFileName;\r\n\t      ret.newFileName = mine.newFileName;\r\n\t      ret.oldHeader = mine.oldHeader;\r\n\t      ret.newHeader = mine.newHeader;\r\n\t    } else {\r\n\t      // Both changed... figure it out\r\n\t      ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);\r\n\t      ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);\r\n\t      ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);\r\n\t      ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);\r\n\t    }\r\n\t  }\r\n\r\n\t  ret.hunks = [];\r\n\r\n\t  var mineIndex = 0,\r\n\t      theirsIndex = 0,\r\n\t      mineOffset = 0,\r\n\t      theirsOffset = 0;\r\n\r\n\t  while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {\r\n\t    var mineCurrent = mine.hunks[mineIndex] || { oldStart: Infinity },\r\n\t        theirsCurrent = theirs.hunks[theirsIndex] || { oldStart: Infinity };\r\n\r\n\t    if (hunkBefore(mineCurrent, theirsCurrent)) {\r\n\t      // This patch does not overlap with any of the others, yay.\r\n\t      ret.hunks.push(cloneHunk(mineCurrent, mineOffset));\r\n\t      mineIndex++;\r\n\t      theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;\r\n\t    } else if (hunkBefore(theirsCurrent, mineCurrent)) {\r\n\t      // This patch does not overlap with any of the others, yay.\r\n\t      ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));\r\n\t      theirsIndex++;\r\n\t      mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;\r\n\t    } else {\r\n\t      // Overlap, merge as best we can\r\n\t      var mergedHunk = {\r\n\t        oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),\r\n\t        oldLines: 0,\r\n\t        newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),\r\n\t        newLines: 0,\r\n\t        lines: []\r\n\t      };\r\n\t      mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);\r\n\t      theirsIndex++;\r\n\t      mineIndex++;\r\n\r\n\t      ret.hunks.push(mergedHunk);\r\n\t    }\r\n\t  }\r\n\r\n\t  return ret;\r\n\t}\r\n\r\n\tfunction loadPatch(param, base) {\r\n\t  if (typeof param === 'string') {\r\n\t    if (/^@@/m.test(param) || /^Index:/m.test(param)) {\r\n\t      return (/*istanbul ignore start*/(0, _parse.parsePatch) /*istanbul ignore end*/(param)[0]\r\n\t      );\r\n\t    }\r\n\r\n\t    if (!base) {\r\n\t      throw new Error('Must provide a base reference or pass in a patch');\r\n\t    }\r\n\t    return (/*istanbul ignore start*/(0, _create.structuredPatch) /*istanbul ignore end*/(undefined, undefined, base, param)\r\n\t    );\r\n\t  }\r\n\r\n\t  return param;\r\n\t}\r\n\r\n\tfunction fileNameChanged(patch) {\r\n\t  return patch.newFileName && patch.newFileName !== patch.oldFileName;\r\n\t}\r\n\r\n\tfunction selectField(index, mine, theirs) {\r\n\t  if (mine === theirs) {\r\n\t    return mine;\r\n\t  } else {\r\n\t    index.conflict = true;\r\n\t    return { mine: mine, theirs: theirs };\r\n\t  }\r\n\t}\r\n\r\n\tfunction hunkBefore(test, check) {\r\n\t  return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;\r\n\t}\r\n\r\n\tfunction cloneHunk(hunk, offset) {\r\n\t  return {\r\n\t    oldStart: hunk.oldStart, oldLines: hunk.oldLines,\r\n\t    newStart: hunk.newStart + offset, newLines: hunk.newLines,\r\n\t    lines: hunk.lines\r\n\t  };\r\n\t}\r\n\r\n\tfunction mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {\r\n\t  // This will generally result in a conflicted hunk, but there are cases where the context\r\n\t  // is the only overlap where we can successfully merge the content here.\r\n\t  var mine = { offset: mineOffset, lines: mineLines, index: 0 },\r\n\t      their = { offset: theirOffset, lines: theirLines, index: 0 };\r\n\r\n\t  // Handle any leading content\r\n\t  insertLeading(hunk, mine, their);\r\n\t  insertLeading(hunk, their, mine);\r\n\r\n\t  // Now in the overlap content. Scan through and select the best changes from each.\r\n\t  while (mine.index < mine.lines.length && their.index < their.lines.length) {\r\n\t    var mineCurrent = mine.lines[mine.index],\r\n\t        theirCurrent = their.lines[their.index];\r\n\r\n\t    if ((mineCurrent[0] === '-' || mineCurrent[0] === '+') && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {\r\n\t      // Both modified ...\r\n\t      mutualChange(hunk, mine, their);\r\n\t    } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {\r\n\t      /*istanbul ignore start*/var _hunk$lines;\r\n\r\n\t      /*istanbul ignore end*/ // Mine inserted\r\n\t      /*istanbul ignore start*/(_hunk$lines = /*istanbul ignore end*/hunk.lines).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_hunk$lines /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/collectChange(mine)));\r\n\t    } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {\r\n\t      /*istanbul ignore start*/var _hunk$lines2;\r\n\r\n\t      /*istanbul ignore end*/ // Theirs inserted\r\n\t      /*istanbul ignore start*/(_hunk$lines2 = /*istanbul ignore end*/hunk.lines).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_hunk$lines2 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/collectChange(their)));\r\n\t    } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {\r\n\t      // Mine removed or edited\r\n\t      removal(hunk, mine, their);\r\n\t    } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {\r\n\t      // Their removed or edited\r\n\t      removal(hunk, their, mine, true);\r\n\t    } else if (mineCurrent === theirCurrent) {\r\n\t      // Context identity\r\n\t      hunk.lines.push(mineCurrent);\r\n\t      mine.index++;\r\n\t      their.index++;\r\n\t    } else {\r\n\t      // Context mismatch\r\n\t      conflict(hunk, collectChange(mine), collectChange(their));\r\n\t    }\r\n\t  }\r\n\r\n\t  // Now push anything that may be remaining\r\n\t  insertTrailing(hunk, mine);\r\n\t  insertTrailing(hunk, their);\r\n\r\n\t  calcLineCount(hunk);\r\n\t}\r\n\r\n\tfunction mutualChange(hunk, mine, their) {\r\n\t  var myChanges = collectChange(mine),\r\n\t      theirChanges = collectChange(their);\r\n\r\n\t  if (allRemoves(myChanges) && allRemoves(theirChanges)) {\r\n\t    // Special case for remove changes that are supersets of one another\r\n\t    if ( /*istanbul ignore start*/(0, _array.arrayStartsWith) /*istanbul ignore end*/(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {\r\n\t      /*istanbul ignore start*/var _hunk$lines3;\r\n\r\n\t      /*istanbul ignore end*/ /*istanbul ignore start*/(_hunk$lines3 = /*istanbul ignore end*/hunk.lines).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_hunk$lines3 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/myChanges));\r\n\t      return;\r\n\t    } else if ( /*istanbul ignore start*/(0, _array.arrayStartsWith) /*istanbul ignore end*/(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {\r\n\t      /*istanbul ignore start*/var _hunk$lines4;\r\n\r\n\t      /*istanbul ignore end*/ /*istanbul ignore start*/(_hunk$lines4 = /*istanbul ignore end*/hunk.lines).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_hunk$lines4 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/theirChanges));\r\n\t      return;\r\n\t    }\r\n\t  } else if ( /*istanbul ignore start*/(0, _array.arrayEqual) /*istanbul ignore end*/(myChanges, theirChanges)) {\r\n\t    /*istanbul ignore start*/var _hunk$lines5;\r\n\r\n\t    /*istanbul ignore end*/ /*istanbul ignore start*/(_hunk$lines5 = /*istanbul ignore end*/hunk.lines).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_hunk$lines5 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/myChanges));\r\n\t    return;\r\n\t  }\r\n\r\n\t  conflict(hunk, myChanges, theirChanges);\r\n\t}\r\n\r\n\tfunction removal(hunk, mine, their, swap) {\r\n\t  var myChanges = collectChange(mine),\r\n\t      theirChanges = collectContext(their, myChanges);\r\n\t  if (theirChanges.merged) {\r\n\t    /*istanbul ignore start*/var _hunk$lines6;\r\n\r\n\t    /*istanbul ignore end*/ /*istanbul ignore start*/(_hunk$lines6 = /*istanbul ignore end*/hunk.lines).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_hunk$lines6 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/theirChanges.merged));\r\n\t  } else {\r\n\t    conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);\r\n\t  }\r\n\t}\r\n\r\n\tfunction conflict(hunk, mine, their) {\r\n\t  hunk.conflict = true;\r\n\t  hunk.lines.push({\r\n\t    conflict: true,\r\n\t    mine: mine,\r\n\t    theirs: their\r\n\t  });\r\n\t}\r\n\r\n\tfunction insertLeading(hunk, insert, their) {\r\n\t  while (insert.offset < their.offset && insert.index < insert.lines.length) {\r\n\t    var line = insert.lines[insert.index++];\r\n\t    hunk.lines.push(line);\r\n\t    insert.offset++;\r\n\t  }\r\n\t}\r\n\tfunction insertTrailing(hunk, insert) {\r\n\t  while (insert.index < insert.lines.length) {\r\n\t    var line = insert.lines[insert.index++];\r\n\t    hunk.lines.push(line);\r\n\t  }\r\n\t}\r\n\r\n\tfunction collectChange(state) {\r\n\t  var ret = [],\r\n\t      operation = state.lines[state.index][0];\r\n\t  while (state.index < state.lines.length) {\r\n\t    var line = state.lines[state.index];\r\n\r\n\t    // Group additions that are immediately after subtractions and treat them as one \"atomic\" modify change.\r\n\t    if (operation === '-' && line[0] === '+') {\r\n\t      operation = '+';\r\n\t    }\r\n\r\n\t    if (operation === line[0]) {\r\n\t      ret.push(line);\r\n\t      state.index++;\r\n\t    } else {\r\n\t      break;\r\n\t    }\r\n\t  }\r\n\r\n\t  return ret;\r\n\t}\r\n\tfunction collectContext(state, matchChanges) {\r\n\t  var changes = [],\r\n\t      merged = [],\r\n\t      matchIndex = 0,\r\n\t      contextChanges = false,\r\n\t      conflicted = false;\r\n\t  while (matchIndex < matchChanges.length && state.index < state.lines.length) {\r\n\t    var change = state.lines[state.index],\r\n\t        match = matchChanges[matchIndex];\r\n\r\n\t    // Once we've hit our add, then we are done\r\n\t    if (match[0] === '+') {\r\n\t      break;\r\n\t    }\r\n\r\n\t    contextChanges = contextChanges || change[0] !== ' ';\r\n\r\n\t    merged.push(match);\r\n\t    matchIndex++;\r\n\r\n\t    // Consume any additions in the other block as a conflict to attempt\r\n\t    // to pull in the remaining context after this\r\n\t    if (change[0] === '+') {\r\n\t      conflicted = true;\r\n\r\n\t      while (change[0] === '+') {\r\n\t        changes.push(change);\r\n\t        change = state.lines[++state.index];\r\n\t      }\r\n\t    }\r\n\r\n\t    if (match.substr(1) === change.substr(1)) {\r\n\t      changes.push(change);\r\n\t      state.index++;\r\n\t    } else {\r\n\t      conflicted = true;\r\n\t    }\r\n\t  }\r\n\r\n\t  if ((matchChanges[matchIndex] || '')[0] === '+' && contextChanges) {\r\n\t    conflicted = true;\r\n\t  }\r\n\r\n\t  if (conflicted) {\r\n\t    return changes;\r\n\t  }\r\n\r\n\t  while (matchIndex < matchChanges.length) {\r\n\t    merged.push(matchChanges[matchIndex++]);\r\n\t  }\r\n\r\n\t  return {\r\n\t    merged: merged,\r\n\t    changes: changes\r\n\t  };\r\n\t}\r\n\r\n\tfunction allRemoves(changes) {\r\n\t  return changes.reduce(function (prev, change) {\r\n\t    return prev && change[0] === '-';\r\n\t  }, true);\r\n\t}\r\n\tfunction skipRemoveSuperset(state, removeChanges, delta) {\r\n\t  for (var i = 0; i < delta; i++) {\r\n\t    var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);\r\n\t    if (state.lines[state.index + i] !== ' ' + changeContent) {\r\n\t      return false;\r\n\t    }\r\n\t  }\r\n\r\n\t  state.index += delta;\r\n\t  return true;\r\n\t}\r\n\r\n\tfunction calcOldNewLineCount(lines) {\r\n\t  var oldLines = 0;\r\n\t  var newLines = 0;\r\n\r\n\t  lines.forEach(function (line) {\r\n\t    if (typeof line !== 'string') {\r\n\t      var myCount = calcOldNewLineCount(line.mine);\r\n\t      var theirCount = calcOldNewLineCount(line.theirs);\r\n\r\n\t      if (oldLines !== undefined) {\r\n\t        if (myCount.oldLines === theirCount.oldLines) {\r\n\t          oldLines += myCount.oldLines;\r\n\t        } else {\r\n\t          oldLines = undefined;\r\n\t        }\r\n\t      }\r\n\r\n\t      if (newLines !== undefined) {\r\n\t        if (myCount.newLines === theirCount.newLines) {\r\n\t          newLines += myCount.newLines;\r\n\t        } else {\r\n\t          newLines = undefined;\r\n\t        }\r\n\t      }\r\n\t    } else {\r\n\t      if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {\r\n\t        newLines++;\r\n\t      }\r\n\t      if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {\r\n\t        oldLines++;\r\n\t      }\r\n\t    }\r\n\t  });\r\n\r\n\t  return { oldLines: oldLines, newLines: newLines };\r\n\t}\r\n\t//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wYXRjaC9tZXJnZS5qcyJdLCJuYW1lcyI6WyJjYWxjTGluZUNvdW50IiwibWVyZ2UiLCJodW5rIiwiY2FsY09sZE5ld0xpbmVDb3VudCIsImxpbmVzIiwib2xkTGluZXMiLCJuZXdMaW5lcyIsInVuZGVmaW5lZCIsIm1pbmUiLCJ0aGVpcnMiLCJiYXNlIiwibG9hZFBhdGNoIiwicmV0IiwiaW5kZXgiLCJuZXdGaWxlTmFtZSIsImZpbGVOYW1lQ2hhbmdlZCIsIm9sZEZpbGVOYW1lIiwib2xkSGVhZGVyIiwibmV3SGVhZGVyIiwic2VsZWN0RmllbGQiLCJodW5rcyIsIm1pbmVJbmRleCIsInRoZWlyc0luZGV4IiwibWluZU9mZnNldCIsInRoZWlyc09mZnNldCIsImxlbmd0aCIsIm1pbmVDdXJyZW50Iiwib2xkU3RhcnQiLCJJbmZpbml0eSIsInRoZWlyc0N1cnJlbnQiLCJodW5rQmVmb3JlIiwicHVzaCIsImNsb25lSHVuayIsIm1lcmdlZEh1bmsiLCJNYXRoIiwibWluIiwibmV3U3RhcnQiLCJtZXJnZUxpbmVzIiwicGFyYW0iLCJ0ZXN0IiwiRXJyb3IiLCJwYXRjaCIsImNvbmZsaWN0IiwiY2hlY2siLCJvZmZzZXQiLCJtaW5lTGluZXMiLCJ0aGVpck9mZnNldCIsInRoZWlyTGluZXMiLCJ0aGVpciIsImluc2VydExlYWRpbmciLCJ0aGVpckN1cnJlbnQiLCJtdXR1YWxDaGFuZ2UiLCJjb2xsZWN0Q2hhbmdlIiwicmVtb3ZhbCIsImluc2VydFRyYWlsaW5nIiwibXlDaGFuZ2VzIiwidGhlaXJDaGFuZ2VzIiwiYWxsUmVtb3ZlcyIsInNraXBSZW1vdmVTdXBlcnNldCIsInN3YXAiLCJjb2xsZWN0Q29udGV4dCIsIm1lcmdlZCIsImluc2VydCIsImxpbmUiLCJzdGF0ZSIsIm9wZXJhdGlvbiIsIm1hdGNoQ2hhbmdlcyIsImNoYW5nZXMiLCJtYXRjaEluZGV4IiwiY29udGV4dENoYW5nZXMiLCJjb25mbGljdGVkIiwiY2hhbmdlIiwibWF0Y2giLCJzdWJzdHIiLCJyZWR1Y2UiLCJwcmV2IiwicmVtb3ZlQ2hhbmdlcyIsImRlbHRhIiwiaSIsImNoYW5nZUNvbnRlbnQiLCJmb3JFYWNoIiwibXlDb3VudCIsInRoZWlyQ291bnQiXSwibWFwcGluZ3MiOiI7OztnQ0FLZ0JBLGEsR0FBQUEsYTt5REFnQkFDLEssR0FBQUEsSzs7QUFyQmhCOztBQUNBOztBQUVBOzs7O3VCQUVPLFNBQVNELGFBQVQsQ0FBdUJFLElBQXZCLEVBQTZCO0FBQUEsNkVBQ0xDLG9CQUFvQkQsS0FBS0UsS0FBekIsQ0FESztBQUFBLE1BQzNCQyxRQUQyQix3QkFDM0JBLFFBRDJCO0FBQUEsTUFDakJDLFFBRGlCLHdCQUNqQkEsUUFEaUI7O0FBR2xDLE1BQUlELGFBQWFFLFNBQWpCLEVBQTRCO0FBQzFCTCxTQUFLRyxRQUFMLEdBQWdCQSxRQUFoQjtBQUNELEdBRkQsTUFFTztBQUNMLFdBQU9ILEtBQUtHLFFBQVo7QUFDRDs7QUFFRCxNQUFJQyxhQUFhQyxTQUFqQixFQUE0QjtBQUMxQkwsU0FBS0ksUUFBTCxHQUFnQkEsUUFBaEI7QUFDRCxHQUZELE1BRU87QUFDTCxXQUFPSixLQUFLSSxRQUFaO0FBQ0Q7QUFDRjs7QUFFTSxTQUFTTCxLQUFULENBQWVPLElBQWYsRUFBcUJDLE1BQXJCLEVBQTZCQyxJQUE3QixFQUFtQztBQUN4Q0YsU0FBT0csVUFBVUgsSUFBVixFQUFnQkUsSUFBaEIsQ0FBUDtBQUNBRCxXQUFTRSxVQUFVRixNQUFWLEVBQWtCQyxJQUFsQixDQUFUOztBQUVBLE1BQUlFLE1BQU0sRUFBVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFJSixLQUFLSyxLQUFMLElBQWNKLE9BQU9JLEtBQXpCLEVBQWdDO0FBQzlCRCxRQUFJQyxLQUFKLEdBQVlMLEtBQUtLLEtBQUwsSUFBY0osT0FBT0ksS0FBakM7QUFDRDs7QUFFRCxNQUFJTCxLQUFLTSxXQUFMLElBQW9CTCxPQUFPSyxXQUEvQixFQUE0QztBQUMxQyxRQUFJLENBQUNDLGdCQUFnQlAsSUFBaEIsQ0FBTCxFQUE0QjtBQUMxQjtBQUNBSSxVQUFJSSxXQUFKLEdBQWtCUCxPQUFPTyxXQUFQLElBQXNCUixLQUFLUSxXQUE3QztBQUNBSixVQUFJRSxXQUFKLEdBQWtCTCxPQUFPSyxXQUFQLElBQXNCTixLQUFLTSxXQUE3QztBQUNBRixVQUFJSyxTQUFKLEdBQWdCUixPQUFPUSxTQUFQLElBQW9CVCxLQUFLUyxTQUF6QztBQUNBTCxVQUFJTSxTQUFKLEdBQWdCVCxPQUFPUyxTQUFQLElBQW9CVixLQUFLVSxTQUF6QztBQUNELEtBTkQsTUFNTyxJQUFJLENBQUNILGdCQUFnQk4sTUFBaEIsQ0FBTCxFQUE4QjtBQUNuQztBQUNBRyxVQUFJSSxXQUFKLEdBQWtCUixLQUFLUSxXQUF2QjtBQUNBSixVQUFJRSxXQUFKLEdBQWtCTixLQUFLTSxXQUF2QjtBQUNBRixVQUFJSyxTQUFKLEdBQWdCVCxLQUFLUyxTQUFyQjtBQUNBTCxVQUFJTSxTQUFKLEdBQWdCVixLQUFLVSxTQUFyQjtBQUNELEtBTk0sTUFNQTtBQUNMO0FBQ0FOLFVBQUlJLFdBQUosR0FBa0JHLFlBQVlQLEdBQVosRUFBaUJKLEtBQUtRLFdBQXRCLEVBQW1DUCxPQUFPTyxXQUExQyxDQUFsQjtBQUNBSixVQUFJRSxXQUFKLEdBQWtCSyxZQUFZUCxHQUFaLEVBQWlCSixLQUFLTSxXQUF0QixFQUFtQ0wsT0FBT0ssV0FBMUMsQ0FBbEI7QUFDQUYsVUFBSUssU0FBSixHQUFnQkUsWUFBWVAsR0FBWixFQUFpQkosS0FBS1MsU0FBdEIsRUFBaUNSLE9BQU9RLFNBQXhDLENBQWhCO0FBQ0FMLFVBQUlNLFNBQUosR0FBZ0JDLFlBQVlQLEdBQVosRUFBaUJKLEtBQUtVLFNBQXRCLEVBQWlDVCxPQUFPUyxTQUF4QyxDQUFoQjtBQUNEO0FBQ0Y7O0FBRUROLE1BQUlRLEtBQUosR0FBWSxFQUFaOztBQUVBLE1BQUlDLFlBQVksQ0FBaEI7QUFBQSxNQUNJQyxjQUFjLENBRGxCO0FBQUEsTUFFSUMsYUFBYSxDQUZqQjtBQUFBLE1BR0lDLGVBQWUsQ0FIbkI7O0FBS0EsU0FBT0gsWUFBWWIsS0FBS1ksS0FBTCxDQUFXSyxNQUF2QixJQUFpQ0gsY0FBY2IsT0FBT1csS0FBUCxDQUFhSyxNQUFuRSxFQUEyRTtBQUN6RSxRQUFJQyxjQUFjbEIsS0FBS1ksS0FBTCxDQUFXQyxTQUFYLEtBQXlCLEVBQUNNLFVBQVVDLFFBQVgsRUFBM0M7QUFBQSxRQUNJQyxnQkFBZ0JwQixPQUFPVyxLQUFQLENBQWFFLFdBQWIsS0FBNkIsRUFBQ0ssVUFBVUMsUUFBWCxFQURqRDs7QUFHQSxRQUFJRSxXQUFXSixXQUFYLEVBQXdCRyxhQUF4QixDQUFKLEVBQTRDO0FBQzFDO0FBQ0FqQixVQUFJUSxLQUFKLENBQVVXLElBQVYsQ0FBZUMsVUFBVU4sV0FBVixFQUF1QkgsVUFBdkIsQ0FBZjtBQUNBRjtBQUNBRyxzQkFBZ0JFLFlBQVlwQixRQUFaLEdBQXVCb0IsWUFBWXJCLFFBQW5EO0FBQ0QsS0FMRCxNQUtPLElBQUl5QixXQUFXRCxhQUFYLEVBQTBCSCxXQUExQixDQUFKLEVBQTRDO0FBQ2pEO0FBQ0FkLFVBQUlRLEtBQUosQ0FBVVcsSUFBVixDQUFlQyxVQUFVSCxhQUFWLEVBQXlCTCxZQUF6QixDQUFmO0FBQ0FGO0FBQ0FDLG9CQUFjTSxjQUFjdkIsUUFBZCxHQUF5QnVCLGNBQWN4QixRQUFyRDtBQUNELEtBTE0sTUFLQTtBQUNMO0FBQ0EsVUFBSTRCLGFBQWE7QUFDZk4sa0JBQVVPLEtBQUtDLEdBQUwsQ0FBU1QsWUFBWUMsUUFBckIsRUFBK0JFLGNBQWNGLFFBQTdDLENBREs7QUFFZnRCLGtCQUFVLENBRks7QUFHZitCLGtCQUFVRixLQUFLQyxHQUFMLENBQVNULFlBQVlVLFFBQVosR0FBdUJiLFVBQWhDLEVBQTRDTSxjQUFjRixRQUFkLEdBQXlCSCxZQUFyRSxDQUhLO0FBSWZsQixrQkFBVSxDQUpLO0FBS2ZGLGVBQU87QUFMUSxPQUFqQjtBQU9BaUMsaUJBQVdKLFVBQVgsRUFBdUJQLFlBQVlDLFFBQW5DLEVBQTZDRCxZQUFZdEIsS0FBekQsRUFBZ0V5QixjQUFjRixRQUE5RSxFQUF3RkUsY0FBY3pCLEtBQXRHO0FBQ0FrQjtBQUNBRDs7QUFFQVQsVUFBSVEsS0FBSixDQUFVVyxJQUFWLENBQWVFLFVBQWY7QUFDRDtBQUNGOztBQUVELFNBQU9yQixHQUFQO0FBQ0Q7O0FBRUQsU0FBU0QsU0FBVCxDQUFtQjJCLEtBQW5CLEVBQTBCNUIsSUFBMUIsRUFBZ0M7QUFDOUIsTUFBSSxPQUFPNEIsS0FBUCxLQUFpQixRQUFyQixFQUErQjtBQUM3QixRQUFJLE9BQU9DLElBQVAsQ0FBWUQsS0FBWixLQUF1QixXQUFXQyxJQUFYLENBQWdCRCxLQUFoQixDQUEzQixFQUFvRDtBQUNsRCxhQUFPLHlFQUFXQSxLQUFYLEVBQWtCLENBQWxCO0FBQVA7QUFDRDs7QUFFRCxRQUFJLENBQUM1QixJQUFMLEVBQVc7QUFDVCxZQUFNLElBQUk4QixLQUFKLENBQVUsa0RBQVYsQ0FBTjtBQUNEO0FBQ0QsV0FBTywrRUFBZ0JqQyxTQUFoQixFQUEyQkEsU0FBM0IsRUFBc0NHLElBQXRDLEVBQTRDNEIsS0FBNUM7QUFBUDtBQUNEOztBQUVELFNBQU9BLEtBQVA7QUFDRDs7QUFFRCxTQUFTdkIsZUFBVCxDQUF5QjBCLEtBQXpCLEVBQWdDO0FBQzlCLFNBQU9BLE1BQU0zQixXQUFOLElBQXFCMkIsTUFBTTNCLFdBQU4sS0FBc0IyQixNQUFNekIsV0FBeEQ7QUFDRDs7QUFFRCxTQUFTRyxXQUFULENBQXFCTixLQUFyQixFQUE0QkwsSUFBNUIsRUFBa0NDLE1BQWxDLEVBQTBDO0FBQ3hDLE1BQUlELFNBQVNDLE1BQWIsRUFBcUI7QUFDbkIsV0FBT0QsSUFBUDtBQUNELEdBRkQsTUFFTztBQUNMSyxVQUFNNkIsUUFBTixHQUFpQixJQUFqQjtBQUNBLFdBQU8sRUFBQ2xDLFVBQUQsRUFBT0MsY0FBUCxFQUFQO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTcUIsVUFBVCxDQUFvQlMsSUFBcEIsRUFBMEJJLEtBQTFCLEVBQWlDO0FBQy9CLFNBQU9KLEtBQUtaLFFBQUwsR0FBZ0JnQixNQUFNaEIsUUFBdEIsSUFDRFksS0FBS1osUUFBTCxHQUFnQlksS0FBS2xDLFFBQXRCLEdBQWtDc0MsTUFBTWhCLFFBRDdDO0FBRUQ7O0FBRUQsU0FBU0ssU0FBVCxDQUFtQjlCLElBQW5CLEVBQXlCMEMsTUFBekIsRUFBaUM7QUFDL0IsU0FBTztBQUNMakIsY0FBVXpCLEtBQUt5QixRQURWLEVBQ29CdEIsVUFBVUgsS0FBS0csUUFEbkM7QUFFTCtCLGNBQVVsQyxLQUFLa0MsUUFBTCxHQUFnQlEsTUFGckIsRUFFNkJ0QyxVQUFVSixLQUFLSSxRQUY1QztBQUdMRixXQUFPRixLQUFLRTtBQUhQLEdBQVA7QUFLRDs7QUFFRCxTQUFTaUMsVUFBVCxDQUFvQm5DLElBQXBCLEVBQTBCcUIsVUFBMUIsRUFBc0NzQixTQUF0QyxFQUFpREMsV0FBakQsRUFBOERDLFVBQTlELEVBQTBFO0FBQ3hFO0FBQ0E7QUFDQSxNQUFJdkMsT0FBTyxFQUFDb0MsUUFBUXJCLFVBQVQsRUFBcUJuQixPQUFPeUMsU0FBNUIsRUFBdUNoQyxPQUFPLENBQTlDLEVBQVg7QUFBQSxNQUNJbUMsUUFBUSxFQUFDSixRQUFRRSxXQUFULEVBQXNCMUMsT0FBTzJDLFVBQTdCLEVBQXlDbEMsT0FBTyxDQUFoRCxFQURaOztBQUdBO0FBQ0FvQyxnQkFBYy9DLElBQWQsRUFBb0JNLElBQXBCLEVBQTBCd0MsS0FBMUI7QUFDQUMsZ0JBQWMvQyxJQUFkLEVBQW9COEMsS0FBcEIsRUFBMkJ4QyxJQUEzQjs7QUFFQTtBQUNBLFNBQU9BLEtBQUtLLEtBQUwsR0FBYUwsS0FBS0osS0FBTCxDQUFXcUIsTUFBeEIsSUFBa0N1QixNQUFNbkMsS0FBTixHQUFjbUMsTUFBTTVDLEtBQU4sQ0FBWXFCLE1BQW5FLEVBQTJFO0FBQ3pFLFFBQUlDLGNBQWNsQixLQUFLSixLQUFMLENBQVdJLEtBQUtLLEtBQWhCLENBQWxCO0FBQUEsUUFDSXFDLGVBQWVGLE1BQU01QyxLQUFOLENBQVk0QyxNQUFNbkMsS0FBbEIsQ0FEbkI7O0FBR0EsUUFBSSxDQUFDYSxZQUFZLENBQVosTUFBbUIsR0FBbkIsSUFBMEJBLFlBQVksQ0FBWixNQUFtQixHQUE5QyxNQUNJd0IsYUFBYSxDQUFiLE1BQW9CLEdBQXBCLElBQTJCQSxhQUFhLENBQWIsTUFBb0IsR0FEbkQsQ0FBSixFQUM2RDtBQUMzRDtBQUNBQyxtQkFBYWpELElBQWIsRUFBbUJNLElBQW5CLEVBQXlCd0MsS0FBekI7QUFDRCxLQUpELE1BSU8sSUFBSXRCLFlBQVksQ0FBWixNQUFtQixHQUFuQixJQUEwQndCLGFBQWEsQ0FBYixNQUFvQixHQUFsRCxFQUF1RDtBQUFBOztBQUFBLDhCQUM1RDtBQUNBLDBFQUFLOUMsS0FBTCxFQUFXMkIsSUFBWCw0TEFBb0JxQixjQUFjNUMsSUFBZCxDQUFwQjtBQUNELEtBSE0sTUFHQSxJQUFJMEMsYUFBYSxDQUFiLE1BQW9CLEdBQXBCLElBQTJCeEIsWUFBWSxDQUFaLE1BQW1CLEdBQWxELEVBQXVEO0FBQUE7O0FBQUEsOEJBQzVEO0FBQ0EsMkVBQUt0QixLQUFMLEVBQVcyQixJQUFYLDZMQUFvQnFCLGNBQWNKLEtBQWQsQ0FBcEI7QUFDRCxLQUhNLE1BR0EsSUFBSXRCLFlBQVksQ0FBWixNQUFtQixHQUFuQixJQUEwQndCLGFBQWEsQ0FBYixNQUFvQixHQUFsRCxFQUF1RDtBQUM1RDtBQUNBRyxjQUFRbkQsSUFBUixFQUFjTSxJQUFkLEVBQW9Cd0MsS0FBcEI7QUFDRCxLQUhNLE1BR0EsSUFBSUUsYUFBYSxDQUFiLE1BQW9CLEdBQXBCLElBQTJCeEIsWUFBWSxDQUFaLE1BQW1CLEdBQWxELEVBQXVEO0FBQzVEO0FBQ0EyQixjQUFRbkQsSUFBUixFQUFjOEMsS0FBZCxFQUFxQnhDLElBQXJCLEVBQTJCLElBQTNCO0FBQ0QsS0FITSxNQUdBLElBQUlrQixnQkFBZ0J3QixZQUFwQixFQUFrQztBQUN2QztBQUNBaEQsV0FBS0UsS0FBTCxDQUFXMkIsSUFBWCxDQUFnQkwsV0FBaEI7QUFDQWxCLFdBQUtLLEtBQUw7QUFDQW1DLFlBQU1uQyxLQUFOO0FBQ0QsS0FMTSxNQUtBO0FBQ0w7QUFDQTZCLGVBQVN4QyxJQUFULEVBQWVrRCxjQUFjNUMsSUFBZCxDQUFmLEVBQW9DNEMsY0FBY0osS0FBZCxDQUFwQztBQUNEO0FBQ0Y7O0FBRUQ7QUFDQU0saUJBQWVwRCxJQUFmLEVBQXFCTSxJQUFyQjtBQUNBOEMsaUJBQWVwRCxJQUFmLEVBQXFCOEMsS0FBckI7O0FBRUFoRCxnQkFBY0UsSUFBZDtBQUNEOztBQUVELFNBQVNpRCxZQUFULENBQXNCakQsSUFBdEIsRUFBNEJNLElBQTVCLEVBQWtDd0MsS0FBbEMsRUFBeUM7QUFDdkMsTUFBSU8sWUFBWUgsY0FBYzVDLElBQWQsQ0FBaEI7QUFBQSxNQUNJZ0QsZUFBZUosY0FBY0osS0FBZCxDQURuQjs7QUFHQSxNQUFJUyxXQUFXRixTQUFYLEtBQXlCRSxXQUFXRCxZQUFYLENBQTdCLEVBQXVEO0FBQ3JEO0FBQ0EsUUFBSSw4RUFBZ0JELFNBQWhCLEVBQTJCQyxZQUEzQixLQUNHRSxtQkFBbUJWLEtBQW5CLEVBQTBCTyxTQUExQixFQUFxQ0EsVUFBVTlCLE1BQVYsR0FBbUIrQixhQUFhL0IsTUFBckUsQ0FEUCxFQUNxRjtBQUFBOztBQUFBLDZCQUNuRixzRUFBS3JCLEtBQUwsRUFBVzJCLElBQVgsNkxBQW9Cd0IsU0FBcEI7QUFDQTtBQUNELEtBSkQsTUFJTyxJQUFJLDhFQUFnQkMsWUFBaEIsRUFBOEJELFNBQTlCLEtBQ0pHLG1CQUFtQmxELElBQW5CLEVBQXlCZ0QsWUFBekIsRUFBdUNBLGFBQWEvQixNQUFiLEdBQXNCOEIsVUFBVTlCLE1BQXZFLENBREEsRUFDZ0Y7QUFBQTs7QUFBQSw2QkFDckYsc0VBQUtyQixLQUFMLEVBQVcyQixJQUFYLDZMQUFvQnlCLFlBQXBCO0FBQ0E7QUFDRDtBQUNGLEdBWEQsTUFXTyxJQUFJLHlFQUFXRCxTQUFYLEVBQXNCQyxZQUF0QixDQUFKLEVBQXlDO0FBQUE7O0FBQUEsMkJBQzlDLHNFQUFLcEQsS0FBTCxFQUFXMkIsSUFBWCw2TEFBb0J3QixTQUFwQjtBQUNBO0FBQ0Q7O0FBRURiLFdBQVN4QyxJQUFULEVBQWVxRCxTQUFmLEVBQTBCQyxZQUExQjtBQUNEOztBQUVELFNBQVNILE9BQVQsQ0FBaUJuRCxJQUFqQixFQUF1Qk0sSUFBdkIsRUFBNkJ3QyxLQUE3QixFQUFvQ1csSUFBcEMsRUFBMEM7QUFDeEMsTUFBSUosWUFBWUgsY0FBYzVDLElBQWQsQ0FBaEI7QUFBQSxNQUNJZ0QsZUFBZUksZUFBZVosS0FBZixFQUFzQk8sU0FBdEIsQ0FEbkI7QUFFQSxNQUFJQyxhQUFhSyxNQUFqQixFQUF5QjtBQUFBOztBQUFBLDJCQUN2QixzRUFBS3pELEtBQUwsRUFBVzJCLElBQVgsNkxBQW9CeUIsYUFBYUssTUFBakM7QUFDRCxHQUZELE1BRU87QUFDTG5CLGFBQVN4QyxJQUFULEVBQWV5RCxPQUFPSCxZQUFQLEdBQXNCRCxTQUFyQyxFQUFnREksT0FBT0osU0FBUCxHQUFtQkMsWUFBbkU7QUFDRDtBQUNGOztBQUVELFNBQVNkLFFBQVQsQ0FBa0J4QyxJQUFsQixFQUF3Qk0sSUFBeEIsRUFBOEJ3QyxLQUE5QixFQUFxQztBQUNuQzlDLE9BQUt3QyxRQUFMLEdBQWdCLElBQWhCO0FBQ0F4QyxPQUFLRSxLQUFMLENBQVcyQixJQUFYLENBQWdCO0FBQ2RXLGNBQVUsSUFESTtBQUVkbEMsVUFBTUEsSUFGUTtBQUdkQyxZQUFRdUM7QUFITSxHQUFoQjtBQUtEOztBQUVELFNBQVNDLGFBQVQsQ0FBdUIvQyxJQUF2QixFQUE2QjRELE1BQTdCLEVBQXFDZCxLQUFyQyxFQUE0QztBQUMxQyxTQUFPYyxPQUFPbEIsTUFBUCxHQUFnQkksTUFBTUosTUFBdEIsSUFBZ0NrQixPQUFPakQsS0FBUCxHQUFlaUQsT0FBTzFELEtBQVAsQ0FBYXFCLE1BQW5FLEVBQTJFO0FBQ3pFLFFBQUlzQyxPQUFPRCxPQUFPMUQsS0FBUCxDQUFhMEQsT0FBT2pELEtBQVAsRUFBYixDQUFYO0FBQ0FYLFNBQUtFLEtBQUwsQ0FBVzJCLElBQVgsQ0FBZ0JnQyxJQUFoQjtBQUNBRCxXQUFPbEIsTUFBUDtBQUNEO0FBQ0Y7QUFDRCxTQUFTVSxjQUFULENBQXdCcEQsSUFBeEIsRUFBOEI0RCxNQUE5QixFQUFzQztBQUNwQyxTQUFPQSxPQUFPakQsS0FBUCxHQUFlaUQsT0FBTzFELEtBQVAsQ0FBYXFCLE1BQW5DLEVBQTJDO0FBQ3pDLFFBQUlzQyxPQUFPRCxPQUFPMUQsS0FBUCxDQUFhMEQsT0FBT2pELEtBQVAsRUFBYixDQUFYO0FBQ0FYLFNBQUtFLEtBQUwsQ0FBVzJCLElBQVgsQ0FBZ0JnQyxJQUFoQjtBQUNEO0FBQ0Y7O0FBRUQsU0FBU1gsYUFBVCxDQUF1QlksS0FBdkIsRUFBOEI7QUFDNUIsTUFBSXBELE1BQU0sRUFBVjtBQUFBLE1BQ0lxRCxZQUFZRCxNQUFNNUQsS0FBTixDQUFZNEQsTUFBTW5ELEtBQWxCLEVBQXlCLENBQXpCLENBRGhCO0FBRUEsU0FBT21ELE1BQU1uRCxLQUFOLEdBQWNtRCxNQUFNNUQsS0FBTixDQUFZcUIsTUFBakMsRUFBeUM7QUFDdkMsUUFBSXNDLE9BQU9DLE1BQU01RCxLQUFOLENBQVk0RCxNQUFNbkQsS0FBbEIsQ0FBWDs7QUFFQTtBQUNBLFFBQUlvRCxjQUFjLEdBQWQsSUFBcUJGLEtBQUssQ0FBTCxNQUFZLEdBQXJDLEVBQTBDO0FBQ3hDRSxrQkFBWSxHQUFaO0FBQ0Q7O0FBRUQsUUFBSUEsY0FBY0YsS0FBSyxDQUFMLENBQWxCLEVBQTJCO0FBQ3pCbkQsVUFBSW1CLElBQUosQ0FBU2dDLElBQVQ7QUFDQUMsWUFBTW5ELEtBQU47QUFDRCxLQUhELE1BR087QUFDTDtBQUNEO0FBQ0Y7O0FBRUQsU0FBT0QsR0FBUDtBQUNEO0FBQ0QsU0FBU2dELGNBQVQsQ0FBd0JJLEtBQXhCLEVBQStCRSxZQUEvQixFQUE2QztBQUMzQyxNQUFJQyxVQUFVLEVBQWQ7QUFBQSxNQUNJTixTQUFTLEVBRGI7QUFBQSxNQUVJTyxhQUFhLENBRmpCO0FBQUEsTUFHSUMsaUJBQWlCLEtBSHJCO0FBQUEsTUFJSUMsYUFBYSxLQUpqQjtBQUtBLFNBQU9GLGFBQWFGLGFBQWF6QyxNQUExQixJQUNFdUMsTUFBTW5ELEtBQU4sR0FBY21ELE1BQU01RCxLQUFOLENBQVlxQixNQURuQyxFQUMyQztBQUN6QyxRQUFJOEMsU0FBU1AsTUFBTTVELEtBQU4sQ0FBWTRELE1BQU1uRCxLQUFsQixDQUFiO0FBQUEsUUFDSTJELFFBQVFOLGFBQWFFLFVBQWIsQ0FEWjs7QUFHQTtBQUNBLFFBQUlJLE1BQU0sQ0FBTixNQUFhLEdBQWpCLEVBQXNCO0FBQ3BCO0FBQ0Q7O0FBRURILHFCQUFpQkEsa0JBQWtCRSxPQUFPLENBQVAsTUFBYyxHQUFqRDs7QUFFQVYsV0FBTzlCLElBQVAsQ0FBWXlDLEtBQVo7QUFDQUo7O0FBRUE7QUFDQTtBQUNBLFFBQUlHLE9BQU8sQ0FBUCxNQUFjLEdBQWxCLEVBQXVCO0FBQ3JCRCxtQkFBYSxJQUFiOztBQUVBLGFBQU9DLE9BQU8sQ0FBUCxNQUFjLEdBQXJCLEVBQTBCO0FBQ3hCSixnQkFBUXBDLElBQVIsQ0FBYXdDLE1BQWI7QUFDQUEsaUJBQVNQLE1BQU01RCxLQUFOLENBQVksRUFBRTRELE1BQU1uRCxLQUFwQixDQUFUO0FBQ0Q7QUFDRjs7QUFFRCxRQUFJMkQsTUFBTUMsTUFBTixDQUFhLENBQWIsTUFBb0JGLE9BQU9FLE1BQVAsQ0FBYyxDQUFkLENBQXhCLEVBQTBDO0FBQ3hDTixjQUFRcEMsSUFBUixDQUFhd0MsTUFBYjtBQUNBUCxZQUFNbkQsS0FBTjtBQUNELEtBSEQsTUFHTztBQUNMeUQsbUJBQWEsSUFBYjtBQUNEO0FBQ0Y7O0FBRUQsTUFBSSxDQUFDSixhQUFhRSxVQUFiLEtBQTRCLEVBQTdCLEVBQWlDLENBQWpDLE1BQXdDLEdBQXhDLElBQ0dDLGNBRFAsRUFDdUI7QUFDckJDLGlCQUFhLElBQWI7QUFDRDs7QUFFRCxNQUFJQSxVQUFKLEVBQWdCO0FBQ2QsV0FBT0gsT0FBUDtBQUNEOztBQUVELFNBQU9DLGFBQWFGLGFBQWF6QyxNQUFqQyxFQUF5QztBQUN2Q29DLFdBQU85QixJQUFQLENBQVltQyxhQUFhRSxZQUFiLENBQVo7QUFDRDs7QUFFRCxTQUFPO0FBQ0xQLGtCQURLO0FBRUxNO0FBRkssR0FBUDtBQUlEOztBQUVELFNBQVNWLFVBQVQsQ0FBb0JVLE9BQXBCLEVBQTZCO0FBQzNCLFNBQU9BLFFBQVFPLE1BQVIsQ0FBZSxVQUFTQyxJQUFULEVBQWVKLE1BQWYsRUFBdUI7QUFDM0MsV0FBT0ksUUFBUUosT0FBTyxDQUFQLE1BQWMsR0FBN0I7QUFDRCxHQUZNLEVBRUosSUFGSSxDQUFQO0FBR0Q7QUFDRCxTQUFTYixrQkFBVCxDQUE0Qk0sS0FBNUIsRUFBbUNZLGFBQW5DLEVBQWtEQyxLQUFsRCxFQUF5RDtBQUN2RCxPQUFLLElBQUlDLElBQUksQ0FBYixFQUFnQkEsSUFBSUQsS0FBcEIsRUFBMkJDLEdBQTNCLEVBQWdDO0FBQzlCLFFBQUlDLGdCQUFnQkgsY0FBY0EsY0FBY25ELE1BQWQsR0FBdUJvRCxLQUF2QixHQUErQkMsQ0FBN0MsRUFBZ0RMLE1BQWhELENBQXVELENBQXZELENBQXBCO0FBQ0EsUUFBSVQsTUFBTTVELEtBQU4sQ0FBWTRELE1BQU1uRCxLQUFOLEdBQWNpRSxDQUExQixNQUFpQyxNQUFNQyxhQUEzQyxFQUEwRDtBQUN4RCxhQUFPLEtBQVA7QUFDRDtBQUNGOztBQUVEZixRQUFNbkQsS0FBTixJQUFlZ0UsS0FBZjtBQUNBLFNBQU8sSUFBUDtBQUNEOztBQUVELFNBQVMxRSxtQkFBVCxDQUE2QkMsS0FBN0IsRUFBb0M7QUFDbEMsTUFBSUMsV0FBVyxDQUFmO0FBQ0EsTUFBSUMsV0FBVyxDQUFmOztBQUVBRixRQUFNNEUsT0FBTixDQUFjLFVBQVNqQixJQUFULEVBQWU7QUFDM0IsUUFBSSxPQUFPQSxJQUFQLEtBQWdCLFFBQXBCLEVBQThCO0FBQzVCLFVBQUlrQixVQUFVOUUsb0JBQW9CNEQsS0FBS3ZELElBQXpCLENBQWQ7QUFDQSxVQUFJMEUsYUFBYS9FLG9CQUFvQjRELEtBQUt0RCxNQUF6QixDQUFqQjs7QUFFQSxVQUFJSixhQUFhRSxTQUFqQixFQUE0QjtBQUMxQixZQUFJMEUsUUFBUTVFLFFBQVIsS0FBcUI2RSxXQUFXN0UsUUFBcEMsRUFBOEM7QUFDNUNBLHNCQUFZNEUsUUFBUTVFLFFBQXBCO0FBQ0QsU0FGRCxNQUVPO0FBQ0xBLHFCQUFXRSxTQUFYO0FBQ0Q7QUFDRjs7QUFFRCxVQUFJRCxhQUFhQyxTQUFqQixFQUE0QjtBQUMxQixZQUFJMEUsUUFBUTNFLFFBQVIsS0FBcUI0RSxXQUFXNUUsUUFBcEMsRUFBOEM7QUFDNUNBLHNCQUFZMkUsUUFBUTNFLFFBQXBCO0FBQ0QsU0FGRCxNQUVPO0FBQ0xBLHFCQUFXQyxTQUFYO0FBQ0Q7QUFDRjtBQUNGLEtBbkJELE1BbUJPO0FBQ0wsVUFBSUQsYUFBYUMsU0FBYixLQUEyQndELEtBQUssQ0FBTCxNQUFZLEdBQVosSUFBbUJBLEtBQUssQ0FBTCxNQUFZLEdBQTFELENBQUosRUFBb0U7QUFDbEV6RDtBQUNEO0FBQ0QsVUFBSUQsYUFBYUUsU0FBYixLQUEyQndELEtBQUssQ0FBTCxNQUFZLEdBQVosSUFBbUJBLEtBQUssQ0FBTCxNQUFZLEdBQTFELENBQUosRUFBb0U7QUFDbEUxRDtBQUNEO0FBQ0Y7QUFDRixHQTVCRDs7QUE4QkEsU0FBTyxFQUFDQSxrQkFBRCxFQUFXQyxrQkFBWCxFQUFQO0FBQ0QiLCJmaWxlIjoibWVyZ2UuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3N0cnVjdHVyZWRQYXRjaH0gZnJvbSAnLi9jcmVhdGUnO1xuaW1wb3J0IHtwYXJzZVBhdGNofSBmcm9tICcuL3BhcnNlJztcblxuaW1wb3J0IHthcnJheUVxdWFsLCBhcnJheVN0YXJ0c1dpdGh9IGZyb20gJy4uL3V0aWwvYXJyYXknO1xuXG5leHBvcnQgZnVuY3Rpb24gY2FsY0xpbmVDb3VudChodW5rKSB7XG4gIGNvbnN0IHtvbGRMaW5lcywgbmV3TGluZXN9ID0gY2FsY09sZE5ld0xpbmVDb3VudChodW5rLmxpbmVzKTtcblxuICBpZiAob2xkTGluZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIGh1bmsub2xkTGluZXMgPSBvbGRMaW5lcztcbiAgfSBlbHNlIHtcbiAgICBkZWxldGUgaHVuay5vbGRMaW5lcztcbiAgfVxuXG4gIGlmIChuZXdMaW5lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaHVuay5uZXdMaW5lcyA9IG5ld0xpbmVzO1xuICB9IGVsc2Uge1xuICAgIGRlbGV0ZSBodW5rLm5ld0xpbmVzO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZShtaW5lLCB0aGVpcnMsIGJhc2UpIHtcbiAgbWluZSA9IGxvYWRQYXRjaChtaW5lLCBiYXNlKTtcbiAgdGhlaXJzID0gbG9hZFBhdGNoKHRoZWlycywgYmFzZSk7XG5cbiAgbGV0IHJldCA9IHt9O1xuXG4gIC8vIEZvciBpbmRleCB3ZSBqdXN0IGxldCBpdCBwYXNzIHRocm91Z2ggYXMgaXQgZG9lc24ndCBoYXZlIGFueSBuZWNlc3NhcnkgbWVhbmluZy5cbiAgLy8gTGVhdmluZyBzYW5pdHkgY2hlY2tzIG9uIHRoaXMgdG8gdGhlIEFQSSBjb25zdW1lciB0aGF0IG1heSBrbm93IG1vcmUgYWJvdXQgdGhlXG4gIC8vIG1lYW5pbmcgaW4gdGhlaXIgb3duIGNvbnRleHQuXG4gIGlmIChtaW5lLmluZGV4IHx8IHRoZWlycy5pbmRleCkge1xuICAgIHJldC5pbmRleCA9IG1pbmUuaW5kZXggfHwgdGhlaXJzLmluZGV4O1xuICB9XG5cbiAgaWYgKG1pbmUubmV3RmlsZU5hbWUgfHwgdGhlaXJzLm5ld0ZpbGVOYW1lKSB7XG4gICAgaWYgKCFmaWxlTmFtZUNoYW5nZWQobWluZSkpIHtcbiAgICAgIC8vIE5vIGhlYWRlciBvciBubyBjaGFuZ2UgaW4gb3VycywgdXNlIHRoZWlycyAoYW5kIG91cnMgaWYgdGhlaXJzIGRvZXMgbm90IGV4aXN0KVxuICAgICAgcmV0Lm9sZEZpbGVOYW1lID0gdGhlaXJzLm9sZEZpbGVOYW1lIHx8IG1pbmUub2xkRmlsZU5hbWU7XG4gICAgICByZXQubmV3RmlsZU5hbWUgPSB0aGVpcnMubmV3RmlsZU5hbWUgfHwgbWluZS5uZXdGaWxlTmFtZTtcbiAgICAgIHJldC5vbGRIZWFkZXIgPSB0aGVpcnMub2xkSGVhZGVyIHx8IG1pbmUub2xkSGVhZGVyO1xuICAgICAgcmV0Lm5ld0hlYWRlciA9IHRoZWlycy5uZXdIZWFkZXIgfHwgbWluZS5uZXdIZWFkZXI7XG4gICAgfSBlbHNlIGlmICghZmlsZU5hbWVDaGFuZ2VkKHRoZWlycykpIHtcbiAgICAgIC8vIE5vIGhlYWRlciBvciBubyBjaGFuZ2UgaW4gdGhlaXJzLCB1c2Ugb3Vyc1xuICAgICAgcmV0Lm9sZEZpbGVOYW1lID0gbWluZS5vbGRGaWxlTmFtZTtcbiAgICAgIHJldC5uZXdGaWxlTmFtZSA9IG1pbmUubmV3RmlsZU5hbWU7XG4gICAgICByZXQub2xkSGVhZGVyID0gbWluZS5vbGRIZWFkZXI7XG4gICAgICByZXQubmV3SGVhZGVyID0gbWluZS5uZXdIZWFkZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEJvdGggY2hhbmdlZC4uLiBmaWd1cmUgaXQgb3V0XG4gICAgICByZXQub2xkRmlsZU5hbWUgPSBzZWxlY3RGaWVsZChyZXQsIG1pbmUub2xkRmlsZU5hbWUsIHRoZWlycy5vbGRGaWxlTmFtZSk7XG4gICAgICByZXQubmV3RmlsZU5hbWUgPSBzZWxlY3RGaWVsZChyZXQsIG1pbmUubmV3RmlsZU5hbWUsIHRoZWlycy5uZXdGaWxlTmFtZSk7XG4gICAgICByZXQub2xkSGVhZGVyID0gc2VsZWN0RmllbGQocmV0LCBtaW5lLm9sZEhlYWRlciwgdGhlaXJzLm9sZEhlYWRlcik7XG4gICAgICByZXQubmV3SGVhZGVyID0gc2VsZWN0RmllbGQocmV0LCBtaW5lLm5ld0hlYWRlciwgdGhlaXJzLm5ld0hlYWRlcik7XG4gICAgfVxuICB9XG5cbiAgcmV0Lmh1bmtzID0gW107XG5cbiAgbGV0IG1pbmVJbmRleCA9IDAsXG4gICAgICB0aGVpcnNJbmRleCA9IDAsXG4gICAgICBtaW5lT2Zmc2V0ID0gMCxcbiAgICAgIHRoZWlyc09mZnNldCA9IDA7XG5cbiAgd2hpbGUgKG1pbmVJbmRleCA8IG1pbmUuaHVua3MubGVuZ3RoIHx8IHRoZWlyc0luZGV4IDwgdGhlaXJzLmh1bmtzLmxlbmd0aCkge1xuICAgIGxldCBtaW5lQ3VycmVudCA9IG1pbmUuaHVua3NbbWluZUluZGV4XSB8fCB7b2xkU3RhcnQ6IEluZmluaXR5fSxcbiAgICAgICAgdGhlaXJzQ3VycmVudCA9IHRoZWlycy5odW5rc1t0aGVpcnNJbmRleF0gfHwge29sZFN0YXJ0OiBJbmZpbml0eX07XG5cbiAgICBpZiAoaHVua0JlZm9yZShtaW5lQ3VycmVudCwgdGhlaXJzQ3VycmVudCkpIHtcbiAgICAgIC8vIFRoaXMgcGF0Y2ggZG9lcyBub3Qgb3ZlcmxhcCB3aXRoIGFueSBvZiB0aGUgb3RoZXJzLCB5YXkuXG4gICAgICByZXQuaHVua3MucHVzaChjbG9uZUh1bmsobWluZUN1cnJlbnQsIG1pbmVPZmZzZXQpKTtcbiAgICAgIG1pbmVJbmRleCsrO1xuICAgICAgdGhlaXJzT2Zmc2V0ICs9IG1pbmVDdXJyZW50Lm5ld0xpbmVzIC0gbWluZUN1cnJlbnQub2xkTGluZXM7XG4gICAgfSBlbHNlIGlmIChodW5rQmVmb3JlKHRoZWlyc0N1cnJlbnQsIG1pbmVDdXJyZW50KSkge1xuICAgICAgLy8gVGhpcyBwYXRjaCBkb2VzIG5vdCBvdmVybGFwIHdpdGggYW55IG9mIHRoZSBvdGhlcnMsIHlheS5cbiAgICAgIHJldC5odW5rcy5wdXNoKGNsb25lSHVuayh0aGVpcnNDdXJyZW50LCB0aGVpcnNPZmZzZXQpKTtcbiAgICAgIHRoZWlyc0luZGV4Kys7XG4gICAgICBtaW5lT2Zmc2V0ICs9IHRoZWlyc0N1cnJlbnQubmV3TGluZXMgLSB0aGVpcnNDdXJyZW50Lm9sZExpbmVzO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPdmVybGFwLCBtZXJnZSBhcyBiZXN0IHdlIGNhblxuICAgICAgbGV0IG1lcmdlZEh1bmsgPSB7XG4gICAgICAgIG9sZFN0YXJ0OiBNYXRoLm1pbihtaW5lQ3VycmVudC5vbGRTdGFydCwgdGhlaXJzQ3VycmVudC5vbGRTdGFydCksXG4gICAgICAgIG9sZExpbmVzOiAwLFxuICAgICAgICBuZXdTdGFydDogTWF0aC5taW4obWluZUN1cnJlbnQubmV3U3RhcnQgKyBtaW5lT2Zmc2V0LCB0aGVpcnNDdXJyZW50Lm9sZFN0YXJ0ICsgdGhlaXJzT2Zmc2V0KSxcbiAgICAgICAgbmV3TGluZXM6IDAsXG4gICAgICAgIGxpbmVzOiBbXVxuICAgICAgfTtcbiAgICAgIG1lcmdlTGluZXMobWVyZ2VkSHVuaywgbWluZUN1cnJlbnQub2xkU3RhcnQsIG1pbmVDdXJyZW50LmxpbmVzLCB0aGVpcnNDdXJyZW50Lm9sZFN0YXJ0LCB0aGVpcnNDdXJyZW50LmxpbmVzKTtcbiAgICAgIHRoZWlyc0luZGV4Kys7XG4gICAgICBtaW5lSW5kZXgrKztcblxuICAgICAgcmV0Lmh1bmtzLnB1c2gobWVyZ2VkSHVuayk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gbG9hZFBhdGNoKHBhcmFtLCBiYXNlKSB7XG4gIGlmICh0eXBlb2YgcGFyYW0gPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKC9eQEAvbS50ZXN0KHBhcmFtKSB8fCAoL15JbmRleDovbS50ZXN0KHBhcmFtKSkpIHtcbiAgICAgIHJldHVybiBwYXJzZVBhdGNoKHBhcmFtKVswXTtcbiAgICB9XG5cbiAgICBpZiAoIWJhc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBwcm92aWRlIGEgYmFzZSByZWZlcmVuY2Ugb3IgcGFzcyBpbiBhIHBhdGNoJyk7XG4gICAgfVxuICAgIHJldHVybiBzdHJ1Y3R1cmVkUGF0Y2godW5kZWZpbmVkLCB1bmRlZmluZWQsIGJhc2UsIHBhcmFtKTtcbiAgfVxuXG4gIHJldHVybiBwYXJhbTtcbn1cblxuZnVuY3Rpb24gZmlsZU5hbWVDaGFuZ2VkKHBhdGNoKSB7XG4gIHJldHVybiBwYXRjaC5uZXdGaWxlTmFtZSAmJiBwYXRjaC5uZXdGaWxlTmFtZSAhPT0gcGF0Y2gub2xkRmlsZU5hbWU7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdEZpZWxkKGluZGV4LCBtaW5lLCB0aGVpcnMpIHtcbiAgaWYgKG1pbmUgPT09IHRoZWlycykge1xuICAgIHJldHVybiBtaW5lO1xuICB9IGVsc2Uge1xuICAgIGluZGV4LmNvbmZsaWN0ID0gdHJ1ZTtcbiAgICByZXR1cm4ge21pbmUsIHRoZWlyc307XG4gIH1cbn1cblxuZnVuY3Rpb24gaHVua0JlZm9yZSh0ZXN0LCBjaGVjaykge1xuICByZXR1cm4gdGVzdC5vbGRTdGFydCA8IGNoZWNrLm9sZFN0YXJ0XG4gICAgJiYgKHRlc3Qub2xkU3RhcnQgKyB0ZXN0Lm9sZExpbmVzKSA8IGNoZWNrLm9sZFN0YXJ0O1xufVxuXG5mdW5jdGlvbiBjbG9uZUh1bmsoaHVuaywgb2Zmc2V0KSB7XG4gIHJldHVybiB7XG4gICAgb2xkU3RhcnQ6IGh1bmsub2xkU3RhcnQsIG9sZExpbmVzOiBodW5rLm9sZExpbmVzLFxuICAgIG5ld1N0YXJ0OiBodW5rLm5ld1N0YXJ0ICsgb2Zmc2V0LCBuZXdMaW5lczogaHVuay5uZXdMaW5lcyxcbiAgICBsaW5lczogaHVuay5saW5lc1xuICB9O1xufVxuXG5mdW5jdGlvbiBtZXJnZUxpbmVzKGh1bmssIG1pbmVPZmZzZXQsIG1pbmVMaW5lcywgdGhlaXJPZmZzZXQsIHRoZWlyTGluZXMpIHtcbiAgLy8gVGhpcyB3aWxsIGdlbmVyYWxseSByZXN1bHQgaW4gYSBjb25mbGljdGVkIGh1bmssIGJ1dCB0aGVyZSBhcmUgY2FzZXMgd2hlcmUgdGhlIGNvbnRleHRcbiAgLy8gaXMgdGhlIG9ubHkgb3ZlcmxhcCB3aGVyZSB3ZSBjYW4gc3VjY2Vzc2Z1bGx5IG1lcmdlIHRoZSBjb250ZW50IGhlcmUuXG4gIGxldCBtaW5lID0ge29mZnNldDogbWluZU9mZnNldCwgbGluZXM6IG1pbmVMaW5lcywgaW5kZXg6IDB9LFxuICAgICAgdGhlaXIgPSB7b2Zmc2V0OiB0aGVpck9mZnNldCwgbGluZXM6IHRoZWlyTGluZXMsIGluZGV4OiAwfTtcblxuICAvLyBIYW5kbGUgYW55IGxlYWRpbmcgY29udGVudFxuICBpbnNlcnRMZWFkaW5nKGh1bmssIG1pbmUsIHRoZWlyKTtcbiAgaW5zZXJ0TGVhZGluZyhodW5rLCB0aGVpciwgbWluZSk7XG5cbiAgLy8gTm93IGluIHRoZSBvdmVybGFwIGNvbnRlbnQuIFNjYW4gdGhyb3VnaCBhbmQgc2VsZWN0IHRoZSBiZXN0IGNoYW5nZXMgZnJvbSBlYWNoLlxuICB3aGlsZSAobWluZS5pbmRleCA8IG1pbmUubGluZXMubGVuZ3RoICYmIHRoZWlyLmluZGV4IDwgdGhlaXIubGluZXMubGVuZ3RoKSB7XG4gICAgbGV0IG1pbmVDdXJyZW50ID0gbWluZS5saW5lc1ttaW5lLmluZGV4XSxcbiAgICAgICAgdGhlaXJDdXJyZW50ID0gdGhlaXIubGluZXNbdGhlaXIuaW5kZXhdO1xuXG4gICAgaWYgKChtaW5lQ3VycmVudFswXSA9PT0gJy0nIHx8IG1pbmVDdXJyZW50WzBdID09PSAnKycpXG4gICAgICAgICYmICh0aGVpckN1cnJlbnRbMF0gPT09ICctJyB8fCB0aGVpckN1cnJlbnRbMF0gPT09ICcrJykpIHtcbiAgICAgIC8vIEJvdGggbW9kaWZpZWQgLi4uXG4gICAgICBtdXR1YWxDaGFuZ2UoaHVuaywgbWluZSwgdGhlaXIpO1xuICAgIH0gZWxzZSBpZiAobWluZUN1cnJlbnRbMF0gPT09ICcrJyAmJiB0aGVpckN1cnJlbnRbMF0gPT09ICcgJykge1xuICAgICAgLy8gTWluZSBpbnNlcnRlZFxuICAgICAgaHVuay5saW5lcy5wdXNoKC4uLiBjb2xsZWN0Q2hhbmdlKG1pbmUpKTtcbiAgICB9IGVsc2UgaWYgKHRoZWlyQ3VycmVudFswXSA9PT0gJysnICYmIG1pbmVDdXJyZW50WzBdID09PSAnICcpIHtcbiAgICAgIC8vIFRoZWlycyBpbnNlcnRlZFxuICAgICAgaHVuay5saW5lcy5wdXNoKC4uLiBjb2xsZWN0Q2hhbmdlKHRoZWlyKSk7XG4gICAgfSBlbHNlIGlmIChtaW5lQ3VycmVudFswXSA9PT0gJy0nICYmIHRoZWlyQ3VycmVudFswXSA9PT0gJyAnKSB7XG4gICAgICAvLyBNaW5lIHJlbW92ZWQgb3IgZWRpdGVkXG4gICAgICByZW1vdmFsKGh1bmssIG1pbmUsIHRoZWlyKTtcbiAgICB9IGVsc2UgaWYgKHRoZWlyQ3VycmVudFswXSA9PT0gJy0nICYmIG1pbmVDdXJyZW50WzBdID09PSAnICcpIHtcbiAgICAgIC8vIFRoZWlyIHJlbW92ZWQgb3IgZWRpdGVkXG4gICAgICByZW1vdmFsKGh1bmssIHRoZWlyLCBtaW5lLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKG1pbmVDdXJyZW50ID09PSB0aGVpckN1cnJlbnQpIHtcbiAgICAgIC8vIENvbnRleHQgaWRlbnRpdHlcbiAgICAgIGh1bmsubGluZXMucHVzaChtaW5lQ3VycmVudCk7XG4gICAgICBtaW5lLmluZGV4Kys7XG4gICAgICB0aGVpci5pbmRleCsrO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDb250ZXh0IG1pc21hdGNoXG4gICAgICBjb25mbGljdChodW5rLCBjb2xsZWN0Q2hhbmdlKG1pbmUpLCBjb2xsZWN0Q2hhbmdlKHRoZWlyKSk7XG4gICAgfVxuICB9XG5cbiAgLy8gTm93IHB1c2ggYW55dGhpbmcgdGhhdCBtYXkgYmUgcmVtYWluaW5nXG4gIGluc2VydFRyYWlsaW5nKGh1bmssIG1pbmUpO1xuICBpbnNlcnRUcmFpbGluZyhodW5rLCB0aGVpcik7XG5cbiAgY2FsY0xpbmVDb3VudChodW5rKTtcbn1cblxuZnVuY3Rpb24gbXV0dWFsQ2hhbmdlKGh1bmssIG1pbmUsIHRoZWlyKSB7XG4gIGxldCBteUNoYW5nZXMgPSBjb2xsZWN0Q2hhbmdlKG1pbmUpLFxuICAgICAgdGhlaXJDaGFuZ2VzID0gY29sbGVjdENoYW5nZSh0aGVpcik7XG5cbiAgaWYgKGFsbFJlbW92ZXMobXlDaGFuZ2VzKSAmJiBhbGxSZW1vdmVzKHRoZWlyQ2hhbmdlcykpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIHJlbW92ZSBjaGFuZ2VzIHRoYXQgYXJlIHN1cGVyc2V0cyBvZiBvbmUgYW5vdGhlclxuICAgIGlmIChhcnJheVN0YXJ0c1dpdGgobXlDaGFuZ2VzLCB0aGVpckNoYW5nZXMpXG4gICAgICAgICYmIHNraXBSZW1vdmVTdXBlcnNldCh0aGVpciwgbXlDaGFuZ2VzLCBteUNoYW5nZXMubGVuZ3RoIC0gdGhlaXJDaGFuZ2VzLmxlbmd0aCkpIHtcbiAgICAgIGh1bmsubGluZXMucHVzaCguLi4gbXlDaGFuZ2VzKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKGFycmF5U3RhcnRzV2l0aCh0aGVpckNoYW5nZXMsIG15Q2hhbmdlcylcbiAgICAgICAgJiYgc2tpcFJlbW92ZVN1cGVyc2V0KG1pbmUsIHRoZWlyQ2hhbmdlcywgdGhlaXJDaGFuZ2VzLmxlbmd0aCAtIG15Q2hhbmdlcy5sZW5ndGgpKSB7XG4gICAgICBodW5rLmxpbmVzLnB1c2goLi4uIHRoZWlyQ2hhbmdlcyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9IGVsc2UgaWYgKGFycmF5RXF1YWwobXlDaGFuZ2VzLCB0aGVpckNoYW5nZXMpKSB7XG4gICAgaHVuay5saW5lcy5wdXNoKC4uLiBteUNoYW5nZXMpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbmZsaWN0KGh1bmssIG15Q2hhbmdlcywgdGhlaXJDaGFuZ2VzKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZhbChodW5rLCBtaW5lLCB0aGVpciwgc3dhcCkge1xuICBsZXQgbXlDaGFuZ2VzID0gY29sbGVjdENoYW5nZShtaW5lKSxcbiAgICAgIHRoZWlyQ2hhbmdlcyA9IGNvbGxlY3RDb250ZXh0KHRoZWlyLCBteUNoYW5nZXMpO1xuICBpZiAodGhlaXJDaGFuZ2VzLm1lcmdlZCkge1xuICAgIGh1bmsubGluZXMucHVzaCguLi4gdGhlaXJDaGFuZ2VzLm1lcmdlZCk7XG4gIH0gZWxzZSB7XG4gICAgY29uZmxpY3QoaHVuaywgc3dhcCA/IHRoZWlyQ2hhbmdlcyA6IG15Q2hhbmdlcywgc3dhcCA/IG15Q2hhbmdlcyA6IHRoZWlyQ2hhbmdlcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29uZmxpY3QoaHVuaywgbWluZSwgdGhlaXIpIHtcbiAgaHVuay5jb25mbGljdCA9IHRydWU7XG4gIGh1bmsubGluZXMucHVzaCh7XG4gICAgY29uZmxpY3Q6IHRydWUsXG4gICAgbWluZTogbWluZSxcbiAgICB0aGVpcnM6IHRoZWlyXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRMZWFkaW5nKGh1bmssIGluc2VydCwgdGhlaXIpIHtcbiAgd2hpbGUgKGluc2VydC5vZmZzZXQgPCB0aGVpci5vZmZzZXQgJiYgaW5zZXJ0LmluZGV4IDwgaW5zZXJ0LmxpbmVzLmxlbmd0aCkge1xuICAgIGxldCBsaW5lID0gaW5zZXJ0LmxpbmVzW2luc2VydC5pbmRleCsrXTtcbiAgICBodW5rLmxpbmVzLnB1c2gobGluZSk7XG4gICAgaW5zZXJ0Lm9mZnNldCsrO1xuICB9XG59XG5mdW5jdGlvbiBpbnNlcnRUcmFpbGluZyhodW5rLCBpbnNlcnQpIHtcbiAgd2hpbGUgKGluc2VydC5pbmRleCA8IGluc2VydC5saW5lcy5sZW5ndGgpIHtcbiAgICBsZXQgbGluZSA9IGluc2VydC5saW5lc1tpbnNlcnQuaW5kZXgrK107XG4gICAgaHVuay5saW5lcy5wdXNoKGxpbmUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbGxlY3RDaGFuZ2Uoc3RhdGUpIHtcbiAgbGV0IHJldCA9IFtdLFxuICAgICAgb3BlcmF0aW9uID0gc3RhdGUubGluZXNbc3RhdGUuaW5kZXhdWzBdO1xuICB3aGlsZSAoc3RhdGUuaW5kZXggPCBzdGF0ZS5saW5lcy5sZW5ndGgpIHtcbiAgICBsZXQgbGluZSA9IHN0YXRlLmxpbmVzW3N0YXRlLmluZGV4XTtcblxuICAgIC8vIEdyb3VwIGFkZGl0aW9ucyB0aGF0IGFyZSBpbW1lZGlhdGVseSBhZnRlciBzdWJ0cmFjdGlvbnMgYW5kIHRyZWF0IHRoZW0gYXMgb25lIFwiYXRvbWljXCIgbW9kaWZ5IGNoYW5nZS5cbiAgICBpZiAob3BlcmF0aW9uID09PSAnLScgJiYgbGluZVswXSA9PT0gJysnKSB7XG4gICAgICBvcGVyYXRpb24gPSAnKyc7XG4gICAgfVxuXG4gICAgaWYgKG9wZXJhdGlvbiA9PT0gbGluZVswXSkge1xuICAgICAgcmV0LnB1c2gobGluZSk7XG4gICAgICBzdGF0ZS5pbmRleCsrO1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gY29sbGVjdENvbnRleHQoc3RhdGUsIG1hdGNoQ2hhbmdlcykge1xuICBsZXQgY2hhbmdlcyA9IFtdLFxuICAgICAgbWVyZ2VkID0gW10sXG4gICAgICBtYXRjaEluZGV4ID0gMCxcbiAgICAgIGNvbnRleHRDaGFuZ2VzID0gZmFsc2UsXG4gICAgICBjb25mbGljdGVkID0gZmFsc2U7XG4gIHdoaWxlIChtYXRjaEluZGV4IDwgbWF0Y2hDaGFuZ2VzLmxlbmd0aFxuICAgICAgICAmJiBzdGF0ZS5pbmRleCA8IHN0YXRlLmxpbmVzLmxlbmd0aCkge1xuICAgIGxldCBjaGFuZ2UgPSBzdGF0ZS5saW5lc1tzdGF0ZS5pbmRleF0sXG4gICAgICAgIG1hdGNoID0gbWF0Y2hDaGFuZ2VzW21hdGNoSW5kZXhdO1xuXG4gICAgLy8gT25jZSB3ZSd2ZSBoaXQgb3VyIGFkZCwgdGhlbiB3ZSBhcmUgZG9uZVxuICAgIGlmIChtYXRjaFswXSA9PT0gJysnKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjb250ZXh0Q2hhbmdlcyA9IGNvbnRleHRDaGFuZ2VzIHx8IGNoYW5nZVswXSAhPT0gJyAnO1xuXG4gICAgbWVyZ2VkLnB1c2gobWF0Y2gpO1xuICAgIG1hdGNoSW5kZXgrKztcblxuICAgIC8vIENvbnN1bWUgYW55IGFkZGl0aW9ucyBpbiB0aGUgb3RoZXIgYmxvY2sgYXMgYSBjb25mbGljdCB0byBhdHRlbXB0XG4gICAgLy8gdG8gcHVsbCBpbiB0aGUgcmVtYWluaW5nIGNvbnRleHQgYWZ0ZXIgdGhpc1xuICAgIGlmIChjaGFuZ2VbMF0gPT09ICcrJykge1xuICAgICAgY29uZmxpY3RlZCA9IHRydWU7XG5cbiAgICAgIHdoaWxlIChjaGFuZ2VbMF0gPT09ICcrJykge1xuICAgICAgICBjaGFuZ2VzLnB1c2goY2hhbmdlKTtcbiAgICAgICAgY2hhbmdlID0gc3RhdGUubGluZXNbKytzdGF0ZS5pbmRleF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1hdGNoLnN1YnN0cigxKSA9PT0gY2hhbmdlLnN1YnN0cigxKSkge1xuICAgICAgY2hhbmdlcy5wdXNoKGNoYW5nZSk7XG4gICAgICBzdGF0ZS5pbmRleCsrO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25mbGljdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoKG1hdGNoQ2hhbmdlc1ttYXRjaEluZGV4XSB8fCAnJylbMF0gPT09ICcrJ1xuICAgICAgJiYgY29udGV4dENoYW5nZXMpIHtcbiAgICBjb25mbGljdGVkID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChjb25mbGljdGVkKSB7XG4gICAgcmV0dXJuIGNoYW5nZXM7XG4gIH1cblxuICB3aGlsZSAobWF0Y2hJbmRleCA8IG1hdGNoQ2hhbmdlcy5sZW5ndGgpIHtcbiAgICBtZXJnZWQucHVzaChtYXRjaENoYW5nZXNbbWF0Y2hJbmRleCsrXSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG1lcmdlZCxcbiAgICBjaGFuZ2VzXG4gIH07XG59XG5cbmZ1bmN0aW9uIGFsbFJlbW92ZXMoY2hhbmdlcykge1xuICByZXR1cm4gY2hhbmdlcy5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY2hhbmdlKSB7XG4gICAgcmV0dXJuIHByZXYgJiYgY2hhbmdlWzBdID09PSAnLSc7XG4gIH0sIHRydWUpO1xufVxuZnVuY3Rpb24gc2tpcFJlbW92ZVN1cGVyc2V0KHN0YXRlLCByZW1vdmVDaGFuZ2VzLCBkZWx0YSkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRlbHRhOyBpKyspIHtcbiAgICBsZXQgY2hhbmdlQ29udGVudCA9IHJlbW92ZUNoYW5nZXNbcmVtb3ZlQ2hhbmdlcy5sZW5ndGggLSBkZWx0YSArIGldLnN1YnN0cigxKTtcbiAgICBpZiAoc3RhdGUubGluZXNbc3RhdGUuaW5kZXggKyBpXSAhPT0gJyAnICsgY2hhbmdlQ29udGVudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLmluZGV4ICs9IGRlbHRhO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY2FsY09sZE5ld0xpbmVDb3VudChsaW5lcykge1xuICBsZXQgb2xkTGluZXMgPSAwO1xuICBsZXQgbmV3TGluZXMgPSAwO1xuXG4gIGxpbmVzLmZvckVhY2goZnVuY3Rpb24obGluZSkge1xuICAgIGlmICh0eXBlb2YgbGluZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGxldCBteUNvdW50ID0gY2FsY09sZE5ld0xpbmVDb3VudChsaW5lLm1pbmUpO1xuICAgICAgbGV0IHRoZWlyQ291bnQgPSBjYWxjT2xkTmV3TGluZUNvdW50KGxpbmUudGhlaXJzKTtcblxuICAgICAgaWYgKG9sZExpbmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKG15Q291bnQub2xkTGluZXMgPT09IHRoZWlyQ291bnQub2xkTGluZXMpIHtcbiAgICAgICAgICBvbGRMaW5lcyArPSBteUNvdW50Lm9sZExpbmVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9sZExpbmVzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXdMaW5lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChteUNvdW50Lm5ld0xpbmVzID09PSB0aGVpckNvdW50Lm5ld0xpbmVzKSB7XG4gICAgICAgICAgbmV3TGluZXMgKz0gbXlDb3VudC5uZXdMaW5lcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdMaW5lcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobmV3TGluZXMgIT09IHVuZGVmaW5lZCAmJiAobGluZVswXSA9PT0gJysnIHx8IGxpbmVbMF0gPT09ICcgJykpIHtcbiAgICAgICAgbmV3TGluZXMrKztcbiAgICAgIH1cbiAgICAgIGlmIChvbGRMaW5lcyAhPT0gdW5kZWZpbmVkICYmIChsaW5lWzBdID09PSAnLScgfHwgbGluZVswXSA9PT0gJyAnKSkge1xuICAgICAgICBvbGRMaW5lcysrO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHtvbGRMaW5lcywgbmV3TGluZXN9O1xufVxuIl19\r\n\r\n\r\n/***/ }),\r\n/* 14 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\t/*istanbul ignore start*/'use strict';\r\n\r\n\texports.__esModule = true;\r\n\texports. /*istanbul ignore end*/structuredPatch = structuredPatch;\r\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/createTwoFilesPatch = createTwoFilesPatch;\r\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/createPatch = createPatch;\r\n\r\n\tvar /*istanbul ignore start*/_line = __webpack_require__(5) /*istanbul ignore end*/;\r\n\r\n\t/*istanbul ignore start*/function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\r\n\r\n\t/*istanbul ignore end*/function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\r\n\t  if (!options) {\r\n\t    options = {};\r\n\t  }\r\n\t  if (typeof options.context === 'undefined') {\r\n\t    options.context = 4;\r\n\t  }\r\n\r\n\t  var diff = /*istanbul ignore start*/(0, _line.diffLines) /*istanbul ignore end*/(oldStr, newStr, options);\r\n\t  diff.push({ value: '', lines: [] }); // Append an empty value to make cleanup easier\r\n\r\n\t  function contextLines(lines) {\r\n\t    return lines.map(function (entry) {\r\n\t      return ' ' + entry;\r\n\t    });\r\n\t  }\r\n\r\n\t  var hunks = [];\r\n\t  var oldRangeStart = 0,\r\n\t      newRangeStart = 0,\r\n\t      curRange = [],\r\n\t      oldLine = 1,\r\n\t      newLine = 1;\r\n\r\n\t  /*istanbul ignore start*/var _loop = function _loop( /*istanbul ignore end*/i) {\r\n\t    var current = diff[i],\r\n\t        lines = current.lines || current.value.replace(/\\n$/, '').split('\\n');\r\n\t    current.lines = lines;\r\n\r\n\t    if (current.added || current.removed) {\r\n\t      /*istanbul ignore start*/var _curRange;\r\n\r\n\t      /*istanbul ignore end*/ // If we have previous context, start with that\r\n\t      if (!oldRangeStart) {\r\n\t        var prev = diff[i - 1];\r\n\t        oldRangeStart = oldLine;\r\n\t        newRangeStart = newLine;\r\n\r\n\t        if (prev) {\r\n\t          curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];\r\n\t          oldRangeStart -= curRange.length;\r\n\t          newRangeStart -= curRange.length;\r\n\t        }\r\n\t      }\r\n\r\n\t      // Output our changes\r\n\t      /*istanbul ignore start*/(_curRange = /*istanbul ignore end*/curRange).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_curRange /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/lines.map(function (entry) {\r\n\t        return (current.added ? '+' : '-') + entry;\r\n\t      })));\r\n\r\n\t      // Track the updated file position\r\n\t      if (current.added) {\r\n\t        newLine += lines.length;\r\n\t      } else {\r\n\t        oldLine += lines.length;\r\n\t      }\r\n\t    } else {\r\n\t      // Identical context lines. Track line changes\r\n\t      if (oldRangeStart) {\r\n\t        // Close out any changes that have been output (or join overlapping)\r\n\t        if (lines.length <= options.context * 2 && i < diff.length - 2) {\r\n\t          /*istanbul ignore start*/var _curRange2;\r\n\r\n\t          /*istanbul ignore end*/ // Overlapping\r\n\t          /*istanbul ignore start*/(_curRange2 = /*istanbul ignore end*/curRange).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_curRange2 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/contextLines(lines)));\r\n\t        } else {\r\n\t          /*istanbul ignore start*/var _curRange3;\r\n\r\n\t          /*istanbul ignore end*/ // end the range and output\r\n\t          var contextSize = Math.min(lines.length, options.context);\r\n\t          /*istanbul ignore start*/(_curRange3 = /*istanbul ignore end*/curRange).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_curRange3 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/contextLines(lines.slice(0, contextSize))));\r\n\r\n\t          var hunk = {\r\n\t            oldStart: oldRangeStart,\r\n\t            oldLines: oldLine - oldRangeStart + contextSize,\r\n\t            newStart: newRangeStart,\r\n\t            newLines: newLine - newRangeStart + contextSize,\r\n\t            lines: curRange\r\n\t          };\r\n\t          if (i >= diff.length - 2 && lines.length <= options.context) {\r\n\t            // EOF is inside this hunk\r\n\t            var oldEOFNewline = /\\n$/.test(oldStr);\r\n\t            var newEOFNewline = /\\n$/.test(newStr);\r\n\t            if (lines.length == 0 && !oldEOFNewline) {\r\n\t              // special case: old has no eol and no trailing context; no-nl can end up before adds\r\n\t              curRange.splice(hunk.oldLines, 0, '\\\\ No newline at end of file');\r\n\t            } else if (!oldEOFNewline || !newEOFNewline) {\r\n\t              curRange.push('\\\\ No newline at end of file');\r\n\t            }\r\n\t          }\r\n\t          hunks.push(hunk);\r\n\r\n\t          oldRangeStart = 0;\r\n\t          newRangeStart = 0;\r\n\t          curRange = [];\r\n\t        }\r\n\t      }\r\n\t      oldLine += lines.length;\r\n\t      newLine += lines.length;\r\n\t    }\r\n\t  };\r\n\r\n\t  for (var i = 0; i < diff.length; i++) {\r\n\t    /*istanbul ignore start*/_loop( /*istanbul ignore end*/i);\r\n\t  }\r\n\r\n\t  return {\r\n\t    oldFileName: oldFileName, newFileName: newFileName,\r\n\t    oldHeader: oldHeader, newHeader: newHeader,\r\n\t    hunks: hunks\r\n\t  };\r\n\t}\r\n\r\n\tfunction createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\r\n\t  var diff = structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options);\r\n\r\n\t  var ret = [];\r\n\t  if (oldFileName == newFileName) {\r\n\t    ret.push('Index: ' + oldFileName);\r\n\t  }\r\n\t  ret.push('===================================================================');\r\n\t  ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\\t' + diff.oldHeader));\r\n\t  ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\\t' + diff.newHeader));\r\n\r\n\t  for (var i = 0; i < diff.hunks.length; i++) {\r\n\t    var hunk = diff.hunks[i];\r\n\t    ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');\r\n\t    ret.push.apply(ret, hunk.lines);\r\n\t  }\r\n\r\n\t  return ret.join('\\n') + '\\n';\r\n\t}\r\n\r\n\tfunction createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {\r\n\t  return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);\r\n\t}\r\n\t//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wYXRjaC9jcmVhdGUuanMiXSwibmFtZXMiOlsic3RydWN0dXJlZFBhdGNoIiwiY3JlYXRlVHdvRmlsZXNQYXRjaCIsImNyZWF0ZVBhdGNoIiwib2xkRmlsZU5hbWUiLCJuZXdGaWxlTmFtZSIsIm9sZFN0ciIsIm5ld1N0ciIsIm9sZEhlYWRlciIsIm5ld0hlYWRlciIsIm9wdGlvbnMiLCJjb250ZXh0IiwiZGlmZiIsInB1c2giLCJ2YWx1ZSIsImxpbmVzIiwiY29udGV4dExpbmVzIiwibWFwIiwiZW50cnkiLCJodW5rcyIsIm9sZFJhbmdlU3RhcnQiLCJuZXdSYW5nZVN0YXJ0IiwiY3VyUmFuZ2UiLCJvbGRMaW5lIiwibmV3TGluZSIsImkiLCJjdXJyZW50IiwicmVwbGFjZSIsInNwbGl0IiwiYWRkZWQiLCJyZW1vdmVkIiwicHJldiIsInNsaWNlIiwibGVuZ3RoIiwiY29udGV4dFNpemUiLCJNYXRoIiwibWluIiwiaHVuayIsIm9sZFN0YXJ0Iiwib2xkTGluZXMiLCJuZXdTdGFydCIsIm5ld0xpbmVzIiwib2xkRU9GTmV3bGluZSIsInRlc3QiLCJuZXdFT0ZOZXdsaW5lIiwic3BsaWNlIiwicmV0IiwiYXBwbHkiLCJqb2luIiwiZmlsZU5hbWUiXSwibWFwcGluZ3MiOiI7OztnQ0FFZ0JBLGUsR0FBQUEsZTt5REFpR0FDLG1CLEdBQUFBLG1CO3lEQXdCQUMsVyxHQUFBQSxXOztBQTNIaEI7Ozs7dUJBRU8sU0FBU0YsZUFBVCxDQUF5QkcsV0FBekIsRUFBc0NDLFdBQXRDLEVBQW1EQyxNQUFuRCxFQUEyREMsTUFBM0QsRUFBbUVDLFNBQW5FLEVBQThFQyxTQUE5RSxFQUF5RkMsT0FBekYsRUFBa0c7QUFDdkcsTUFBSSxDQUFDQSxPQUFMLEVBQWM7QUFDWkEsY0FBVSxFQUFWO0FBQ0Q7QUFDRCxNQUFJLE9BQU9BLFFBQVFDLE9BQWYsS0FBMkIsV0FBL0IsRUFBNEM7QUFDMUNELFlBQVFDLE9BQVIsR0FBa0IsQ0FBbEI7QUFDRDs7QUFFRCxNQUFNQyxPQUFPLHNFQUFVTixNQUFWLEVBQWtCQyxNQUFsQixFQUEwQkcsT0FBMUIsQ0FBYjtBQUNBRSxPQUFLQyxJQUFMLENBQVUsRUFBQ0MsT0FBTyxFQUFSLEVBQVlDLE9BQU8sRUFBbkIsRUFBVixFQVR1RyxDQVNsRTs7QUFFckMsV0FBU0MsWUFBVCxDQUFzQkQsS0FBdEIsRUFBNkI7QUFDM0IsV0FBT0EsTUFBTUUsR0FBTixDQUFVLFVBQVNDLEtBQVQsRUFBZ0I7QUFBRSxhQUFPLE1BQU1BLEtBQWI7QUFBcUIsS0FBakQsQ0FBUDtBQUNEOztBQUVELE1BQUlDLFFBQVEsRUFBWjtBQUNBLE1BQUlDLGdCQUFnQixDQUFwQjtBQUFBLE1BQXVCQyxnQkFBZ0IsQ0FBdkM7QUFBQSxNQUEwQ0MsV0FBVyxFQUFyRDtBQUFBLE1BQ0lDLFVBQVUsQ0FEZDtBQUFBLE1BQ2lCQyxVQUFVLENBRDNCOztBQWhCdUcsOEVBa0I5RkMsQ0FsQjhGO0FBbUJyRyxRQUFNQyxVQUFVZCxLQUFLYSxDQUFMLENBQWhCO0FBQUEsUUFDTVYsUUFBUVcsUUFBUVgsS0FBUixJQUFpQlcsUUFBUVosS0FBUixDQUFjYSxPQUFkLENBQXNCLEtBQXRCLEVBQTZCLEVBQTdCLEVBQWlDQyxLQUFqQyxDQUF1QyxJQUF2QyxDQUQvQjtBQUVBRixZQUFRWCxLQUFSLEdBQWdCQSxLQUFoQjs7QUFFQSxRQUFJVyxRQUFRRyxLQUFSLElBQWlCSCxRQUFRSSxPQUE3QixFQUFzQztBQUFBOztBQUFBLDhCQUNwQztBQUNBLFVBQUksQ0FBQ1YsYUFBTCxFQUFvQjtBQUNsQixZQUFNVyxPQUFPbkIsS0FBS2EsSUFBSSxDQUFULENBQWI7QUFDQUwsd0JBQWdCRyxPQUFoQjtBQUNBRix3QkFBZ0JHLE9BQWhCOztBQUVBLFlBQUlPLElBQUosRUFBVTtBQUNSVCxxQkFBV1osUUFBUUMsT0FBUixHQUFrQixDQUFsQixHQUFzQkssYUFBYWUsS0FBS2hCLEtBQUwsQ0FBV2lCLEtBQVgsQ0FBaUIsQ0FBQ3RCLFFBQVFDLE9BQTFCLENBQWIsQ0FBdEIsR0FBeUUsRUFBcEY7QUFDQVMsMkJBQWlCRSxTQUFTVyxNQUExQjtBQUNBWiwyQkFBaUJDLFNBQVNXLE1BQTFCO0FBQ0Q7QUFDRjs7QUFFRDtBQUNBLDZFQUFTcEIsSUFBVCwwTEFBa0JFLE1BQU1FLEdBQU4sQ0FBVSxVQUFTQyxLQUFULEVBQWdCO0FBQzFDLGVBQU8sQ0FBQ1EsUUFBUUcsS0FBUixHQUFnQixHQUFoQixHQUFzQixHQUF2QixJQUE4QlgsS0FBckM7QUFDRCxPQUZpQixDQUFsQjs7QUFJQTtBQUNBLFVBQUlRLFFBQVFHLEtBQVosRUFBbUI7QUFDakJMLG1CQUFXVCxNQUFNa0IsTUFBakI7QUFDRCxPQUZELE1BRU87QUFDTFYsbUJBQVdSLE1BQU1rQixNQUFqQjtBQUNEO0FBQ0YsS0F6QkQsTUF5Qk87QUFDTDtBQUNBLFVBQUliLGFBQUosRUFBbUI7QUFDakI7QUFDQSxZQUFJTCxNQUFNa0IsTUFBTixJQUFnQnZCLFFBQVFDLE9BQVIsR0FBa0IsQ0FBbEMsSUFBdUNjLElBQUliLEtBQUtxQixNQUFMLEdBQWMsQ0FBN0QsRUFBZ0U7QUFBQTs7QUFBQSxrQ0FDOUQ7QUFDQSxrRkFBU3BCLElBQVQsMkxBQWtCRyxhQUFhRCxLQUFiLENBQWxCO0FBQ0QsU0FIRCxNQUdPO0FBQUE7O0FBQUEsa0NBQ0w7QUFDQSxjQUFJbUIsY0FBY0MsS0FBS0MsR0FBTCxDQUFTckIsTUFBTWtCLE1BQWYsRUFBdUJ2QixRQUFRQyxPQUEvQixDQUFsQjtBQUNBLGtGQUFTRSxJQUFULDJMQUFrQkcsYUFBYUQsTUFBTWlCLEtBQU4sQ0FBWSxDQUFaLEVBQWVFLFdBQWYsQ0FBYixDQUFsQjs7QUFFQSxjQUFJRyxPQUFPO0FBQ1RDLHNCQUFVbEIsYUFERDtBQUVUbUIsc0JBQVdoQixVQUFVSCxhQUFWLEdBQTBCYyxXQUY1QjtBQUdUTSxzQkFBVW5CLGFBSEQ7QUFJVG9CLHNCQUFXakIsVUFBVUgsYUFBVixHQUEwQmEsV0FKNUI7QUFLVG5CLG1CQUFPTztBQUxFLFdBQVg7QUFPQSxjQUFJRyxLQUFLYixLQUFLcUIsTUFBTCxHQUFjLENBQW5CLElBQXdCbEIsTUFBTWtCLE1BQU4sSUFBZ0J2QixRQUFRQyxPQUFwRCxFQUE2RDtBQUMzRDtBQUNBLGdCQUFJK0IsZ0JBQWlCLE1BQU1DLElBQU4sQ0FBV3JDLE1BQVgsQ0FBckI7QUFDQSxnQkFBSXNDLGdCQUFpQixNQUFNRCxJQUFOLENBQVdwQyxNQUFYLENBQXJCO0FBQ0EsZ0JBQUlRLE1BQU1rQixNQUFOLElBQWdCLENBQWhCLElBQXFCLENBQUNTLGFBQTFCLEVBQXlDO0FBQ3ZDO0FBQ0FwQix1QkFBU3VCLE1BQVQsQ0FBZ0JSLEtBQUtFLFFBQXJCLEVBQStCLENBQS9CLEVBQWtDLDhCQUFsQztBQUNELGFBSEQsTUFHTyxJQUFJLENBQUNHLGFBQUQsSUFBa0IsQ0FBQ0UsYUFBdkIsRUFBc0M7QUFDM0N0Qix1QkFBU1QsSUFBVCxDQUFjLDhCQUFkO0FBQ0Q7QUFDRjtBQUNETSxnQkFBTU4sSUFBTixDQUFXd0IsSUFBWDs7QUFFQWpCLDBCQUFnQixDQUFoQjtBQUNBQywwQkFBZ0IsQ0FBaEI7QUFDQUMscUJBQVcsRUFBWDtBQUNEO0FBQ0Y7QUFDREMsaUJBQVdSLE1BQU1rQixNQUFqQjtBQUNBVCxpQkFBV1QsTUFBTWtCLE1BQWpCO0FBQ0Q7QUF2Rm9HOztBQWtCdkcsT0FBSyxJQUFJUixJQUFJLENBQWIsRUFBZ0JBLElBQUliLEtBQUtxQixNQUF6QixFQUFpQ1IsR0FBakMsRUFBc0M7QUFBQSwyREFBN0JBLENBQTZCO0FBc0VyQzs7QUFFRCxTQUFPO0FBQ0xyQixpQkFBYUEsV0FEUixFQUNxQkMsYUFBYUEsV0FEbEM7QUFFTEcsZUFBV0EsU0FGTixFQUVpQkMsV0FBV0EsU0FGNUI7QUFHTFUsV0FBT0E7QUFIRixHQUFQO0FBS0Q7O0FBRU0sU0FBU2pCLG1CQUFULENBQTZCRSxXQUE3QixFQUEwQ0MsV0FBMUMsRUFBdURDLE1BQXZELEVBQStEQyxNQUEvRCxFQUF1RUMsU0FBdkUsRUFBa0ZDLFNBQWxGLEVBQTZGQyxPQUE3RixFQUFzRztBQUMzRyxNQUFNRSxPQUFPWCxnQkFBZ0JHLFdBQWhCLEVBQTZCQyxXQUE3QixFQUEwQ0MsTUFBMUMsRUFBa0RDLE1BQWxELEVBQTBEQyxTQUExRCxFQUFxRUMsU0FBckUsRUFBZ0ZDLE9BQWhGLENBQWI7O0FBRUEsTUFBTW9DLE1BQU0sRUFBWjtBQUNBLE1BQUkxQyxlQUFlQyxXQUFuQixFQUFnQztBQUM5QnlDLFFBQUlqQyxJQUFKLENBQVMsWUFBWVQsV0FBckI7QUFDRDtBQUNEMEMsTUFBSWpDLElBQUosQ0FBUyxxRUFBVDtBQUNBaUMsTUFBSWpDLElBQUosQ0FBUyxTQUFTRCxLQUFLUixXQUFkLElBQTZCLE9BQU9RLEtBQUtKLFNBQVosS0FBMEIsV0FBMUIsR0FBd0MsRUFBeEMsR0FBNkMsT0FBT0ksS0FBS0osU0FBdEYsQ0FBVDtBQUNBc0MsTUFBSWpDLElBQUosQ0FBUyxTQUFTRCxLQUFLUCxXQUFkLElBQTZCLE9BQU9PLEtBQUtILFNBQVosS0FBMEIsV0FBMUIsR0FBd0MsRUFBeEMsR0FBNkMsT0FBT0csS0FBS0gsU0FBdEYsQ0FBVDs7QUFFQSxPQUFLLElBQUlnQixJQUFJLENBQWIsRUFBZ0JBLElBQUliLEtBQUtPLEtBQUwsQ0FBV2MsTUFBL0IsRUFBdUNSLEdBQXZDLEVBQTRDO0FBQzFDLFFBQU1ZLE9BQU96QixLQUFLTyxLQUFMLENBQVdNLENBQVgsQ0FBYjtBQUNBcUIsUUFBSWpDLElBQUosQ0FDRSxTQUFTd0IsS0FBS0MsUUFBZCxHQUF5QixHQUF6QixHQUErQkQsS0FBS0UsUUFBcEMsR0FDRSxJQURGLEdBQ1NGLEtBQUtHLFFBRGQsR0FDeUIsR0FEekIsR0FDK0JILEtBQUtJLFFBRHBDLEdBRUUsS0FISjtBQUtBSyxRQUFJakMsSUFBSixDQUFTa0MsS0FBVCxDQUFlRCxHQUFmLEVBQW9CVCxLQUFLdEIsS0FBekI7QUFDRDs7QUFFRCxTQUFPK0IsSUFBSUUsSUFBSixDQUFTLElBQVQsSUFBaUIsSUFBeEI7QUFDRDs7QUFFTSxTQUFTN0MsV0FBVCxDQUFxQjhDLFFBQXJCLEVBQStCM0MsTUFBL0IsRUFBdUNDLE1BQXZDLEVBQStDQyxTQUEvQyxFQUEwREMsU0FBMUQsRUFBcUVDLE9BQXJFLEVBQThFO0FBQ25GLFNBQU9SLG9CQUFvQitDLFFBQXBCLEVBQThCQSxRQUE5QixFQUF3QzNDLE1BQXhDLEVBQWdEQyxNQUFoRCxFQUF3REMsU0FBeEQsRUFBbUVDLFNBQW5FLEVBQThFQyxPQUE5RSxDQUFQO0FBQ0QiLCJmaWxlIjoiY3JlYXRlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtkaWZmTGluZXN9IGZyb20gJy4uL2RpZmYvbGluZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBzdHJ1Y3R1cmVkUGF0Y2gob2xkRmlsZU5hbWUsIG5ld0ZpbGVOYW1lLCBvbGRTdHIsIG5ld1N0ciwgb2xkSGVhZGVyLCBuZXdIZWFkZXIsIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5jb250ZXh0ID09PSAndW5kZWZpbmVkJykge1xuICAgIG9wdGlvbnMuY29udGV4dCA9IDQ7XG4gIH1cblxuICBjb25zdCBkaWZmID0gZGlmZkxpbmVzKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKTtcbiAgZGlmZi5wdXNoKHt2YWx1ZTogJycsIGxpbmVzOiBbXX0pOyAgIC8vIEFwcGVuZCBhbiBlbXB0eSB2YWx1ZSB0byBtYWtlIGNsZWFudXAgZWFzaWVyXG5cbiAgZnVuY3Rpb24gY29udGV4dExpbmVzKGxpbmVzKSB7XG4gICAgcmV0dXJuIGxpbmVzLm1hcChmdW5jdGlvbihlbnRyeSkgeyByZXR1cm4gJyAnICsgZW50cnk7IH0pO1xuICB9XG5cbiAgbGV0IGh1bmtzID0gW107XG4gIGxldCBvbGRSYW5nZVN0YXJ0ID0gMCwgbmV3UmFuZ2VTdGFydCA9IDAsIGN1clJhbmdlID0gW10sXG4gICAgICBvbGRMaW5lID0gMSwgbmV3TGluZSA9IDE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGlmZi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGN1cnJlbnQgPSBkaWZmW2ldLFxuICAgICAgICAgIGxpbmVzID0gY3VycmVudC5saW5lcyB8fCBjdXJyZW50LnZhbHVlLnJlcGxhY2UoL1xcbiQvLCAnJykuc3BsaXQoJ1xcbicpO1xuICAgIGN1cnJlbnQubGluZXMgPSBsaW5lcztcblxuICAgIGlmIChjdXJyZW50LmFkZGVkIHx8IGN1cnJlbnQucmVtb3ZlZCkge1xuICAgICAgLy8gSWYgd2UgaGF2ZSBwcmV2aW91cyBjb250ZXh0LCBzdGFydCB3aXRoIHRoYXRcbiAgICAgIGlmICghb2xkUmFuZ2VTdGFydCkge1xuICAgICAgICBjb25zdCBwcmV2ID0gZGlmZltpIC0gMV07XG4gICAgICAgIG9sZFJhbmdlU3RhcnQgPSBvbGRMaW5lO1xuICAgICAgICBuZXdSYW5nZVN0YXJ0ID0gbmV3TGluZTtcblxuICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgIGN1clJhbmdlID0gb3B0aW9ucy5jb250ZXh0ID4gMCA/IGNvbnRleHRMaW5lcyhwcmV2LmxpbmVzLnNsaWNlKC1vcHRpb25zLmNvbnRleHQpKSA6IFtdO1xuICAgICAgICAgIG9sZFJhbmdlU3RhcnQgLT0gY3VyUmFuZ2UubGVuZ3RoO1xuICAgICAgICAgIG5ld1JhbmdlU3RhcnQgLT0gY3VyUmFuZ2UubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE91dHB1dCBvdXIgY2hhbmdlc1xuICAgICAgY3VyUmFuZ2UucHVzaCguLi4gbGluZXMubWFwKGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgIHJldHVybiAoY3VycmVudC5hZGRlZCA/ICcrJyA6ICctJykgKyBlbnRyeTtcbiAgICAgIH0pKTtcblxuICAgICAgLy8gVHJhY2sgdGhlIHVwZGF0ZWQgZmlsZSBwb3NpdGlvblxuICAgICAgaWYgKGN1cnJlbnQuYWRkZWQpIHtcbiAgICAgICAgbmV3TGluZSArPSBsaW5lcy5sZW5ndGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbGRMaW5lICs9IGxpbmVzLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWRlbnRpY2FsIGNvbnRleHQgbGluZXMuIFRyYWNrIGxpbmUgY2hhbmdlc1xuICAgICAgaWYgKG9sZFJhbmdlU3RhcnQpIHtcbiAgICAgICAgLy8gQ2xvc2Ugb3V0IGFueSBjaGFuZ2VzIHRoYXQgaGF2ZSBiZWVuIG91dHB1dCAob3Igam9pbiBvdmVybGFwcGluZylcbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA8PSBvcHRpb25zLmNvbnRleHQgKiAyICYmIGkgPCBkaWZmLmxlbmd0aCAtIDIpIHtcbiAgICAgICAgICAvLyBPdmVybGFwcGluZ1xuICAgICAgICAgIGN1clJhbmdlLnB1c2goLi4uIGNvbnRleHRMaW5lcyhsaW5lcykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGVuZCB0aGUgcmFuZ2UgYW5kIG91dHB1dFxuICAgICAgICAgIGxldCBjb250ZXh0U2l6ZSA9IE1hdGgubWluKGxpbmVzLmxlbmd0aCwgb3B0aW9ucy5jb250ZXh0KTtcbiAgICAgICAgICBjdXJSYW5nZS5wdXNoKC4uLiBjb250ZXh0TGluZXMobGluZXMuc2xpY2UoMCwgY29udGV4dFNpemUpKSk7XG5cbiAgICAgICAgICBsZXQgaHVuayA9IHtcbiAgICAgICAgICAgIG9sZFN0YXJ0OiBvbGRSYW5nZVN0YXJ0LFxuICAgICAgICAgICAgb2xkTGluZXM6IChvbGRMaW5lIC0gb2xkUmFuZ2VTdGFydCArIGNvbnRleHRTaXplKSxcbiAgICAgICAgICAgIG5ld1N0YXJ0OiBuZXdSYW5nZVN0YXJ0LFxuICAgICAgICAgICAgbmV3TGluZXM6IChuZXdMaW5lIC0gbmV3UmFuZ2VTdGFydCArIGNvbnRleHRTaXplKSxcbiAgICAgICAgICAgIGxpbmVzOiBjdXJSYW5nZVxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKGkgPj0gZGlmZi5sZW5ndGggLSAyICYmIGxpbmVzLmxlbmd0aCA8PSBvcHRpb25zLmNvbnRleHQpIHtcbiAgICAgICAgICAgIC8vIEVPRiBpcyBpbnNpZGUgdGhpcyBodW5rXG4gICAgICAgICAgICBsZXQgb2xkRU9GTmV3bGluZSA9ICgvXFxuJC8udGVzdChvbGRTdHIpKTtcbiAgICAgICAgICAgIGxldCBuZXdFT0ZOZXdsaW5lID0gKC9cXG4kLy50ZXN0KG5ld1N0cikpO1xuICAgICAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA9PSAwICYmICFvbGRFT0ZOZXdsaW5lKSB7XG4gICAgICAgICAgICAgIC8vIHNwZWNpYWwgY2FzZTogb2xkIGhhcyBubyBlb2wgYW5kIG5vIHRyYWlsaW5nIGNvbnRleHQ7IG5vLW5sIGNhbiBlbmQgdXAgYmVmb3JlIGFkZHNcbiAgICAgICAgICAgICAgY3VyUmFuZ2Uuc3BsaWNlKGh1bmsub2xkTGluZXMsIDAsICdcXFxcIE5vIG5ld2xpbmUgYXQgZW5kIG9mIGZpbGUnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIW9sZEVPRk5ld2xpbmUgfHwgIW5ld0VPRk5ld2xpbmUpIHtcbiAgICAgICAgICAgICAgY3VyUmFuZ2UucHVzaCgnXFxcXCBObyBuZXdsaW5lIGF0IGVuZCBvZiBmaWxlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGh1bmtzLnB1c2goaHVuayk7XG5cbiAgICAgICAgICBvbGRSYW5nZVN0YXJ0ID0gMDtcbiAgICAgICAgICBuZXdSYW5nZVN0YXJ0ID0gMDtcbiAgICAgICAgICBjdXJSYW5nZSA9IFtdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvbGRMaW5lICs9IGxpbmVzLmxlbmd0aDtcbiAgICAgIG5ld0xpbmUgKz0gbGluZXMubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgb2xkRmlsZU5hbWU6IG9sZEZpbGVOYW1lLCBuZXdGaWxlTmFtZTogbmV3RmlsZU5hbWUsXG4gICAgb2xkSGVhZGVyOiBvbGRIZWFkZXIsIG5ld0hlYWRlcjogbmV3SGVhZGVyLFxuICAgIGh1bmtzOiBodW5rc1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVHdvRmlsZXNQYXRjaChvbGRGaWxlTmFtZSwgbmV3RmlsZU5hbWUsIG9sZFN0ciwgbmV3U3RyLCBvbGRIZWFkZXIsIG5ld0hlYWRlciwgb3B0aW9ucykge1xuICBjb25zdCBkaWZmID0gc3RydWN0dXJlZFBhdGNoKG9sZEZpbGVOYW1lLCBuZXdGaWxlTmFtZSwgb2xkU3RyLCBuZXdTdHIsIG9sZEhlYWRlciwgbmV3SGVhZGVyLCBvcHRpb25zKTtcblxuICBjb25zdCByZXQgPSBbXTtcbiAgaWYgKG9sZEZpbGVOYW1lID09IG5ld0ZpbGVOYW1lKSB7XG4gICAgcmV0LnB1c2goJ0luZGV4OiAnICsgb2xkRmlsZU5hbWUpO1xuICB9XG4gIHJldC5wdXNoKCc9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Jyk7XG4gIHJldC5wdXNoKCctLS0gJyArIGRpZmYub2xkRmlsZU5hbWUgKyAodHlwZW9mIGRpZmYub2xkSGVhZGVyID09PSAndW5kZWZpbmVkJyA/ICcnIDogJ1xcdCcgKyBkaWZmLm9sZEhlYWRlcikpO1xuICByZXQucHVzaCgnKysrICcgKyBkaWZmLm5ld0ZpbGVOYW1lICsgKHR5cGVvZiBkaWZmLm5ld0hlYWRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnJyA6ICdcXHQnICsgZGlmZi5uZXdIZWFkZXIpKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGRpZmYuaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBodW5rID0gZGlmZi5odW5rc1tpXTtcbiAgICByZXQucHVzaChcbiAgICAgICdAQCAtJyArIGh1bmsub2xkU3RhcnQgKyAnLCcgKyBodW5rLm9sZExpbmVzXG4gICAgICArICcgKycgKyBodW5rLm5ld1N0YXJ0ICsgJywnICsgaHVuay5uZXdMaW5lc1xuICAgICAgKyAnIEBAJ1xuICAgICk7XG4gICAgcmV0LnB1c2guYXBwbHkocmV0LCBodW5rLmxpbmVzKTtcbiAgfVxuXG4gIHJldHVybiByZXQuam9pbignXFxuJykgKyAnXFxuJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVBhdGNoKGZpbGVOYW1lLCBvbGRTdHIsIG5ld1N0ciwgb2xkSGVhZGVyLCBuZXdIZWFkZXIsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGNyZWF0ZVR3b0ZpbGVzUGF0Y2goZmlsZU5hbWUsIGZpbGVOYW1lLCBvbGRTdHIsIG5ld1N0ciwgb2xkSGVhZGVyLCBuZXdIZWFkZXIsIG9wdGlvbnMpO1xufVxuIl19\r\n\r\n\r\n/***/ }),\r\n/* 15 */\r\n/***/ (function(module, exports) {\r\n\r\n\t/*istanbul ignore start*/\"use strict\";\r\n\r\n\texports.__esModule = true;\r\n\texports. /*istanbul ignore end*/arrayEqual = arrayEqual;\r\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/arrayStartsWith = arrayStartsWith;\r\n\tfunction arrayEqual(a, b) {\r\n\t  if (a.length !== b.length) {\r\n\t    return false;\r\n\t  }\r\n\r\n\t  return arrayStartsWith(a, b);\r\n\t}\r\n\r\n\tfunction arrayStartsWith(array, start) {\r\n\t  if (start.length > array.length) {\r\n\t    return false;\r\n\t  }\r\n\r\n\t  for (var i = 0; i < start.length; i++) {\r\n\t    if (start[i] !== array[i]) {\r\n\t      return false;\r\n\t    }\r\n\t  }\r\n\r\n\t  return true;\r\n\t}\r\n\t//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsL2FycmF5LmpzIl0sIm5hbWVzIjpbImFycmF5RXF1YWwiLCJhcnJheVN0YXJ0c1dpdGgiLCJhIiwiYiIsImxlbmd0aCIsImFycmF5Iiwic3RhcnQiLCJpIl0sIm1hcHBpbmdzIjoiOzs7Z0NBQWdCQSxVLEdBQUFBLFU7eURBUUFDLGUsR0FBQUEsZTtBQVJULFNBQVNELFVBQVQsQ0FBb0JFLENBQXBCLEVBQXVCQyxDQUF2QixFQUEwQjtBQUMvQixNQUFJRCxFQUFFRSxNQUFGLEtBQWFELEVBQUVDLE1BQW5CLEVBQTJCO0FBQ3pCLFdBQU8sS0FBUDtBQUNEOztBQUVELFNBQU9ILGdCQUFnQkMsQ0FBaEIsRUFBbUJDLENBQW5CLENBQVA7QUFDRDs7QUFFTSxTQUFTRixlQUFULENBQXlCSSxLQUF6QixFQUFnQ0MsS0FBaEMsRUFBdUM7QUFDNUMsTUFBSUEsTUFBTUYsTUFBTixHQUFlQyxNQUFNRCxNQUF6QixFQUFpQztBQUMvQixXQUFPLEtBQVA7QUFDRDs7QUFFRCxPQUFLLElBQUlHLElBQUksQ0FBYixFQUFnQkEsSUFBSUQsTUFBTUYsTUFBMUIsRUFBa0NHLEdBQWxDLEVBQXVDO0FBQ3JDLFFBQUlELE1BQU1DLENBQU4sTUFBYUYsTUFBTUUsQ0FBTixDQUFqQixFQUEyQjtBQUN6QixhQUFPLEtBQVA7QUFDRDtBQUNGOztBQUVELFNBQU8sSUFBUDtBQUNEIiwiZmlsZSI6ImFycmF5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGFycmF5RXF1YWwoYSwgYikge1xuICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGFycmF5U3RhcnRzV2l0aChhLCBiKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFycmF5U3RhcnRzV2l0aChhcnJheSwgc3RhcnQpIHtcbiAgaWYgKHN0YXJ0Lmxlbmd0aCA+IGFycmF5Lmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhcnQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3RhcnRbaV0gIT09IGFycmF5W2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG4iXX0=\r\n\r\n\r\n/***/ }),\r\n/* 16 */\r\n/***/ (function(module, exports) {\r\n\r\n\t/*istanbul ignore start*/\"use strict\";\r\n\r\n\texports.__esModule = true;\r\n\texports. /*istanbul ignore end*/convertChangesToDMP = convertChangesToDMP;\r\n\t// See: http://code.google.com/p/google-diff-match-patch/wiki/API\r\n\tfunction convertChangesToDMP(changes) {\r\n\t  var ret = [],\r\n\t      change = /*istanbul ignore start*/void 0 /*istanbul ignore end*/,\r\n\t      operation = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;\r\n\t  for (var i = 0; i < changes.length; i++) {\r\n\t    change = changes[i];\r\n\t    if (change.added) {\r\n\t      operation = 1;\r\n\t    } else if (change.removed) {\r\n\t      operation = -1;\r\n\t    } else {\r\n\t      operation = 0;\r\n\t    }\r\n\r\n\t    ret.push([operation, change.value]);\r\n\t  }\r\n\t  return ret;\r\n\t}\r\n\t//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb252ZXJ0L2RtcC5qcyJdLCJuYW1lcyI6WyJjb252ZXJ0Q2hhbmdlc1RvRE1QIiwiY2hhbmdlcyIsInJldCIsImNoYW5nZSIsIm9wZXJhdGlvbiIsImkiLCJsZW5ndGgiLCJhZGRlZCIsInJlbW92ZWQiLCJwdXNoIiwidmFsdWUiXSwibWFwcGluZ3MiOiI7OztnQ0FDZ0JBLG1CLEdBQUFBLG1CO0FBRGhCO0FBQ08sU0FBU0EsbUJBQVQsQ0FBNkJDLE9BQTdCLEVBQXNDO0FBQzNDLE1BQUlDLE1BQU0sRUFBVjtBQUFBLE1BQ0lDLHdDQURKO0FBQUEsTUFFSUMsMkNBRko7QUFHQSxPQUFLLElBQUlDLElBQUksQ0FBYixFQUFnQkEsSUFBSUosUUFBUUssTUFBNUIsRUFBb0NELEdBQXBDLEVBQXlDO0FBQ3ZDRixhQUFTRixRQUFRSSxDQUFSLENBQVQ7QUFDQSxRQUFJRixPQUFPSSxLQUFYLEVBQWtCO0FBQ2hCSCxrQkFBWSxDQUFaO0FBQ0QsS0FGRCxNQUVPLElBQUlELE9BQU9LLE9BQVgsRUFBb0I7QUFDekJKLGtCQUFZLENBQUMsQ0FBYjtBQUNELEtBRk0sTUFFQTtBQUNMQSxrQkFBWSxDQUFaO0FBQ0Q7O0FBRURGLFFBQUlPLElBQUosQ0FBUyxDQUFDTCxTQUFELEVBQVlELE9BQU9PLEtBQW5CLENBQVQ7QUFDRDtBQUNELFNBQU9SLEdBQVA7QUFDRCIsImZpbGUiOiJkbXAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTZWU6IGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9nb29nbGUtZGlmZi1tYXRjaC1wYXRjaC93aWtpL0FQSVxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRDaGFuZ2VzVG9ETVAoY2hhbmdlcykge1xuICBsZXQgcmV0ID0gW10sXG4gICAgICBjaGFuZ2UsXG4gICAgICBvcGVyYXRpb247XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgIGNoYW5nZSA9IGNoYW5nZXNbaV07XG4gICAgaWYgKGNoYW5nZS5hZGRlZCkge1xuICAgICAgb3BlcmF0aW9uID0gMTtcbiAgICB9IGVsc2UgaWYgKGNoYW5nZS5yZW1vdmVkKSB7XG4gICAgICBvcGVyYXRpb24gPSAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3BlcmF0aW9uID0gMDtcbiAgICB9XG5cbiAgICByZXQucHVzaChbb3BlcmF0aW9uLCBjaGFuZ2UudmFsdWVdKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuIl19\r\n\r\n\r\n/***/ }),\r\n/* 17 */\r\n/***/ (function(module, exports) {\r\n\r\n\t/*istanbul ignore start*/'use strict';\r\n\r\n\texports.__esModule = true;\r\n\texports. /*istanbul ignore end*/convertChangesToXML = convertChangesToXML;\r\n\tfunction convertChangesToXML(changes) {\r\n\t  var ret = [];\r\n\t  for (var i = 0; i < changes.length; i++) {\r\n\t    var change = changes[i];\r\n\t    if (change.added) {\r\n\t      ret.push('<ins>');\r\n\t    } else if (change.removed) {\r\n\t      ret.push('<del>');\r\n\t    }\r\n\r\n\t    ret.push(escapeHTML(change.value));\r\n\r\n\t    if (change.added) {\r\n\t      ret.push('</ins>');\r\n\t    } else if (change.removed) {\r\n\t      ret.push('</del>');\r\n\t    }\r\n\t  }\r\n\t  return ret.join('');\r\n\t}\r\n\r\n\tfunction escapeHTML(s) {\r\n\t  var n = s;\r\n\t  n = n.replace(/&/g, '&amp;');\r\n\t  n = n.replace(/</g, '&lt;');\r\n\t  n = n.replace(/>/g, '&gt;');\r\n\t  n = n.replace(/\"/g, '&quot;');\r\n\r\n\t  return n;\r\n\t}\r\n\t//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb252ZXJ0L3htbC5qcyJdLCJuYW1lcyI6WyJjb252ZXJ0Q2hhbmdlc1RvWE1MIiwiY2hhbmdlcyIsInJldCIsImkiLCJsZW5ndGgiLCJjaGFuZ2UiLCJhZGRlZCIsInB1c2giLCJyZW1vdmVkIiwiZXNjYXBlSFRNTCIsInZhbHVlIiwiam9pbiIsInMiLCJuIiwicmVwbGFjZSJdLCJtYXBwaW5ncyI6Ijs7O2dDQUFnQkEsbUIsR0FBQUEsbUI7QUFBVCxTQUFTQSxtQkFBVCxDQUE2QkMsT0FBN0IsRUFBc0M7QUFDM0MsTUFBSUMsTUFBTSxFQUFWO0FBQ0EsT0FBSyxJQUFJQyxJQUFJLENBQWIsRUFBZ0JBLElBQUlGLFFBQVFHLE1BQTVCLEVBQW9DRCxHQUFwQyxFQUF5QztBQUN2QyxRQUFJRSxTQUFTSixRQUFRRSxDQUFSLENBQWI7QUFDQSxRQUFJRSxPQUFPQyxLQUFYLEVBQWtCO0FBQ2hCSixVQUFJSyxJQUFKLENBQVMsT0FBVDtBQUNELEtBRkQsTUFFTyxJQUFJRixPQUFPRyxPQUFYLEVBQW9CO0FBQ3pCTixVQUFJSyxJQUFKLENBQVMsT0FBVDtBQUNEOztBQUVETCxRQUFJSyxJQUFKLENBQVNFLFdBQVdKLE9BQU9LLEtBQWxCLENBQVQ7O0FBRUEsUUFBSUwsT0FBT0MsS0FBWCxFQUFrQjtBQUNoQkosVUFBSUssSUFBSixDQUFTLFFBQVQ7QUFDRCxLQUZELE1BRU8sSUFBSUYsT0FBT0csT0FBWCxFQUFvQjtBQUN6Qk4sVUFBSUssSUFBSixDQUFTLFFBQVQ7QUFDRDtBQUNGO0FBQ0QsU0FBT0wsSUFBSVMsSUFBSixDQUFTLEVBQVQsQ0FBUDtBQUNEOztBQUVELFNBQVNGLFVBQVQsQ0FBb0JHLENBQXBCLEVBQXVCO0FBQ3JCLE1BQUlDLElBQUlELENBQVI7QUFDQUMsTUFBSUEsRUFBRUMsT0FBRixDQUFVLElBQVYsRUFBZ0IsT0FBaEIsQ0FBSjtBQUNBRCxNQUFJQSxFQUFFQyxPQUFGLENBQVUsSUFBVixFQUFnQixNQUFoQixDQUFKO0FBQ0FELE1BQUlBLEVBQUVDLE9BQUYsQ0FBVSxJQUFWLEVBQWdCLE1BQWhCLENBQUo7QUFDQUQsTUFBSUEsRUFBRUMsT0FBRixDQUFVLElBQVYsRUFBZ0IsUUFBaEIsQ0FBSjs7QUFFQSxTQUFPRCxDQUFQO0FBQ0QiLCJmaWxlIjoieG1sLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRDaGFuZ2VzVG9YTUwoY2hhbmdlcykge1xuICBsZXQgcmV0ID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBjaGFuZ2UgPSBjaGFuZ2VzW2ldO1xuICAgIGlmIChjaGFuZ2UuYWRkZWQpIHtcbiAgICAgIHJldC5wdXNoKCc8aW5zPicpO1xuICAgIH0gZWxzZSBpZiAoY2hhbmdlLnJlbW92ZWQpIHtcbiAgICAgIHJldC5wdXNoKCc8ZGVsPicpO1xuICAgIH1cblxuICAgIHJldC5wdXNoKGVzY2FwZUhUTUwoY2hhbmdlLnZhbHVlKSk7XG5cbiAgICBpZiAoY2hhbmdlLmFkZGVkKSB7XG4gICAgICByZXQucHVzaCgnPC9pbnM+Jyk7XG4gICAgfSBlbHNlIGlmIChjaGFuZ2UucmVtb3ZlZCkge1xuICAgICAgcmV0LnB1c2goJzwvZGVsPicpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0LmpvaW4oJycpO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVIVE1MKHMpIHtcbiAgbGV0IG4gPSBzO1xuICBuID0gbi5yZXBsYWNlKC8mL2csICcmYW1wOycpO1xuICBuID0gbi5yZXBsYWNlKC88L2csICcmbHQ7Jyk7XG4gIG4gPSBuLnJlcGxhY2UoLz4vZywgJyZndDsnKTtcbiAgbiA9IG4ucmVwbGFjZSgvXCIvZywgJyZxdW90OycpO1xuXG4gIHJldHVybiBuO1xufVxuIl19\r\n\r\n\r\n/***/ })\r\n/******/ ])\r\n});\r\n;\n\n//# sourceURL=webpack:///./node_modules/diff/dist/diff.js?");

/***/ }),

/***/ "./node_modules/escape-string-regexp/index.js":
/*!****************************************************!*\
  !*** ./node_modules/escape-string-regexp/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar matchOperatorsRe = /[|\\\\{}()[\\]^$+*?.]/g;\r\n\r\nmodule.exports = function (str) {\r\n\tif (typeof str !== 'string') {\r\n\t\tthrow new TypeError('Expected a string');\r\n\t}\r\n\r\n\treturn str.replace(matchOperatorsRe, '\\\\$&');\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/escape-string-regexp/index.js?");

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the\r\n// \"Software\"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n// persons to whom the Software is furnished to do so, subject to the\r\n// following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n\r\n\r\nvar R = typeof Reflect === 'object' ? Reflect : null\r\nvar ReflectApply = R && typeof R.apply === 'function'\r\n  ? R.apply\r\n  : function ReflectApply(target, receiver, args) {\r\n    return Function.prototype.apply.call(target, receiver, args);\r\n  }\r\n\r\nvar ReflectOwnKeys\r\nif (R && typeof R.ownKeys === 'function') {\r\n  ReflectOwnKeys = R.ownKeys\r\n} else if (Object.getOwnPropertySymbols) {\r\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\r\n    return Object.getOwnPropertyNames(target)\r\n      .concat(Object.getOwnPropertySymbols(target));\r\n  };\r\n} else {\r\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\r\n    return Object.getOwnPropertyNames(target);\r\n  };\r\n}\r\n\r\nfunction ProcessEmitWarning(warning) {\r\n  if (console && console.warn) console.warn(warning);\r\n}\r\n\r\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\r\n  return value !== value;\r\n}\r\n\r\nfunction EventEmitter() {\r\n  EventEmitter.init.call(this);\r\n}\r\nmodule.exports = EventEmitter;\r\n\r\n// Backwards-compat with node 0.10.x\r\nEventEmitter.EventEmitter = EventEmitter;\r\n\r\nEventEmitter.prototype._events = undefined;\r\nEventEmitter.prototype._eventsCount = 0;\r\nEventEmitter.prototype._maxListeners = undefined;\r\n\r\n// By default EventEmitters will print a warning if more than 10 listeners are\r\n// added to it. This is a useful default which helps finding memory leaks.\r\nvar defaultMaxListeners = 10;\r\n\r\nfunction checkListener(listener) {\r\n  if (typeof listener !== 'function') {\r\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\r\n  }\r\n}\r\n\r\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\r\n  enumerable: true,\r\n  get: function() {\r\n    return defaultMaxListeners;\r\n  },\r\n  set: function(arg) {\r\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\r\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\r\n    }\r\n    defaultMaxListeners = arg;\r\n  }\r\n});\r\n\r\nEventEmitter.init = function() {\r\n\r\n  if (this._events === undefined ||\r\n      this._events === Object.getPrototypeOf(this)._events) {\r\n    this._events = Object.create(null);\r\n    this._eventsCount = 0;\r\n  }\r\n\r\n  this._maxListeners = this._maxListeners || undefined;\r\n};\r\n\r\n// Obviously not all Emitters should be limited to 10. This function allows\r\n// that to be increased. Set to zero for unlimited.\r\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\r\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\r\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\r\n  }\r\n  this._maxListeners = n;\r\n  return this;\r\n};\r\n\r\nfunction _getMaxListeners(that) {\r\n  if (that._maxListeners === undefined)\r\n    return EventEmitter.defaultMaxListeners;\r\n  return that._maxListeners;\r\n}\r\n\r\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\r\n  return _getMaxListeners(this);\r\n};\r\n\r\nEventEmitter.prototype.emit = function emit(type) {\r\n  var args = [];\r\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\r\n  var doError = (type === 'error');\r\n\r\n  var events = this._events;\r\n  if (events !== undefined)\r\n    doError = (doError && events.error === undefined);\r\n  else if (!doError)\r\n    return false;\r\n\r\n  // If there is no 'error' event listener then throw.\r\n  if (doError) {\r\n    var er;\r\n    if (args.length > 0)\r\n      er = args[0];\r\n    if (er instanceof Error) {\r\n      // Note: The comments on the `throw` lines are intentional, they show\r\n      // up in Node's output if this results in an unhandled exception.\r\n      throw er; // Unhandled 'error' event\r\n    }\r\n    // At least give some kind of context to the user\r\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\r\n    err.context = er;\r\n    throw err; // Unhandled 'error' event\r\n  }\r\n\r\n  var handler = events[type];\r\n\r\n  if (handler === undefined)\r\n    return false;\r\n\r\n  if (typeof handler === 'function') {\r\n    ReflectApply(handler, this, args);\r\n  } else {\r\n    var len = handler.length;\r\n    var listeners = arrayClone(handler, len);\r\n    for (var i = 0; i < len; ++i)\r\n      ReflectApply(listeners[i], this, args);\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nfunction _addListener(target, type, listener, prepend) {\r\n  var m;\r\n  var events;\r\n  var existing;\r\n\r\n  checkListener(listener);\r\n\r\n  events = target._events;\r\n  if (events === undefined) {\r\n    events = target._events = Object.create(null);\r\n    target._eventsCount = 0;\r\n  } else {\r\n    // To avoid recursion in the case that type === \"newListener\"! Before\r\n    // adding it to the listeners, first emit \"newListener\".\r\n    if (events.newListener !== undefined) {\r\n      target.emit('newListener', type,\r\n                  listener.listener ? listener.listener : listener);\r\n\r\n      // Re-assign `events` because a newListener handler could have caused the\r\n      // this._events to be assigned to a new object\r\n      events = target._events;\r\n    }\r\n    existing = events[type];\r\n  }\r\n\r\n  if (existing === undefined) {\r\n    // Optimize the case of one listener. Don't need the extra array object.\r\n    existing = events[type] = listener;\r\n    ++target._eventsCount;\r\n  } else {\r\n    if (typeof existing === 'function') {\r\n      // Adding the second element, need to change to array.\r\n      existing = events[type] =\r\n        prepend ? [listener, existing] : [existing, listener];\r\n      // If we've already got an array, just append.\r\n    } else if (prepend) {\r\n      existing.unshift(listener);\r\n    } else {\r\n      existing.push(listener);\r\n    }\r\n\r\n    // Check for listener leak\r\n    m = _getMaxListeners(target);\r\n    if (m > 0 && existing.length > m && !existing.warned) {\r\n      existing.warned = true;\r\n      // No error code for this since it is a Warning\r\n      // eslint-disable-next-line no-restricted-syntax\r\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\r\n                          existing.length + ' ' + String(type) + ' listeners ' +\r\n                          'added. Use emitter.setMaxListeners() to ' +\r\n                          'increase limit');\r\n      w.name = 'MaxListenersExceededWarning';\r\n      w.emitter = target;\r\n      w.type = type;\r\n      w.count = existing.length;\r\n      ProcessEmitWarning(w);\r\n    }\r\n  }\r\n\r\n  return target;\r\n}\r\n\r\nEventEmitter.prototype.addListener = function addListener(type, listener) {\r\n  return _addListener(this, type, listener, false);\r\n};\r\n\r\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\r\n\r\nEventEmitter.prototype.prependListener =\r\n    function prependListener(type, listener) {\r\n      return _addListener(this, type, listener, true);\r\n    };\r\n\r\nfunction onceWrapper() {\r\n  if (!this.fired) {\r\n    this.target.removeListener(this.type, this.wrapFn);\r\n    this.fired = true;\r\n    if (arguments.length === 0)\r\n      return this.listener.call(this.target);\r\n    return this.listener.apply(this.target, arguments);\r\n  }\r\n}\r\n\r\nfunction _onceWrap(target, type, listener) {\r\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\r\n  var wrapped = onceWrapper.bind(state);\r\n  wrapped.listener = listener;\r\n  state.wrapFn = wrapped;\r\n  return wrapped;\r\n}\r\n\r\nEventEmitter.prototype.once = function once(type, listener) {\r\n  checkListener(listener);\r\n  this.on(type, _onceWrap(this, type, listener));\r\n  return this;\r\n};\r\n\r\nEventEmitter.prototype.prependOnceListener =\r\n    function prependOnceListener(type, listener) {\r\n      checkListener(listener);\r\n      this.prependListener(type, _onceWrap(this, type, listener));\r\n      return this;\r\n    };\r\n\r\n// Emits a 'removeListener' event if and only if the listener was removed.\r\nEventEmitter.prototype.removeListener =\r\n    function removeListener(type, listener) {\r\n      var list, events, position, i, originalListener;\r\n\r\n      checkListener(listener);\r\n\r\n      events = this._events;\r\n      if (events === undefined)\r\n        return this;\r\n\r\n      list = events[type];\r\n      if (list === undefined)\r\n        return this;\r\n\r\n      if (list === listener || list.listener === listener) {\r\n        if (--this._eventsCount === 0)\r\n          this._events = Object.create(null);\r\n        else {\r\n          delete events[type];\r\n          if (events.removeListener)\r\n            this.emit('removeListener', type, list.listener || listener);\r\n        }\r\n      } else if (typeof list !== 'function') {\r\n        position = -1;\r\n\r\n        for (i = list.length - 1; i >= 0; i--) {\r\n          if (list[i] === listener || list[i].listener === listener) {\r\n            originalListener = list[i].listener;\r\n            position = i;\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (position < 0)\r\n          return this;\r\n\r\n        if (position === 0)\r\n          list.shift();\r\n        else {\r\n          spliceOne(list, position);\r\n        }\r\n\r\n        if (list.length === 1)\r\n          events[type] = list[0];\r\n\r\n        if (events.removeListener !== undefined)\r\n          this.emit('removeListener', type, originalListener || listener);\r\n      }\r\n\r\n      return this;\r\n    };\r\n\r\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\r\n\r\nEventEmitter.prototype.removeAllListeners =\r\n    function removeAllListeners(type) {\r\n      var listeners, events, i;\r\n\r\n      events = this._events;\r\n      if (events === undefined)\r\n        return this;\r\n\r\n      // not listening for removeListener, no need to emit\r\n      if (events.removeListener === undefined) {\r\n        if (arguments.length === 0) {\r\n          this._events = Object.create(null);\r\n          this._eventsCount = 0;\r\n        } else if (events[type] !== undefined) {\r\n          if (--this._eventsCount === 0)\r\n            this._events = Object.create(null);\r\n          else\r\n            delete events[type];\r\n        }\r\n        return this;\r\n      }\r\n\r\n      // emit removeListener for all listeners on all events\r\n      if (arguments.length === 0) {\r\n        var keys = Object.keys(events);\r\n        var key;\r\n        for (i = 0; i < keys.length; ++i) {\r\n          key = keys[i];\r\n          if (key === 'removeListener') continue;\r\n          this.removeAllListeners(key);\r\n        }\r\n        this.removeAllListeners('removeListener');\r\n        this._events = Object.create(null);\r\n        this._eventsCount = 0;\r\n        return this;\r\n      }\r\n\r\n      listeners = events[type];\r\n\r\n      if (typeof listeners === 'function') {\r\n        this.removeListener(type, listeners);\r\n      } else if (listeners !== undefined) {\r\n        // LIFO order\r\n        for (i = listeners.length - 1; i >= 0; i--) {\r\n          this.removeListener(type, listeners[i]);\r\n        }\r\n      }\r\n\r\n      return this;\r\n    };\r\n\r\nfunction _listeners(target, type, unwrap) {\r\n  var events = target._events;\r\n\r\n  if (events === undefined)\r\n    return [];\r\n\r\n  var evlistener = events[type];\r\n  if (evlistener === undefined)\r\n    return [];\r\n\r\n  if (typeof evlistener === 'function')\r\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\r\n\r\n  return unwrap ?\r\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\r\n}\r\n\r\nEventEmitter.prototype.listeners = function listeners(type) {\r\n  return _listeners(this, type, true);\r\n};\r\n\r\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\r\n  return _listeners(this, type, false);\r\n};\r\n\r\nEventEmitter.listenerCount = function(emitter, type) {\r\n  if (typeof emitter.listenerCount === 'function') {\r\n    return emitter.listenerCount(type);\r\n  } else {\r\n    return listenerCount.call(emitter, type);\r\n  }\r\n};\r\n\r\nEventEmitter.prototype.listenerCount = listenerCount;\r\nfunction listenerCount(type) {\r\n  var events = this._events;\r\n\r\n  if (events !== undefined) {\r\n    var evlistener = events[type];\r\n\r\n    if (typeof evlistener === 'function') {\r\n      return 1;\r\n    } else if (evlistener !== undefined) {\r\n      return evlistener.length;\r\n    }\r\n  }\r\n\r\n  return 0;\r\n}\r\n\r\nEventEmitter.prototype.eventNames = function eventNames() {\r\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\r\n};\r\n\r\nfunction arrayClone(arr, n) {\r\n  var copy = new Array(n);\r\n  for (var i = 0; i < n; ++i)\r\n    copy[i] = arr[i];\r\n  return copy;\r\n}\r\n\r\nfunction spliceOne(list, index) {\r\n  for (; index + 1 < list.length; index++)\r\n    list[index] = list[index + 1];\r\n  list.pop();\r\n}\r\n\r\nfunction unwrapListeners(arr) {\r\n  var ret = new Array(arr.length);\r\n  for (var i = 0; i < ret.length; ++i) {\r\n    ret[i] = arr[i].listener || arr[i];\r\n  }\r\n  return ret;\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/events/events.js?");

/***/ }),

/***/ "./node_modules/function-bind/implementation.js":
/*!******************************************************!*\
  !*** ./node_modules/function-bind/implementation.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\n/* eslint no-invalid-this: 1 */\r\n\r\nvar ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';\r\nvar slice = Array.prototype.slice;\r\nvar toStr = Object.prototype.toString;\r\nvar funcType = '[object Function]';\r\n\r\nmodule.exports = function bind(that) {\r\n    var target = this;\r\n    if (typeof target !== 'function' || toStr.call(target) !== funcType) {\r\n        throw new TypeError(ERROR_MESSAGE + target);\r\n    }\r\n    var args = slice.call(arguments, 1);\r\n\r\n    var bound;\r\n    var binder = function () {\r\n        if (this instanceof bound) {\r\n            var result = target.apply(\r\n                this,\r\n                args.concat(slice.call(arguments))\r\n            );\r\n            if (Object(result) === result) {\r\n                return result;\r\n            }\r\n            return this;\r\n        } else {\r\n            return target.apply(\r\n                that,\r\n                args.concat(slice.call(arguments))\r\n            );\r\n        }\r\n    };\r\n\r\n    var boundLength = Math.max(0, target.length - args.length);\r\n    var boundArgs = [];\r\n    for (var i = 0; i < boundLength; i++) {\r\n        boundArgs.push('$' + i);\r\n    }\r\n\r\n    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);\r\n\r\n    if (target.prototype) {\r\n        var Empty = function Empty() {};\r\n        Empty.prototype = target.prototype;\r\n        bound.prototype = new Empty();\r\n        Empty.prototype = null;\r\n    }\r\n\r\n    return bound;\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/function-bind/implementation.js?");

/***/ }),

/***/ "./node_modules/function-bind/index.js":
/*!*********************************************!*\
  !*** ./node_modules/function-bind/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar implementation = __webpack_require__(/*! ./implementation */ \"./node_modules/function-bind/implementation.js\");\r\n\r\nmodule.exports = Function.prototype.bind || implementation;\r\n\n\n//# sourceURL=webpack:///./node_modules/function-bind/index.js?");

/***/ }),

/***/ "./node_modules/has-symbols/shams.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/shams.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\n/* eslint complexity: [2, 18], max-statements: [2, 33] */\r\nmodule.exports = function hasSymbols() {\r\n\tif (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }\r\n\tif (typeof Symbol.iterator === 'symbol') { return true; }\r\n\r\n\tvar obj = {};\r\n\tvar sym = Symbol('test');\r\n\tvar symObj = Object(sym);\r\n\tif (typeof sym === 'string') { return false; }\r\n\r\n\tif (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }\r\n\tif (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }\r\n\r\n\t// temp disabled per https://github.com/ljharb/object.assign/issues/17\r\n\t// if (sym instanceof Symbol) { return false; }\r\n\t// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4\r\n\t// if (!(symObj instanceof Symbol)) { return false; }\r\n\r\n\t// if (typeof Symbol.prototype.toString !== 'function') { return false; }\r\n\t// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }\r\n\r\n\tvar symVal = 42;\r\n\tobj[sym] = symVal;\r\n\tfor (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax\r\n\tif (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }\r\n\r\n\tif (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }\r\n\r\n\tvar syms = Object.getOwnPropertySymbols(obj);\r\n\tif (syms.length !== 1 || syms[0] !== sym) { return false; }\r\n\r\n\tif (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }\r\n\r\n\tif (typeof Object.getOwnPropertyDescriptor === 'function') {\r\n\t\tvar descriptor = Object.getOwnPropertyDescriptor(obj, sym);\r\n\t\tif (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }\r\n\t}\r\n\r\n\treturn true;\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/has-symbols/shams.js?");

/***/ }),

/***/ "./node_modules/he/he.js":
/*!*******************************!*\
  !*** ./node_modules/he/he.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/he v1.2.0 by @mathias | MIT license */\r\n;(function(root) {\r\n\r\n\t// Detect free variables `exports`.\r\n\tvar freeExports =  true && exports;\r\n\r\n\t// Detect free variable `module`.\r\n\tvar freeModule =  true && module &&\r\n\t\tmodule.exports == freeExports && module;\r\n\r\n\t// Detect free variable `global`, from Node.js or Browserified code,\r\n\t// and use it as `root`.\r\n\tvar freeGlobal = typeof global == 'object' && global;\r\n\tif (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {\r\n\t\troot = freeGlobal;\r\n\t}\r\n\r\n\t/*--------------------------------------------------------------------------*/\r\n\r\n\t// All astral symbols.\r\n\tvar regexAstralSymbols = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\r\n\t// All ASCII symbols (not just printable ASCII) except those listed in the\r\n\t// first column of the overrides table.\r\n\t// https://html.spec.whatwg.org/multipage/syntax.html#table-charref-overrides\r\n\tvar regexAsciiWhitelist = /[\\x01-\\x7F]/g;\r\n\t// All BMP symbols that are not ASCII newlines, printable ASCII symbols, or\r\n\t// code points listed in the first column of the overrides table on\r\n\t// https://html.spec.whatwg.org/multipage/syntax.html#table-charref-overrides.\r\n\tvar regexBmpWhitelist = /[\\x01-\\t\\x0B\\f\\x0E-\\x1F\\x7F\\x81\\x8D\\x8F\\x90\\x9D\\xA0-\\uFFFF]/g;\r\n\r\n\tvar regexEncodeNonAscii = /<\\u20D2|=\\u20E5|>\\u20D2|\\u205F\\u200A|\\u219D\\u0338|\\u2202\\u0338|\\u2220\\u20D2|\\u2229\\uFE00|\\u222A\\uFE00|\\u223C\\u20D2|\\u223D\\u0331|\\u223E\\u0333|\\u2242\\u0338|\\u224B\\u0338|\\u224D\\u20D2|\\u224E\\u0338|\\u224F\\u0338|\\u2250\\u0338|\\u2261\\u20E5|\\u2264\\u20D2|\\u2265\\u20D2|\\u2266\\u0338|\\u2267\\u0338|\\u2268\\uFE00|\\u2269\\uFE00|\\u226A\\u0338|\\u226A\\u20D2|\\u226B\\u0338|\\u226B\\u20D2|\\u227F\\u0338|\\u2282\\u20D2|\\u2283\\u20D2|\\u228A\\uFE00|\\u228B\\uFE00|\\u228F\\u0338|\\u2290\\u0338|\\u2293\\uFE00|\\u2294\\uFE00|\\u22B4\\u20D2|\\u22B5\\u20D2|\\u22D8\\u0338|\\u22D9\\u0338|\\u22DA\\uFE00|\\u22DB\\uFE00|\\u22F5\\u0338|\\u22F9\\u0338|\\u2933\\u0338|\\u29CF\\u0338|\\u29D0\\u0338|\\u2A6D\\u0338|\\u2A70\\u0338|\\u2A7D\\u0338|\\u2A7E\\u0338|\\u2AA1\\u0338|\\u2AA2\\u0338|\\u2AAC\\uFE00|\\u2AAD\\uFE00|\\u2AAF\\u0338|\\u2AB0\\u0338|\\u2AC5\\u0338|\\u2AC6\\u0338|\\u2ACB\\uFE00|\\u2ACC\\uFE00|\\u2AFD\\u20E5|[\\xA0-\\u0113\\u0116-\\u0122\\u0124-\\u012B\\u012E-\\u014D\\u0150-\\u017E\\u0192\\u01B5\\u01F5\\u0237\\u02C6\\u02C7\\u02D8-\\u02DD\\u0311\\u0391-\\u03A1\\u03A3-\\u03A9\\u03B1-\\u03C9\\u03D1\\u03D2\\u03D5\\u03D6\\u03DC\\u03DD\\u03F0\\u03F1\\u03F5\\u03F6\\u0401-\\u040C\\u040E-\\u044F\\u0451-\\u045C\\u045E\\u045F\\u2002-\\u2005\\u2007-\\u2010\\u2013-\\u2016\\u2018-\\u201A\\u201C-\\u201E\\u2020-\\u2022\\u2025\\u2026\\u2030-\\u2035\\u2039\\u203A\\u203E\\u2041\\u2043\\u2044\\u204F\\u2057\\u205F-\\u2063\\u20AC\\u20DB\\u20DC\\u2102\\u2105\\u210A-\\u2113\\u2115-\\u211E\\u2122\\u2124\\u2127-\\u2129\\u212C\\u212D\\u212F-\\u2131\\u2133-\\u2138\\u2145-\\u2148\\u2153-\\u215E\\u2190-\\u219B\\u219D-\\u21A7\\u21A9-\\u21AE\\u21B0-\\u21B3\\u21B5-\\u21B7\\u21BA-\\u21DB\\u21DD\\u21E4\\u21E5\\u21F5\\u21FD-\\u2205\\u2207-\\u2209\\u220B\\u220C\\u220F-\\u2214\\u2216-\\u2218\\u221A\\u221D-\\u2238\\u223A-\\u2257\\u2259\\u225A\\u225C\\u225F-\\u2262\\u2264-\\u228B\\u228D-\\u229B\\u229D-\\u22A5\\u22A7-\\u22B0\\u22B2-\\u22BB\\u22BD-\\u22DB\\u22DE-\\u22E3\\u22E6-\\u22F7\\u22F9-\\u22FE\\u2305\\u2306\\u2308-\\u2310\\u2312\\u2313\\u2315\\u2316\\u231C-\\u231F\\u2322\\u2323\\u232D\\u232E\\u2336\\u233D\\u233F\\u237C\\u23B0\\u23B1\\u23B4-\\u23B6\\u23DC-\\u23DF\\u23E2\\u23E7\\u2423\\u24C8\\u2500\\u2502\\u250C\\u2510\\u2514\\u2518\\u251C\\u2524\\u252C\\u2534\\u253C\\u2550-\\u256C\\u2580\\u2584\\u2588\\u2591-\\u2593\\u25A1\\u25AA\\u25AB\\u25AD\\u25AE\\u25B1\\u25B3-\\u25B5\\u25B8\\u25B9\\u25BD-\\u25BF\\u25C2\\u25C3\\u25CA\\u25CB\\u25EC\\u25EF\\u25F8-\\u25FC\\u2605\\u2606\\u260E\\u2640\\u2642\\u2660\\u2663\\u2665\\u2666\\u266A\\u266D-\\u266F\\u2713\\u2717\\u2720\\u2736\\u2758\\u2772\\u2773\\u27C8\\u27C9\\u27E6-\\u27ED\\u27F5-\\u27FA\\u27FC\\u27FF\\u2902-\\u2905\\u290C-\\u2913\\u2916\\u2919-\\u2920\\u2923-\\u292A\\u2933\\u2935-\\u2939\\u293C\\u293D\\u2945\\u2948-\\u294B\\u294E-\\u2976\\u2978\\u2979\\u297B-\\u297F\\u2985\\u2986\\u298B-\\u2996\\u299A\\u299C\\u299D\\u29A4-\\u29B7\\u29B9\\u29BB\\u29BC\\u29BE-\\u29C5\\u29C9\\u29CD-\\u29D0\\u29DC-\\u29DE\\u29E3-\\u29E5\\u29EB\\u29F4\\u29F6\\u2A00-\\u2A02\\u2A04\\u2A06\\u2A0C\\u2A0D\\u2A10-\\u2A17\\u2A22-\\u2A27\\u2A29\\u2A2A\\u2A2D-\\u2A31\\u2A33-\\u2A3C\\u2A3F\\u2A40\\u2A42-\\u2A4D\\u2A50\\u2A53-\\u2A58\\u2A5A-\\u2A5D\\u2A5F\\u2A66\\u2A6A\\u2A6D-\\u2A75\\u2A77-\\u2A9A\\u2A9D-\\u2AA2\\u2AA4-\\u2AB0\\u2AB3-\\u2AC8\\u2ACB\\u2ACC\\u2ACF-\\u2ADB\\u2AE4\\u2AE6-\\u2AE9\\u2AEB-\\u2AF3\\u2AFD\\uFB00-\\uFB04]|\\uD835[\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDCCF\\uDD04\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDD6B]/g;\r\n\tvar encodeMap = {'\\xAD':'shy','\\u200C':'zwnj','\\u200D':'zwj','\\u200E':'lrm','\\u2063':'ic','\\u2062':'it','\\u2061':'af','\\u200F':'rlm','\\u200B':'ZeroWidthSpace','\\u2060':'NoBreak','\\u0311':'DownBreve','\\u20DB':'tdot','\\u20DC':'DotDot','\\t':'Tab','\\n':'NewLine','\\u2008':'puncsp','\\u205F':'MediumSpace','\\u2009':'thinsp','\\u200A':'hairsp','\\u2004':'emsp13','\\u2002':'ensp','\\u2005':'emsp14','\\u2003':'emsp','\\u2007':'numsp','\\xA0':'nbsp','\\u205F\\u200A':'ThickSpace','\\u203E':'oline','_':'lowbar','\\u2010':'dash','\\u2013':'ndash','\\u2014':'mdash','\\u2015':'horbar',',':'comma',';':'semi','\\u204F':'bsemi',':':'colon','\\u2A74':'Colone','!':'excl','\\xA1':'iexcl','?':'quest','\\xBF':'iquest','.':'period','\\u2025':'nldr','\\u2026':'mldr','\\xB7':'middot','\\'':'apos','\\u2018':'lsquo','\\u2019':'rsquo','\\u201A':'sbquo','\\u2039':'lsaquo','\\u203A':'rsaquo','\"':'quot','\\u201C':'ldquo','\\u201D':'rdquo','\\u201E':'bdquo','\\xAB':'laquo','\\xBB':'raquo','(':'lpar',')':'rpar','[':'lsqb',']':'rsqb','{':'lcub','}':'rcub','\\u2308':'lceil','\\u2309':'rceil','\\u230A':'lfloor','\\u230B':'rfloor','\\u2985':'lopar','\\u2986':'ropar','\\u298B':'lbrke','\\u298C':'rbrke','\\u298D':'lbrkslu','\\u298E':'rbrksld','\\u298F':'lbrksld','\\u2990':'rbrkslu','\\u2991':'langd','\\u2992':'rangd','\\u2993':'lparlt','\\u2994':'rpargt','\\u2995':'gtlPar','\\u2996':'ltrPar','\\u27E6':'lobrk','\\u27E7':'robrk','\\u27E8':'lang','\\u27E9':'rang','\\u27EA':'Lang','\\u27EB':'Rang','\\u27EC':'loang','\\u27ED':'roang','\\u2772':'lbbrk','\\u2773':'rbbrk','\\u2016':'Vert','\\xA7':'sect','\\xB6':'para','@':'commat','*':'ast','/':'sol','undefined':null,'&':'amp','#':'num','%':'percnt','\\u2030':'permil','\\u2031':'pertenk','\\u2020':'dagger','\\u2021':'Dagger','\\u2022':'bull','\\u2043':'hybull','\\u2032':'prime','\\u2033':'Prime','\\u2034':'tprime','\\u2057':'qprime','\\u2035':'bprime','\\u2041':'caret','`':'grave','\\xB4':'acute','\\u02DC':'tilde','^':'Hat','\\xAF':'macr','\\u02D8':'breve','\\u02D9':'dot','\\xA8':'die','\\u02DA':'ring','\\u02DD':'dblac','\\xB8':'cedil','\\u02DB':'ogon','\\u02C6':'circ','\\u02C7':'caron','\\xB0':'deg','\\xA9':'copy','\\xAE':'reg','\\u2117':'copysr','\\u2118':'wp','\\u211E':'rx','\\u2127':'mho','\\u2129':'iiota','\\u2190':'larr','\\u219A':'nlarr','\\u2192':'rarr','\\u219B':'nrarr','\\u2191':'uarr','\\u2193':'darr','\\u2194':'harr','\\u21AE':'nharr','\\u2195':'varr','\\u2196':'nwarr','\\u2197':'nearr','\\u2198':'searr','\\u2199':'swarr','\\u219D':'rarrw','\\u219D\\u0338':'nrarrw','\\u219E':'Larr','\\u219F':'Uarr','\\u21A0':'Rarr','\\u21A1':'Darr','\\u21A2':'larrtl','\\u21A3':'rarrtl','\\u21A4':'mapstoleft','\\u21A5':'mapstoup','\\u21A6':'map','\\u21A7':'mapstodown','\\u21A9':'larrhk','\\u21AA':'rarrhk','\\u21AB':'larrlp','\\u21AC':'rarrlp','\\u21AD':'harrw','\\u21B0':'lsh','\\u21B1':'rsh','\\u21B2':'ldsh','\\u21B3':'rdsh','\\u21B5':'crarr','\\u21B6':'cularr','\\u21B7':'curarr','\\u21BA':'olarr','\\u21BB':'orarr','\\u21BC':'lharu','\\u21BD':'lhard','\\u21BE':'uharr','\\u21BF':'uharl','\\u21C0':'rharu','\\u21C1':'rhard','\\u21C2':'dharr','\\u21C3':'dharl','\\u21C4':'rlarr','\\u21C5':'udarr','\\u21C6':'lrarr','\\u21C7':'llarr','\\u21C8':'uuarr','\\u21C9':'rrarr','\\u21CA':'ddarr','\\u21CB':'lrhar','\\u21CC':'rlhar','\\u21D0':'lArr','\\u21CD':'nlArr','\\u21D1':'uArr','\\u21D2':'rArr','\\u21CF':'nrArr','\\u21D3':'dArr','\\u21D4':'iff','\\u21CE':'nhArr','\\u21D5':'vArr','\\u21D6':'nwArr','\\u21D7':'neArr','\\u21D8':'seArr','\\u21D9':'swArr','\\u21DA':'lAarr','\\u21DB':'rAarr','\\u21DD':'zigrarr','\\u21E4':'larrb','\\u21E5':'rarrb','\\u21F5':'duarr','\\u21FD':'loarr','\\u21FE':'roarr','\\u21FF':'hoarr','\\u2200':'forall','\\u2201':'comp','\\u2202':'part','\\u2202\\u0338':'npart','\\u2203':'exist','\\u2204':'nexist','\\u2205':'empty','\\u2207':'Del','\\u2208':'in','\\u2209':'notin','\\u220B':'ni','\\u220C':'notni','\\u03F6':'bepsi','\\u220F':'prod','\\u2210':'coprod','\\u2211':'sum','+':'plus','\\xB1':'pm','\\xF7':'div','\\xD7':'times','<':'lt','\\u226E':'nlt','<\\u20D2':'nvlt','=':'equals','\\u2260':'ne','=\\u20E5':'bne','\\u2A75':'Equal','>':'gt','\\u226F':'ngt','>\\u20D2':'nvgt','\\xAC':'not','|':'vert','\\xA6':'brvbar','\\u2212':'minus','\\u2213':'mp','\\u2214':'plusdo','\\u2044':'frasl','\\u2216':'setmn','\\u2217':'lowast','\\u2218':'compfn','\\u221A':'Sqrt','\\u221D':'prop','\\u221E':'infin','\\u221F':'angrt','\\u2220':'ang','\\u2220\\u20D2':'nang','\\u2221':'angmsd','\\u2222':'angsph','\\u2223':'mid','\\u2224':'nmid','\\u2225':'par','\\u2226':'npar','\\u2227':'and','\\u2228':'or','\\u2229':'cap','\\u2229\\uFE00':'caps','\\u222A':'cup','\\u222A\\uFE00':'cups','\\u222B':'int','\\u222C':'Int','\\u222D':'tint','\\u2A0C':'qint','\\u222E':'oint','\\u222F':'Conint','\\u2230':'Cconint','\\u2231':'cwint','\\u2232':'cwconint','\\u2233':'awconint','\\u2234':'there4','\\u2235':'becaus','\\u2236':'ratio','\\u2237':'Colon','\\u2238':'minusd','\\u223A':'mDDot','\\u223B':'homtht','\\u223C':'sim','\\u2241':'nsim','\\u223C\\u20D2':'nvsim','\\u223D':'bsim','\\u223D\\u0331':'race','\\u223E':'ac','\\u223E\\u0333':'acE','\\u223F':'acd','\\u2240':'wr','\\u2242':'esim','\\u2242\\u0338':'nesim','\\u2243':'sime','\\u2244':'nsime','\\u2245':'cong','\\u2247':'ncong','\\u2246':'simne','\\u2248':'ap','\\u2249':'nap','\\u224A':'ape','\\u224B':'apid','\\u224B\\u0338':'napid','\\u224C':'bcong','\\u224D':'CupCap','\\u226D':'NotCupCap','\\u224D\\u20D2':'nvap','\\u224E':'bump','\\u224E\\u0338':'nbump','\\u224F':'bumpe','\\u224F\\u0338':'nbumpe','\\u2250':'doteq','\\u2250\\u0338':'nedot','\\u2251':'eDot','\\u2252':'efDot','\\u2253':'erDot','\\u2254':'colone','\\u2255':'ecolon','\\u2256':'ecir','\\u2257':'cire','\\u2259':'wedgeq','\\u225A':'veeeq','\\u225C':'trie','\\u225F':'equest','\\u2261':'equiv','\\u2262':'nequiv','\\u2261\\u20E5':'bnequiv','\\u2264':'le','\\u2270':'nle','\\u2264\\u20D2':'nvle','\\u2265':'ge','\\u2271':'nge','\\u2265\\u20D2':'nvge','\\u2266':'lE','\\u2266\\u0338':'nlE','\\u2267':'gE','\\u2267\\u0338':'ngE','\\u2268\\uFE00':'lvnE','\\u2268':'lnE','\\u2269':'gnE','\\u2269\\uFE00':'gvnE','\\u226A':'ll','\\u226A\\u0338':'nLtv','\\u226A\\u20D2':'nLt','\\u226B':'gg','\\u226B\\u0338':'nGtv','\\u226B\\u20D2':'nGt','\\u226C':'twixt','\\u2272':'lsim','\\u2274':'nlsim','\\u2273':'gsim','\\u2275':'ngsim','\\u2276':'lg','\\u2278':'ntlg','\\u2277':'gl','\\u2279':'ntgl','\\u227A':'pr','\\u2280':'npr','\\u227B':'sc','\\u2281':'nsc','\\u227C':'prcue','\\u22E0':'nprcue','\\u227D':'sccue','\\u22E1':'nsccue','\\u227E':'prsim','\\u227F':'scsim','\\u227F\\u0338':'NotSucceedsTilde','\\u2282':'sub','\\u2284':'nsub','\\u2282\\u20D2':'vnsub','\\u2283':'sup','\\u2285':'nsup','\\u2283\\u20D2':'vnsup','\\u2286':'sube','\\u2288':'nsube','\\u2287':'supe','\\u2289':'nsupe','\\u228A\\uFE00':'vsubne','\\u228A':'subne','\\u228B\\uFE00':'vsupne','\\u228B':'supne','\\u228D':'cupdot','\\u228E':'uplus','\\u228F':'sqsub','\\u228F\\u0338':'NotSquareSubset','\\u2290':'sqsup','\\u2290\\u0338':'NotSquareSuperset','\\u2291':'sqsube','\\u22E2':'nsqsube','\\u2292':'sqsupe','\\u22E3':'nsqsupe','\\u2293':'sqcap','\\u2293\\uFE00':'sqcaps','\\u2294':'sqcup','\\u2294\\uFE00':'sqcups','\\u2295':'oplus','\\u2296':'ominus','\\u2297':'otimes','\\u2298':'osol','\\u2299':'odot','\\u229A':'ocir','\\u229B':'oast','\\u229D':'odash','\\u229E':'plusb','\\u229F':'minusb','\\u22A0':'timesb','\\u22A1':'sdotb','\\u22A2':'vdash','\\u22AC':'nvdash','\\u22A3':'dashv','\\u22A4':'top','\\u22A5':'bot','\\u22A7':'models','\\u22A8':'vDash','\\u22AD':'nvDash','\\u22A9':'Vdash','\\u22AE':'nVdash','\\u22AA':'Vvdash','\\u22AB':'VDash','\\u22AF':'nVDash','\\u22B0':'prurel','\\u22B2':'vltri','\\u22EA':'nltri','\\u22B3':'vrtri','\\u22EB':'nrtri','\\u22B4':'ltrie','\\u22EC':'nltrie','\\u22B4\\u20D2':'nvltrie','\\u22B5':'rtrie','\\u22ED':'nrtrie','\\u22B5\\u20D2':'nvrtrie','\\u22B6':'origof','\\u22B7':'imof','\\u22B8':'mumap','\\u22B9':'hercon','\\u22BA':'intcal','\\u22BB':'veebar','\\u22BD':'barvee','\\u22BE':'angrtvb','\\u22BF':'lrtri','\\u22C0':'Wedge','\\u22C1':'Vee','\\u22C2':'xcap','\\u22C3':'xcup','\\u22C4':'diam','\\u22C5':'sdot','\\u22C6':'Star','\\u22C7':'divonx','\\u22C8':'bowtie','\\u22C9':'ltimes','\\u22CA':'rtimes','\\u22CB':'lthree','\\u22CC':'rthree','\\u22CD':'bsime','\\u22CE':'cuvee','\\u22CF':'cuwed','\\u22D0':'Sub','\\u22D1':'Sup','\\u22D2':'Cap','\\u22D3':'Cup','\\u22D4':'fork','\\u22D5':'epar','\\u22D6':'ltdot','\\u22D7':'gtdot','\\u22D8':'Ll','\\u22D8\\u0338':'nLl','\\u22D9':'Gg','\\u22D9\\u0338':'nGg','\\u22DA\\uFE00':'lesg','\\u22DA':'leg','\\u22DB':'gel','\\u22DB\\uFE00':'gesl','\\u22DE':'cuepr','\\u22DF':'cuesc','\\u22E6':'lnsim','\\u22E7':'gnsim','\\u22E8':'prnsim','\\u22E9':'scnsim','\\u22EE':'vellip','\\u22EF':'ctdot','\\u22F0':'utdot','\\u22F1':'dtdot','\\u22F2':'disin','\\u22F3':'isinsv','\\u22F4':'isins','\\u22F5':'isindot','\\u22F5\\u0338':'notindot','\\u22F6':'notinvc','\\u22F7':'notinvb','\\u22F9':'isinE','\\u22F9\\u0338':'notinE','\\u22FA':'nisd','\\u22FB':'xnis','\\u22FC':'nis','\\u22FD':'notnivc','\\u22FE':'notnivb','\\u2305':'barwed','\\u2306':'Barwed','\\u230C':'drcrop','\\u230D':'dlcrop','\\u230E':'urcrop','\\u230F':'ulcrop','\\u2310':'bnot','\\u2312':'profline','\\u2313':'profsurf','\\u2315':'telrec','\\u2316':'target','\\u231C':'ulcorn','\\u231D':'urcorn','\\u231E':'dlcorn','\\u231F':'drcorn','\\u2322':'frown','\\u2323':'smile','\\u232D':'cylcty','\\u232E':'profalar','\\u2336':'topbot','\\u233D':'ovbar','\\u233F':'solbar','\\u237C':'angzarr','\\u23B0':'lmoust','\\u23B1':'rmoust','\\u23B4':'tbrk','\\u23B5':'bbrk','\\u23B6':'bbrktbrk','\\u23DC':'OverParenthesis','\\u23DD':'UnderParenthesis','\\u23DE':'OverBrace','\\u23DF':'UnderBrace','\\u23E2':'trpezium','\\u23E7':'elinters','\\u2423':'blank','\\u2500':'boxh','\\u2502':'boxv','\\u250C':'boxdr','\\u2510':'boxdl','\\u2514':'boxur','\\u2518':'boxul','\\u251C':'boxvr','\\u2524':'boxvl','\\u252C':'boxhd','\\u2534':'boxhu','\\u253C':'boxvh','\\u2550':'boxH','\\u2551':'boxV','\\u2552':'boxdR','\\u2553':'boxDr','\\u2554':'boxDR','\\u2555':'boxdL','\\u2556':'boxDl','\\u2557':'boxDL','\\u2558':'boxuR','\\u2559':'boxUr','\\u255A':'boxUR','\\u255B':'boxuL','\\u255C':'boxUl','\\u255D':'boxUL','\\u255E':'boxvR','\\u255F':'boxVr','\\u2560':'boxVR','\\u2561':'boxvL','\\u2562':'boxVl','\\u2563':'boxVL','\\u2564':'boxHd','\\u2565':'boxhD','\\u2566':'boxHD','\\u2567':'boxHu','\\u2568':'boxhU','\\u2569':'boxHU','\\u256A':'boxvH','\\u256B':'boxVh','\\u256C':'boxVH','\\u2580':'uhblk','\\u2584':'lhblk','\\u2588':'block','\\u2591':'blk14','\\u2592':'blk12','\\u2593':'blk34','\\u25A1':'squ','\\u25AA':'squf','\\u25AB':'EmptyVerySmallSquare','\\u25AD':'rect','\\u25AE':'marker','\\u25B1':'fltns','\\u25B3':'xutri','\\u25B4':'utrif','\\u25B5':'utri','\\u25B8':'rtrif','\\u25B9':'rtri','\\u25BD':'xdtri','\\u25BE':'dtrif','\\u25BF':'dtri','\\u25C2':'ltrif','\\u25C3':'ltri','\\u25CA':'loz','\\u25CB':'cir','\\u25EC':'tridot','\\u25EF':'xcirc','\\u25F8':'ultri','\\u25F9':'urtri','\\u25FA':'lltri','\\u25FB':'EmptySmallSquare','\\u25FC':'FilledSmallSquare','\\u2605':'starf','\\u2606':'star','\\u260E':'phone','\\u2640':'female','\\u2642':'male','\\u2660':'spades','\\u2663':'clubs','\\u2665':'hearts','\\u2666':'diams','\\u266A':'sung','\\u2713':'check','\\u2717':'cross','\\u2720':'malt','\\u2736':'sext','\\u2758':'VerticalSeparator','\\u27C8':'bsolhsub','\\u27C9':'suphsol','\\u27F5':'xlarr','\\u27F6':'xrarr','\\u27F7':'xharr','\\u27F8':'xlArr','\\u27F9':'xrArr','\\u27FA':'xhArr','\\u27FC':'xmap','\\u27FF':'dzigrarr','\\u2902':'nvlArr','\\u2903':'nvrArr','\\u2904':'nvHarr','\\u2905':'Map','\\u290C':'lbarr','\\u290D':'rbarr','\\u290E':'lBarr','\\u290F':'rBarr','\\u2910':'RBarr','\\u2911':'DDotrahd','\\u2912':'UpArrowBar','\\u2913':'DownArrowBar','\\u2916':'Rarrtl','\\u2919':'latail','\\u291A':'ratail','\\u291B':'lAtail','\\u291C':'rAtail','\\u291D':'larrfs','\\u291E':'rarrfs','\\u291F':'larrbfs','\\u2920':'rarrbfs','\\u2923':'nwarhk','\\u2924':'nearhk','\\u2925':'searhk','\\u2926':'swarhk','\\u2927':'nwnear','\\u2928':'toea','\\u2929':'tosa','\\u292A':'swnwar','\\u2933':'rarrc','\\u2933\\u0338':'nrarrc','\\u2935':'cudarrr','\\u2936':'ldca','\\u2937':'rdca','\\u2938':'cudarrl','\\u2939':'larrpl','\\u293C':'curarrm','\\u293D':'cularrp','\\u2945':'rarrpl','\\u2948':'harrcir','\\u2949':'Uarrocir','\\u294A':'lurdshar','\\u294B':'ldrushar','\\u294E':'LeftRightVector','\\u294F':'RightUpDownVector','\\u2950':'DownLeftRightVector','\\u2951':'LeftUpDownVector','\\u2952':'LeftVectorBar','\\u2953':'RightVectorBar','\\u2954':'RightUpVectorBar','\\u2955':'RightDownVectorBar','\\u2956':'DownLeftVectorBar','\\u2957':'DownRightVectorBar','\\u2958':'LeftUpVectorBar','\\u2959':'LeftDownVectorBar','\\u295A':'LeftTeeVector','\\u295B':'RightTeeVector','\\u295C':'RightUpTeeVector','\\u295D':'RightDownTeeVector','\\u295E':'DownLeftTeeVector','\\u295F':'DownRightTeeVector','\\u2960':'LeftUpTeeVector','\\u2961':'LeftDownTeeVector','\\u2962':'lHar','\\u2963':'uHar','\\u2964':'rHar','\\u2965':'dHar','\\u2966':'luruhar','\\u2967':'ldrdhar','\\u2968':'ruluhar','\\u2969':'rdldhar','\\u296A':'lharul','\\u296B':'llhard','\\u296C':'rharul','\\u296D':'lrhard','\\u296E':'udhar','\\u296F':'duhar','\\u2970':'RoundImplies','\\u2971':'erarr','\\u2972':'simrarr','\\u2973':'larrsim','\\u2974':'rarrsim','\\u2975':'rarrap','\\u2976':'ltlarr','\\u2978':'gtrarr','\\u2979':'subrarr','\\u297B':'suplarr','\\u297C':'lfisht','\\u297D':'rfisht','\\u297E':'ufisht','\\u297F':'dfisht','\\u299A':'vzigzag','\\u299C':'vangrt','\\u299D':'angrtvbd','\\u29A4':'ange','\\u29A5':'range','\\u29A6':'dwangle','\\u29A7':'uwangle','\\u29A8':'angmsdaa','\\u29A9':'angmsdab','\\u29AA':'angmsdac','\\u29AB':'angmsdad','\\u29AC':'angmsdae','\\u29AD':'angmsdaf','\\u29AE':'angmsdag','\\u29AF':'angmsdah','\\u29B0':'bemptyv','\\u29B1':'demptyv','\\u29B2':'cemptyv','\\u29B3':'raemptyv','\\u29B4':'laemptyv','\\u29B5':'ohbar','\\u29B6':'omid','\\u29B7':'opar','\\u29B9':'operp','\\u29BB':'olcross','\\u29BC':'odsold','\\u29BE':'olcir','\\u29BF':'ofcir','\\u29C0':'olt','\\u29C1':'ogt','\\u29C2':'cirscir','\\u29C3':'cirE','\\u29C4':'solb','\\u29C5':'bsolb','\\u29C9':'boxbox','\\u29CD':'trisb','\\u29CE':'rtriltri','\\u29CF':'LeftTriangleBar','\\u29CF\\u0338':'NotLeftTriangleBar','\\u29D0':'RightTriangleBar','\\u29D0\\u0338':'NotRightTriangleBar','\\u29DC':'iinfin','\\u29DD':'infintie','\\u29DE':'nvinfin','\\u29E3':'eparsl','\\u29E4':'smeparsl','\\u29E5':'eqvparsl','\\u29EB':'lozf','\\u29F4':'RuleDelayed','\\u29F6':'dsol','\\u2A00':'xodot','\\u2A01':'xoplus','\\u2A02':'xotime','\\u2A04':'xuplus','\\u2A06':'xsqcup','\\u2A0D':'fpartint','\\u2A10':'cirfnint','\\u2A11':'awint','\\u2A12':'rppolint','\\u2A13':'scpolint','\\u2A14':'npolint','\\u2A15':'pointint','\\u2A16':'quatint','\\u2A17':'intlarhk','\\u2A22':'pluscir','\\u2A23':'plusacir','\\u2A24':'simplus','\\u2A25':'plusdu','\\u2A26':'plussim','\\u2A27':'plustwo','\\u2A29':'mcomma','\\u2A2A':'minusdu','\\u2A2D':'loplus','\\u2A2E':'roplus','\\u2A2F':'Cross','\\u2A30':'timesd','\\u2A31':'timesbar','\\u2A33':'smashp','\\u2A34':'lotimes','\\u2A35':'rotimes','\\u2A36':'otimesas','\\u2A37':'Otimes','\\u2A38':'odiv','\\u2A39':'triplus','\\u2A3A':'triminus','\\u2A3B':'tritime','\\u2A3C':'iprod','\\u2A3F':'amalg','\\u2A40':'capdot','\\u2A42':'ncup','\\u2A43':'ncap','\\u2A44':'capand','\\u2A45':'cupor','\\u2A46':'cupcap','\\u2A47':'capcup','\\u2A48':'cupbrcap','\\u2A49':'capbrcup','\\u2A4A':'cupcup','\\u2A4B':'capcap','\\u2A4C':'ccups','\\u2A4D':'ccaps','\\u2A50':'ccupssm','\\u2A53':'And','\\u2A54':'Or','\\u2A55':'andand','\\u2A56':'oror','\\u2A57':'orslope','\\u2A58':'andslope','\\u2A5A':'andv','\\u2A5B':'orv','\\u2A5C':'andd','\\u2A5D':'ord','\\u2A5F':'wedbar','\\u2A66':'sdote','\\u2A6A':'simdot','\\u2A6D':'congdot','\\u2A6D\\u0338':'ncongdot','\\u2A6E':'easter','\\u2A6F':'apacir','\\u2A70':'apE','\\u2A70\\u0338':'napE','\\u2A71':'eplus','\\u2A72':'pluse','\\u2A73':'Esim','\\u2A77':'eDDot','\\u2A78':'equivDD','\\u2A79':'ltcir','\\u2A7A':'gtcir','\\u2A7B':'ltquest','\\u2A7C':'gtquest','\\u2A7D':'les','\\u2A7D\\u0338':'nles','\\u2A7E':'ges','\\u2A7E\\u0338':'nges','\\u2A7F':'lesdot','\\u2A80':'gesdot','\\u2A81':'lesdoto','\\u2A82':'gesdoto','\\u2A83':'lesdotor','\\u2A84':'gesdotol','\\u2A85':'lap','\\u2A86':'gap','\\u2A87':'lne','\\u2A88':'gne','\\u2A89':'lnap','\\u2A8A':'gnap','\\u2A8B':'lEg','\\u2A8C':'gEl','\\u2A8D':'lsime','\\u2A8E':'gsime','\\u2A8F':'lsimg','\\u2A90':'gsiml','\\u2A91':'lgE','\\u2A92':'glE','\\u2A93':'lesges','\\u2A94':'gesles','\\u2A95':'els','\\u2A96':'egs','\\u2A97':'elsdot','\\u2A98':'egsdot','\\u2A99':'el','\\u2A9A':'eg','\\u2A9D':'siml','\\u2A9E':'simg','\\u2A9F':'simlE','\\u2AA0':'simgE','\\u2AA1':'LessLess','\\u2AA1\\u0338':'NotNestedLessLess','\\u2AA2':'GreaterGreater','\\u2AA2\\u0338':'NotNestedGreaterGreater','\\u2AA4':'glj','\\u2AA5':'gla','\\u2AA6':'ltcc','\\u2AA7':'gtcc','\\u2AA8':'lescc','\\u2AA9':'gescc','\\u2AAA':'smt','\\u2AAB':'lat','\\u2AAC':'smte','\\u2AAC\\uFE00':'smtes','\\u2AAD':'late','\\u2AAD\\uFE00':'lates','\\u2AAE':'bumpE','\\u2AAF':'pre','\\u2AAF\\u0338':'npre','\\u2AB0':'sce','\\u2AB0\\u0338':'nsce','\\u2AB3':'prE','\\u2AB4':'scE','\\u2AB5':'prnE','\\u2AB6':'scnE','\\u2AB7':'prap','\\u2AB8':'scap','\\u2AB9':'prnap','\\u2ABA':'scnap','\\u2ABB':'Pr','\\u2ABC':'Sc','\\u2ABD':'subdot','\\u2ABE':'supdot','\\u2ABF':'subplus','\\u2AC0':'supplus','\\u2AC1':'submult','\\u2AC2':'supmult','\\u2AC3':'subedot','\\u2AC4':'supedot','\\u2AC5':'subE','\\u2AC5\\u0338':'nsubE','\\u2AC6':'supE','\\u2AC6\\u0338':'nsupE','\\u2AC7':'subsim','\\u2AC8':'supsim','\\u2ACB\\uFE00':'vsubnE','\\u2ACB':'subnE','\\u2ACC\\uFE00':'vsupnE','\\u2ACC':'supnE','\\u2ACF':'csub','\\u2AD0':'csup','\\u2AD1':'csube','\\u2AD2':'csupe','\\u2AD3':'subsup','\\u2AD4':'supsub','\\u2AD5':'subsub','\\u2AD6':'supsup','\\u2AD7':'suphsub','\\u2AD8':'supdsub','\\u2AD9':'forkv','\\u2ADA':'topfork','\\u2ADB':'mlcp','\\u2AE4':'Dashv','\\u2AE6':'Vdashl','\\u2AE7':'Barv','\\u2AE8':'vBar','\\u2AE9':'vBarv','\\u2AEB':'Vbar','\\u2AEC':'Not','\\u2AED':'bNot','\\u2AEE':'rnmid','\\u2AEF':'cirmid','\\u2AF0':'midcir','\\u2AF1':'topcir','\\u2AF2':'nhpar','\\u2AF3':'parsim','\\u2AFD':'parsl','\\u2AFD\\u20E5':'nparsl','\\u266D':'flat','\\u266E':'natur','\\u266F':'sharp','\\xA4':'curren','\\xA2':'cent','$':'dollar','\\xA3':'pound','\\xA5':'yen','\\u20AC':'euro','\\xB9':'sup1','\\xBD':'half','\\u2153':'frac13','\\xBC':'frac14','\\u2155':'frac15','\\u2159':'frac16','\\u215B':'frac18','\\xB2':'sup2','\\u2154':'frac23','\\u2156':'frac25','\\xB3':'sup3','\\xBE':'frac34','\\u2157':'frac35','\\u215C':'frac38','\\u2158':'frac45','\\u215A':'frac56','\\u215D':'frac58','\\u215E':'frac78','\\uD835\\uDCB6':'ascr','\\uD835\\uDD52':'aopf','\\uD835\\uDD1E':'afr','\\uD835\\uDD38':'Aopf','\\uD835\\uDD04':'Afr','\\uD835\\uDC9C':'Ascr','\\xAA':'ordf','\\xE1':'aacute','\\xC1':'Aacute','\\xE0':'agrave','\\xC0':'Agrave','\\u0103':'abreve','\\u0102':'Abreve','\\xE2':'acirc','\\xC2':'Acirc','\\xE5':'aring','\\xC5':'angst','\\xE4':'auml','\\xC4':'Auml','\\xE3':'atilde','\\xC3':'Atilde','\\u0105':'aogon','\\u0104':'Aogon','\\u0101':'amacr','\\u0100':'Amacr','\\xE6':'aelig','\\xC6':'AElig','\\uD835\\uDCB7':'bscr','\\uD835\\uDD53':'bopf','\\uD835\\uDD1F':'bfr','\\uD835\\uDD39':'Bopf','\\u212C':'Bscr','\\uD835\\uDD05':'Bfr','\\uD835\\uDD20':'cfr','\\uD835\\uDCB8':'cscr','\\uD835\\uDD54':'copf','\\u212D':'Cfr','\\uD835\\uDC9E':'Cscr','\\u2102':'Copf','\\u0107':'cacute','\\u0106':'Cacute','\\u0109':'ccirc','\\u0108':'Ccirc','\\u010D':'ccaron','\\u010C':'Ccaron','\\u010B':'cdot','\\u010A':'Cdot','\\xE7':'ccedil','\\xC7':'Ccedil','\\u2105':'incare','\\uD835\\uDD21':'dfr','\\u2146':'dd','\\uD835\\uDD55':'dopf','\\uD835\\uDCB9':'dscr','\\uD835\\uDC9F':'Dscr','\\uD835\\uDD07':'Dfr','\\u2145':'DD','\\uD835\\uDD3B':'Dopf','\\u010F':'dcaron','\\u010E':'Dcaron','\\u0111':'dstrok','\\u0110':'Dstrok','\\xF0':'eth','\\xD0':'ETH','\\u2147':'ee','\\u212F':'escr','\\uD835\\uDD22':'efr','\\uD835\\uDD56':'eopf','\\u2130':'Escr','\\uD835\\uDD08':'Efr','\\uD835\\uDD3C':'Eopf','\\xE9':'eacute','\\xC9':'Eacute','\\xE8':'egrave','\\xC8':'Egrave','\\xEA':'ecirc','\\xCA':'Ecirc','\\u011B':'ecaron','\\u011A':'Ecaron','\\xEB':'euml','\\xCB':'Euml','\\u0117':'edot','\\u0116':'Edot','\\u0119':'eogon','\\u0118':'Eogon','\\u0113':'emacr','\\u0112':'Emacr','\\uD835\\uDD23':'ffr','\\uD835\\uDD57':'fopf','\\uD835\\uDCBB':'fscr','\\uD835\\uDD09':'Ffr','\\uD835\\uDD3D':'Fopf','\\u2131':'Fscr','\\uFB00':'fflig','\\uFB03':'ffilig','\\uFB04':'ffllig','\\uFB01':'filig','fj':'fjlig','\\uFB02':'fllig','\\u0192':'fnof','\\u210A':'gscr','\\uD835\\uDD58':'gopf','\\uD835\\uDD24':'gfr','\\uD835\\uDCA2':'Gscr','\\uD835\\uDD3E':'Gopf','\\uD835\\uDD0A':'Gfr','\\u01F5':'gacute','\\u011F':'gbreve','\\u011E':'Gbreve','\\u011D':'gcirc','\\u011C':'Gcirc','\\u0121':'gdot','\\u0120':'Gdot','\\u0122':'Gcedil','\\uD835\\uDD25':'hfr','\\u210E':'planckh','\\uD835\\uDCBD':'hscr','\\uD835\\uDD59':'hopf','\\u210B':'Hscr','\\u210C':'Hfr','\\u210D':'Hopf','\\u0125':'hcirc','\\u0124':'Hcirc','\\u210F':'hbar','\\u0127':'hstrok','\\u0126':'Hstrok','\\uD835\\uDD5A':'iopf','\\uD835\\uDD26':'ifr','\\uD835\\uDCBE':'iscr','\\u2148':'ii','\\uD835\\uDD40':'Iopf','\\u2110':'Iscr','\\u2111':'Im','\\xED':'iacute','\\xCD':'Iacute','\\xEC':'igrave','\\xCC':'Igrave','\\xEE':'icirc','\\xCE':'Icirc','\\xEF':'iuml','\\xCF':'Iuml','\\u0129':'itilde','\\u0128':'Itilde','\\u0130':'Idot','\\u012F':'iogon','\\u012E':'Iogon','\\u012B':'imacr','\\u012A':'Imacr','\\u0133':'ijlig','\\u0132':'IJlig','\\u0131':'imath','\\uD835\\uDCBF':'jscr','\\uD835\\uDD5B':'jopf','\\uD835\\uDD27':'jfr','\\uD835\\uDCA5':'Jscr','\\uD835\\uDD0D':'Jfr','\\uD835\\uDD41':'Jopf','\\u0135':'jcirc','\\u0134':'Jcirc','\\u0237':'jmath','\\uD835\\uDD5C':'kopf','\\uD835\\uDCC0':'kscr','\\uD835\\uDD28':'kfr','\\uD835\\uDCA6':'Kscr','\\uD835\\uDD42':'Kopf','\\uD835\\uDD0E':'Kfr','\\u0137':'kcedil','\\u0136':'Kcedil','\\uD835\\uDD29':'lfr','\\uD835\\uDCC1':'lscr','\\u2113':'ell','\\uD835\\uDD5D':'lopf','\\u2112':'Lscr','\\uD835\\uDD0F':'Lfr','\\uD835\\uDD43':'Lopf','\\u013A':'lacute','\\u0139':'Lacute','\\u013E':'lcaron','\\u013D':'Lcaron','\\u013C':'lcedil','\\u013B':'Lcedil','\\u0142':'lstrok','\\u0141':'Lstrok','\\u0140':'lmidot','\\u013F':'Lmidot','\\uD835\\uDD2A':'mfr','\\uD835\\uDD5E':'mopf','\\uD835\\uDCC2':'mscr','\\uD835\\uDD10':'Mfr','\\uD835\\uDD44':'Mopf','\\u2133':'Mscr','\\uD835\\uDD2B':'nfr','\\uD835\\uDD5F':'nopf','\\uD835\\uDCC3':'nscr','\\u2115':'Nopf','\\uD835\\uDCA9':'Nscr','\\uD835\\uDD11':'Nfr','\\u0144':'nacute','\\u0143':'Nacute','\\u0148':'ncaron','\\u0147':'Ncaron','\\xF1':'ntilde','\\xD1':'Ntilde','\\u0146':'ncedil','\\u0145':'Ncedil','\\u2116':'numero','\\u014B':'eng','\\u014A':'ENG','\\uD835\\uDD60':'oopf','\\uD835\\uDD2C':'ofr','\\u2134':'oscr','\\uD835\\uDCAA':'Oscr','\\uD835\\uDD12':'Ofr','\\uD835\\uDD46':'Oopf','\\xBA':'ordm','\\xF3':'oacute','\\xD3':'Oacute','\\xF2':'ograve','\\xD2':'Ograve','\\xF4':'ocirc','\\xD4':'Ocirc','\\xF6':'ouml','\\xD6':'Ouml','\\u0151':'odblac','\\u0150':'Odblac','\\xF5':'otilde','\\xD5':'Otilde','\\xF8':'oslash','\\xD8':'Oslash','\\u014D':'omacr','\\u014C':'Omacr','\\u0153':'oelig','\\u0152':'OElig','\\uD835\\uDD2D':'pfr','\\uD835\\uDCC5':'pscr','\\uD835\\uDD61':'popf','\\u2119':'Popf','\\uD835\\uDD13':'Pfr','\\uD835\\uDCAB':'Pscr','\\uD835\\uDD62':'qopf','\\uD835\\uDD2E':'qfr','\\uD835\\uDCC6':'qscr','\\uD835\\uDCAC':'Qscr','\\uD835\\uDD14':'Qfr','\\u211A':'Qopf','\\u0138':'kgreen','\\uD835\\uDD2F':'rfr','\\uD835\\uDD63':'ropf','\\uD835\\uDCC7':'rscr','\\u211B':'Rscr','\\u211C':'Re','\\u211D':'Ropf','\\u0155':'racute','\\u0154':'Racute','\\u0159':'rcaron','\\u0158':'Rcaron','\\u0157':'rcedil','\\u0156':'Rcedil','\\uD835\\uDD64':'sopf','\\uD835\\uDCC8':'sscr','\\uD835\\uDD30':'sfr','\\uD835\\uDD4A':'Sopf','\\uD835\\uDD16':'Sfr','\\uD835\\uDCAE':'Sscr','\\u24C8':'oS','\\u015B':'sacute','\\u015A':'Sacute','\\u015D':'scirc','\\u015C':'Scirc','\\u0161':'scaron','\\u0160':'Scaron','\\u015F':'scedil','\\u015E':'Scedil','\\xDF':'szlig','\\uD835\\uDD31':'tfr','\\uD835\\uDCC9':'tscr','\\uD835\\uDD65':'topf','\\uD835\\uDCAF':'Tscr','\\uD835\\uDD17':'Tfr','\\uD835\\uDD4B':'Topf','\\u0165':'tcaron','\\u0164':'Tcaron','\\u0163':'tcedil','\\u0162':'Tcedil','\\u2122':'trade','\\u0167':'tstrok','\\u0166':'Tstrok','\\uD835\\uDCCA':'uscr','\\uD835\\uDD66':'uopf','\\uD835\\uDD32':'ufr','\\uD835\\uDD4C':'Uopf','\\uD835\\uDD18':'Ufr','\\uD835\\uDCB0':'Uscr','\\xFA':'uacute','\\xDA':'Uacute','\\xF9':'ugrave','\\xD9':'Ugrave','\\u016D':'ubreve','\\u016C':'Ubreve','\\xFB':'ucirc','\\xDB':'Ucirc','\\u016F':'uring','\\u016E':'Uring','\\xFC':'uuml','\\xDC':'Uuml','\\u0171':'udblac','\\u0170':'Udblac','\\u0169':'utilde','\\u0168':'Utilde','\\u0173':'uogon','\\u0172':'Uogon','\\u016B':'umacr','\\u016A':'Umacr','\\uD835\\uDD33':'vfr','\\uD835\\uDD67':'vopf','\\uD835\\uDCCB':'vscr','\\uD835\\uDD19':'Vfr','\\uD835\\uDD4D':'Vopf','\\uD835\\uDCB1':'Vscr','\\uD835\\uDD68':'wopf','\\uD835\\uDCCC':'wscr','\\uD835\\uDD34':'wfr','\\uD835\\uDCB2':'Wscr','\\uD835\\uDD4E':'Wopf','\\uD835\\uDD1A':'Wfr','\\u0175':'wcirc','\\u0174':'Wcirc','\\uD835\\uDD35':'xfr','\\uD835\\uDCCD':'xscr','\\uD835\\uDD69':'xopf','\\uD835\\uDD4F':'Xopf','\\uD835\\uDD1B':'Xfr','\\uD835\\uDCB3':'Xscr','\\uD835\\uDD36':'yfr','\\uD835\\uDCCE':'yscr','\\uD835\\uDD6A':'yopf','\\uD835\\uDCB4':'Yscr','\\uD835\\uDD1C':'Yfr','\\uD835\\uDD50':'Yopf','\\xFD':'yacute','\\xDD':'Yacute','\\u0177':'ycirc','\\u0176':'Ycirc','\\xFF':'yuml','\\u0178':'Yuml','\\uD835\\uDCCF':'zscr','\\uD835\\uDD37':'zfr','\\uD835\\uDD6B':'zopf','\\u2128':'Zfr','\\u2124':'Zopf','\\uD835\\uDCB5':'Zscr','\\u017A':'zacute','\\u0179':'Zacute','\\u017E':'zcaron','\\u017D':'Zcaron','\\u017C':'zdot','\\u017B':'Zdot','\\u01B5':'imped','\\xFE':'thorn','\\xDE':'THORN','\\u0149':'napos','\\u03B1':'alpha','\\u0391':'Alpha','\\u03B2':'beta','\\u0392':'Beta','\\u03B3':'gamma','\\u0393':'Gamma','\\u03B4':'delta','\\u0394':'Delta','\\u03B5':'epsi','\\u03F5':'epsiv','\\u0395':'Epsilon','\\u03DD':'gammad','\\u03DC':'Gammad','\\u03B6':'zeta','\\u0396':'Zeta','\\u03B7':'eta','\\u0397':'Eta','\\u03B8':'theta','\\u03D1':'thetav','\\u0398':'Theta','\\u03B9':'iota','\\u0399':'Iota','\\u03BA':'kappa','\\u03F0':'kappav','\\u039A':'Kappa','\\u03BB':'lambda','\\u039B':'Lambda','\\u03BC':'mu','\\xB5':'micro','\\u039C':'Mu','\\u03BD':'nu','\\u039D':'Nu','\\u03BE':'xi','\\u039E':'Xi','\\u03BF':'omicron','\\u039F':'Omicron','\\u03C0':'pi','\\u03D6':'piv','\\u03A0':'Pi','\\u03C1':'rho','\\u03F1':'rhov','\\u03A1':'Rho','\\u03C3':'sigma','\\u03A3':'Sigma','\\u03C2':'sigmaf','\\u03C4':'tau','\\u03A4':'Tau','\\u03C5':'upsi','\\u03A5':'Upsilon','\\u03D2':'Upsi','\\u03C6':'phi','\\u03D5':'phiv','\\u03A6':'Phi','\\u03C7':'chi','\\u03A7':'Chi','\\u03C8':'psi','\\u03A8':'Psi','\\u03C9':'omega','\\u03A9':'ohm','\\u0430':'acy','\\u0410':'Acy','\\u0431':'bcy','\\u0411':'Bcy','\\u0432':'vcy','\\u0412':'Vcy','\\u0433':'gcy','\\u0413':'Gcy','\\u0453':'gjcy','\\u0403':'GJcy','\\u0434':'dcy','\\u0414':'Dcy','\\u0452':'djcy','\\u0402':'DJcy','\\u0435':'iecy','\\u0415':'IEcy','\\u0451':'iocy','\\u0401':'IOcy','\\u0454':'jukcy','\\u0404':'Jukcy','\\u0436':'zhcy','\\u0416':'ZHcy','\\u0437':'zcy','\\u0417':'Zcy','\\u0455':'dscy','\\u0405':'DScy','\\u0438':'icy','\\u0418':'Icy','\\u0456':'iukcy','\\u0406':'Iukcy','\\u0457':'yicy','\\u0407':'YIcy','\\u0439':'jcy','\\u0419':'Jcy','\\u0458':'jsercy','\\u0408':'Jsercy','\\u043A':'kcy','\\u041A':'Kcy','\\u045C':'kjcy','\\u040C':'KJcy','\\u043B':'lcy','\\u041B':'Lcy','\\u0459':'ljcy','\\u0409':'LJcy','\\u043C':'mcy','\\u041C':'Mcy','\\u043D':'ncy','\\u041D':'Ncy','\\u045A':'njcy','\\u040A':'NJcy','\\u043E':'ocy','\\u041E':'Ocy','\\u043F':'pcy','\\u041F':'Pcy','\\u0440':'rcy','\\u0420':'Rcy','\\u0441':'scy','\\u0421':'Scy','\\u0442':'tcy','\\u0422':'Tcy','\\u045B':'tshcy','\\u040B':'TSHcy','\\u0443':'ucy','\\u0423':'Ucy','\\u045E':'ubrcy','\\u040E':'Ubrcy','\\u0444':'fcy','\\u0424':'Fcy','\\u0445':'khcy','\\u0425':'KHcy','\\u0446':'tscy','\\u0426':'TScy','\\u0447':'chcy','\\u0427':'CHcy','\\u045F':'dzcy','\\u040F':'DZcy','\\u0448':'shcy','\\u0428':'SHcy','\\u0449':'shchcy','\\u0429':'SHCHcy','\\u044A':'hardcy','\\u042A':'HARDcy','\\u044B':'ycy','\\u042B':'Ycy','\\u044C':'softcy','\\u042C':'SOFTcy','\\u044D':'ecy','\\u042D':'Ecy','\\u044E':'yucy','\\u042E':'YUcy','\\u044F':'yacy','\\u042F':'YAcy','\\u2135':'aleph','\\u2136':'beth','\\u2137':'gimel','\\u2138':'daleth'};\r\n\r\n\tvar regexEscape = /[\"&'<>`]/g;\r\n\tvar escapeMap = {\r\n\t\t'\"': '&quot;',\r\n\t\t'&': '&amp;',\r\n\t\t'\\'': '&#x27;',\r\n\t\t'<': '&lt;',\r\n\t\t// See https://mathiasbynens.be/notes/ambiguous-ampersands: in HTML, the\r\n\t\t// following is not strictly necessary unless its part of a tag or an\r\n\t\t// unquoted attribute value. Were only escaping it to support those\r\n\t\t// situations, and for XML support.\r\n\t\t'>': '&gt;',\r\n\t\t// In Internet Explorer  8, the backtick character can be used\r\n\t\t// to break out of (un)quoted attribute values or HTML comments.\r\n\t\t// See http://html5sec.org/#102, http://html5sec.org/#108, and\r\n\t\t// http://html5sec.org/#133.\r\n\t\t'`': '&#x60;'\r\n\t};\r\n\r\n\tvar regexInvalidEntity = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/;\r\n\tvar regexInvalidRawCodePoint = /[\\0-\\x08\\x0B\\x0E-\\x1F\\x7F-\\x9F\\uFDD0-\\uFDEF\\uFFFE\\uFFFF]|[\\uD83F\\uD87F\\uD8BF\\uD8FF\\uD93F\\uD97F\\uD9BF\\uD9FF\\uDA3F\\uDA7F\\uDABF\\uDAFF\\uDB3F\\uDB7F\\uDBBF\\uDBFF][\\uDFFE\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\r\n\tvar regexDecode = /&(CounterClockwiseContourIntegral|DoubleLongLeftRightArrow|ClockwiseContourIntegral|NotNestedGreaterGreater|NotSquareSupersetEqual|DiacriticalDoubleAcute|NotRightTriangleEqual|NotSucceedsSlantEqual|NotPrecedesSlantEqual|CloseCurlyDoubleQuote|NegativeVeryThinSpace|DoubleContourIntegral|FilledVerySmallSquare|CapitalDifferentialD|OpenCurlyDoubleQuote|EmptyVerySmallSquare|NestedGreaterGreater|DoubleLongRightArrow|NotLeftTriangleEqual|NotGreaterSlantEqual|ReverseUpEquilibrium|DoubleLeftRightArrow|NotSquareSubsetEqual|NotDoubleVerticalBar|RightArrowLeftArrow|NotGreaterFullEqual|NotRightTriangleBar|SquareSupersetEqual|DownLeftRightVector|DoubleLongLeftArrow|leftrightsquigarrow|LeftArrowRightArrow|NegativeMediumSpace|blacktriangleright|RightDownVectorBar|PrecedesSlantEqual|RightDoubleBracket|SucceedsSlantEqual|NotLeftTriangleBar|RightTriangleEqual|SquareIntersection|RightDownTeeVector|ReverseEquilibrium|NegativeThickSpace|longleftrightarrow|Longleftrightarrow|LongLeftRightArrow|DownRightTeeVector|DownRightVectorBar|GreaterSlantEqual|SquareSubsetEqual|LeftDownVectorBar|LeftDoubleBracket|VerticalSeparator|rightleftharpoons|NotGreaterGreater|NotSquareSuperset|blacktriangleleft|blacktriangledown|NegativeThinSpace|LeftDownTeeVector|NotLessSlantEqual|leftrightharpoons|DoubleUpDownArrow|DoubleVerticalBar|LeftTriangleEqual|FilledSmallSquare|twoheadrightarrow|NotNestedLessLess|DownLeftTeeVector|DownLeftVectorBar|RightAngleBracket|NotTildeFullEqual|NotReverseElement|RightUpDownVector|DiacriticalTilde|NotSucceedsTilde|circlearrowright|NotPrecedesEqual|rightharpoondown|DoubleRightArrow|NotSucceedsEqual|NonBreakingSpace|NotRightTriangle|LessEqualGreater|RightUpTeeVector|LeftAngleBracket|GreaterFullEqual|DownArrowUpArrow|RightUpVectorBar|twoheadleftarrow|GreaterEqualLess|downharpoonright|RightTriangleBar|ntrianglerighteq|NotSupersetEqual|LeftUpDownVector|DiacriticalAcute|rightrightarrows|vartriangleright|UpArrowDownArrow|DiacriticalGrave|UnderParenthesis|EmptySmallSquare|LeftUpVectorBar|leftrightarrows|DownRightVector|downharpoonleft|trianglerighteq|ShortRightArrow|OverParenthesis|DoubleLeftArrow|DoubleDownArrow|NotSquareSubset|bigtriangledown|ntrianglelefteq|UpperRightArrow|curvearrowright|vartriangleleft|NotLeftTriangle|nleftrightarrow|LowerRightArrow|NotHumpDownHump|NotGreaterTilde|rightthreetimes|LeftUpTeeVector|NotGreaterEqual|straightepsilon|LeftTriangleBar|rightsquigarrow|ContourIntegral|rightleftarrows|CloseCurlyQuote|RightDownVector|LeftRightVector|nLeftrightarrow|leftharpoondown|circlearrowleft|SquareSuperset|OpenCurlyQuote|hookrightarrow|HorizontalLine|DiacriticalDot|NotLessGreater|ntriangleright|DoubleRightTee|InvisibleComma|InvisibleTimes|LowerLeftArrow|DownLeftVector|NotSubsetEqual|curvearrowleft|trianglelefteq|NotVerticalBar|TildeFullEqual|downdownarrows|NotGreaterLess|RightTeeVector|ZeroWidthSpace|looparrowright|LongRightArrow|doublebarwedge|ShortLeftArrow|ShortDownArrow|RightVectorBar|GreaterGreater|ReverseElement|rightharpoonup|LessSlantEqual|leftthreetimes|upharpoonright|rightarrowtail|LeftDownVector|Longrightarrow|NestedLessLess|UpperLeftArrow|nshortparallel|leftleftarrows|leftrightarrow|Leftrightarrow|LeftRightArrow|longrightarrow|upharpoonleft|RightArrowBar|ApplyFunction|LeftTeeVector|leftarrowtail|NotEqualTilde|varsubsetneqq|varsupsetneqq|RightTeeArrow|SucceedsEqual|SucceedsTilde|LeftVectorBar|SupersetEqual|hookleftarrow|DifferentialD|VerticalTilde|VeryThinSpace|blacktriangle|bigtriangleup|LessFullEqual|divideontimes|leftharpoonup|UpEquilibrium|ntriangleleft|RightTriangle|measuredangle|shortparallel|longleftarrow|Longleftarrow|LongLeftArrow|DoubleLeftTee|Poincareplane|PrecedesEqual|triangleright|DoubleUpArrow|RightUpVector|fallingdotseq|looparrowleft|PrecedesTilde|NotTildeEqual|NotTildeTilde|smallsetminus|Proportional|triangleleft|triangledown|UnderBracket|NotHumpEqual|exponentiale|ExponentialE|NotLessTilde|HilbertSpace|RightCeiling|blacklozenge|varsupsetneq|HumpDownHump|GreaterEqual|VerticalLine|LeftTeeArrow|NotLessEqual|DownTeeArrow|LeftTriangle|varsubsetneq|Intersection|NotCongruent|DownArrowBar|LeftUpVector|LeftArrowBar|risingdotseq|GreaterTilde|RoundImplies|SquareSubset|ShortUpArrow|NotSuperset|quaternions|precnapprox|backepsilon|preccurlyeq|OverBracket|blacksquare|MediumSpace|VerticalBar|circledcirc|circleddash|CircleMinus|CircleTimes|LessGreater|curlyeqprec|curlyeqsucc|diamondsuit|UpDownArrow|Updownarrow|RuleDelayed|Rrightarrow|updownarrow|RightVector|nRightarrow|nrightarrow|eqslantless|LeftCeiling|Equilibrium|SmallCircle|expectation|NotSucceeds|thickapprox|GreaterLess|SquareUnion|NotPrecedes|NotLessLess|straightphi|succnapprox|succcurlyeq|SubsetEqual|sqsupseteq|Proportion|Laplacetrf|ImaginaryI|supsetneqq|NotGreater|gtreqqless|NotElement|ThickSpace|TildeEqual|TildeTilde|Fouriertrf|rmoustache|EqualTilde|eqslantgtr|UnderBrace|LeftVector|UpArrowBar|nLeftarrow|nsubseteqq|subsetneqq|nsupseteqq|nleftarrow|succapprox|lessapprox|UpTeeArrow|upuparrows|curlywedge|lesseqqgtr|varepsilon|varnothing|RightFloor|complement|CirclePlus|sqsubseteq|Lleftarrow|circledast|RightArrow|Rightarrow|rightarrow|lmoustache|Bernoullis|precapprox|mapstoleft|mapstodown|longmapsto|dotsquare|downarrow|DoubleDot|nsubseteq|supsetneq|leftarrow|nsupseteq|subsetneq|ThinSpace|ngeqslant|subseteqq|HumpEqual|NotSubset|triangleq|NotCupCap|lesseqgtr|heartsuit|TripleDot|Leftarrow|Coproduct|Congruent|varpropto|complexes|gvertneqq|LeftArrow|LessTilde|supseteqq|MinusPlus|CircleDot|nleqslant|NotExists|gtreqless|nparallel|UnionPlus|LeftFloor|checkmark|CenterDot|centerdot|Mellintrf|gtrapprox|bigotimes|OverBrace|spadesuit|therefore|pitchfork|rationals|PlusMinus|Backslash|Therefore|DownBreve|backsimeq|backprime|DownArrow|nshortmid|Downarrow|lvertneqq|eqvparsl|imagline|imagpart|infintie|integers|Integral|intercal|LessLess|Uarrocir|intlarhk|sqsupset|angmsdaf|sqsubset|llcorner|vartheta|cupbrcap|lnapprox|Superset|SuchThat|succnsim|succneqq|angmsdag|biguplus|curlyvee|trpezium|Succeeds|NotTilde|bigwedge|angmsdah|angrtvbd|triminus|cwconint|fpartint|lrcorner|smeparsl|subseteq|urcorner|lurdshar|laemptyv|DDotrahd|approxeq|ldrushar|awconint|mapstoup|backcong|shortmid|triangle|geqslant|gesdotol|timesbar|circledR|circledS|setminus|multimap|naturals|scpolint|ncongdot|RightTee|boxminus|gnapprox|boxtimes|andslope|thicksim|angmsdaa|varsigma|cirfnint|rtriltri|angmsdab|rppolint|angmsdac|barwedge|drbkarow|clubsuit|thetasym|bsolhsub|capbrcup|dzigrarr|doteqdot|DotEqual|dotminus|UnderBar|NotEqual|realpart|otimesas|ulcorner|hksearow|hkswarow|parallel|PartialD|elinters|emptyset|plusacir|bbrktbrk|angmsdad|pointint|bigoplus|angmsdae|Precedes|bigsqcup|varkappa|notindot|supseteq|precneqq|precnsim|profalar|profline|profsurf|leqslant|lesdotor|raemptyv|subplus|notnivb|notnivc|subrarr|zigrarr|vzigzag|submult|subedot|Element|between|cirscir|larrbfs|larrsim|lotimes|lbrksld|lbrkslu|lozenge|ldrdhar|dbkarow|bigcirc|epsilon|simrarr|simplus|ltquest|Epsilon|luruhar|gtquest|maltese|npolint|eqcolon|npreceq|bigodot|ddagger|gtrless|bnequiv|harrcir|ddotseq|equivDD|backsim|demptyv|nsqsube|nsqsupe|Upsilon|nsubset|upsilon|minusdu|nsucceq|swarrow|nsupset|coloneq|searrow|boxplus|napprox|natural|asympeq|alefsym|congdot|nearrow|bigstar|diamond|supplus|tritime|LeftTee|nvinfin|triplus|NewLine|nvltrie|nvrtrie|nwarrow|nexists|Diamond|ruluhar|Implies|supmult|angzarr|suplarr|suphsub|questeq|because|digamma|Because|olcross|bemptyv|omicron|Omicron|rotimes|NoBreak|intprod|angrtvb|orderof|uwangle|suphsol|lesdoto|orslope|DownTee|realine|cudarrl|rdldhar|OverBar|supedot|lessdot|supdsub|topfork|succsim|rbrkslu|rbrksld|pertenk|cudarrr|isindot|planckh|lessgtr|pluscir|gesdoto|plussim|plustwo|lesssim|cularrp|rarrsim|Cayleys|notinva|notinvb|notinvc|UpArrow|Uparrow|uparrow|NotLess|dwangle|precsim|Product|curarrm|Cconint|dotplus|rarrbfs|ccupssm|Cedilla|cemptyv|notniva|quatint|frac35|frac38|frac45|frac56|frac58|frac78|tridot|xoplus|gacute|gammad|Gammad|lfisht|lfloor|bigcup|sqsupe|gbreve|Gbreve|lharul|sqsube|sqcups|Gcedil|apacir|llhard|lmidot|Lmidot|lmoust|andand|sqcaps|approx|Abreve|spades|circeq|tprime|divide|topcir|Assign|topbot|gesdot|divonx|xuplus|timesd|gesles|atilde|solbar|SOFTcy|loplus|timesb|lowast|lowbar|dlcorn|dlcrop|softcy|dollar|lparlt|thksim|lrhard|Atilde|lsaquo|smashp|bigvee|thinsp|wreath|bkarow|lsquor|lstrok|Lstrok|lthree|ltimes|ltlarr|DotDot|simdot|ltrPar|weierp|xsqcup|angmsd|sigmav|sigmaf|zeetrf|Zcaron|zcaron|mapsto|vsupne|thetav|cirmid|marker|mcomma|Zacute|vsubnE|there4|gtlPar|vsubne|bottom|gtrarr|SHCHcy|shchcy|midast|midcir|middot|minusb|minusd|gtrdot|bowtie|sfrown|mnplus|models|colone|seswar|Colone|mstpos|searhk|gtrsim|nacute|Nacute|boxbox|telrec|hairsp|Tcedil|nbumpe|scnsim|ncaron|Ncaron|ncedil|Ncedil|hamilt|Scedil|nearhk|hardcy|HARDcy|tcedil|Tcaron|commat|nequiv|nesear|tcaron|target|hearts|nexist|varrho|scedil|Scaron|scaron|hellip|Sacute|sacute|hercon|swnwar|compfn|rtimes|rthree|rsquor|rsaquo|zacute|wedgeq|homtht|barvee|barwed|Barwed|rpargt|horbar|conint|swarhk|roplus|nltrie|hslash|hstrok|Hstrok|rmoust|Conint|bprime|hybull|hyphen|iacute|Iacute|supsup|supsub|supsim|varphi|coprod|brvbar|agrave|Supset|supset|igrave|Igrave|notinE|Agrave|iiiint|iinfin|copysr|wedbar|Verbar|vangrt|becaus|incare|verbar|inodot|bullet|drcorn|intcal|drcrop|cularr|vellip|Utilde|bumpeq|cupcap|dstrok|Dstrok|CupCap|cupcup|cupdot|eacute|Eacute|supdot|iquest|easter|ecaron|Ecaron|ecolon|isinsv|utilde|itilde|Itilde|curarr|succeq|Bumpeq|cacute|ulcrop|nparsl|Cacute|nprcue|egrave|Egrave|nrarrc|nrarrw|subsup|subsub|nrtrie|jsercy|nsccue|Jsercy|kappav|kcedil|Kcedil|subsim|ulcorn|nsimeq|egsdot|veebar|kgreen|capand|elsdot|Subset|subset|curren|aacute|lacute|Lacute|emptyv|ntilde|Ntilde|lagran|lambda|Lambda|capcap|Ugrave|langle|subdot|emsp13|numero|emsp14|nvdash|nvDash|nVdash|nVDash|ugrave|ufisht|nvHarr|larrfs|nvlArr|larrhk|larrlp|larrpl|nvrArr|Udblac|nwarhk|larrtl|nwnear|oacute|Oacute|latail|lAtail|sstarf|lbrace|odblac|Odblac|lbrack|udblac|odsold|eparsl|lcaron|Lcaron|ograve|Ograve|lcedil|Lcedil|Aacute|ssmile|ssetmn|squarf|ldquor|capcup|ominus|cylcty|rharul|eqcirc|dagger|rfloor|rfisht|Dagger|daleth|equals|origof|capdot|equest|dcaron|Dcaron|rdquor|oslash|Oslash|otilde|Otilde|otimes|Otimes|urcrop|Ubreve|ubreve|Yacute|Uacute|uacute|Rcedil|rcedil|urcorn|parsim|Rcaron|Vdashl|rcaron|Tstrok|percnt|period|permil|Exists|yacute|rbrack|rbrace|phmmat|ccaron|Ccaron|planck|ccedil|plankv|tstrok|female|plusdo|plusdu|ffilig|plusmn|ffllig|Ccedil|rAtail|dfisht|bernou|ratail|Rarrtl|rarrtl|angsph|rarrpl|rarrlp|rarrhk|xwedge|xotime|forall|ForAll|Vvdash|vsupnE|preceq|bigcap|frac12|frac13|frac14|primes|rarrfs|prnsim|frac15|Square|frac16|square|lesdot|frac18|frac23|propto|prurel|rarrap|rangle|puncsp|frac25|Racute|qprime|racute|lesges|frac34|abreve|AElig|eqsim|utdot|setmn|urtri|Equal|Uring|seArr|uring|searr|dashv|Dashv|mumap|nabla|iogon|Iogon|sdote|sdotb|scsim|napid|napos|equiv|natur|Acirc|dblac|erarr|nbump|iprod|erDot|ucirc|awint|esdot|angrt|ncong|isinE|scnap|Scirc|scirc|ndash|isins|Ubrcy|nearr|neArr|isinv|nedot|ubrcy|acute|Ycirc|iukcy|Iukcy|xutri|nesim|caret|jcirc|Jcirc|caron|twixt|ddarr|sccue|exist|jmath|sbquo|ngeqq|angst|ccaps|lceil|ngsim|UpTee|delta|Delta|rtrif|nharr|nhArr|nhpar|rtrie|jukcy|Jukcy|kappa|rsquo|Kappa|nlarr|nlArr|TSHcy|rrarr|aogon|Aogon|fflig|xrarr|tshcy|ccirc|nleqq|filig|upsih|nless|dharl|nlsim|fjlig|ropar|nltri|dharr|robrk|roarr|fllig|fltns|roang|rnmid|subnE|subne|lAarr|trisb|Ccirc|acirc|ccups|blank|VDash|forkv|Vdash|langd|cedil|blk12|blk14|laquo|strns|diams|notin|vDash|larrb|blk34|block|disin|uplus|vdash|vBarv|aelig|starf|Wedge|check|xrArr|lates|lbarr|lBarr|notni|lbbrk|bcong|frasl|lbrke|frown|vrtri|vprop|vnsup|gamma|Gamma|wedge|xodot|bdquo|srarr|doteq|ldquo|boxdl|boxdL|gcirc|Gcirc|boxDl|boxDL|boxdr|boxdR|boxDr|TRADE|trade|rlhar|boxDR|vnsub|npart|vltri|rlarr|boxhd|boxhD|nprec|gescc|nrarr|nrArr|boxHd|boxHD|boxhu|boxhU|nrtri|boxHu|clubs|boxHU|times|colon|Colon|gimel|xlArr|Tilde|nsime|tilde|nsmid|nspar|THORN|thorn|xlarr|nsube|nsubE|thkap|xhArr|comma|nsucc|boxul|boxuL|nsupe|nsupE|gneqq|gnsim|boxUl|boxUL|grave|boxur|boxuR|boxUr|boxUR|lescc|angle|bepsi|boxvh|varpi|boxvH|numsp|Theta|gsime|gsiml|theta|boxVh|boxVH|boxvl|gtcir|gtdot|boxvL|boxVl|boxVL|crarr|cross|Cross|nvsim|boxvr|nwarr|nwArr|sqsup|dtdot|Uogon|lhard|lharu|dtrif|ocirc|Ocirc|lhblk|duarr|odash|sqsub|Hacek|sqcup|llarr|duhar|oelig|OElig|ofcir|boxvR|uogon|lltri|boxVr|csube|uuarr|ohbar|csupe|ctdot|olarr|olcir|harrw|oline|sqcap|omacr|Omacr|omega|Omega|boxVR|aleph|lneqq|lnsim|loang|loarr|rharu|lobrk|hcirc|operp|oplus|rhard|Hcirc|orarr|Union|order|ecirc|Ecirc|cuepr|szlig|cuesc|breve|reals|eDDot|Breve|hoarr|lopar|utrif|rdquo|Umacr|umacr|efDot|swArr|ultri|alpha|rceil|ovbar|swarr|Wcirc|wcirc|smtes|smile|bsemi|lrarr|aring|parsl|lrhar|bsime|uhblk|lrtri|cupor|Aring|uharr|uharl|slarr|rbrke|bsolb|lsime|rbbrk|RBarr|lsimg|phone|rBarr|rbarr|icirc|lsquo|Icirc|emacr|Emacr|ratio|simne|plusb|simlE|simgE|simeq|pluse|ltcir|ltdot|empty|xharr|xdtri|iexcl|Alpha|ltrie|rarrw|pound|ltrif|xcirc|bumpe|prcue|bumpE|asymp|amacr|cuvee|Sigma|sigma|iiint|udhar|iiota|ijlig|IJlig|supnE|imacr|Imacr|prime|Prime|image|prnap|eogon|Eogon|rarrc|mdash|mDDot|cuwed|imath|supne|imped|Amacr|udarr|prsim|micro|rarrb|cwint|raquo|infin|eplus|range|rangd|Ucirc|radic|minus|amalg|veeeq|rAarr|epsiv|ycirc|quest|sharp|quot|zwnj|Qscr|race|qscr|Qopf|qopf|qint|rang|Rang|Zscr|zscr|Zopf|zopf|rarr|rArr|Rarr|Pscr|pscr|prop|prod|prnE|prec|ZHcy|zhcy|prap|Zeta|zeta|Popf|popf|Zdot|plus|zdot|Yuml|yuml|phiv|YUcy|yucy|Yscr|yscr|perp|Yopf|yopf|part|para|YIcy|Ouml|rcub|yicy|YAcy|rdca|ouml|osol|Oscr|rdsh|yacy|real|oscr|xvee|andd|rect|andv|Xscr|oror|ordm|ordf|xscr|ange|aopf|Aopf|rHar|Xopf|opar|Oopf|xopf|xnis|rhov|oopf|omid|xmap|oint|apid|apos|ogon|ascr|Ascr|odot|odiv|xcup|xcap|ocir|oast|nvlt|nvle|nvgt|nvge|nvap|Wscr|wscr|auml|ntlg|ntgl|nsup|nsub|nsim|Nscr|nscr|nsce|Wopf|ring|npre|wopf|npar|Auml|Barv|bbrk|Nopf|nopf|nmid|nLtv|beta|ropf|Ropf|Beta|beth|nles|rpar|nleq|bnot|bNot|nldr|NJcy|rscr|Rscr|Vscr|vscr|rsqb|njcy|bopf|nisd|Bopf|rtri|Vopf|nGtv|ngtr|vopf|boxh|boxH|boxv|nges|ngeq|boxV|bscr|scap|Bscr|bsim|Vert|vert|bsol|bull|bump|caps|cdot|ncup|scnE|ncap|nbsp|napE|Cdot|cent|sdot|Vbar|nang|vBar|chcy|Mscr|mscr|sect|semi|CHcy|Mopf|mopf|sext|circ|cire|mldr|mlcp|cirE|comp|shcy|SHcy|vArr|varr|cong|copf|Copf|copy|COPY|malt|male|macr|lvnE|cscr|ltri|sime|ltcc|simg|Cscr|siml|csub|Uuml|lsqb|lsim|uuml|csup|Lscr|lscr|utri|smid|lpar|cups|smte|lozf|darr|Lopf|Uscr|solb|lopf|sopf|Sopf|lneq|uscr|spar|dArr|lnap|Darr|dash|Sqrt|LJcy|ljcy|lHar|dHar|Upsi|upsi|diam|lesg|djcy|DJcy|leqq|dopf|Dopf|dscr|Dscr|dscy|ldsh|ldca|squf|DScy|sscr|Sscr|dsol|lcub|late|star|Star|Uopf|Larr|lArr|larr|uopf|dtri|dzcy|sube|subE|Lang|lang|Kscr|kscr|Kopf|kopf|KJcy|kjcy|KHcy|khcy|DZcy|ecir|edot|eDot|Jscr|jscr|succ|Jopf|jopf|Edot|uHar|emsp|ensp|Iuml|iuml|eopf|isin|Iscr|iscr|Eopf|epar|sung|epsi|escr|sup1|sup2|sup3|Iota|iota|supe|supE|Iopf|iopf|IOcy|iocy|Escr|esim|Esim|imof|Uarr|QUOT|uArr|uarr|euml|IEcy|iecy|Idot|Euml|euro|excl|Hscr|hscr|Hopf|hopf|TScy|tscy|Tscr|hbar|tscr|flat|tbrk|fnof|hArr|harr|half|fopf|Fopf|tdot|gvnE|fork|trie|gtcc|fscr|Fscr|gdot|gsim|Gscr|gscr|Gopf|gopf|gneq|Gdot|tosa|gnap|Topf|topf|geqq|toea|GJcy|gjcy|tint|gesl|mid|Sfr|ggg|top|ges|gla|glE|glj|geq|gne|gEl|gel|gnE|Gcy|gcy|gap|Tfr|tfr|Tcy|tcy|Hat|Tau|Ffr|tau|Tab|hfr|Hfr|ffr|Fcy|fcy|icy|Icy|iff|ETH|eth|ifr|Ifr|Eta|eta|int|Int|Sup|sup|ucy|Ucy|Sum|sum|jcy|ENG|ufr|Ufr|eng|Jcy|jfr|els|ell|egs|Efr|efr|Jfr|uml|kcy|Kcy|Ecy|ecy|kfr|Kfr|lap|Sub|sub|lat|lcy|Lcy|leg|Dot|dot|lEg|leq|les|squ|div|die|lfr|Lfr|lgE|Dfr|dfr|Del|deg|Dcy|dcy|lne|lnE|sol|loz|smt|Cup|lrm|cup|lsh|Lsh|sim|shy|map|Map|mcy|Mcy|mfr|Mfr|mho|gfr|Gfr|sfr|cir|Chi|chi|nap|Cfr|vcy|Vcy|cfr|Scy|scy|ncy|Ncy|vee|Vee|Cap|cap|nfr|scE|sce|Nfr|nge|ngE|nGg|vfr|Vfr|ngt|bot|nGt|nis|niv|Rsh|rsh|nle|nlE|bne|Bfr|bfr|nLl|nlt|nLt|Bcy|bcy|not|Not|rlm|wfr|Wfr|npr|nsc|num|ocy|ast|Ocy|ofr|xfr|Xfr|Ofr|ogt|ohm|apE|olt|Rho|ape|rho|Rfr|rfr|ord|REG|ang|reg|orv|And|and|AMP|Rcy|amp|Afr|ycy|Ycy|yen|yfr|Yfr|rcy|par|pcy|Pcy|pfr|Pfr|phi|Phi|afr|Acy|acy|zcy|Zcy|piv|acE|acd|zfr|Zfr|pre|prE|psi|Psi|qfr|Qfr|zwj|Or|ge|Gg|gt|gg|el|oS|lt|Lt|LT|Re|lg|gl|eg|ne|Im|it|le|DD|wp|wr|nu|Nu|dd|lE|Sc|sc|pi|Pi|ee|af|ll|Ll|rx|gE|xi|pm|Xi|ic|pr|Pr|in|ni|mp|mu|ac|Mu|or|ap|Gt|GT|ii);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)(?!;)([=a-zA-Z0-9]?)|&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+)/g;\r\n\tvar decodeMap = {'aacute':'\\xE1','Aacute':'\\xC1','abreve':'\\u0103','Abreve':'\\u0102','ac':'\\u223E','acd':'\\u223F','acE':'\\u223E\\u0333','acirc':'\\xE2','Acirc':'\\xC2','acute':'\\xB4','acy':'\\u0430','Acy':'\\u0410','aelig':'\\xE6','AElig':'\\xC6','af':'\\u2061','afr':'\\uD835\\uDD1E','Afr':'\\uD835\\uDD04','agrave':'\\xE0','Agrave':'\\xC0','alefsym':'\\u2135','aleph':'\\u2135','alpha':'\\u03B1','Alpha':'\\u0391','amacr':'\\u0101','Amacr':'\\u0100','amalg':'\\u2A3F','amp':'&','AMP':'&','and':'\\u2227','And':'\\u2A53','andand':'\\u2A55','andd':'\\u2A5C','andslope':'\\u2A58','andv':'\\u2A5A','ang':'\\u2220','ange':'\\u29A4','angle':'\\u2220','angmsd':'\\u2221','angmsdaa':'\\u29A8','angmsdab':'\\u29A9','angmsdac':'\\u29AA','angmsdad':'\\u29AB','angmsdae':'\\u29AC','angmsdaf':'\\u29AD','angmsdag':'\\u29AE','angmsdah':'\\u29AF','angrt':'\\u221F','angrtvb':'\\u22BE','angrtvbd':'\\u299D','angsph':'\\u2222','angst':'\\xC5','angzarr':'\\u237C','aogon':'\\u0105','Aogon':'\\u0104','aopf':'\\uD835\\uDD52','Aopf':'\\uD835\\uDD38','ap':'\\u2248','apacir':'\\u2A6F','ape':'\\u224A','apE':'\\u2A70','apid':'\\u224B','apos':'\\'','ApplyFunction':'\\u2061','approx':'\\u2248','approxeq':'\\u224A','aring':'\\xE5','Aring':'\\xC5','ascr':'\\uD835\\uDCB6','Ascr':'\\uD835\\uDC9C','Assign':'\\u2254','ast':'*','asymp':'\\u2248','asympeq':'\\u224D','atilde':'\\xE3','Atilde':'\\xC3','auml':'\\xE4','Auml':'\\xC4','awconint':'\\u2233','awint':'\\u2A11','backcong':'\\u224C','backepsilon':'\\u03F6','backprime':'\\u2035','backsim':'\\u223D','backsimeq':'\\u22CD','Backslash':'\\u2216','Barv':'\\u2AE7','barvee':'\\u22BD','barwed':'\\u2305','Barwed':'\\u2306','barwedge':'\\u2305','bbrk':'\\u23B5','bbrktbrk':'\\u23B6','bcong':'\\u224C','bcy':'\\u0431','Bcy':'\\u0411','bdquo':'\\u201E','becaus':'\\u2235','because':'\\u2235','Because':'\\u2235','bemptyv':'\\u29B0','bepsi':'\\u03F6','bernou':'\\u212C','Bernoullis':'\\u212C','beta':'\\u03B2','Beta':'\\u0392','beth':'\\u2136','between':'\\u226C','bfr':'\\uD835\\uDD1F','Bfr':'\\uD835\\uDD05','bigcap':'\\u22C2','bigcirc':'\\u25EF','bigcup':'\\u22C3','bigodot':'\\u2A00','bigoplus':'\\u2A01','bigotimes':'\\u2A02','bigsqcup':'\\u2A06','bigstar':'\\u2605','bigtriangledown':'\\u25BD','bigtriangleup':'\\u25B3','biguplus':'\\u2A04','bigvee':'\\u22C1','bigwedge':'\\u22C0','bkarow':'\\u290D','blacklozenge':'\\u29EB','blacksquare':'\\u25AA','blacktriangle':'\\u25B4','blacktriangledown':'\\u25BE','blacktriangleleft':'\\u25C2','blacktriangleright':'\\u25B8','blank':'\\u2423','blk12':'\\u2592','blk14':'\\u2591','blk34':'\\u2593','block':'\\u2588','bne':'=\\u20E5','bnequiv':'\\u2261\\u20E5','bnot':'\\u2310','bNot':'\\u2AED','bopf':'\\uD835\\uDD53','Bopf':'\\uD835\\uDD39','bot':'\\u22A5','bottom':'\\u22A5','bowtie':'\\u22C8','boxbox':'\\u29C9','boxdl':'\\u2510','boxdL':'\\u2555','boxDl':'\\u2556','boxDL':'\\u2557','boxdr':'\\u250C','boxdR':'\\u2552','boxDr':'\\u2553','boxDR':'\\u2554','boxh':'\\u2500','boxH':'\\u2550','boxhd':'\\u252C','boxhD':'\\u2565','boxHd':'\\u2564','boxHD':'\\u2566','boxhu':'\\u2534','boxhU':'\\u2568','boxHu':'\\u2567','boxHU':'\\u2569','boxminus':'\\u229F','boxplus':'\\u229E','boxtimes':'\\u22A0','boxul':'\\u2518','boxuL':'\\u255B','boxUl':'\\u255C','boxUL':'\\u255D','boxur':'\\u2514','boxuR':'\\u2558','boxUr':'\\u2559','boxUR':'\\u255A','boxv':'\\u2502','boxV':'\\u2551','boxvh':'\\u253C','boxvH':'\\u256A','boxVh':'\\u256B','boxVH':'\\u256C','boxvl':'\\u2524','boxvL':'\\u2561','boxVl':'\\u2562','boxVL':'\\u2563','boxvr':'\\u251C','boxvR':'\\u255E','boxVr':'\\u255F','boxVR':'\\u2560','bprime':'\\u2035','breve':'\\u02D8','Breve':'\\u02D8','brvbar':'\\xA6','bscr':'\\uD835\\uDCB7','Bscr':'\\u212C','bsemi':'\\u204F','bsim':'\\u223D','bsime':'\\u22CD','bsol':'\\\\','bsolb':'\\u29C5','bsolhsub':'\\u27C8','bull':'\\u2022','bullet':'\\u2022','bump':'\\u224E','bumpe':'\\u224F','bumpE':'\\u2AAE','bumpeq':'\\u224F','Bumpeq':'\\u224E','cacute':'\\u0107','Cacute':'\\u0106','cap':'\\u2229','Cap':'\\u22D2','capand':'\\u2A44','capbrcup':'\\u2A49','capcap':'\\u2A4B','capcup':'\\u2A47','capdot':'\\u2A40','CapitalDifferentialD':'\\u2145','caps':'\\u2229\\uFE00','caret':'\\u2041','caron':'\\u02C7','Cayleys':'\\u212D','ccaps':'\\u2A4D','ccaron':'\\u010D','Ccaron':'\\u010C','ccedil':'\\xE7','Ccedil':'\\xC7','ccirc':'\\u0109','Ccirc':'\\u0108','Cconint':'\\u2230','ccups':'\\u2A4C','ccupssm':'\\u2A50','cdot':'\\u010B','Cdot':'\\u010A','cedil':'\\xB8','Cedilla':'\\xB8','cemptyv':'\\u29B2','cent':'\\xA2','centerdot':'\\xB7','CenterDot':'\\xB7','cfr':'\\uD835\\uDD20','Cfr':'\\u212D','chcy':'\\u0447','CHcy':'\\u0427','check':'\\u2713','checkmark':'\\u2713','chi':'\\u03C7','Chi':'\\u03A7','cir':'\\u25CB','circ':'\\u02C6','circeq':'\\u2257','circlearrowleft':'\\u21BA','circlearrowright':'\\u21BB','circledast':'\\u229B','circledcirc':'\\u229A','circleddash':'\\u229D','CircleDot':'\\u2299','circledR':'\\xAE','circledS':'\\u24C8','CircleMinus':'\\u2296','CirclePlus':'\\u2295','CircleTimes':'\\u2297','cire':'\\u2257','cirE':'\\u29C3','cirfnint':'\\u2A10','cirmid':'\\u2AEF','cirscir':'\\u29C2','ClockwiseContourIntegral':'\\u2232','CloseCurlyDoubleQuote':'\\u201D','CloseCurlyQuote':'\\u2019','clubs':'\\u2663','clubsuit':'\\u2663','colon':':','Colon':'\\u2237','colone':'\\u2254','Colone':'\\u2A74','coloneq':'\\u2254','comma':',','commat':'@','comp':'\\u2201','compfn':'\\u2218','complement':'\\u2201','complexes':'\\u2102','cong':'\\u2245','congdot':'\\u2A6D','Congruent':'\\u2261','conint':'\\u222E','Conint':'\\u222F','ContourIntegral':'\\u222E','copf':'\\uD835\\uDD54','Copf':'\\u2102','coprod':'\\u2210','Coproduct':'\\u2210','copy':'\\xA9','COPY':'\\xA9','copysr':'\\u2117','CounterClockwiseContourIntegral':'\\u2233','crarr':'\\u21B5','cross':'\\u2717','Cross':'\\u2A2F','cscr':'\\uD835\\uDCB8','Cscr':'\\uD835\\uDC9E','csub':'\\u2ACF','csube':'\\u2AD1','csup':'\\u2AD0','csupe':'\\u2AD2','ctdot':'\\u22EF','cudarrl':'\\u2938','cudarrr':'\\u2935','cuepr':'\\u22DE','cuesc':'\\u22DF','cularr':'\\u21B6','cularrp':'\\u293D','cup':'\\u222A','Cup':'\\u22D3','cupbrcap':'\\u2A48','cupcap':'\\u2A46','CupCap':'\\u224D','cupcup':'\\u2A4A','cupdot':'\\u228D','cupor':'\\u2A45','cups':'\\u222A\\uFE00','curarr':'\\u21B7','curarrm':'\\u293C','curlyeqprec':'\\u22DE','curlyeqsucc':'\\u22DF','curlyvee':'\\u22CE','curlywedge':'\\u22CF','curren':'\\xA4','curvearrowleft':'\\u21B6','curvearrowright':'\\u21B7','cuvee':'\\u22CE','cuwed':'\\u22CF','cwconint':'\\u2232','cwint':'\\u2231','cylcty':'\\u232D','dagger':'\\u2020','Dagger':'\\u2021','daleth':'\\u2138','darr':'\\u2193','dArr':'\\u21D3','Darr':'\\u21A1','dash':'\\u2010','dashv':'\\u22A3','Dashv':'\\u2AE4','dbkarow':'\\u290F','dblac':'\\u02DD','dcaron':'\\u010F','Dcaron':'\\u010E','dcy':'\\u0434','Dcy':'\\u0414','dd':'\\u2146','DD':'\\u2145','ddagger':'\\u2021','ddarr':'\\u21CA','DDotrahd':'\\u2911','ddotseq':'\\u2A77','deg':'\\xB0','Del':'\\u2207','delta':'\\u03B4','Delta':'\\u0394','demptyv':'\\u29B1','dfisht':'\\u297F','dfr':'\\uD835\\uDD21','Dfr':'\\uD835\\uDD07','dHar':'\\u2965','dharl':'\\u21C3','dharr':'\\u21C2','DiacriticalAcute':'\\xB4','DiacriticalDot':'\\u02D9','DiacriticalDoubleAcute':'\\u02DD','DiacriticalGrave':'`','DiacriticalTilde':'\\u02DC','diam':'\\u22C4','diamond':'\\u22C4','Diamond':'\\u22C4','diamondsuit':'\\u2666','diams':'\\u2666','die':'\\xA8','DifferentialD':'\\u2146','digamma':'\\u03DD','disin':'\\u22F2','div':'\\xF7','divide':'\\xF7','divideontimes':'\\u22C7','divonx':'\\u22C7','djcy':'\\u0452','DJcy':'\\u0402','dlcorn':'\\u231E','dlcrop':'\\u230D','dollar':'$','dopf':'\\uD835\\uDD55','Dopf':'\\uD835\\uDD3B','dot':'\\u02D9','Dot':'\\xA8','DotDot':'\\u20DC','doteq':'\\u2250','doteqdot':'\\u2251','DotEqual':'\\u2250','dotminus':'\\u2238','dotplus':'\\u2214','dotsquare':'\\u22A1','doublebarwedge':'\\u2306','DoubleContourIntegral':'\\u222F','DoubleDot':'\\xA8','DoubleDownArrow':'\\u21D3','DoubleLeftArrow':'\\u21D0','DoubleLeftRightArrow':'\\u21D4','DoubleLeftTee':'\\u2AE4','DoubleLongLeftArrow':'\\u27F8','DoubleLongLeftRightArrow':'\\u27FA','DoubleLongRightArrow':'\\u27F9','DoubleRightArrow':'\\u21D2','DoubleRightTee':'\\u22A8','DoubleUpArrow':'\\u21D1','DoubleUpDownArrow':'\\u21D5','DoubleVerticalBar':'\\u2225','downarrow':'\\u2193','Downarrow':'\\u21D3','DownArrow':'\\u2193','DownArrowBar':'\\u2913','DownArrowUpArrow':'\\u21F5','DownBreve':'\\u0311','downdownarrows':'\\u21CA','downharpoonleft':'\\u21C3','downharpoonright':'\\u21C2','DownLeftRightVector':'\\u2950','DownLeftTeeVector':'\\u295E','DownLeftVector':'\\u21BD','DownLeftVectorBar':'\\u2956','DownRightTeeVector':'\\u295F','DownRightVector':'\\u21C1','DownRightVectorBar':'\\u2957','DownTee':'\\u22A4','DownTeeArrow':'\\u21A7','drbkarow':'\\u2910','drcorn':'\\u231F','drcrop':'\\u230C','dscr':'\\uD835\\uDCB9','Dscr':'\\uD835\\uDC9F','dscy':'\\u0455','DScy':'\\u0405','dsol':'\\u29F6','dstrok':'\\u0111','Dstrok':'\\u0110','dtdot':'\\u22F1','dtri':'\\u25BF','dtrif':'\\u25BE','duarr':'\\u21F5','duhar':'\\u296F','dwangle':'\\u29A6','dzcy':'\\u045F','DZcy':'\\u040F','dzigrarr':'\\u27FF','eacute':'\\xE9','Eacute':'\\xC9','easter':'\\u2A6E','ecaron':'\\u011B','Ecaron':'\\u011A','ecir':'\\u2256','ecirc':'\\xEA','Ecirc':'\\xCA','ecolon':'\\u2255','ecy':'\\u044D','Ecy':'\\u042D','eDDot':'\\u2A77','edot':'\\u0117','eDot':'\\u2251','Edot':'\\u0116','ee':'\\u2147','efDot':'\\u2252','efr':'\\uD835\\uDD22','Efr':'\\uD835\\uDD08','eg':'\\u2A9A','egrave':'\\xE8','Egrave':'\\xC8','egs':'\\u2A96','egsdot':'\\u2A98','el':'\\u2A99','Element':'\\u2208','elinters':'\\u23E7','ell':'\\u2113','els':'\\u2A95','elsdot':'\\u2A97','emacr':'\\u0113','Emacr':'\\u0112','empty':'\\u2205','emptyset':'\\u2205','EmptySmallSquare':'\\u25FB','emptyv':'\\u2205','EmptyVerySmallSquare':'\\u25AB','emsp':'\\u2003','emsp13':'\\u2004','emsp14':'\\u2005','eng':'\\u014B','ENG':'\\u014A','ensp':'\\u2002','eogon':'\\u0119','Eogon':'\\u0118','eopf':'\\uD835\\uDD56','Eopf':'\\uD835\\uDD3C','epar':'\\u22D5','eparsl':'\\u29E3','eplus':'\\u2A71','epsi':'\\u03B5','epsilon':'\\u03B5','Epsilon':'\\u0395','epsiv':'\\u03F5','eqcirc':'\\u2256','eqcolon':'\\u2255','eqsim':'\\u2242','eqslantgtr':'\\u2A96','eqslantless':'\\u2A95','Equal':'\\u2A75','equals':'=','EqualTilde':'\\u2242','equest':'\\u225F','Equilibrium':'\\u21CC','equiv':'\\u2261','equivDD':'\\u2A78','eqvparsl':'\\u29E5','erarr':'\\u2971','erDot':'\\u2253','escr':'\\u212F','Escr':'\\u2130','esdot':'\\u2250','esim':'\\u2242','Esim':'\\u2A73','eta':'\\u03B7','Eta':'\\u0397','eth':'\\xF0','ETH':'\\xD0','euml':'\\xEB','Euml':'\\xCB','euro':'\\u20AC','excl':'!','exist':'\\u2203','Exists':'\\u2203','expectation':'\\u2130','exponentiale':'\\u2147','ExponentialE':'\\u2147','fallingdotseq':'\\u2252','fcy':'\\u0444','Fcy':'\\u0424','female':'\\u2640','ffilig':'\\uFB03','fflig':'\\uFB00','ffllig':'\\uFB04','ffr':'\\uD835\\uDD23','Ffr':'\\uD835\\uDD09','filig':'\\uFB01','FilledSmallSquare':'\\u25FC','FilledVerySmallSquare':'\\u25AA','fjlig':'fj','flat':'\\u266D','fllig':'\\uFB02','fltns':'\\u25B1','fnof':'\\u0192','fopf':'\\uD835\\uDD57','Fopf':'\\uD835\\uDD3D','forall':'\\u2200','ForAll':'\\u2200','fork':'\\u22D4','forkv':'\\u2AD9','Fouriertrf':'\\u2131','fpartint':'\\u2A0D','frac12':'\\xBD','frac13':'\\u2153','frac14':'\\xBC','frac15':'\\u2155','frac16':'\\u2159','frac18':'\\u215B','frac23':'\\u2154','frac25':'\\u2156','frac34':'\\xBE','frac35':'\\u2157','frac38':'\\u215C','frac45':'\\u2158','frac56':'\\u215A','frac58':'\\u215D','frac78':'\\u215E','frasl':'\\u2044','frown':'\\u2322','fscr':'\\uD835\\uDCBB','Fscr':'\\u2131','gacute':'\\u01F5','gamma':'\\u03B3','Gamma':'\\u0393','gammad':'\\u03DD','Gammad':'\\u03DC','gap':'\\u2A86','gbreve':'\\u011F','Gbreve':'\\u011E','Gcedil':'\\u0122','gcirc':'\\u011D','Gcirc':'\\u011C','gcy':'\\u0433','Gcy':'\\u0413','gdot':'\\u0121','Gdot':'\\u0120','ge':'\\u2265','gE':'\\u2267','gel':'\\u22DB','gEl':'\\u2A8C','geq':'\\u2265','geqq':'\\u2267','geqslant':'\\u2A7E','ges':'\\u2A7E','gescc':'\\u2AA9','gesdot':'\\u2A80','gesdoto':'\\u2A82','gesdotol':'\\u2A84','gesl':'\\u22DB\\uFE00','gesles':'\\u2A94','gfr':'\\uD835\\uDD24','Gfr':'\\uD835\\uDD0A','gg':'\\u226B','Gg':'\\u22D9','ggg':'\\u22D9','gimel':'\\u2137','gjcy':'\\u0453','GJcy':'\\u0403','gl':'\\u2277','gla':'\\u2AA5','glE':'\\u2A92','glj':'\\u2AA4','gnap':'\\u2A8A','gnapprox':'\\u2A8A','gne':'\\u2A88','gnE':'\\u2269','gneq':'\\u2A88','gneqq':'\\u2269','gnsim':'\\u22E7','gopf':'\\uD835\\uDD58','Gopf':'\\uD835\\uDD3E','grave':'`','GreaterEqual':'\\u2265','GreaterEqualLess':'\\u22DB','GreaterFullEqual':'\\u2267','GreaterGreater':'\\u2AA2','GreaterLess':'\\u2277','GreaterSlantEqual':'\\u2A7E','GreaterTilde':'\\u2273','gscr':'\\u210A','Gscr':'\\uD835\\uDCA2','gsim':'\\u2273','gsime':'\\u2A8E','gsiml':'\\u2A90','gt':'>','Gt':'\\u226B','GT':'>','gtcc':'\\u2AA7','gtcir':'\\u2A7A','gtdot':'\\u22D7','gtlPar':'\\u2995','gtquest':'\\u2A7C','gtrapprox':'\\u2A86','gtrarr':'\\u2978','gtrdot':'\\u22D7','gtreqless':'\\u22DB','gtreqqless':'\\u2A8C','gtrless':'\\u2277','gtrsim':'\\u2273','gvertneqq':'\\u2269\\uFE00','gvnE':'\\u2269\\uFE00','Hacek':'\\u02C7','hairsp':'\\u200A','half':'\\xBD','hamilt':'\\u210B','hardcy':'\\u044A','HARDcy':'\\u042A','harr':'\\u2194','hArr':'\\u21D4','harrcir':'\\u2948','harrw':'\\u21AD','Hat':'^','hbar':'\\u210F','hcirc':'\\u0125','Hcirc':'\\u0124','hearts':'\\u2665','heartsuit':'\\u2665','hellip':'\\u2026','hercon':'\\u22B9','hfr':'\\uD835\\uDD25','Hfr':'\\u210C','HilbertSpace':'\\u210B','hksearow':'\\u2925','hkswarow':'\\u2926','hoarr':'\\u21FF','homtht':'\\u223B','hookleftarrow':'\\u21A9','hookrightarrow':'\\u21AA','hopf':'\\uD835\\uDD59','Hopf':'\\u210D','horbar':'\\u2015','HorizontalLine':'\\u2500','hscr':'\\uD835\\uDCBD','Hscr':'\\u210B','hslash':'\\u210F','hstrok':'\\u0127','Hstrok':'\\u0126','HumpDownHump':'\\u224E','HumpEqual':'\\u224F','hybull':'\\u2043','hyphen':'\\u2010','iacute':'\\xED','Iacute':'\\xCD','ic':'\\u2063','icirc':'\\xEE','Icirc':'\\xCE','icy':'\\u0438','Icy':'\\u0418','Idot':'\\u0130','iecy':'\\u0435','IEcy':'\\u0415','iexcl':'\\xA1','iff':'\\u21D4','ifr':'\\uD835\\uDD26','Ifr':'\\u2111','igrave':'\\xEC','Igrave':'\\xCC','ii':'\\u2148','iiiint':'\\u2A0C','iiint':'\\u222D','iinfin':'\\u29DC','iiota':'\\u2129','ijlig':'\\u0133','IJlig':'\\u0132','Im':'\\u2111','imacr':'\\u012B','Imacr':'\\u012A','image':'\\u2111','ImaginaryI':'\\u2148','imagline':'\\u2110','imagpart':'\\u2111','imath':'\\u0131','imof':'\\u22B7','imped':'\\u01B5','Implies':'\\u21D2','in':'\\u2208','incare':'\\u2105','infin':'\\u221E','infintie':'\\u29DD','inodot':'\\u0131','int':'\\u222B','Int':'\\u222C','intcal':'\\u22BA','integers':'\\u2124','Integral':'\\u222B','intercal':'\\u22BA','Intersection':'\\u22C2','intlarhk':'\\u2A17','intprod':'\\u2A3C','InvisibleComma':'\\u2063','InvisibleTimes':'\\u2062','iocy':'\\u0451','IOcy':'\\u0401','iogon':'\\u012F','Iogon':'\\u012E','iopf':'\\uD835\\uDD5A','Iopf':'\\uD835\\uDD40','iota':'\\u03B9','Iota':'\\u0399','iprod':'\\u2A3C','iquest':'\\xBF','iscr':'\\uD835\\uDCBE','Iscr':'\\u2110','isin':'\\u2208','isindot':'\\u22F5','isinE':'\\u22F9','isins':'\\u22F4','isinsv':'\\u22F3','isinv':'\\u2208','it':'\\u2062','itilde':'\\u0129','Itilde':'\\u0128','iukcy':'\\u0456','Iukcy':'\\u0406','iuml':'\\xEF','Iuml':'\\xCF','jcirc':'\\u0135','Jcirc':'\\u0134','jcy':'\\u0439','Jcy':'\\u0419','jfr':'\\uD835\\uDD27','Jfr':'\\uD835\\uDD0D','jmath':'\\u0237','jopf':'\\uD835\\uDD5B','Jopf':'\\uD835\\uDD41','jscr':'\\uD835\\uDCBF','Jscr':'\\uD835\\uDCA5','jsercy':'\\u0458','Jsercy':'\\u0408','jukcy':'\\u0454','Jukcy':'\\u0404','kappa':'\\u03BA','Kappa':'\\u039A','kappav':'\\u03F0','kcedil':'\\u0137','Kcedil':'\\u0136','kcy':'\\u043A','Kcy':'\\u041A','kfr':'\\uD835\\uDD28','Kfr':'\\uD835\\uDD0E','kgreen':'\\u0138','khcy':'\\u0445','KHcy':'\\u0425','kjcy':'\\u045C','KJcy':'\\u040C','kopf':'\\uD835\\uDD5C','Kopf':'\\uD835\\uDD42','kscr':'\\uD835\\uDCC0','Kscr':'\\uD835\\uDCA6','lAarr':'\\u21DA','lacute':'\\u013A','Lacute':'\\u0139','laemptyv':'\\u29B4','lagran':'\\u2112','lambda':'\\u03BB','Lambda':'\\u039B','lang':'\\u27E8','Lang':'\\u27EA','langd':'\\u2991','langle':'\\u27E8','lap':'\\u2A85','Laplacetrf':'\\u2112','laquo':'\\xAB','larr':'\\u2190','lArr':'\\u21D0','Larr':'\\u219E','larrb':'\\u21E4','larrbfs':'\\u291F','larrfs':'\\u291D','larrhk':'\\u21A9','larrlp':'\\u21AB','larrpl':'\\u2939','larrsim':'\\u2973','larrtl':'\\u21A2','lat':'\\u2AAB','latail':'\\u2919','lAtail':'\\u291B','late':'\\u2AAD','lates':'\\u2AAD\\uFE00','lbarr':'\\u290C','lBarr':'\\u290E','lbbrk':'\\u2772','lbrace':'{','lbrack':'[','lbrke':'\\u298B','lbrksld':'\\u298F','lbrkslu':'\\u298D','lcaron':'\\u013E','Lcaron':'\\u013D','lcedil':'\\u013C','Lcedil':'\\u013B','lceil':'\\u2308','lcub':'{','lcy':'\\u043B','Lcy':'\\u041B','ldca':'\\u2936','ldquo':'\\u201C','ldquor':'\\u201E','ldrdhar':'\\u2967','ldrushar':'\\u294B','ldsh':'\\u21B2','le':'\\u2264','lE':'\\u2266','LeftAngleBracket':'\\u27E8','leftarrow':'\\u2190','Leftarrow':'\\u21D0','LeftArrow':'\\u2190','LeftArrowBar':'\\u21E4','LeftArrowRightArrow':'\\u21C6','leftarrowtail':'\\u21A2','LeftCeiling':'\\u2308','LeftDoubleBracket':'\\u27E6','LeftDownTeeVector':'\\u2961','LeftDownVector':'\\u21C3','LeftDownVectorBar':'\\u2959','LeftFloor':'\\u230A','leftharpoondown':'\\u21BD','leftharpoonup':'\\u21BC','leftleftarrows':'\\u21C7','leftrightarrow':'\\u2194','Leftrightarrow':'\\u21D4','LeftRightArrow':'\\u2194','leftrightarrows':'\\u21C6','leftrightharpoons':'\\u21CB','leftrightsquigarrow':'\\u21AD','LeftRightVector':'\\u294E','LeftTee':'\\u22A3','LeftTeeArrow':'\\u21A4','LeftTeeVector':'\\u295A','leftthreetimes':'\\u22CB','LeftTriangle':'\\u22B2','LeftTriangleBar':'\\u29CF','LeftTriangleEqual':'\\u22B4','LeftUpDownVector':'\\u2951','LeftUpTeeVector':'\\u2960','LeftUpVector':'\\u21BF','LeftUpVectorBar':'\\u2958','LeftVector':'\\u21BC','LeftVectorBar':'\\u2952','leg':'\\u22DA','lEg':'\\u2A8B','leq':'\\u2264','leqq':'\\u2266','leqslant':'\\u2A7D','les':'\\u2A7D','lescc':'\\u2AA8','lesdot':'\\u2A7F','lesdoto':'\\u2A81','lesdotor':'\\u2A83','lesg':'\\u22DA\\uFE00','lesges':'\\u2A93','lessapprox':'\\u2A85','lessdot':'\\u22D6','lesseqgtr':'\\u22DA','lesseqqgtr':'\\u2A8B','LessEqualGreater':'\\u22DA','LessFullEqual':'\\u2266','LessGreater':'\\u2276','lessgtr':'\\u2276','LessLess':'\\u2AA1','lesssim':'\\u2272','LessSlantEqual':'\\u2A7D','LessTilde':'\\u2272','lfisht':'\\u297C','lfloor':'\\u230A','lfr':'\\uD835\\uDD29','Lfr':'\\uD835\\uDD0F','lg':'\\u2276','lgE':'\\u2A91','lHar':'\\u2962','lhard':'\\u21BD','lharu':'\\u21BC','lharul':'\\u296A','lhblk':'\\u2584','ljcy':'\\u0459','LJcy':'\\u0409','ll':'\\u226A','Ll':'\\u22D8','llarr':'\\u21C7','llcorner':'\\u231E','Lleftarrow':'\\u21DA','llhard':'\\u296B','lltri':'\\u25FA','lmidot':'\\u0140','Lmidot':'\\u013F','lmoust':'\\u23B0','lmoustache':'\\u23B0','lnap':'\\u2A89','lnapprox':'\\u2A89','lne':'\\u2A87','lnE':'\\u2268','lneq':'\\u2A87','lneqq':'\\u2268','lnsim':'\\u22E6','loang':'\\u27EC','loarr':'\\u21FD','lobrk':'\\u27E6','longleftarrow':'\\u27F5','Longleftarrow':'\\u27F8','LongLeftArrow':'\\u27F5','longleftrightarrow':'\\u27F7','Longleftrightarrow':'\\u27FA','LongLeftRightArrow':'\\u27F7','longmapsto':'\\u27FC','longrightarrow':'\\u27F6','Longrightarrow':'\\u27F9','LongRightArrow':'\\u27F6','looparrowleft':'\\u21AB','looparrowright':'\\u21AC','lopar':'\\u2985','lopf':'\\uD835\\uDD5D','Lopf':'\\uD835\\uDD43','loplus':'\\u2A2D','lotimes':'\\u2A34','lowast':'\\u2217','lowbar':'_','LowerLeftArrow':'\\u2199','LowerRightArrow':'\\u2198','loz':'\\u25CA','lozenge':'\\u25CA','lozf':'\\u29EB','lpar':'(','lparlt':'\\u2993','lrarr':'\\u21C6','lrcorner':'\\u231F','lrhar':'\\u21CB','lrhard':'\\u296D','lrm':'\\u200E','lrtri':'\\u22BF','lsaquo':'\\u2039','lscr':'\\uD835\\uDCC1','Lscr':'\\u2112','lsh':'\\u21B0','Lsh':'\\u21B0','lsim':'\\u2272','lsime':'\\u2A8D','lsimg':'\\u2A8F','lsqb':'[','lsquo':'\\u2018','lsquor':'\\u201A','lstrok':'\\u0142','Lstrok':'\\u0141','lt':'<','Lt':'\\u226A','LT':'<','ltcc':'\\u2AA6','ltcir':'\\u2A79','ltdot':'\\u22D6','lthree':'\\u22CB','ltimes':'\\u22C9','ltlarr':'\\u2976','ltquest':'\\u2A7B','ltri':'\\u25C3','ltrie':'\\u22B4','ltrif':'\\u25C2','ltrPar':'\\u2996','lurdshar':'\\u294A','luruhar':'\\u2966','lvertneqq':'\\u2268\\uFE00','lvnE':'\\u2268\\uFE00','macr':'\\xAF','male':'\\u2642','malt':'\\u2720','maltese':'\\u2720','map':'\\u21A6','Map':'\\u2905','mapsto':'\\u21A6','mapstodown':'\\u21A7','mapstoleft':'\\u21A4','mapstoup':'\\u21A5','marker':'\\u25AE','mcomma':'\\u2A29','mcy':'\\u043C','Mcy':'\\u041C','mdash':'\\u2014','mDDot':'\\u223A','measuredangle':'\\u2221','MediumSpace':'\\u205F','Mellintrf':'\\u2133','mfr':'\\uD835\\uDD2A','Mfr':'\\uD835\\uDD10','mho':'\\u2127','micro':'\\xB5','mid':'\\u2223','midast':'*','midcir':'\\u2AF0','middot':'\\xB7','minus':'\\u2212','minusb':'\\u229F','minusd':'\\u2238','minusdu':'\\u2A2A','MinusPlus':'\\u2213','mlcp':'\\u2ADB','mldr':'\\u2026','mnplus':'\\u2213','models':'\\u22A7','mopf':'\\uD835\\uDD5E','Mopf':'\\uD835\\uDD44','mp':'\\u2213','mscr':'\\uD835\\uDCC2','Mscr':'\\u2133','mstpos':'\\u223E','mu':'\\u03BC','Mu':'\\u039C','multimap':'\\u22B8','mumap':'\\u22B8','nabla':'\\u2207','nacute':'\\u0144','Nacute':'\\u0143','nang':'\\u2220\\u20D2','nap':'\\u2249','napE':'\\u2A70\\u0338','napid':'\\u224B\\u0338','napos':'\\u0149','napprox':'\\u2249','natur':'\\u266E','natural':'\\u266E','naturals':'\\u2115','nbsp':'\\xA0','nbump':'\\u224E\\u0338','nbumpe':'\\u224F\\u0338','ncap':'\\u2A43','ncaron':'\\u0148','Ncaron':'\\u0147','ncedil':'\\u0146','Ncedil':'\\u0145','ncong':'\\u2247','ncongdot':'\\u2A6D\\u0338','ncup':'\\u2A42','ncy':'\\u043D','Ncy':'\\u041D','ndash':'\\u2013','ne':'\\u2260','nearhk':'\\u2924','nearr':'\\u2197','neArr':'\\u21D7','nearrow':'\\u2197','nedot':'\\u2250\\u0338','NegativeMediumSpace':'\\u200B','NegativeThickSpace':'\\u200B','NegativeThinSpace':'\\u200B','NegativeVeryThinSpace':'\\u200B','nequiv':'\\u2262','nesear':'\\u2928','nesim':'\\u2242\\u0338','NestedGreaterGreater':'\\u226B','NestedLessLess':'\\u226A','NewLine':'\\n','nexist':'\\u2204','nexists':'\\u2204','nfr':'\\uD835\\uDD2B','Nfr':'\\uD835\\uDD11','nge':'\\u2271','ngE':'\\u2267\\u0338','ngeq':'\\u2271','ngeqq':'\\u2267\\u0338','ngeqslant':'\\u2A7E\\u0338','nges':'\\u2A7E\\u0338','nGg':'\\u22D9\\u0338','ngsim':'\\u2275','ngt':'\\u226F','nGt':'\\u226B\\u20D2','ngtr':'\\u226F','nGtv':'\\u226B\\u0338','nharr':'\\u21AE','nhArr':'\\u21CE','nhpar':'\\u2AF2','ni':'\\u220B','nis':'\\u22FC','nisd':'\\u22FA','niv':'\\u220B','njcy':'\\u045A','NJcy':'\\u040A','nlarr':'\\u219A','nlArr':'\\u21CD','nldr':'\\u2025','nle':'\\u2270','nlE':'\\u2266\\u0338','nleftarrow':'\\u219A','nLeftarrow':'\\u21CD','nleftrightarrow':'\\u21AE','nLeftrightarrow':'\\u21CE','nleq':'\\u2270','nleqq':'\\u2266\\u0338','nleqslant':'\\u2A7D\\u0338','nles':'\\u2A7D\\u0338','nless':'\\u226E','nLl':'\\u22D8\\u0338','nlsim':'\\u2274','nlt':'\\u226E','nLt':'\\u226A\\u20D2','nltri':'\\u22EA','nltrie':'\\u22EC','nLtv':'\\u226A\\u0338','nmid':'\\u2224','NoBreak':'\\u2060','NonBreakingSpace':'\\xA0','nopf':'\\uD835\\uDD5F','Nopf':'\\u2115','not':'\\xAC','Not':'\\u2AEC','NotCongruent':'\\u2262','NotCupCap':'\\u226D','NotDoubleVerticalBar':'\\u2226','NotElement':'\\u2209','NotEqual':'\\u2260','NotEqualTilde':'\\u2242\\u0338','NotExists':'\\u2204','NotGreater':'\\u226F','NotGreaterEqual':'\\u2271','NotGreaterFullEqual':'\\u2267\\u0338','NotGreaterGreater':'\\u226B\\u0338','NotGreaterLess':'\\u2279','NotGreaterSlantEqual':'\\u2A7E\\u0338','NotGreaterTilde':'\\u2275','NotHumpDownHump':'\\u224E\\u0338','NotHumpEqual':'\\u224F\\u0338','notin':'\\u2209','notindot':'\\u22F5\\u0338','notinE':'\\u22F9\\u0338','notinva':'\\u2209','notinvb':'\\u22F7','notinvc':'\\u22F6','NotLeftTriangle':'\\u22EA','NotLeftTriangleBar':'\\u29CF\\u0338','NotLeftTriangleEqual':'\\u22EC','NotLess':'\\u226E','NotLessEqual':'\\u2270','NotLessGreater':'\\u2278','NotLessLess':'\\u226A\\u0338','NotLessSlantEqual':'\\u2A7D\\u0338','NotLessTilde':'\\u2274','NotNestedGreaterGreater':'\\u2AA2\\u0338','NotNestedLessLess':'\\u2AA1\\u0338','notni':'\\u220C','notniva':'\\u220C','notnivb':'\\u22FE','notnivc':'\\u22FD','NotPrecedes':'\\u2280','NotPrecedesEqual':'\\u2AAF\\u0338','NotPrecedesSlantEqual':'\\u22E0','NotReverseElement':'\\u220C','NotRightTriangle':'\\u22EB','NotRightTriangleBar':'\\u29D0\\u0338','NotRightTriangleEqual':'\\u22ED','NotSquareSubset':'\\u228F\\u0338','NotSquareSubsetEqual':'\\u22E2','NotSquareSuperset':'\\u2290\\u0338','NotSquareSupersetEqual':'\\u22E3','NotSubset':'\\u2282\\u20D2','NotSubsetEqual':'\\u2288','NotSucceeds':'\\u2281','NotSucceedsEqual':'\\u2AB0\\u0338','NotSucceedsSlantEqual':'\\u22E1','NotSucceedsTilde':'\\u227F\\u0338','NotSuperset':'\\u2283\\u20D2','NotSupersetEqual':'\\u2289','NotTilde':'\\u2241','NotTildeEqual':'\\u2244','NotTildeFullEqual':'\\u2247','NotTildeTilde':'\\u2249','NotVerticalBar':'\\u2224','npar':'\\u2226','nparallel':'\\u2226','nparsl':'\\u2AFD\\u20E5','npart':'\\u2202\\u0338','npolint':'\\u2A14','npr':'\\u2280','nprcue':'\\u22E0','npre':'\\u2AAF\\u0338','nprec':'\\u2280','npreceq':'\\u2AAF\\u0338','nrarr':'\\u219B','nrArr':'\\u21CF','nrarrc':'\\u2933\\u0338','nrarrw':'\\u219D\\u0338','nrightarrow':'\\u219B','nRightarrow':'\\u21CF','nrtri':'\\u22EB','nrtrie':'\\u22ED','nsc':'\\u2281','nsccue':'\\u22E1','nsce':'\\u2AB0\\u0338','nscr':'\\uD835\\uDCC3','Nscr':'\\uD835\\uDCA9','nshortmid':'\\u2224','nshortparallel':'\\u2226','nsim':'\\u2241','nsime':'\\u2244','nsimeq':'\\u2244','nsmid':'\\u2224','nspar':'\\u2226','nsqsube':'\\u22E2','nsqsupe':'\\u22E3','nsub':'\\u2284','nsube':'\\u2288','nsubE':'\\u2AC5\\u0338','nsubset':'\\u2282\\u20D2','nsubseteq':'\\u2288','nsubseteqq':'\\u2AC5\\u0338','nsucc':'\\u2281','nsucceq':'\\u2AB0\\u0338','nsup':'\\u2285','nsupe':'\\u2289','nsupE':'\\u2AC6\\u0338','nsupset':'\\u2283\\u20D2','nsupseteq':'\\u2289','nsupseteqq':'\\u2AC6\\u0338','ntgl':'\\u2279','ntilde':'\\xF1','Ntilde':'\\xD1','ntlg':'\\u2278','ntriangleleft':'\\u22EA','ntrianglelefteq':'\\u22EC','ntriangleright':'\\u22EB','ntrianglerighteq':'\\u22ED','nu':'\\u03BD','Nu':'\\u039D','num':'#','numero':'\\u2116','numsp':'\\u2007','nvap':'\\u224D\\u20D2','nvdash':'\\u22AC','nvDash':'\\u22AD','nVdash':'\\u22AE','nVDash':'\\u22AF','nvge':'\\u2265\\u20D2','nvgt':'>\\u20D2','nvHarr':'\\u2904','nvinfin':'\\u29DE','nvlArr':'\\u2902','nvle':'\\u2264\\u20D2','nvlt':'<\\u20D2','nvltrie':'\\u22B4\\u20D2','nvrArr':'\\u2903','nvrtrie':'\\u22B5\\u20D2','nvsim':'\\u223C\\u20D2','nwarhk':'\\u2923','nwarr':'\\u2196','nwArr':'\\u21D6','nwarrow':'\\u2196','nwnear':'\\u2927','oacute':'\\xF3','Oacute':'\\xD3','oast':'\\u229B','ocir':'\\u229A','ocirc':'\\xF4','Ocirc':'\\xD4','ocy':'\\u043E','Ocy':'\\u041E','odash':'\\u229D','odblac':'\\u0151','Odblac':'\\u0150','odiv':'\\u2A38','odot':'\\u2299','odsold':'\\u29BC','oelig':'\\u0153','OElig':'\\u0152','ofcir':'\\u29BF','ofr':'\\uD835\\uDD2C','Ofr':'\\uD835\\uDD12','ogon':'\\u02DB','ograve':'\\xF2','Ograve':'\\xD2','ogt':'\\u29C1','ohbar':'\\u29B5','ohm':'\\u03A9','oint':'\\u222E','olarr':'\\u21BA','olcir':'\\u29BE','olcross':'\\u29BB','oline':'\\u203E','olt':'\\u29C0','omacr':'\\u014D','Omacr':'\\u014C','omega':'\\u03C9','Omega':'\\u03A9','omicron':'\\u03BF','Omicron':'\\u039F','omid':'\\u29B6','ominus':'\\u2296','oopf':'\\uD835\\uDD60','Oopf':'\\uD835\\uDD46','opar':'\\u29B7','OpenCurlyDoubleQuote':'\\u201C','OpenCurlyQuote':'\\u2018','operp':'\\u29B9','oplus':'\\u2295','or':'\\u2228','Or':'\\u2A54','orarr':'\\u21BB','ord':'\\u2A5D','order':'\\u2134','orderof':'\\u2134','ordf':'\\xAA','ordm':'\\xBA','origof':'\\u22B6','oror':'\\u2A56','orslope':'\\u2A57','orv':'\\u2A5B','oS':'\\u24C8','oscr':'\\u2134','Oscr':'\\uD835\\uDCAA','oslash':'\\xF8','Oslash':'\\xD8','osol':'\\u2298','otilde':'\\xF5','Otilde':'\\xD5','otimes':'\\u2297','Otimes':'\\u2A37','otimesas':'\\u2A36','ouml':'\\xF6','Ouml':'\\xD6','ovbar':'\\u233D','OverBar':'\\u203E','OverBrace':'\\u23DE','OverBracket':'\\u23B4','OverParenthesis':'\\u23DC','par':'\\u2225','para':'\\xB6','parallel':'\\u2225','parsim':'\\u2AF3','parsl':'\\u2AFD','part':'\\u2202','PartialD':'\\u2202','pcy':'\\u043F','Pcy':'\\u041F','percnt':'%','period':'.','permil':'\\u2030','perp':'\\u22A5','pertenk':'\\u2031','pfr':'\\uD835\\uDD2D','Pfr':'\\uD835\\uDD13','phi':'\\u03C6','Phi':'\\u03A6','phiv':'\\u03D5','phmmat':'\\u2133','phone':'\\u260E','pi':'\\u03C0','Pi':'\\u03A0','pitchfork':'\\u22D4','piv':'\\u03D6','planck':'\\u210F','planckh':'\\u210E','plankv':'\\u210F','plus':'+','plusacir':'\\u2A23','plusb':'\\u229E','pluscir':'\\u2A22','plusdo':'\\u2214','plusdu':'\\u2A25','pluse':'\\u2A72','PlusMinus':'\\xB1','plusmn':'\\xB1','plussim':'\\u2A26','plustwo':'\\u2A27','pm':'\\xB1','Poincareplane':'\\u210C','pointint':'\\u2A15','popf':'\\uD835\\uDD61','Popf':'\\u2119','pound':'\\xA3','pr':'\\u227A','Pr':'\\u2ABB','prap':'\\u2AB7','prcue':'\\u227C','pre':'\\u2AAF','prE':'\\u2AB3','prec':'\\u227A','precapprox':'\\u2AB7','preccurlyeq':'\\u227C','Precedes':'\\u227A','PrecedesEqual':'\\u2AAF','PrecedesSlantEqual':'\\u227C','PrecedesTilde':'\\u227E','preceq':'\\u2AAF','precnapprox':'\\u2AB9','precneqq':'\\u2AB5','precnsim':'\\u22E8','precsim':'\\u227E','prime':'\\u2032','Prime':'\\u2033','primes':'\\u2119','prnap':'\\u2AB9','prnE':'\\u2AB5','prnsim':'\\u22E8','prod':'\\u220F','Product':'\\u220F','profalar':'\\u232E','profline':'\\u2312','profsurf':'\\u2313','prop':'\\u221D','Proportion':'\\u2237','Proportional':'\\u221D','propto':'\\u221D','prsim':'\\u227E','prurel':'\\u22B0','pscr':'\\uD835\\uDCC5','Pscr':'\\uD835\\uDCAB','psi':'\\u03C8','Psi':'\\u03A8','puncsp':'\\u2008','qfr':'\\uD835\\uDD2E','Qfr':'\\uD835\\uDD14','qint':'\\u2A0C','qopf':'\\uD835\\uDD62','Qopf':'\\u211A','qprime':'\\u2057','qscr':'\\uD835\\uDCC6','Qscr':'\\uD835\\uDCAC','quaternions':'\\u210D','quatint':'\\u2A16','quest':'?','questeq':'\\u225F','quot':'\"','QUOT':'\"','rAarr':'\\u21DB','race':'\\u223D\\u0331','racute':'\\u0155','Racute':'\\u0154','radic':'\\u221A','raemptyv':'\\u29B3','rang':'\\u27E9','Rang':'\\u27EB','rangd':'\\u2992','range':'\\u29A5','rangle':'\\u27E9','raquo':'\\xBB','rarr':'\\u2192','rArr':'\\u21D2','Rarr':'\\u21A0','rarrap':'\\u2975','rarrb':'\\u21E5','rarrbfs':'\\u2920','rarrc':'\\u2933','rarrfs':'\\u291E','rarrhk':'\\u21AA','rarrlp':'\\u21AC','rarrpl':'\\u2945','rarrsim':'\\u2974','rarrtl':'\\u21A3','Rarrtl':'\\u2916','rarrw':'\\u219D','ratail':'\\u291A','rAtail':'\\u291C','ratio':'\\u2236','rationals':'\\u211A','rbarr':'\\u290D','rBarr':'\\u290F','RBarr':'\\u2910','rbbrk':'\\u2773','rbrace':'}','rbrack':']','rbrke':'\\u298C','rbrksld':'\\u298E','rbrkslu':'\\u2990','rcaron':'\\u0159','Rcaron':'\\u0158','rcedil':'\\u0157','Rcedil':'\\u0156','rceil':'\\u2309','rcub':'}','rcy':'\\u0440','Rcy':'\\u0420','rdca':'\\u2937','rdldhar':'\\u2969','rdquo':'\\u201D','rdquor':'\\u201D','rdsh':'\\u21B3','Re':'\\u211C','real':'\\u211C','realine':'\\u211B','realpart':'\\u211C','reals':'\\u211D','rect':'\\u25AD','reg':'\\xAE','REG':'\\xAE','ReverseElement':'\\u220B','ReverseEquilibrium':'\\u21CB','ReverseUpEquilibrium':'\\u296F','rfisht':'\\u297D','rfloor':'\\u230B','rfr':'\\uD835\\uDD2F','Rfr':'\\u211C','rHar':'\\u2964','rhard':'\\u21C1','rharu':'\\u21C0','rharul':'\\u296C','rho':'\\u03C1','Rho':'\\u03A1','rhov':'\\u03F1','RightAngleBracket':'\\u27E9','rightarrow':'\\u2192','Rightarrow':'\\u21D2','RightArrow':'\\u2192','RightArrowBar':'\\u21E5','RightArrowLeftArrow':'\\u21C4','rightarrowtail':'\\u21A3','RightCeiling':'\\u2309','RightDoubleBracket':'\\u27E7','RightDownTeeVector':'\\u295D','RightDownVector':'\\u21C2','RightDownVectorBar':'\\u2955','RightFloor':'\\u230B','rightharpoondown':'\\u21C1','rightharpoonup':'\\u21C0','rightleftarrows':'\\u21C4','rightleftharpoons':'\\u21CC','rightrightarrows':'\\u21C9','rightsquigarrow':'\\u219D','RightTee':'\\u22A2','RightTeeArrow':'\\u21A6','RightTeeVector':'\\u295B','rightthreetimes':'\\u22CC','RightTriangle':'\\u22B3','RightTriangleBar':'\\u29D0','RightTriangleEqual':'\\u22B5','RightUpDownVector':'\\u294F','RightUpTeeVector':'\\u295C','RightUpVector':'\\u21BE','RightUpVectorBar':'\\u2954','RightVector':'\\u21C0','RightVectorBar':'\\u2953','ring':'\\u02DA','risingdotseq':'\\u2253','rlarr':'\\u21C4','rlhar':'\\u21CC','rlm':'\\u200F','rmoust':'\\u23B1','rmoustache':'\\u23B1','rnmid':'\\u2AEE','roang':'\\u27ED','roarr':'\\u21FE','robrk':'\\u27E7','ropar':'\\u2986','ropf':'\\uD835\\uDD63','Ropf':'\\u211D','roplus':'\\u2A2E','rotimes':'\\u2A35','RoundImplies':'\\u2970','rpar':')','rpargt':'\\u2994','rppolint':'\\u2A12','rrarr':'\\u21C9','Rrightarrow':'\\u21DB','rsaquo':'\\u203A','rscr':'\\uD835\\uDCC7','Rscr':'\\u211B','rsh':'\\u21B1','Rsh':'\\u21B1','rsqb':']','rsquo':'\\u2019','rsquor':'\\u2019','rthree':'\\u22CC','rtimes':'\\u22CA','rtri':'\\u25B9','rtrie':'\\u22B5','rtrif':'\\u25B8','rtriltri':'\\u29CE','RuleDelayed':'\\u29F4','ruluhar':'\\u2968','rx':'\\u211E','sacute':'\\u015B','Sacute':'\\u015A','sbquo':'\\u201A','sc':'\\u227B','Sc':'\\u2ABC','scap':'\\u2AB8','scaron':'\\u0161','Scaron':'\\u0160','sccue':'\\u227D','sce':'\\u2AB0','scE':'\\u2AB4','scedil':'\\u015F','Scedil':'\\u015E','scirc':'\\u015D','Scirc':'\\u015C','scnap':'\\u2ABA','scnE':'\\u2AB6','scnsim':'\\u22E9','scpolint':'\\u2A13','scsim':'\\u227F','scy':'\\u0441','Scy':'\\u0421','sdot':'\\u22C5','sdotb':'\\u22A1','sdote':'\\u2A66','searhk':'\\u2925','searr':'\\u2198','seArr':'\\u21D8','searrow':'\\u2198','sect':'\\xA7','semi':';','seswar':'\\u2929','setminus':'\\u2216','setmn':'\\u2216','sext':'\\u2736','sfr':'\\uD835\\uDD30','Sfr':'\\uD835\\uDD16','sfrown':'\\u2322','sharp':'\\u266F','shchcy':'\\u0449','SHCHcy':'\\u0429','shcy':'\\u0448','SHcy':'\\u0428','ShortDownArrow':'\\u2193','ShortLeftArrow':'\\u2190','shortmid':'\\u2223','shortparallel':'\\u2225','ShortRightArrow':'\\u2192','ShortUpArrow':'\\u2191','shy':'\\xAD','sigma':'\\u03C3','Sigma':'\\u03A3','sigmaf':'\\u03C2','sigmav':'\\u03C2','sim':'\\u223C','simdot':'\\u2A6A','sime':'\\u2243','simeq':'\\u2243','simg':'\\u2A9E','simgE':'\\u2AA0','siml':'\\u2A9D','simlE':'\\u2A9F','simne':'\\u2246','simplus':'\\u2A24','simrarr':'\\u2972','slarr':'\\u2190','SmallCircle':'\\u2218','smallsetminus':'\\u2216','smashp':'\\u2A33','smeparsl':'\\u29E4','smid':'\\u2223','smile':'\\u2323','smt':'\\u2AAA','smte':'\\u2AAC','smtes':'\\u2AAC\\uFE00','softcy':'\\u044C','SOFTcy':'\\u042C','sol':'/','solb':'\\u29C4','solbar':'\\u233F','sopf':'\\uD835\\uDD64','Sopf':'\\uD835\\uDD4A','spades':'\\u2660','spadesuit':'\\u2660','spar':'\\u2225','sqcap':'\\u2293','sqcaps':'\\u2293\\uFE00','sqcup':'\\u2294','sqcups':'\\u2294\\uFE00','Sqrt':'\\u221A','sqsub':'\\u228F','sqsube':'\\u2291','sqsubset':'\\u228F','sqsubseteq':'\\u2291','sqsup':'\\u2290','sqsupe':'\\u2292','sqsupset':'\\u2290','sqsupseteq':'\\u2292','squ':'\\u25A1','square':'\\u25A1','Square':'\\u25A1','SquareIntersection':'\\u2293','SquareSubset':'\\u228F','SquareSubsetEqual':'\\u2291','SquareSuperset':'\\u2290','SquareSupersetEqual':'\\u2292','SquareUnion':'\\u2294','squarf':'\\u25AA','squf':'\\u25AA','srarr':'\\u2192','sscr':'\\uD835\\uDCC8','Sscr':'\\uD835\\uDCAE','ssetmn':'\\u2216','ssmile':'\\u2323','sstarf':'\\u22C6','star':'\\u2606','Star':'\\u22C6','starf':'\\u2605','straightepsilon':'\\u03F5','straightphi':'\\u03D5','strns':'\\xAF','sub':'\\u2282','Sub':'\\u22D0','subdot':'\\u2ABD','sube':'\\u2286','subE':'\\u2AC5','subedot':'\\u2AC3','submult':'\\u2AC1','subne':'\\u228A','subnE':'\\u2ACB','subplus':'\\u2ABF','subrarr':'\\u2979','subset':'\\u2282','Subset':'\\u22D0','subseteq':'\\u2286','subseteqq':'\\u2AC5','SubsetEqual':'\\u2286','subsetneq':'\\u228A','subsetneqq':'\\u2ACB','subsim':'\\u2AC7','subsub':'\\u2AD5','subsup':'\\u2AD3','succ':'\\u227B','succapprox':'\\u2AB8','succcurlyeq':'\\u227D','Succeeds':'\\u227B','SucceedsEqual':'\\u2AB0','SucceedsSlantEqual':'\\u227D','SucceedsTilde':'\\u227F','succeq':'\\u2AB0','succnapprox':'\\u2ABA','succneqq':'\\u2AB6','succnsim':'\\u22E9','succsim':'\\u227F','SuchThat':'\\u220B','sum':'\\u2211','Sum':'\\u2211','sung':'\\u266A','sup':'\\u2283','Sup':'\\u22D1','sup1':'\\xB9','sup2':'\\xB2','sup3':'\\xB3','supdot':'\\u2ABE','supdsub':'\\u2AD8','supe':'\\u2287','supE':'\\u2AC6','supedot':'\\u2AC4','Superset':'\\u2283','SupersetEqual':'\\u2287','suphsol':'\\u27C9','suphsub':'\\u2AD7','suplarr':'\\u297B','supmult':'\\u2AC2','supne':'\\u228B','supnE':'\\u2ACC','supplus':'\\u2AC0','supset':'\\u2283','Supset':'\\u22D1','supseteq':'\\u2287','supseteqq':'\\u2AC6','supsetneq':'\\u228B','supsetneqq':'\\u2ACC','supsim':'\\u2AC8','supsub':'\\u2AD4','supsup':'\\u2AD6','swarhk':'\\u2926','swarr':'\\u2199','swArr':'\\u21D9','swarrow':'\\u2199','swnwar':'\\u292A','szlig':'\\xDF','Tab':'\\t','target':'\\u2316','tau':'\\u03C4','Tau':'\\u03A4','tbrk':'\\u23B4','tcaron':'\\u0165','Tcaron':'\\u0164','tcedil':'\\u0163','Tcedil':'\\u0162','tcy':'\\u0442','Tcy':'\\u0422','tdot':'\\u20DB','telrec':'\\u2315','tfr':'\\uD835\\uDD31','Tfr':'\\uD835\\uDD17','there4':'\\u2234','therefore':'\\u2234','Therefore':'\\u2234','theta':'\\u03B8','Theta':'\\u0398','thetasym':'\\u03D1','thetav':'\\u03D1','thickapprox':'\\u2248','thicksim':'\\u223C','ThickSpace':'\\u205F\\u200A','thinsp':'\\u2009','ThinSpace':'\\u2009','thkap':'\\u2248','thksim':'\\u223C','thorn':'\\xFE','THORN':'\\xDE','tilde':'\\u02DC','Tilde':'\\u223C','TildeEqual':'\\u2243','TildeFullEqual':'\\u2245','TildeTilde':'\\u2248','times':'\\xD7','timesb':'\\u22A0','timesbar':'\\u2A31','timesd':'\\u2A30','tint':'\\u222D','toea':'\\u2928','top':'\\u22A4','topbot':'\\u2336','topcir':'\\u2AF1','topf':'\\uD835\\uDD65','Topf':'\\uD835\\uDD4B','topfork':'\\u2ADA','tosa':'\\u2929','tprime':'\\u2034','trade':'\\u2122','TRADE':'\\u2122','triangle':'\\u25B5','triangledown':'\\u25BF','triangleleft':'\\u25C3','trianglelefteq':'\\u22B4','triangleq':'\\u225C','triangleright':'\\u25B9','trianglerighteq':'\\u22B5','tridot':'\\u25EC','trie':'\\u225C','triminus':'\\u2A3A','TripleDot':'\\u20DB','triplus':'\\u2A39','trisb':'\\u29CD','tritime':'\\u2A3B','trpezium':'\\u23E2','tscr':'\\uD835\\uDCC9','Tscr':'\\uD835\\uDCAF','tscy':'\\u0446','TScy':'\\u0426','tshcy':'\\u045B','TSHcy':'\\u040B','tstrok':'\\u0167','Tstrok':'\\u0166','twixt':'\\u226C','twoheadleftarrow':'\\u219E','twoheadrightarrow':'\\u21A0','uacute':'\\xFA','Uacute':'\\xDA','uarr':'\\u2191','uArr':'\\u21D1','Uarr':'\\u219F','Uarrocir':'\\u2949','ubrcy':'\\u045E','Ubrcy':'\\u040E','ubreve':'\\u016D','Ubreve':'\\u016C','ucirc':'\\xFB','Ucirc':'\\xDB','ucy':'\\u0443','Ucy':'\\u0423','udarr':'\\u21C5','udblac':'\\u0171','Udblac':'\\u0170','udhar':'\\u296E','ufisht':'\\u297E','ufr':'\\uD835\\uDD32','Ufr':'\\uD835\\uDD18','ugrave':'\\xF9','Ugrave':'\\xD9','uHar':'\\u2963','uharl':'\\u21BF','uharr':'\\u21BE','uhblk':'\\u2580','ulcorn':'\\u231C','ulcorner':'\\u231C','ulcrop':'\\u230F','ultri':'\\u25F8','umacr':'\\u016B','Umacr':'\\u016A','uml':'\\xA8','UnderBar':'_','UnderBrace':'\\u23DF','UnderBracket':'\\u23B5','UnderParenthesis':'\\u23DD','Union':'\\u22C3','UnionPlus':'\\u228E','uogon':'\\u0173','Uogon':'\\u0172','uopf':'\\uD835\\uDD66','Uopf':'\\uD835\\uDD4C','uparrow':'\\u2191','Uparrow':'\\u21D1','UpArrow':'\\u2191','UpArrowBar':'\\u2912','UpArrowDownArrow':'\\u21C5','updownarrow':'\\u2195','Updownarrow':'\\u21D5','UpDownArrow':'\\u2195','UpEquilibrium':'\\u296E','upharpoonleft':'\\u21BF','upharpoonright':'\\u21BE','uplus':'\\u228E','UpperLeftArrow':'\\u2196','UpperRightArrow':'\\u2197','upsi':'\\u03C5','Upsi':'\\u03D2','upsih':'\\u03D2','upsilon':'\\u03C5','Upsilon':'\\u03A5','UpTee':'\\u22A5','UpTeeArrow':'\\u21A5','upuparrows':'\\u21C8','urcorn':'\\u231D','urcorner':'\\u231D','urcrop':'\\u230E','uring':'\\u016F','Uring':'\\u016E','urtri':'\\u25F9','uscr':'\\uD835\\uDCCA','Uscr':'\\uD835\\uDCB0','utdot':'\\u22F0','utilde':'\\u0169','Utilde':'\\u0168','utri':'\\u25B5','utrif':'\\u25B4','uuarr':'\\u21C8','uuml':'\\xFC','Uuml':'\\xDC','uwangle':'\\u29A7','vangrt':'\\u299C','varepsilon':'\\u03F5','varkappa':'\\u03F0','varnothing':'\\u2205','varphi':'\\u03D5','varpi':'\\u03D6','varpropto':'\\u221D','varr':'\\u2195','vArr':'\\u21D5','varrho':'\\u03F1','varsigma':'\\u03C2','varsubsetneq':'\\u228A\\uFE00','varsubsetneqq':'\\u2ACB\\uFE00','varsupsetneq':'\\u228B\\uFE00','varsupsetneqq':'\\u2ACC\\uFE00','vartheta':'\\u03D1','vartriangleleft':'\\u22B2','vartriangleright':'\\u22B3','vBar':'\\u2AE8','Vbar':'\\u2AEB','vBarv':'\\u2AE9','vcy':'\\u0432','Vcy':'\\u0412','vdash':'\\u22A2','vDash':'\\u22A8','Vdash':'\\u22A9','VDash':'\\u22AB','Vdashl':'\\u2AE6','vee':'\\u2228','Vee':'\\u22C1','veebar':'\\u22BB','veeeq':'\\u225A','vellip':'\\u22EE','verbar':'|','Verbar':'\\u2016','vert':'|','Vert':'\\u2016','VerticalBar':'\\u2223','VerticalLine':'|','VerticalSeparator':'\\u2758','VerticalTilde':'\\u2240','VeryThinSpace':'\\u200A','vfr':'\\uD835\\uDD33','Vfr':'\\uD835\\uDD19','vltri':'\\u22B2','vnsub':'\\u2282\\u20D2','vnsup':'\\u2283\\u20D2','vopf':'\\uD835\\uDD67','Vopf':'\\uD835\\uDD4D','vprop':'\\u221D','vrtri':'\\u22B3','vscr':'\\uD835\\uDCCB','Vscr':'\\uD835\\uDCB1','vsubne':'\\u228A\\uFE00','vsubnE':'\\u2ACB\\uFE00','vsupne':'\\u228B\\uFE00','vsupnE':'\\u2ACC\\uFE00','Vvdash':'\\u22AA','vzigzag':'\\u299A','wcirc':'\\u0175','Wcirc':'\\u0174','wedbar':'\\u2A5F','wedge':'\\u2227','Wedge':'\\u22C0','wedgeq':'\\u2259','weierp':'\\u2118','wfr':'\\uD835\\uDD34','Wfr':'\\uD835\\uDD1A','wopf':'\\uD835\\uDD68','Wopf':'\\uD835\\uDD4E','wp':'\\u2118','wr':'\\u2240','wreath':'\\u2240','wscr':'\\uD835\\uDCCC','Wscr':'\\uD835\\uDCB2','xcap':'\\u22C2','xcirc':'\\u25EF','xcup':'\\u22C3','xdtri':'\\u25BD','xfr':'\\uD835\\uDD35','Xfr':'\\uD835\\uDD1B','xharr':'\\u27F7','xhArr':'\\u27FA','xi':'\\u03BE','Xi':'\\u039E','xlarr':'\\u27F5','xlArr':'\\u27F8','xmap':'\\u27FC','xnis':'\\u22FB','xodot':'\\u2A00','xopf':'\\uD835\\uDD69','Xopf':'\\uD835\\uDD4F','xoplus':'\\u2A01','xotime':'\\u2A02','xrarr':'\\u27F6','xrArr':'\\u27F9','xscr':'\\uD835\\uDCCD','Xscr':'\\uD835\\uDCB3','xsqcup':'\\u2A06','xuplus':'\\u2A04','xutri':'\\u25B3','xvee':'\\u22C1','xwedge':'\\u22C0','yacute':'\\xFD','Yacute':'\\xDD','yacy':'\\u044F','YAcy':'\\u042F','ycirc':'\\u0177','Ycirc':'\\u0176','ycy':'\\u044B','Ycy':'\\u042B','yen':'\\xA5','yfr':'\\uD835\\uDD36','Yfr':'\\uD835\\uDD1C','yicy':'\\u0457','YIcy':'\\u0407','yopf':'\\uD835\\uDD6A','Yopf':'\\uD835\\uDD50','yscr':'\\uD835\\uDCCE','Yscr':'\\uD835\\uDCB4','yucy':'\\u044E','YUcy':'\\u042E','yuml':'\\xFF','Yuml':'\\u0178','zacute':'\\u017A','Zacute':'\\u0179','zcaron':'\\u017E','Zcaron':'\\u017D','zcy':'\\u0437','Zcy':'\\u0417','zdot':'\\u017C','Zdot':'\\u017B','zeetrf':'\\u2128','ZeroWidthSpace':'\\u200B','zeta':'\\u03B6','Zeta':'\\u0396','zfr':'\\uD835\\uDD37','Zfr':'\\u2128','zhcy':'\\u0436','ZHcy':'\\u0416','zigrarr':'\\u21DD','zopf':'\\uD835\\uDD6B','Zopf':'\\u2124','zscr':'\\uD835\\uDCCF','Zscr':'\\uD835\\uDCB5','zwj':'\\u200D','zwnj':'\\u200C'};\r\n\tvar decodeMapLegacy = {'aacute':'\\xE1','Aacute':'\\xC1','acirc':'\\xE2','Acirc':'\\xC2','acute':'\\xB4','aelig':'\\xE6','AElig':'\\xC6','agrave':'\\xE0','Agrave':'\\xC0','amp':'&','AMP':'&','aring':'\\xE5','Aring':'\\xC5','atilde':'\\xE3','Atilde':'\\xC3','auml':'\\xE4','Auml':'\\xC4','brvbar':'\\xA6','ccedil':'\\xE7','Ccedil':'\\xC7','cedil':'\\xB8','cent':'\\xA2','copy':'\\xA9','COPY':'\\xA9','curren':'\\xA4','deg':'\\xB0','divide':'\\xF7','eacute':'\\xE9','Eacute':'\\xC9','ecirc':'\\xEA','Ecirc':'\\xCA','egrave':'\\xE8','Egrave':'\\xC8','eth':'\\xF0','ETH':'\\xD0','euml':'\\xEB','Euml':'\\xCB','frac12':'\\xBD','frac14':'\\xBC','frac34':'\\xBE','gt':'>','GT':'>','iacute':'\\xED','Iacute':'\\xCD','icirc':'\\xEE','Icirc':'\\xCE','iexcl':'\\xA1','igrave':'\\xEC','Igrave':'\\xCC','iquest':'\\xBF','iuml':'\\xEF','Iuml':'\\xCF','laquo':'\\xAB','lt':'<','LT':'<','macr':'\\xAF','micro':'\\xB5','middot':'\\xB7','nbsp':'\\xA0','not':'\\xAC','ntilde':'\\xF1','Ntilde':'\\xD1','oacute':'\\xF3','Oacute':'\\xD3','ocirc':'\\xF4','Ocirc':'\\xD4','ograve':'\\xF2','Ograve':'\\xD2','ordf':'\\xAA','ordm':'\\xBA','oslash':'\\xF8','Oslash':'\\xD8','otilde':'\\xF5','Otilde':'\\xD5','ouml':'\\xF6','Ouml':'\\xD6','para':'\\xB6','plusmn':'\\xB1','pound':'\\xA3','quot':'\"','QUOT':'\"','raquo':'\\xBB','reg':'\\xAE','REG':'\\xAE','sect':'\\xA7','shy':'\\xAD','sup1':'\\xB9','sup2':'\\xB2','sup3':'\\xB3','szlig':'\\xDF','thorn':'\\xFE','THORN':'\\xDE','times':'\\xD7','uacute':'\\xFA','Uacute':'\\xDA','ucirc':'\\xFB','Ucirc':'\\xDB','ugrave':'\\xF9','Ugrave':'\\xD9','uml':'\\xA8','uuml':'\\xFC','Uuml':'\\xDC','yacute':'\\xFD','Yacute':'\\xDD','yen':'\\xA5','yuml':'\\xFF'};\r\n\tvar decodeMapNumeric = {'0':'\\uFFFD','128':'\\u20AC','130':'\\u201A','131':'\\u0192','132':'\\u201E','133':'\\u2026','134':'\\u2020','135':'\\u2021','136':'\\u02C6','137':'\\u2030','138':'\\u0160','139':'\\u2039','140':'\\u0152','142':'\\u017D','145':'\\u2018','146':'\\u2019','147':'\\u201C','148':'\\u201D','149':'\\u2022','150':'\\u2013','151':'\\u2014','152':'\\u02DC','153':'\\u2122','154':'\\u0161','155':'\\u203A','156':'\\u0153','158':'\\u017E','159':'\\u0178'};\r\n\tvar invalidReferenceCodePoints = [1,2,3,4,5,6,7,8,11,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,64976,64977,64978,64979,64980,64981,64982,64983,64984,64985,64986,64987,64988,64989,64990,64991,64992,64993,64994,64995,64996,64997,64998,64999,65000,65001,65002,65003,65004,65005,65006,65007,65534,65535,131070,131071,196606,196607,262142,262143,327678,327679,393214,393215,458750,458751,524286,524287,589822,589823,655358,655359,720894,720895,786430,786431,851966,851967,917502,917503,983038,983039,1048574,1048575,1114110,1114111];\r\n\r\n\t/*--------------------------------------------------------------------------*/\r\n\r\n\tvar stringFromCharCode = String.fromCharCode;\r\n\r\n\tvar object = {};\r\n\tvar hasOwnProperty = object.hasOwnProperty;\r\n\tvar has = function(object, propertyName) {\r\n\t\treturn hasOwnProperty.call(object, propertyName);\r\n\t};\r\n\r\n\tvar contains = function(array, value) {\r\n\t\tvar index = -1;\r\n\t\tvar length = array.length;\r\n\t\twhile (++index < length) {\r\n\t\t\tif (array[index] == value) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t};\r\n\r\n\tvar merge = function(options, defaults) {\r\n\t\tif (!options) {\r\n\t\t\treturn defaults;\r\n\t\t}\r\n\t\tvar result = {};\r\n\t\tvar key;\r\n\t\tfor (key in defaults) {\r\n\t\t\t// A `hasOwnProperty` check is not needed here, since only recognized\r\n\t\t\t// option names are used anyway. Any others are ignored.\r\n\t\t\tresult[key] = has(options, key) ? options[key] : defaults[key];\r\n\t\t}\r\n\t\treturn result;\r\n\t};\r\n\r\n\t// Modified version of `ucs2encode`; see https://mths.be/punycode.\r\n\tvar codePointToSymbol = function(codePoint, strict) {\r\n\t\tvar output = '';\r\n\t\tif ((codePoint >= 0xD800 && codePoint <= 0xDFFF) || codePoint > 0x10FFFF) {\r\n\t\t\t// See issue #4:\r\n\t\t\t// Otherwise, if the number is in the range 0xD800 to 0xDFFF or is\r\n\t\t\t// greater than 0x10FFFF, then this is a parse error. Return a U+FFFD\r\n\t\t\t// REPLACEMENT CHARACTER.\r\n\t\t\tif (strict) {\r\n\t\t\t\tparseError('character reference outside the permissible Unicode range');\r\n\t\t\t}\r\n\t\t\treturn '\\uFFFD';\r\n\t\t}\r\n\t\tif (has(decodeMapNumeric, codePoint)) {\r\n\t\t\tif (strict) {\r\n\t\t\t\tparseError('disallowed character reference');\r\n\t\t\t}\r\n\t\t\treturn decodeMapNumeric[codePoint];\r\n\t\t}\r\n\t\tif (strict && contains(invalidReferenceCodePoints, codePoint)) {\r\n\t\t\tparseError('disallowed character reference');\r\n\t\t}\r\n\t\tif (codePoint > 0xFFFF) {\r\n\t\t\tcodePoint -= 0x10000;\r\n\t\t\toutput += stringFromCharCode(codePoint >>> 10 & 0x3FF | 0xD800);\r\n\t\t\tcodePoint = 0xDC00 | codePoint & 0x3FF;\r\n\t\t}\r\n\t\toutput += stringFromCharCode(codePoint);\r\n\t\treturn output;\r\n\t};\r\n\r\n\tvar hexEscape = function(codePoint) {\r\n\t\treturn '&#x' + codePoint.toString(16).toUpperCase() + ';';\r\n\t};\r\n\r\n\tvar decEscape = function(codePoint) {\r\n\t\treturn '&#' + codePoint + ';';\r\n\t};\r\n\r\n\tvar parseError = function(message) {\r\n\t\tthrow Error('Parse error: ' + message);\r\n\t};\r\n\r\n\t/*--------------------------------------------------------------------------*/\r\n\r\n\tvar encode = function(string, options) {\r\n\t\toptions = merge(options, encode.options);\r\n\t\tvar strict = options.strict;\r\n\t\tif (strict && regexInvalidRawCodePoint.test(string)) {\r\n\t\t\tparseError('forbidden code point');\r\n\t\t}\r\n\t\tvar encodeEverything = options.encodeEverything;\r\n\t\tvar useNamedReferences = options.useNamedReferences;\r\n\t\tvar allowUnsafeSymbols = options.allowUnsafeSymbols;\r\n\t\tvar escapeCodePoint = options.decimal ? decEscape : hexEscape;\r\n\r\n\t\tvar escapeBmpSymbol = function(symbol) {\r\n\t\t\treturn escapeCodePoint(symbol.charCodeAt(0));\r\n\t\t};\r\n\r\n\t\tif (encodeEverything) {\r\n\t\t\t// Encode ASCII symbols.\r\n\t\t\tstring = string.replace(regexAsciiWhitelist, function(symbol) {\r\n\t\t\t\t// Use named references if requested & possible.\r\n\t\t\t\tif (useNamedReferences && has(encodeMap, symbol)) {\r\n\t\t\t\t\treturn '&' + encodeMap[symbol] + ';';\r\n\t\t\t\t}\r\n\t\t\t\treturn escapeBmpSymbol(symbol);\r\n\t\t\t});\r\n\t\t\t// Shorten a few escapes that represent two symbols, of which at least one\r\n\t\t\t// is within the ASCII range.\r\n\t\t\tif (useNamedReferences) {\r\n\t\t\t\tstring = string\r\n\t\t\t\t\t.replace(/&gt;\\u20D2/g, '&nvgt;')\r\n\t\t\t\t\t.replace(/&lt;\\u20D2/g, '&nvlt;')\r\n\t\t\t\t\t.replace(/&#x66;&#x6A;/g, '&fjlig;');\r\n\t\t\t}\r\n\t\t\t// Encode non-ASCII symbols.\r\n\t\t\tif (useNamedReferences) {\r\n\t\t\t\t// Encode non-ASCII symbols that can be replaced with a named reference.\r\n\t\t\t\tstring = string.replace(regexEncodeNonAscii, function(string) {\r\n\t\t\t\t\t// Note: there is no need to check `has(encodeMap, string)` here.\r\n\t\t\t\t\treturn '&' + encodeMap[string] + ';';\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\t// Note: any remaining non-ASCII symbols are handled outside of the `if`.\r\n\t\t} else if (useNamedReferences) {\r\n\t\t\t// Apply named character references.\r\n\t\t\t// Encode `<>\"'&` using named character references.\r\n\t\t\tif (!allowUnsafeSymbols) {\r\n\t\t\t\tstring = string.replace(regexEscape, function(string) {\r\n\t\t\t\t\treturn '&' + encodeMap[string] + ';'; // no need to check `has()` here\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\t// Shorten escapes that represent two symbols, of which at least one is\r\n\t\t\t// `<>\"'&`.\r\n\t\t\tstring = string\r\n\t\t\t\t.replace(/&gt;\\u20D2/g, '&nvgt;')\r\n\t\t\t\t.replace(/&lt;\\u20D2/g, '&nvlt;');\r\n\t\t\t// Encode non-ASCII symbols that can be replaced with a named reference.\r\n\t\t\tstring = string.replace(regexEncodeNonAscii, function(string) {\r\n\t\t\t\t// Note: there is no need to check `has(encodeMap, string)` here.\r\n\t\t\t\treturn '&' + encodeMap[string] + ';';\r\n\t\t\t});\r\n\t\t} else if (!allowUnsafeSymbols) {\r\n\t\t\t// Encode `<>\"'&` using hexadecimal escapes, now that theyre not handled\r\n\t\t\t// using named character references.\r\n\t\t\tstring = string.replace(regexEscape, escapeBmpSymbol);\r\n\t\t}\r\n\t\treturn string\r\n\t\t\t// Encode astral symbols.\r\n\t\t\t.replace(regexAstralSymbols, function($0) {\r\n\t\t\t\t// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\r\n\t\t\t\tvar high = $0.charCodeAt(0);\r\n\t\t\t\tvar low = $0.charCodeAt(1);\r\n\t\t\t\tvar codePoint = (high - 0xD800) * 0x400 + low - 0xDC00 + 0x10000;\r\n\t\t\t\treturn escapeCodePoint(codePoint);\r\n\t\t\t})\r\n\t\t\t// Encode any remaining BMP symbols that are not printable ASCII symbols\r\n\t\t\t// using a hexadecimal escape.\r\n\t\t\t.replace(regexBmpWhitelist, escapeBmpSymbol);\r\n\t};\r\n\t// Expose default options (so they can be overridden globally).\r\n\tencode.options = {\r\n\t\t'allowUnsafeSymbols': false,\r\n\t\t'encodeEverything': false,\r\n\t\t'strict': false,\r\n\t\t'useNamedReferences': false,\r\n\t\t'decimal' : false\r\n\t};\r\n\r\n\tvar decode = function(html, options) {\r\n\t\toptions = merge(options, decode.options);\r\n\t\tvar strict = options.strict;\r\n\t\tif (strict && regexInvalidEntity.test(html)) {\r\n\t\t\tparseError('malformed character reference');\r\n\t\t}\r\n\t\treturn html.replace(regexDecode, function($0, $1, $2, $3, $4, $5, $6, $7, $8) {\r\n\t\t\tvar codePoint;\r\n\t\t\tvar semicolon;\r\n\t\t\tvar decDigits;\r\n\t\t\tvar hexDigits;\r\n\t\t\tvar reference;\r\n\t\t\tvar next;\r\n\r\n\t\t\tif ($1) {\r\n\t\t\t\treference = $1;\r\n\t\t\t\t// Note: there is no need to check `has(decodeMap, reference)`.\r\n\t\t\t\treturn decodeMap[reference];\r\n\t\t\t}\r\n\r\n\t\t\tif ($2) {\r\n\t\t\t\t// Decode named character references without trailing `;`, e.g. `&amp`.\r\n\t\t\t\t// This is only a parse error if it gets converted to `&`, or if it is\r\n\t\t\t\t// followed by `=` in an attribute context.\r\n\t\t\t\treference = $2;\r\n\t\t\t\tnext = $3;\r\n\t\t\t\tif (next && options.isAttributeValue) {\r\n\t\t\t\t\tif (strict && next == '=') {\r\n\t\t\t\t\t\tparseError('`&` did not start a character reference');\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn $0;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (strict) {\r\n\t\t\t\t\t\tparseError(\r\n\t\t\t\t\t\t\t'named character reference was not terminated by a semicolon'\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// Note: there is no need to check `has(decodeMapLegacy, reference)`.\r\n\t\t\t\t\treturn decodeMapLegacy[reference] + (next || '');\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif ($4) {\r\n\t\t\t\t// Decode decimal escapes, e.g. `&#119558;`.\r\n\t\t\t\tdecDigits = $4;\r\n\t\t\t\tsemicolon = $5;\r\n\t\t\t\tif (strict && !semicolon) {\r\n\t\t\t\t\tparseError('character reference was not terminated by a semicolon');\r\n\t\t\t\t}\r\n\t\t\t\tcodePoint = parseInt(decDigits, 10);\r\n\t\t\t\treturn codePointToSymbol(codePoint, strict);\r\n\t\t\t}\r\n\r\n\t\t\tif ($6) {\r\n\t\t\t\t// Decode hexadecimal escapes, e.g. `&#x1D306;`.\r\n\t\t\t\thexDigits = $6;\r\n\t\t\t\tsemicolon = $7;\r\n\t\t\t\tif (strict && !semicolon) {\r\n\t\t\t\t\tparseError('character reference was not terminated by a semicolon');\r\n\t\t\t\t}\r\n\t\t\t\tcodePoint = parseInt(hexDigits, 16);\r\n\t\t\t\treturn codePointToSymbol(codePoint, strict);\r\n\t\t\t}\r\n\r\n\t\t\t// If were still here, `if ($7)` is implied; its an ambiguous\r\n\t\t\t// ampersand for sure. https://mths.be/notes/ambiguous-ampersands\r\n\t\t\tif (strict) {\r\n\t\t\t\tparseError(\r\n\t\t\t\t\t'named character reference was not terminated by a semicolon'\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t\treturn $0;\r\n\t\t});\r\n\t};\r\n\t// Expose default options (so they can be overridden globally).\r\n\tdecode.options = {\r\n\t\t'isAttributeValue': false,\r\n\t\t'strict': false\r\n\t};\r\n\r\n\tvar escape = function(string) {\r\n\t\treturn string.replace(regexEscape, function($0) {\r\n\t\t\t// Note: there is no need to check `has(escapeMap, $0)` here.\r\n\t\t\treturn escapeMap[$0];\r\n\t\t});\r\n\t};\r\n\r\n\t/*--------------------------------------------------------------------------*/\r\n\r\n\tvar he = {\r\n\t\t'version': '1.2.0',\r\n\t\t'encode': encode,\r\n\t\t'decode': decode,\r\n\t\t'escape': escape,\r\n\t\t'unescape': decode\r\n\t};\r\n\r\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\r\n\t// like the following:\r\n\tif (\r\n\t\ttrue\r\n\t) {\r\n\t\t!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\r\n\t\t\treturn he;\r\n\t\t}).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t}\telse { var key; }\r\n\r\n}(this));\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module), __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/he/he.js?");

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.read = function (buffer, offset, isLE, mLen, nBytes) {\r\n  var e, m\r\n  var eLen = (nBytes * 8) - mLen - 1\r\n  var eMax = (1 << eLen) - 1\r\n  var eBias = eMax >> 1\r\n  var nBits = -7\r\n  var i = isLE ? (nBytes - 1) : 0\r\n  var d = isLE ? -1 : 1\r\n  var s = buffer[offset + i]\r\n\r\n  i += d\r\n\r\n  e = s & ((1 << (-nBits)) - 1)\r\n  s >>= (-nBits)\r\n  nBits += eLen\r\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\r\n\r\n  m = e & ((1 << (-nBits)) - 1)\r\n  e >>= (-nBits)\r\n  nBits += mLen\r\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\r\n\r\n  if (e === 0) {\r\n    e = 1 - eBias\r\n  } else if (e === eMax) {\r\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\r\n  } else {\r\n    m = m + Math.pow(2, mLen)\r\n    e = e - eBias\r\n  }\r\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\r\n}\r\n\r\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\r\n  var e, m, c\r\n  var eLen = (nBytes * 8) - mLen - 1\r\n  var eMax = (1 << eLen) - 1\r\n  var eBias = eMax >> 1\r\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\r\n  var i = isLE ? 0 : (nBytes - 1)\r\n  var d = isLE ? 1 : -1\r\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\r\n\r\n  value = Math.abs(value)\r\n\r\n  if (isNaN(value) || value === Infinity) {\r\n    m = isNaN(value) ? 1 : 0\r\n    e = eMax\r\n  } else {\r\n    e = Math.floor(Math.log(value) / Math.LN2)\r\n    if (value * (c = Math.pow(2, -e)) < 1) {\r\n      e--\r\n      c *= 2\r\n    }\r\n    if (e + eBias >= 1) {\r\n      value += rt / c\r\n    } else {\r\n      value += rt * Math.pow(2, 1 - eBias)\r\n    }\r\n    if (value * c >= 2) {\r\n      e++\r\n      c /= 2\r\n    }\r\n\r\n    if (e + eBias >= eMax) {\r\n      m = 0\r\n      e = eMax\r\n    } else if (e + eBias >= 1) {\r\n      m = ((value * c) - 1) * Math.pow(2, mLen)\r\n      e = e + eBias\r\n    } else {\r\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\r\n      e = 0\r\n    }\r\n  }\r\n\r\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\r\n\r\n  e = (e << mLen) | m\r\n  eLen += mLen\r\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\r\n\r\n  buffer[offset + i - d] |= s * 128\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/ieee754/index.js?");

/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("if (typeof Object.create === 'function') {\r\n  // implementation from standard node.js 'util' module\r\n  module.exports = function inherits(ctor, superCtor) {\r\n    if (superCtor) {\r\n      ctor.super_ = superCtor\r\n      ctor.prototype = Object.create(superCtor.prototype, {\r\n        constructor: {\r\n          value: ctor,\r\n          enumerable: false,\r\n          writable: true,\r\n          configurable: true\r\n        }\r\n      })\r\n    }\r\n  };\r\n} else {\r\n  // old school shim for old browsers\r\n  module.exports = function inherits(ctor, superCtor) {\r\n    if (superCtor) {\r\n      ctor.super_ = superCtor\r\n      var TempCtor = function () {}\r\n      TempCtor.prototype = superCtor.prototype\r\n      ctor.prototype = new TempCtor()\r\n      ctor.prototype.constructor = ctor\r\n    }\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/inherits/inherits_browser.js?");

/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var toString = {}.toString;\r\n\r\nmodule.exports = Array.isArray || function (arr) {\r\n  return toString.call(arr) == '[object Array]';\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/isarray/index.js?");

/***/ }),

/***/ "./node_modules/mkdirp/index.js":
/*!**************************************!*\
  !*** ./node_modules/mkdirp/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var path = __webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\");\r\nvar fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\r\nvar _0777 = parseInt('0777', 8);\r\n\r\nmodule.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;\r\n\r\nfunction mkdirP (p, opts, f, made) {\r\n    if (typeof opts === 'function') {\r\n        f = opts;\r\n        opts = {};\r\n    }\r\n    else if (!opts || typeof opts !== 'object') {\r\n        opts = { mode: opts };\r\n    }\r\n    \r\n    var mode = opts.mode;\r\n    var xfs = opts.fs || fs;\r\n    \r\n    if (mode === undefined) {\r\n        mode = _0777\r\n    }\r\n    if (!made) made = null;\r\n    \r\n    var cb = f || function () {};\r\n    p = path.resolve(p);\r\n    \r\n    xfs.mkdir(p, mode, function (er) {\r\n        if (!er) {\r\n            made = made || p;\r\n            return cb(null, made);\r\n        }\r\n        switch (er.code) {\r\n            case 'ENOENT':\r\n                if (path.dirname(p) === p) return cb(er);\r\n                mkdirP(path.dirname(p), opts, function (er, made) {\r\n                    if (er) cb(er, made);\r\n                    else mkdirP(p, opts, cb, made);\r\n                });\r\n                break;\r\n\r\n            // In the case of any other error, just see if there's a dir\r\n            // there already.  If so, then hooray!  If not, then something\r\n            // is borked.\r\n            default:\r\n                xfs.stat(p, function (er2, stat) {\r\n                    // if the stat fails, then that's super weird.\r\n                    // let the original error be the failure reason.\r\n                    if (er2 || !stat.isDirectory()) cb(er, made)\r\n                    else cb(null, made);\r\n                });\r\n                break;\r\n        }\r\n    });\r\n}\r\n\r\nmkdirP.sync = function sync (p, opts, made) {\r\n    if (!opts || typeof opts !== 'object') {\r\n        opts = { mode: opts };\r\n    }\r\n    \r\n    var mode = opts.mode;\r\n    var xfs = opts.fs || fs;\r\n    \r\n    if (mode === undefined) {\r\n        mode = _0777\r\n    }\r\n    if (!made) made = null;\r\n\r\n    p = path.resolve(p);\r\n\r\n    try {\r\n        xfs.mkdirSync(p, mode);\r\n        made = made || p;\r\n    }\r\n    catch (err0) {\r\n        switch (err0.code) {\r\n            case 'ENOENT' :\r\n                made = sync(path.dirname(p), opts, made);\r\n                sync(p, opts, made);\r\n                break;\r\n\r\n            // In the case of any other error, just see if there's a dir\r\n            // there already.  If so, then hooray!  If not, then something\r\n            // is borked.\r\n            default:\r\n                var stat;\r\n                try {\r\n                    stat = xfs.statSync(p);\r\n                }\r\n                catch (err1) {\r\n                    throw err0;\r\n                }\r\n                if (!stat.isDirectory()) throw err0;\r\n                break;\r\n        }\r\n    }\r\n\r\n    return made;\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/mkdirp/index.js?");

/***/ }),

/***/ "./node_modules/mocha/browser-entry.js":
/*!*********************************************!*\
  !*** ./node_modules/mocha/browser-entry.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process, global) {\r\n\r\n/* eslint no-unused-vars: off */\r\n/* eslint-env commonjs */\r\n\r\n/**\r\n * Shim process.stdout.\r\n */\r\n\r\nprocess.stdout = __webpack_require__(/*! browser-stdout */ \"./node_modules/browser-stdout/index.js\")({label: false});\r\n\r\nvar Mocha = __webpack_require__(/*! ./lib/mocha */ \"./node_modules/mocha/lib/mocha.js\");\r\n\r\n/**\r\n * Create a Mocha instance.\r\n *\r\n * @return {undefined}\r\n */\r\n\r\nvar mocha = new Mocha({reporter: 'html'});\r\n\r\n/**\r\n * Save timer references to avoid Sinon interfering (see GH-237).\r\n */\r\n\r\nvar Date = global.Date;\r\nvar setTimeout = global.setTimeout;\r\nvar setInterval = global.setInterval;\r\nvar clearTimeout = global.clearTimeout;\r\nvar clearInterval = global.clearInterval;\r\n\r\nvar uncaughtExceptionHandlers = [];\r\n\r\nvar originalOnerrorHandler = global.onerror;\r\n\r\n/**\r\n * Remove uncaughtException listener.\r\n * Revert to original onerror handler if previously defined.\r\n */\r\n\r\nprocess.removeListener = function(e, fn) {\r\n  if (e === 'uncaughtException') {\r\n    if (originalOnerrorHandler) {\r\n      global.onerror = originalOnerrorHandler;\r\n    } else {\r\n      global.onerror = function() {};\r\n    }\r\n    var i = uncaughtExceptionHandlers.indexOf(fn);\r\n    if (i !== -1) {\r\n      uncaughtExceptionHandlers.splice(i, 1);\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Implements listenerCount for 'uncaughtException'.\r\n */\r\n\r\nprocess.listenerCount = function(name) {\r\n  if (name === 'uncaughtException') {\r\n    return uncaughtExceptionHandlers.length;\r\n  }\r\n  return 0;\r\n};\r\n\r\n/**\r\n * Implements uncaughtException listener.\r\n */\r\n\r\nprocess.on = function(e, fn) {\r\n  if (e === 'uncaughtException') {\r\n    global.onerror = function(err, url, line) {\r\n      fn(new Error(err + ' (' + url + ':' + line + ')'));\r\n      return !mocha.options.allowUncaught;\r\n    };\r\n    uncaughtExceptionHandlers.push(fn);\r\n  }\r\n};\r\n\r\n// The BDD UI is registered by default, but no UI will be functional in the\r\n// browser without an explicit call to the overridden `mocha.ui` (see below).\r\n// Ensure that this default UI does not expose its methods to the global scope.\r\nmocha.suite.removeAllListeners('pre-require');\r\n\r\nvar immediateQueue = [];\r\nvar immediateTimeout;\r\n\r\nfunction timeslice() {\r\n  var immediateStart = new Date().getTime();\r\n  while (immediateQueue.length && new Date().getTime() - immediateStart < 100) {\r\n    immediateQueue.shift()();\r\n  }\r\n  if (immediateQueue.length) {\r\n    immediateTimeout = setTimeout(timeslice, 0);\r\n  } else {\r\n    immediateTimeout = null;\r\n  }\r\n}\r\n\r\n/**\r\n * High-performance override of Runner.immediately.\r\n */\r\n\r\nMocha.Runner.immediately = function(callback) {\r\n  immediateQueue.push(callback);\r\n  if (!immediateTimeout) {\r\n    immediateTimeout = setTimeout(timeslice, 0);\r\n  }\r\n};\r\n\r\n/**\r\n * Function to allow assertion libraries to throw errors directly into mocha.\r\n * This is useful when running tests in a browser because window.onerror will\r\n * only receive the 'message' attribute of the Error.\r\n */\r\nmocha.throwError = function(err) {\r\n  uncaughtExceptionHandlers.forEach(function(fn) {\r\n    fn(err);\r\n  });\r\n  throw err;\r\n};\r\n\r\n/**\r\n * Override ui to ensure that the ui functions are initialized.\r\n * Normally this would happen in Mocha.prototype.loadFiles.\r\n */\r\n\r\nmocha.ui = function(ui) {\r\n  Mocha.prototype.ui.call(this, ui);\r\n  this.suite.emit('pre-require', global, null, this);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Setup mocha with the given setting options.\r\n */\r\n\r\nmocha.setup = function(opts) {\r\n  if (typeof opts === 'string') {\r\n    opts = {ui: opts};\r\n  }\r\n  for (var opt in opts) {\r\n    if (Object.prototype.hasOwnProperty.call(opts, opt)) {\r\n      this[opt](opts[opt]);\r\n    }\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Run mocha, returning the Runner.\r\n */\r\n\r\nmocha.run = function(fn) {\r\n  var options = mocha.options;\r\n  mocha.globals('location');\r\n\r\n  var query = Mocha.utils.parseQuery(global.location.search || '');\r\n  if (query.grep) {\r\n    mocha.grep(query.grep);\r\n  }\r\n  if (query.fgrep) {\r\n    mocha.fgrep(query.fgrep);\r\n  }\r\n  if (query.invert) {\r\n    mocha.invert();\r\n  }\r\n\r\n  return Mocha.prototype.run.call(mocha, function(err) {\r\n    // The DOM Document is not available in Web Workers.\r\n    var document = global.document;\r\n    if (\r\n      document &&\r\n      document.getElementById('mocha') &&\r\n      options.noHighlighting !== true\r\n    ) {\r\n      Mocha.utils.highlightTags('code');\r\n    }\r\n    if (fn) {\r\n      fn(err);\r\n    }\r\n  });\r\n};\r\n\r\n/**\r\n * Expose the process shim.\r\n * https://github.com/mochajs/mocha/pull/916\r\n */\r\n\r\nMocha.process = process;\r\n\r\n/**\r\n * Expose mocha.\r\n */\r\n\r\nglobal.Mocha = Mocha;\r\nglobal.mocha = mocha;\r\n\r\n// this allows test/acceptance/required-tokens.js to pass; thus,\r\n// you can now do `const describe = require('mocha').describe` in a\r\n// browser context (assuming browserification).  should fix #880\r\nmodule.exports = global;\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\"), __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/mocha/browser-entry.js?");

/***/ }),

/***/ "./node_modules/mocha/lib lazy recursive":
/*!******************************************************!*\
  !*** ./node_modules/mocha/lib lazy namespace object ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function webpackEmptyAsyncContext(req) {\n\t// Here Promise.resolve().then() is used instead of new Promise() to prevent\n\t// uncaught exception popping up in devtools\n\treturn Promise.resolve().then(function() {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t});\n}\nwebpackEmptyAsyncContext.keys = function() { return []; };\nwebpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;\nmodule.exports = webpackEmptyAsyncContext;\nwebpackEmptyAsyncContext.id = \"./node_modules/mocha/lib lazy recursive\";\n\n//# sourceURL=webpack:///./node_modules/mocha/lib_lazy_namespace_object?");

/***/ }),

/***/ "./node_modules/mocha/lib sync recursive":
/*!*************************************!*\
  !*** ./node_modules/mocha/lib sync ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = \"./node_modules/mocha/lib sync recursive\";\n\n//# sourceURL=webpack:///./node_modules/mocha/lib_sync?");

/***/ }),

/***/ "./node_modules/mocha/lib/browser/growl.js":
/*!*************************************************!*\
  !*** ./node_modules/mocha/lib/browser/growl.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global, process) {\r\n\r\n/**\r\n * Web Notifications module.\r\n * @module Growl\r\n */\r\n\r\n/**\r\n * Save timer references to avoid Sinon interfering (see GH-237).\r\n */\r\nvar Date = global.Date;\r\nvar setTimeout = global.setTimeout;\r\nvar EVENT_RUN_END = __webpack_require__(/*! ../runner */ \"./node_modules/mocha/lib/runner.js\").constants.EVENT_RUN_END;\r\n\r\n/**\r\n * Checks if browser notification support exists.\r\n *\r\n * @public\r\n * @see {@link https://caniuse.com/#feat=notifications|Browser support (notifications)}\r\n * @see {@link https://caniuse.com/#feat=promises|Browser support (promises)}\r\n * @see {@link Mocha#growl}\r\n * @see {@link Mocha#isGrowlCapable}\r\n * @return {boolean} whether browser notification support exists\r\n */\r\nexports.isCapable = function() {\r\n  var hasNotificationSupport = 'Notification' in window;\r\n  var hasPromiseSupport = typeof Promise === 'function';\r\n  return process.browser && hasNotificationSupport && hasPromiseSupport;\r\n};\r\n\r\n/**\r\n * Implements browser notifications as a pseudo-reporter.\r\n *\r\n * @public\r\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/notification|Notification API}\r\n * @see {@link https://developers.google.com/web/fundamentals/push-notifications/display-a-notification|Displaying a Notification}\r\n * @see {@link Growl#isPermitted}\r\n * @see {@link Mocha#_growl}\r\n * @param {Runner} runner - Runner instance.\r\n */\r\nexports.notify = function(runner) {\r\n  var promise = isPermitted();\r\n\r\n  /**\r\n   * Attempt notification.\r\n   */\r\n  var sendNotification = function() {\r\n    // If user hasn't responded yet... \"No notification for you!\" (Seinfeld)\r\n    Promise.race([promise, Promise.resolve(undefined)])\r\n      .then(canNotify)\r\n      .then(function() {\r\n        display(runner);\r\n      })\r\n      .catch(notPermitted);\r\n  };\r\n\r\n  runner.once(EVENT_RUN_END, sendNotification);\r\n};\r\n\r\n/**\r\n * Checks if browser notification is permitted by user.\r\n *\r\n * @private\r\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Notification/permission|Notification.permission}\r\n * @see {@link Mocha#growl}\r\n * @see {@link Mocha#isGrowlPermitted}\r\n * @returns {Promise<boolean>} promise determining if browser notification\r\n *     permissible when fulfilled.\r\n */\r\nfunction isPermitted() {\r\n  var permitted = {\r\n    granted: function allow() {\r\n      return Promise.resolve(true);\r\n    },\r\n    denied: function deny() {\r\n      return Promise.resolve(false);\r\n    },\r\n    default: function ask() {\r\n      return Notification.requestPermission().then(function(permission) {\r\n        return permission === 'granted';\r\n      });\r\n    }\r\n  };\r\n\r\n  return permitted[Notification.permission]();\r\n}\r\n\r\n/**\r\n * @summary\r\n * Determines if notification should proceed.\r\n *\r\n * @description\r\n * Notification shall <strong>not</strong> proceed unless `value` is true.\r\n *\r\n * `value` will equal one of:\r\n * <ul>\r\n *   <li><code>true</code> (from `isPermitted`)</li>\r\n *   <li><code>false</code> (from `isPermitted`)</li>\r\n *   <li><code>undefined</code> (from `Promise.race`)</li>\r\n * </ul>\r\n *\r\n * @private\r\n * @param {boolean|undefined} value - Determines if notification permissible.\r\n * @returns {Promise<undefined>} Notification can proceed\r\n */\r\nfunction canNotify(value) {\r\n  if (!value) {\r\n    var why = value === false ? 'blocked' : 'unacknowledged';\r\n    var reason = 'not permitted by user (' + why + ')';\r\n    return Promise.reject(new Error(reason));\r\n  }\r\n  return Promise.resolve();\r\n}\r\n\r\n/**\r\n * Displays the notification.\r\n *\r\n * @private\r\n * @param {Runner} runner - Runner instance.\r\n */\r\nfunction display(runner) {\r\n  var stats = runner.stats;\r\n  var symbol = {\r\n    cross: '\\u274C',\r\n    tick: '\\u2705'\r\n  };\r\n  var logo = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../../package'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())).notifyLogo;\r\n  var _message;\r\n  var message;\r\n  var title;\r\n\r\n  if (stats.failures) {\r\n    _message = stats.failures + ' of ' + stats.tests + ' tests failed';\r\n    message = symbol.cross + ' ' + _message;\r\n    title = 'Failed';\r\n  } else {\r\n    _message = stats.passes + ' tests passed in ' + stats.duration + 'ms';\r\n    message = symbol.tick + ' ' + _message;\r\n    title = 'Passed';\r\n  }\r\n\r\n  // Send notification\r\n  var options = {\r\n    badge: logo,\r\n    body: message,\r\n    dir: 'ltr',\r\n    icon: logo,\r\n    lang: 'en-US',\r\n    name: 'mocha',\r\n    requireInteraction: false,\r\n    timestamp: Date.now()\r\n  };\r\n  var notification = new Notification(title, options);\r\n\r\n  // Autoclose after brief delay (makes various browsers act same)\r\n  var FORCE_DURATION = 4000;\r\n  setTimeout(notification.close.bind(notification), FORCE_DURATION);\r\n}\r\n\r\n/**\r\n * As notifications are tangential to our purpose, just log the error.\r\n *\r\n * @private\r\n * @param {Error} err - Why notification didn't happen.\r\n */\r\nfunction notPermitted(err) {\r\n  console.error('notification error:', err.message);\r\n}\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/mocha/lib/browser/growl.js?");

/***/ }),

/***/ "./node_modules/mocha/lib/browser/progress.js":
/*!****************************************************!*\
  !*** ./node_modules/mocha/lib/browser/progress.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\n/**\r\n * Expose `Progress`.\r\n */\r\n\r\nmodule.exports = Progress;\r\n\r\n/**\r\n * Initialize a new `Progress` indicator.\r\n */\r\nfunction Progress() {\r\n  this.percent = 0;\r\n  this.size(0);\r\n  this.fontSize(11);\r\n  this.font('helvetica, arial, sans-serif');\r\n}\r\n\r\n/**\r\n * Set progress size to `size`.\r\n *\r\n * @public\r\n * @param {number} size\r\n * @return {Progress} Progress instance.\r\n */\r\nProgress.prototype.size = function(size) {\r\n  this._size = size;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set text to `text`.\r\n *\r\n * @public\r\n * @param {string} text\r\n * @return {Progress} Progress instance.\r\n */\r\nProgress.prototype.text = function(text) {\r\n  this._text = text;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set font size to `size`.\r\n *\r\n * @public\r\n * @param {number} size\r\n * @return {Progress} Progress instance.\r\n */\r\nProgress.prototype.fontSize = function(size) {\r\n  this._fontSize = size;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set font to `family`.\r\n *\r\n * @param {string} family\r\n * @return {Progress} Progress instance.\r\n */\r\nProgress.prototype.font = function(family) {\r\n  this._font = family;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Update percentage to `n`.\r\n *\r\n * @param {number} n\r\n * @return {Progress} Progress instance.\r\n */\r\nProgress.prototype.update = function(n) {\r\n  this.percent = n;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Draw on `ctx`.\r\n *\r\n * @param {CanvasRenderingContext2d} ctx\r\n * @return {Progress} Progress instance.\r\n */\r\nProgress.prototype.draw = function(ctx) {\r\n  try {\r\n    var percent = Math.min(this.percent, 100);\r\n    var size = this._size;\r\n    var half = size / 2;\r\n    var x = half;\r\n    var y = half;\r\n    var rad = half - 1;\r\n    var fontSize = this._fontSize;\r\n\r\n    ctx.font = fontSize + 'px ' + this._font;\r\n\r\n    var angle = Math.PI * 2 * (percent / 100);\r\n    ctx.clearRect(0, 0, size, size);\r\n\r\n    // outer circle\r\n    ctx.strokeStyle = '#9f9f9f';\r\n    ctx.beginPath();\r\n    ctx.arc(x, y, rad, 0, angle, false);\r\n    ctx.stroke();\r\n\r\n    // inner circle\r\n    ctx.strokeStyle = '#eee';\r\n    ctx.beginPath();\r\n    ctx.arc(x, y, rad - 1, 0, angle, true);\r\n    ctx.stroke();\r\n\r\n    // text\r\n    var text = this._text || (percent | 0) + '%';\r\n    var w = ctx.measureText(text).width;\r\n\r\n    ctx.fillText(text, x - w / 2 + 1, y + fontSize / 2 - 1);\r\n  } catch (ignore) {\r\n    // don't fail if we can't render progress\r\n  }\r\n  return this;\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/mocha/lib/browser/progress.js?");

/***/ }),

/***/ "./node_modules/mocha/lib/browser/tty.js":
/*!***********************************************!*\
  !*** ./node_modules/mocha/lib/browser/tty.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\r\n\r\nexports.isatty = function isatty() {\r\n  return true;\r\n};\r\n\r\nexports.getWindowSize = function getWindowSize() {\r\n  if ('innerHeight' in global) {\r\n    return [global.innerHeight, global.innerWidth];\r\n  }\r\n  // In a Web Worker, the DOM Window is not available.\r\n  return [640, 480];\r\n};\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/mocha/lib/browser/tty.js?");

/***/ }),

/***/ "./node_modules/mocha/lib/context.js":
/*!*******************************************!*\
  !*** ./node_modules/mocha/lib/context.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n/**\r\n * @module Context\r\n */\r\n/**\r\n * Expose `Context`.\r\n */\r\n\r\nmodule.exports = Context;\r\n\r\n/**\r\n * Initialize a new `Context`.\r\n *\r\n * @private\r\n */\r\nfunction Context() {}\r\n\r\n/**\r\n * Set or get the context `Runnable` to `runnable`.\r\n *\r\n * @private\r\n * @param {Runnable} runnable\r\n * @return {Context} context\r\n */\r\nContext.prototype.runnable = function(runnable) {\r\n  if (!arguments.length) {\r\n    return this._runnable;\r\n  }\r\n  this.test = this._runnable = runnable;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set or get test timeout `ms`.\r\n *\r\n * @private\r\n * @param {number} ms\r\n * @return {Context} self\r\n */\r\nContext.prototype.timeout = function(ms) {\r\n  if (!arguments.length) {\r\n    return this.runnable().timeout();\r\n  }\r\n  this.runnable().timeout(ms);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set test timeout `enabled`.\r\n *\r\n * @private\r\n * @param {boolean} enabled\r\n * @return {Context} self\r\n */\r\nContext.prototype.enableTimeouts = function(enabled) {\r\n  if (!arguments.length) {\r\n    return this.runnable().enableTimeouts();\r\n  }\r\n  this.runnable().enableTimeouts(enabled);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set or get test slowness threshold `ms`.\r\n *\r\n * @private\r\n * @param {number} ms\r\n * @return {Context} self\r\n */\r\nContext.prototype.slow = function(ms) {\r\n  if (!arguments.length) {\r\n    return this.runnable().slow();\r\n  }\r\n  this.runnable().slow(ms);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Mark a test as skipped.\r\n *\r\n * @private\r\n * @throws Pending\r\n */\r\nContext.prototype.skip = function() {\r\n  this.runnable().skip();\r\n};\r\n\r\n/**\r\n * Set or get a number of allowed retries on failed tests\r\n *\r\n * @private\r\n * @param {number} n\r\n * @return {Context} self\r\n */\r\nContext.prototype.retries = function(n) {\r\n  if (!arguments.length) {\r\n    return this.runnable().retries();\r\n  }\r\n  this.runnable().retries(n);\r\n  return this;\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/mocha/lib/context.js?");

/***/ }),

/***/ "./node_modules/mocha/lib/errors.js":
/*!******************************************!*\
  !*** ./node_modules/mocha/lib/errors.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar format = __webpack_require__(/*! util */ \"./node_modules/util/util.js\").format;\r\n\r\n/**\r\n * Factory functions to create throwable error objects\r\n * @module Errors\r\n */\r\n\r\n/**\r\n * When Mocha throw exceptions (or otherwise errors), it attempts to assign a\r\n * `code` property to the `Error` object, for easier handling.  These are the\r\n * potential values of `code`.\r\n */\r\nvar constants = {\r\n  /**\r\n   * An unrecoverable error.\r\n   */\r\n  FATAL: 'ERR_MOCHA_FATAL',\r\n\r\n  /**\r\n   * The type of an argument to a function call is invalid\r\n   */\r\n  INVALID_ARG_TYPE: 'ERR_MOCHA_INVALID_ARG_TYPE',\r\n\r\n  /**\r\n   * The value of an argument to a function call is invalid\r\n   */\r\n  INVALID_ARG_VALUE: 'ERR_MOCHA_INVALID_ARG_VALUE',\r\n\r\n  /**\r\n   * Something was thrown, but it wasn't an `Error`\r\n   */\r\n  INVALID_EXCEPTION: 'ERR_MOCHA_INVALID_EXCEPTION',\r\n\r\n  /**\r\n   * An interface (e.g., `Mocha.interfaces`) is unknown or invalid\r\n   */\r\n  INVALID_INTERFACE: 'ERR_MOCHA_INVALID_INTERFACE',\r\n\r\n  /**\r\n   * A reporter (.e.g, `Mocha.reporters`) is unknown or invalid\r\n   */\r\n  INVALID_REPORTER: 'ERR_MOCHA_INVALID_REPORTER',\r\n\r\n  /**\r\n   * `done()` was called twice in a `Test` or `Hook` callback\r\n   */\r\n  MULTIPLE_DONE: 'ERR_MOCHA_MULTIPLE_DONE',\r\n\r\n  /**\r\n   * No files matched the pattern provided by the user\r\n   */\r\n  NO_FILES_MATCH_PATTERN: 'ERR_MOCHA_NO_FILES_MATCH_PATTERN',\r\n\r\n  /**\r\n   * Known, but unsupported behavior of some kind\r\n   */\r\n  UNSUPPORTED: 'ERR_MOCHA_UNSUPPORTED',\r\n\r\n  /**\r\n   * Invalid state transition occuring in `Mocha` instance\r\n   */\r\n  INSTANCE_ALREADY_RUNNING: 'ERR_MOCHA_INSTANCE_ALREADY_RUNNING',\r\n\r\n  /**\r\n   * Invalid state transition occuring in `Mocha` instance\r\n   */\r\n  INSTANCE_ALREADY_DISPOSED: 'ERR_MOCHA_INSTANCE_ALREADY_DISPOSED'\r\n};\r\n\r\n/**\r\n * Creates an error object to be thrown when no files to be tested could be found using specified pattern.\r\n *\r\n * @public\r\n * @param {string} message - Error message to be displayed.\r\n * @param {string} pattern - User-specified argument value.\r\n * @returns {Error} instance detailing the error condition\r\n */\r\nfunction createNoFilesMatchPatternError(message, pattern) {\r\n  var err = new Error(message);\r\n  err.code = constants.NO_FILES_MATCH_PATTERN;\r\n  err.pattern = pattern;\r\n  return err;\r\n}\r\n\r\n/**\r\n * Creates an error object to be thrown when the reporter specified in the options was not found.\r\n *\r\n * @public\r\n * @param {string} message - Error message to be displayed.\r\n * @param {string} reporter - User-specified reporter value.\r\n * @returns {Error} instance detailing the error condition\r\n */\r\nfunction createInvalidReporterError(message, reporter) {\r\n  var err = new TypeError(message);\r\n  err.code = constants.INVALID_REPORTER;\r\n  err.reporter = reporter;\r\n  return err;\r\n}\r\n\r\n/**\r\n * Creates an error object to be thrown when the interface specified in the options was not found.\r\n *\r\n * @public\r\n * @param {string} message - Error message to be displayed.\r\n * @param {string} ui - User-specified interface value.\r\n * @returns {Error} instance detailing the error condition\r\n */\r\nfunction createInvalidInterfaceError(message, ui) {\r\n  var err = new Error(message);\r\n  err.code = constants.INVALID_INTERFACE;\r\n  err.interface = ui;\r\n  return err;\r\n}\r\n\r\n/**\r\n * Creates an error object to be thrown when a behavior, option, or parameter is unsupported.\r\n *\r\n * @public\r\n * @param {string} message - Error message to be displayed.\r\n * @returns {Error} instance detailing the error condition\r\n */\r\nfunction createUnsupportedError(message) {\r\n  var err = new Error(message);\r\n  err.code = constants.UNSUPPORTED;\r\n  return err;\r\n}\r\n\r\n/**\r\n * Creates an error object to be thrown when an argument is missing.\r\n *\r\n * @public\r\n * @param {string} message - Error message to be displayed.\r\n * @param {string} argument - Argument name.\r\n * @param {string} expected - Expected argument datatype.\r\n * @returns {Error} instance detailing the error condition\r\n */\r\nfunction createMissingArgumentError(message, argument, expected) {\r\n  return createInvalidArgumentTypeError(message, argument, expected);\r\n}\r\n\r\n/**\r\n * Creates an error object to be thrown when an argument did not use the supported type\r\n *\r\n * @public\r\n * @param {string} message - Error message to be displayed.\r\n * @param {string} argument - Argument name.\r\n * @param {string} expected - Expected argument datatype.\r\n * @returns {Error} instance detailing the error condition\r\n */\r\nfunction createInvalidArgumentTypeError(message, argument, expected) {\r\n  var err = new TypeError(message);\r\n  err.code = constants.INVALID_ARG_TYPE;\r\n  err.argument = argument;\r\n  err.expected = expected;\r\n  err.actual = typeof argument;\r\n  return err;\r\n}\r\n\r\n/**\r\n * Creates an error object to be thrown when an argument did not use the supported value\r\n *\r\n * @public\r\n * @param {string} message - Error message to be displayed.\r\n * @param {string} argument - Argument name.\r\n * @param {string} value - Argument value.\r\n * @param {string} [reason] - Why value is invalid.\r\n * @returns {Error} instance detailing the error condition\r\n */\r\nfunction createInvalidArgumentValueError(message, argument, value, reason) {\r\n  var err = new TypeError(message);\r\n  err.code = constants.INVALID_ARG_VALUE;\r\n  err.argument = argument;\r\n  err.value = value;\r\n  err.reason = typeof reason !== 'undefined' ? reason : 'is invalid';\r\n  return err;\r\n}\r\n\r\n/**\r\n * Creates an error object to be thrown when an exception was caught, but the `Error` is falsy or undefined.\r\n *\r\n * @public\r\n * @param {string} message - Error message to be displayed.\r\n * @returns {Error} instance detailing the error condition\r\n */\r\nfunction createInvalidExceptionError(message, value) {\r\n  var err = new Error(message);\r\n  err.code = constants.INVALID_EXCEPTION;\r\n  err.valueType = typeof value;\r\n  err.value = value;\r\n  return err;\r\n}\r\n\r\n/**\r\n * Creates an error object to be thrown when an unrecoverable error occurs.\r\n *\r\n * @public\r\n * @param {string} message - Error message to be displayed.\r\n * @returns {Error} instance detailing the error condition\r\n */\r\nfunction createFatalError(message, value) {\r\n  var err = new Error(message);\r\n  err.code = constants.FATAL;\r\n  err.valueType = typeof value;\r\n  err.value = value;\r\n  return err;\r\n}\r\n\r\n/**\r\n * Dynamically creates a plugin-type-specific error based on plugin type\r\n * @param {string} message - Error message\r\n * @param {\"reporter\"|\"interface\"} pluginType - Plugin type. Future: expand as needed\r\n * @param {string} [pluginId] - Name/path of plugin, if any\r\n * @throws When `pluginType` is not known\r\n * @public\r\n * @returns {Error}\r\n */\r\nfunction createInvalidPluginError(message, pluginType, pluginId) {\r\n  switch (pluginType) {\r\n    case 'reporter':\r\n      return createInvalidReporterError(message, pluginId);\r\n    case 'interface':\r\n      return createInvalidInterfaceError(message, pluginId);\r\n    default:\r\n      throw new Error('unknown pluginType \"' + pluginType + '\"');\r\n  }\r\n}\r\n\r\n/**\r\n * Creates an error object to be thrown when a mocha object's `run` method is executed while it is already disposed.\r\n * @param {string} message The error message to be displayed.\r\n * @param {boolean} cleanReferencesAfterRun the value of `cleanReferencesAfterRun`\r\n * @param {Mocha} instance the mocha instance that throw this error\r\n */\r\nfunction createMochaInstanceAlreadyDisposedError(\r\n  message,\r\n  cleanReferencesAfterRun,\r\n  instance\r\n) {\r\n  var err = new Error(message);\r\n  err.code = constants.INSTANCE_ALREADY_DISPOSED;\r\n  err.cleanReferencesAfterRun = cleanReferencesAfterRun;\r\n  err.instance = instance;\r\n  return err;\r\n}\r\n\r\n/**\r\n * Creates an error object to be thrown when a mocha object's `run` method is called while a test run is in progress.\r\n * @param {string} message The error message to be displayed.\r\n */\r\nfunction createMochaInstanceAlreadyRunningError(message, instance) {\r\n  var err = new Error(message);\r\n  err.code = constants.INSTANCE_ALREADY_RUNNING;\r\n  err.instance = instance;\r\n  return err;\r\n}\r\n\r\n/*\r\n * Creates an error object to be thrown when done() is called multiple times in a test\r\n *\r\n * @public\r\n * @param {Runnable} runnable - Original runnable\r\n * @param {Error} [originalErr] - Original error, if any\r\n * @returns {Error} instance detailing the error condition\r\n */\r\nfunction createMultipleDoneError(runnable, originalErr) {\r\n  var title;\r\n  try {\r\n    title = format('<%s>', runnable.fullTitle());\r\n    if (runnable.parent.root) {\r\n      title += ' (of root suite)';\r\n    }\r\n  } catch (ignored) {\r\n    title = format('<%s> (of unknown suite)', runnable.title);\r\n  }\r\n  var message = format(\r\n    'done() called multiple times in %s %s',\r\n    runnable.type ? runnable.type : 'unknown runnable',\r\n    title\r\n  );\r\n  if (runnable.file) {\r\n    message += format(' of file %s', runnable.file);\r\n  }\r\n  if (originalErr) {\r\n    message += format('; in addition, done() received error: %s', originalErr);\r\n  }\r\n\r\n  var err = new Error(message);\r\n  err.code = constants.MULTIPLE_DONE;\r\n  err.valueType = typeof originalErr;\r\n  err.value = originalErr;\r\n  return err;\r\n}\r\n\r\nmodule.exports = {\r\n  createInvalidArgumentTypeError: createInvalidArgumentTypeError,\r\n  createInvalidArgumentValueError: createInvalidArgumentValueError,\r\n  createInvalidExceptionError: createInvalidExceptionError,\r\n  createInvalidInterfaceError: createInvalidInterfaceError,\r\n  createInvalidReporterError: createInvalidReporterError,\r\n  createMissingArgumentError: createMissingArgumentError,\r\n  createNoFilesMatchPatternError: createNoFilesMatchPatternError,\r\n  createUnsupportedError: createUnsupportedError,\r\n  createInvalidPluginError: createInvalidPluginError,\r\n  createMochaInstanceAlreadyDisposedError: createMochaInstanceAlreadyDisposedError,\r\n  createMochaInstanceAlreadyRunningError: createMochaInstanceAlreadyRunningError,\r\n  createFatalError: createFatalError,\r\n  createMultipleDoneError: createMultipleDoneError,\r\n  constants: constants\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/mocha/lib/errors.js?");

/***/ }),

/***/ "./node_modules/mocha/lib/esm-utils.js":
/*!*********************************************!*\
  !*** ./node_modules/mocha/lib/esm-utils.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const url = __webpack_require__(/*! url */ \"./node_modules/url/url.js\");\r\nconst path = __webpack_require__(/*! path */ 3);\r\n\r\nconst requireOrImport = async file => {\r\n  file = path.resolve(file);\r\n\r\n  if (path.extname(file) === '.mjs') {\r\n    return __webpack_require__(\"./node_modules/mocha/lib lazy recursive\")(url.pathToFileURL(file));\r\n  }\r\n  // This is currently the only known way of figuring out whether a file is CJS or ESM.\r\n  // If Node.js or the community establish a better procedure for that, we can fix this code.\r\n  // Another option here would be to always use `import()`, as this also supports CJS, but I would be\r\n  // wary of using it for _all_ existing test files, till ESM is fully stable.\r\n  try {\r\n    return __webpack_require__(\"./node_modules/mocha/lib sync recursive\")(file);\r\n  } catch (err) {\r\n    if (err.code === 'ERR_REQUIRE_ESM') {\r\n      return __webpack_require__(\"./node_modules/mocha/lib lazy recursive\")(url.pathToFileURL(file));\r\n    } else {\r\n      throw err;\r\n    }\r\n  }\r\n};\r\n\r\nexports.loadFilesAsync = async (files, preLoadFunc, postLoadFunc) => {\r\n  for (const file of files) {\r\n    preLoadFunc(file);\r\n    const result = await requireOrImport(file);\r\n    postLoadFunc(file, result);\r\n  }\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/mocha/lib/esm-utils.js?");

/***/ }),

/***/ "./node_modules/mocha/lib/hook.js":
/*!****************************************!*\
  !*** ./node_modules/mocha/lib/hook.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar Runnable = __webpack_require__(/*! ./runnable */ \"./node_modules/mocha/lib/runnable.js\");\r\nvar inherits = __webpack_require__(/*! ./utils */ \"./node_modules/mocha/lib/utils.js\").inherits;\r\n\r\n/**\r\n * Expose `Hook`.\r\n */\r\n\r\nmodule.exports = Hook;\r\n\r\n/**\r\n * Initialize a new `Hook` with the given `title` and callback `fn`\r\n *\r\n * @class\r\n * @extends Runnable\r\n * @param {String} title\r\n * @param {Function} fn\r\n */\r\nfunction Hook(title, fn) {\r\n  Runnable.call(this, title, fn);\r\n  this.type = 'hook';\r\n}\r\n\r\n/**\r\n * Inherit from `Runnable.prototype`.\r\n */\r\ninherits(Hook, Runnable);\r\n\r\n/**\r\n * Resets the state for a next run.\r\n */\r\nHook.prototype.reset = function() {\r\n  Runnable.prototype.reset.call(this);\r\n  delete this._error;\r\n};\r\n\r\n/**\r\n * Get or set the test `err`.\r\n *\r\n * @memberof Hook\r\n * @public\r\n * @param {Error} err\r\n * @return {Error}\r\n */\r\nHook.prototype.error = function(err) {\r\n  if (!arguments.length) {\r\n    err = this._error;\r\n    this._error = null;\r\n    return err;\r\n  }\r\n\r\n  this._error = err;\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/mocha/lib/hook.js?");

/***/ }),

/***/ "./node_modules/mocha/lib/interfaces/bdd.js":
/*!**************************************************!*\
  !*** ./node_modules/mocha/lib/interfaces/bdd.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar Test = __webpack_require__(/*! ../test */ \"./node_modules/mocha/lib/test.js\");\r\nvar EVENT_FILE_PRE_REQUIRE = __webpack_require__(/*! ../suite */ \"./node_modules/mocha/lib/suite.js\").constants\r\n  .EVENT_FILE_PRE_REQUIRE;\r\n\r\n/**\r\n * BDD-style interface:\r\n *\r\n *      describe('Array', function() {\r\n *        describe('#indexOf()', function() {\r\n *          it('should return -1 when not present', function() {\r\n *            // ...\r\n *          });\r\n *\r\n *          it('should return the index when present', function() {\r\n *            // ...\r\n *          });\r\n *        });\r\n *      });\r\n *\r\n * @param {Suite} suite Root suite.\r\n */\r\nmodule.exports = function bddInterface(suite) {\r\n  var suites = [suite];\r\n\r\n  suite.on(EVENT_FILE_PRE_REQUIRE, function(context, file, mocha) {\r\n    var common = __webpack_require__(/*! ./common */ \"./node_modules/mocha/lib/interfaces/common.js\")(suites, context, mocha);\r\n\r\n    context.before = common.before;\r\n    context.after = common.after;\r\n    context.beforeEach = common.beforeEach;\r\n    context.afterEach = common.afterEach;\r\n    context.run = mocha.options.delay && common.runWithSuite(suite);\r\n    /**\r\n     * Describe a \"suite\" with the given `title`\r\n     * and callback `fn` containing nested suites\r\n     * and/or tests.\r\n     */\r\n\r\n    context.describe = context.context = function(title, fn) {\r\n      return common.suite.create({\r\n        title: title,\r\n        file: file,\r\n        fn: fn\r\n      });\r\n    };\r\n\r\n    /**\r\n     * Pending describe.\r\n     */\r\n\r\n    context.xdescribe = context.xcontext = context.describe.skip = function(\r\n      title,\r\n      fn\r\n    ) {\r\n      return common.suite.skip({\r\n        title: title,\r\n        file: file,\r\n        fn: fn\r\n      });\r\n    };\r\n\r\n    /**\r\n     * Exclusive suite.\r\n     */\r\n\r\n    context.describe.only = function(title, fn) {\r\n      return common.suite.only({\r\n        title: title,\r\n        file: file,\r\n        fn: fn\r\n      });\r\n    };\r\n\r\n    /**\r\n     * Describe a specification or test-case\r\n     * with the given `title` and callback `fn`\r\n     * acting as a thunk.\r\n     */\r\n\r\n    context.it = context.specify = function(title, fn) {\r\n      var suite = suites[0];\r\n      if (suite.isPending()) {\r\n        fn = null;\r\n      }\r\n      var test = new Test(title, fn);\r\n      test.file = file;\r\n      suite.addTest(test);\r\n      return test;\r\n    };\r\n\r\n    /**\r\n     * Exclusive test-case.\r\n     */\r\n\r\n    context.it.only = function(title, fn) {\r\n      return common.test.only(mocha, context.it(title, fn));\r\n    };\r\n\r\n    /**\r\n     * Pending test case.\r\n     */\r\n\r\n    context.xit = context.xspecify = context.it.skip = function(title) {\r\n      return context.it(title);\r\n    };\r\n\r\n    /**\r\n     * Number of attempts to retry.\r\n     */\r\n    context.it.retries = function(n) {\r\n      context.retries(n);\r\n    };\r\n  });\r\n};\r\n\r\nmodule.exports.description = 'BDD or RSpec style [default]';\r\n\n\n//# sourceURL=webpack:///./node_modules/mocha/lib/interfaces/bdd.js?");

/***/ }),

/***/ "./node_modules/mocha/lib/interfaces/common.js":
/*!*****************************************************!*\
  !*** ./node_modules/mocha/lib/interfaces/common.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar Suite = __webpack_require__(/*! ../suite */ \"./node_modules/mocha/lib/suite.js\");\r\nvar errors = __webpack_require__(/*! ../errors */ \"./node_modules/mocha/lib/errors.js\");\r\nvar createMissingArgumentError = errors.createMissingArgumentError;\r\nvar createUnsupportedError = errors.createUnsupportedError;\r\n\r\n/**\r\n * Functions common to more than one interface.\r\n *\r\n * @param {Suite[]} suites\r\n * @param {Context} context\r\n * @param {Mocha} mocha\r\n * @return {Object} An object containing common functions.\r\n */\r\nmodule.exports = function(suites, context, mocha) {\r\n  /**\r\n   * Check if the suite should be tested.\r\n   *\r\n   * @private\r\n   * @param {Suite} suite - suite to check\r\n   * @returns {boolean}\r\n   */\r\n  function shouldBeTested(suite) {\r\n    return (\r\n      !mocha.options.grep ||\r\n      (mocha.options.grep &&\r\n        mocha.options.grep.test(suite.fullTitle()) &&\r\n        !mocha.options.invert)\r\n    );\r\n  }\r\n\r\n  return {\r\n    /**\r\n     * This is only present if flag --delay is passed into Mocha. It triggers\r\n     * root suite execution.\r\n     *\r\n     * @param {Suite} suite The root suite.\r\n     * @return {Function} A function which runs the root suite\r\n     */\r\n    runWithSuite: function runWithSuite(suite) {\r\n      return function run() {\r\n        suite.run();\r\n      };\r\n    },\r\n\r\n    /**\r\n     * Execute before running tests.\r\n     *\r\n     * @param {string} name\r\n     * @param {Function} fn\r\n     */\r\n    before: function(name, fn) {\r\n      suites[0].beforeAll(name, fn);\r\n    },\r\n\r\n    /**\r\n     * Execute after running tests.\r\n     *\r\n     * @param {string} name\r\n     * @param {Function} fn\r\n     */\r\n    after: function(name, fn) {\r\n      suites[0].afterAll(name, fn);\r\n    },\r\n\r\n    /**\r\n     * Execute before each test case.\r\n     *\r\n     * @param {string} name\r\n     * @param {Function} fn\r\n     */\r\n    beforeEach: function(name, fn) {\r\n      suites[0].beforeEach(name, fn);\r\n    },\r\n\r\n    /**\r\n     * Execute after each test case.\r\n     *\r\n     * @param {string} name\r\n     * @param {Function} fn\r\n     */\r\n    afterEach: function(name, fn) {\r\n      suites[0].afterEach(name, fn);\r\n    },\r\n\r\n    suite: {\r\n      /**\r\n       * Create an exclusive Suite; convenience function\r\n       * See docstring for create() below.\r\n       *\r\n       * @param {Object} opts\r\n       * @returns {Suite}\r\n       */\r\n      only: function only(opts) {\r\n        opts.isOnly = true;\r\n        return this.create(opts);\r\n      },\r\n\r\n      /**\r\n       * Create a Suite, but skip it; convenience function\r\n       * See docstring for create() below.\r\n       *\r\n       * @param {Object} opts\r\n       * @returns {Suite}\r\n       */\r\n      skip: function skip(opts) {\r\n        opts.pending = true;\r\n        return this.create(opts);\r\n      },\r\n\r\n      /**\r\n       * Creates a suite.\r\n       *\r\n       * @param {Object} opts Options\r\n       * @param {string} opts.title Title of Suite\r\n       * @param {Function} [opts.fn] Suite Function (not always applicable)\r\n       * @param {boolean} [opts.pending] Is Suite pending?\r\n       * @param {string} [opts.file] Filepath where this Suite resides\r\n       * @param {boolean} [opts.isOnly] Is Suite exclusive?\r\n       * @returns {Suite}\r\n       */\r\n      create: function create(opts) {\r\n        var suite = Suite.create(suites[0], opts.title);\r\n        suite.pending = Boolean(opts.pending);\r\n        suite.file = opts.file;\r\n        suites.unshift(suite);\r\n        if (opts.isOnly) {\r\n          if (mocha.options.forbidOnly && shouldBeTested(suite)) {\r\n            throw createUnsupportedError('`.only` forbidden');\r\n          }\r\n\r\n          suite.parent.appendOnlySuite(suite);\r\n        }\r\n        if (suite.pending) {\r\n          if (mocha.options.forbidPending && shouldBeTested(suite)) {\r\n            throw createUnsupportedError('Pending test forbidden');\r\n          }\r\n        }\r\n        if (typeof opts.fn === 'function') {\r\n          opts.fn.call(suite);\r\n          suites.shift();\r\n        } else if (typeof opts.fn === 'undefined' && !suite.pending) {\r\n          throw createMissingArgumentError(\r\n            'Suite \"' +\r\n              suite.fullTitle() +\r\n              '\" was defined but no callback was supplied. ' +\r\n              'Supply a callback or explicitly skip the suite.',\r\n            'callback',\r\n            'function'\r\n          );\r\n        } else if (!opts.fn && suite.pending) {\r\n          suites.shift();\r\n        }\r\n\r\n        return suite;\r\n      }\r\n    },\r\n\r\n    test: {\r\n      /**\r\n       * Exclusive test-case.\r\n       *\r\n       * @param {Object} mocha\r\n       * @param {Function} test\r\n       * @returns {*}\r\n       */\r\n      only: function(mocha, test) {\r\n        if (mocha.options.forbidOnly)\r\n          throw createUnsupportedError('`.only` forbidden');\r\n        test.markOnly();\r\n        return test;\r\n      },\r\n\r\n      /**\r\n       * Pending test case.\r\n       *\r\n       * @param {string} title\r\n       */\r\n      skip: function(title) {\r\n        context.test(title);\r\n      },\r\n\r\n      /**\r\n       * Number of retry attempts\r\n       *\r\n       * @param {number} n\r\n       */\r\n      retries: function(n) {\r\n        context.retries(n);\r\n      }\r\n    }\r\n  };\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/mocha/lib/interfaces/common.js?");

/***/ }),

/***/ "./node_modules/mocha/lib/interfaces/exports.js":
/*!******************************************************!*\
  !*** ./node_modules/mocha/lib/interfaces/exports.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar Suite = __webpack_require__(/*! ../suite */ \"./node_modules/mocha/lib/suite.js\");\r\nvar Test = __webpack_require__(/*! ../test */ \"./node_modules/mocha/lib/test.js\");\r\n\r\n/**\r\n * Exports-style (as Node.js module) interface:\r\n *\r\n *     exports.Array = {\r\n *       '#indexOf()': {\r\n *         'should return -1 when the value is not present': function() {\r\n *\r\n *         },\r\n *\r\n *         'should return the correct index when the value is present': function() {\r\n *\r\n *         }\r\n *       }\r\n *     };\r\n *\r\n * @param {Suite} suite Root suite.\r\n */\r\nmodule.exports = function(suite) {\r\n  var suites = [suite];\r\n\r\n  suite.on(Suite.constants.EVENT_FILE_REQUIRE, visit);\r\n\r\n  function visit(obj, file) {\r\n    var suite;\r\n    for (var key in obj) {\r\n      if (typeof obj[key] === 'function') {\r\n        var fn = obj[key];\r\n        switch (key) {\r\n          case 'before':\r\n            suites[0].beforeAll(fn);\r\n            break;\r\n          case 'after':\r\n            suites[0].afterAll(fn);\r\n            break;\r\n          case 'beforeEach':\r\n            suites[0].beforeEach(fn);\r\n            break;\r\n          case 'afterEach':\r\n            suites[0].afterEach(fn);\r\n            break;\r\n          default:\r\n            var test = new Test(key, fn);\r\n            test.file = file;\r\n            suites[0].addTest(test);\r\n        }\r\n      } else {\r\n        suite = Suite.create(suites[0], key);\r\n        suites.unshift(suite);\r\n        visit(obj[key], file);\r\n        suites.shift();\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nmodule.exports.description = 'Node.js module (\"exports\") style';\r\n\n\n//# sourceURL=webpack:///./node_modules/mocha/lib/interfaces/exports.js?");

/***/ }),

/***/ "./node_modules/mocha/lib/interfaces/index.js":
/*!****************************************************!*\
  !*** ./node_modules/mocha/lib/interfaces/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nexports.bdd = __webpack_require__(/*! ./bdd */ \"./node_modules/mocha/lib/interfaces/bdd.js\");\r\nexports.tdd = __webpack_require__(/*! ./tdd */ \"./node_modules/mocha/lib/interfaces/tdd.js\");\r\nexports.qunit = __webpack_require__(/*! ./qunit */ \"./node_modules/mocha/lib/interfaces/qunit.js\");\r\nexports.exports = __webpack_require__(/*! ./exports */ \"./node_modules/mocha/lib/interfaces/exports.js\");\r\n\n\n//# sourceURL=webpack:///./node_modules/mocha/lib/interfaces/index.js?");

/***/ }),

/***/ "./node_modules/mocha/lib/interfaces/qunit.js":
/*!****************************************************!*\
  !*** ./node_modules/mocha/lib/interfaces/qunit.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar Test = __webpack_require__(/*! ../test */ \"./node_modules/mocha/lib/test.js\");\r\nvar EVENT_FILE_PRE_REQUIRE = __webpack_require__(/*! ../suite */ \"./node_modules/mocha/lib/suite.js\").constants\r\n  .EVENT_FILE_PRE_REQUIRE;\r\n\r\n/**\r\n * QUnit-style interface:\r\n *\r\n *     suite('Array');\r\n *\r\n *     test('#length', function() {\r\n *       var arr = [1,2,3];\r\n *       ok(arr.length == 3);\r\n *     });\r\n *\r\n *     test('#indexOf()', function() {\r\n *       var arr = [1,2,3];\r\n *       ok(arr.indexOf(1) == 0);\r\n *       ok(arr.indexOf(2) == 1);\r\n *       ok(arr.indexOf(3) == 2);\r\n *     });\r\n *\r\n *     suite('String');\r\n *\r\n *     test('#length', function() {\r\n *       ok('foo'.length == 3);\r\n *     });\r\n *\r\n * @param {Suite} suite Root suite.\r\n */\r\nmodule.exports = function qUnitInterface(suite) {\r\n  var suites = [suite];\r\n\r\n  suite.on(EVENT_FILE_PRE_REQUIRE, function(context, file, mocha) {\r\n    var common = __webpack_require__(/*! ./common */ \"./node_modules/mocha/lib/interfaces/common.js\")(suites, context, mocha);\r\n\r\n    context.before = common.before;\r\n    context.after = common.after;\r\n    context.beforeEach = common.beforeEach;\r\n    context.afterEach = common.afterEach;\r\n    context.run = mocha.options.delay && common.runWithSuite(suite);\r\n    /**\r\n     * Describe a \"suite\" with the given `title`.\r\n     */\r\n\r\n    context.suite = function(title) {\r\n      if (suites.length > 1) {\r\n        suites.shift();\r\n      }\r\n      return common.suite.create({\r\n        title: title,\r\n        file: file,\r\n        fn: false\r\n      });\r\n    };\r\n\r\n    /**\r\n     * Exclusive Suite.\r\n     */\r\n\r\n    context.suite.only = function(title) {\r\n      if (suites.length > 1) {\r\n        suites.shift();\r\n      }\r\n      return common.suite.only({\r\n        title: title,\r\n        file: file,\r\n        fn: false\r\n      });\r\n    };\r\n\r\n    /**\r\n     * Describe a specification or test-case\r\n     * with the given `title` and callback `fn`\r\n     * acting as a thunk.\r\n     */\r\n\r\n    context.test = function(title, fn) {\r\n      var test = new Test(title, fn);\r\n      test.file = file;\r\n      suites[0].addTest(test);\r\n      return test;\r\n    };\r\n\r\n    /**\r\n     * Exclusive test-case.\r\n     */\r\n\r\n    context.test.only = function(title, fn) {\r\n      return common.test.only(mocha, context.test(title, fn));\r\n    };\r\n\r\n    context.test.skip = common.test.skip;\r\n    context.test.retries = common.test.retries;\r\n  });\r\n};\r\n\r\nmodule.exports.description = 'QUnit style';\r\n\n\n//# sourceURL=webpack:///./node_modules/mocha/lib/interfaces/qunit.js?");

/***/ }),

/***/ "./node_modules/mocha/lib/interfaces/tdd.js":
/*!**************************************************!*\
  !*** ./node_modules/mocha/lib/interfaces/tdd.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar Test = __webpack_require__(/*! ../test */ \"./node_modules/mocha/lib/test.js\");\r\nvar EVENT_FILE_PRE_REQUIRE = __webpack_require__(/*! ../suite */ \"./node_modules/mocha/lib/suite.js\").constants\r\n  .EVENT_FILE_PRE_REQUIRE;\r\n\r\n/**\r\n * TDD-style interface:\r\n *\r\n *      suite('Array', function() {\r\n *        suite('#indexOf()', function() {\r\n *          suiteSetup(function() {\r\n *\r\n *          });\r\n *\r\n *          test('should return -1 when not present', function() {\r\n *\r\n *          });\r\n *\r\n *          test('should return the index when present', function() {\r\n *\r\n *          });\r\n *\r\n *          suiteTeardown(function() {\r\n *\r\n *          });\r\n *        });\r\n *      });\r\n *\r\n * @param {Suite} suite Root suite.\r\n */\r\nmodule.exports = function(suite) {\r\n  var suites = [suite];\r\n\r\n  suite.on(EVENT_FILE_PRE_REQUIRE, function(context, file, mocha) {\r\n    var common = __webpack_require__(/*! ./common */ \"./node_modules/mocha/lib/interfaces/common.js\")(suites, context, mocha);\r\n\r\n    context.setup = common.beforeEach;\r\n    context.teardown = common.afterEach;\r\n    context.suiteSetup = common.before;\r\n    context.suiteTeardown = common.after;\r\n    context.run = mocha.options.delay && common.runWithSuite(suite);\r\n\r\n    /**\r\n     * Describe a \"suite\" with the given `title` and callback `fn` containing\r\n     * nested suites and/or tests.\r\n     */\r\n    context.suite = function(title, fn) {\r\n      return common.suite.create({\r\n        title: title,\r\n        file: file,\r\n        fn: fn\r\n      });\r\n    };\r\n\r\n    /**\r\n     * Pending suite.\r\n     */\r\n    context.suite.skip = function(title, fn) {\r\n      return common.suite.skip({\r\n        title: title,\r\n        file: file,\r\n        fn: fn\r\n      });\r\n    };\r\n\r\n    /**\r\n     * Exclusive test-case.\r\n     */\r\n    context.suite.only = function(title, fn) {\r\n      return common.suite.only({\r\n        title: title,\r\n        file: file,\r\n        fn: fn\r\n      });\r\n    };\r\n\r\n    /**\r\n     * Describe a specification or test-case with the given `title` and\r\n     * callback `fn` acting as a thunk.\r\n     */\r\n    context.test = function(title, fn) {\r\n      var suite = suites[0];\r\n      if (suite.isPending()) {\r\n        fn = null;\r\n      }\r\n      var test = new Test(title, fn);\r\n      test.file = file;\r\n      suite.addTest(test);\r\n      return test;\r\n    };\r\n\r\n    /**\r\n     * Exclusive test-case.\r\n     */\r\n\r\n    context.test.only = function(title, fn) {\r\n      return common.test.only(mocha, context.test(title, fn));\r\n    };\r\n\r\n    context.test.skip = common.test.skip;\r\n    context.test.retries = common.test.retries;\r\n  });\r\n};\r\n\r\nmodule.exports.description =\r\n  'traditional \"suite\"/\"test\" instead of BDD\\'s \"describe\"/\"it\"';\r\n\n\n//# sourceURL=webpack:///./node_modules/mocha/lib/interfaces/tdd.js?");

/***/ }),

/***/ "./node_modules/mocha/lib/mocha.js":
/*!*****************************************!*\
  !*** ./node_modules/mocha/lib/mocha.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process, module, global) {\r\n\r\n/*!\r\n * mocha\r\n * Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca>\r\n * MIT Licensed\r\n */\r\n\r\nvar escapeRe = __webpack_require__(/*! escape-string-regexp */ \"./node_modules/escape-string-regexp/index.js\");\r\nvar path = __webpack_require__(/*! path */ 3);\r\nvar builtinReporters = __webpack_require__(/*! ./reporters */ \"./node_modules/mocha/lib/reporters/index.js\");\r\nvar growl = __webpack_require__(/*! ./growl */ \"./node_modules/mocha/lib/browser/growl.js\");\r\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/mocha/lib/utils.js\");\r\nvar mocharc = __webpack_require__(/*! ./mocharc.json */ \"./node_modules/mocha/lib/mocharc.json\");\r\nvar errors = __webpack_require__(/*! ./errors */ \"./node_modules/mocha/lib/errors.js\");\r\nvar Suite = __webpack_require__(/*! ./suite */ \"./node_modules/mocha/lib/suite.js\");\r\nvar esmUtils = utils.supportsEsModules() ? __webpack_require__(/*! ./esm-utils */ \"./node_modules/mocha/lib/esm-utils.js\") : undefined;\r\nvar createStatsCollector = __webpack_require__(/*! ./stats-collector */ \"./node_modules/mocha/lib/stats-collector.js\");\r\nvar createInvalidReporterError = errors.createInvalidReporterError;\r\nvar createInvalidInterfaceError = errors.createInvalidInterfaceError;\r\nvar createMochaInstanceAlreadyDisposedError =\r\n  errors.createMochaInstanceAlreadyDisposedError;\r\nvar createMochaInstanceAlreadyRunningError =\r\n  errors.createMochaInstanceAlreadyRunningError;\r\nvar EVENT_FILE_PRE_REQUIRE = Suite.constants.EVENT_FILE_PRE_REQUIRE;\r\nvar EVENT_FILE_POST_REQUIRE = Suite.constants.EVENT_FILE_POST_REQUIRE;\r\nvar EVENT_FILE_REQUIRE = Suite.constants.EVENT_FILE_REQUIRE;\r\nvar sQuote = utils.sQuote;\r\n\r\nexports = module.exports = Mocha;\r\n\r\n/**\r\n * A Mocha instance is a finite state machine.\r\n * These are the states it can be in.\r\n */\r\nvar mochaStates = utils.defineConstants({\r\n  /**\r\n   * Initial state of the mocha instance\r\n   */\r\n  INIT: 'init',\r\n  /**\r\n   * Mocha instance is running tests\r\n   */\r\n  RUNNING: 'running',\r\n  /**\r\n   * Mocha instance is done running tests and references to test functions and hooks are cleaned.\r\n   * You can reset this state by unloading the test files.\r\n   */\r\n  REFERENCES_CLEANED: 'referencesCleaned',\r\n  /**\r\n   * Mocha instance is disposed and can no longer be used.\r\n   */\r\n  DISPOSED: 'disposed'\r\n});\r\n\r\n/**\r\n * To require local UIs and reporters when running in node.\r\n */\r\n\r\nif (!process.browser && typeof module.paths !== 'undefined') {\r\n  var cwd = utils.cwd();\r\n  module.paths.push(cwd, path.join(cwd, 'node_modules'));\r\n}\r\n\r\n/**\r\n * Expose internals.\r\n */\r\n\r\n/**\r\n * @public\r\n * @class utils\r\n * @memberof Mocha\r\n */\r\nexports.utils = utils;\r\nexports.interfaces = __webpack_require__(/*! ./interfaces */ \"./node_modules/mocha/lib/interfaces/index.js\");\r\n/**\r\n * @public\r\n * @memberof Mocha\r\n */\r\nexports.reporters = builtinReporters;\r\nexports.Runnable = __webpack_require__(/*! ./runnable */ \"./node_modules/mocha/lib/runnable.js\");\r\nexports.Context = __webpack_require__(/*! ./context */ \"./node_modules/mocha/lib/context.js\");\r\n/**\r\n *\r\n * @memberof Mocha\r\n */\r\nexports.Runner = __webpack_require__(/*! ./runner */ \"./node_modules/mocha/lib/runner.js\");\r\nexports.Suite = Suite;\r\nexports.Hook = __webpack_require__(/*! ./hook */ \"./node_modules/mocha/lib/hook.js\");\r\nexports.Test = __webpack_require__(/*! ./test */ \"./node_modules/mocha/lib/test.js\");\r\n\r\n/**\r\n * Constructs a new Mocha instance with `options`.\r\n *\r\n * @public\r\n * @class Mocha\r\n * @param {Object} [options] - Settings object.\r\n * @param {boolean} [options.allowUncaught] - Propagate uncaught errors?\r\n * @param {boolean} [options.asyncOnly] - Force `done` callback or promise?\r\n * @param {boolean} [options.bail] - Bail after first test failure?\r\n * @param {boolean} [options.checkLeaks] - Check for global variable leaks?\r\n * @param {boolean} [options.color] - Color TTY output from reporter?\r\n * @param {boolean} [options.delay] - Delay root suite execution?\r\n * @param {boolean} [options.diff] - Show diff on failure?\r\n * @param {string} [options.fgrep] - Test filter given string.\r\n * @param {boolean} [options.forbidOnly] - Tests marked `only` fail the suite?\r\n * @param {boolean} [options.forbidPending] - Pending tests fail the suite?\r\n * @param {boolean} [options.fullTrace] - Full stacktrace upon failure?\r\n * @param {string[]} [options.global] - Variables expected in global scope.\r\n * @param {RegExp|string} [options.grep] - Test filter given regular expression.\r\n * @param {boolean} [options.growl] - Enable desktop notifications?\r\n * @param {boolean} [options.inlineDiffs] - Display inline diffs?\r\n * @param {boolean} [options.invert] - Invert test filter matches?\r\n * @param {boolean} [options.noHighlighting] - Disable syntax highlighting?\r\n * @param {string|constructor} [options.reporter] - Reporter name or constructor.\r\n * @param {Object} [options.reporterOption] - Reporter settings object.\r\n * @param {number} [options.retries] - Number of times to retry failed tests.\r\n * @param {number} [options.slow] - Slow threshold value.\r\n * @param {number|string} [options.timeout] - Timeout threshold value.\r\n * @param {string} [options.ui] - Interface name.\r\n * @param {MochaRootHookObject} [options.rootHooks] - Hooks to bootstrap the root\r\n * suite with\r\n */\r\nfunction Mocha(options) {\r\n  options = utils.assign({}, mocharc, options || {});\r\n  this.files = [];\r\n  this.options = options;\r\n  // root suite\r\n  this.suite = new exports.Suite('', new exports.Context(), true);\r\n  this._cleanReferencesAfterRun = true;\r\n\r\n  this.grep(options.grep)\r\n    .fgrep(options.fgrep)\r\n    .ui(options.ui)\r\n    .reporter(\r\n      options.reporter,\r\n      options.reporterOption || options.reporterOptions // reporterOptions was previously the only way to specify options to reporter\r\n    )\r\n    .slow(options.slow)\r\n    .global(options.global);\r\n\r\n  // this guard exists because Suite#timeout does not consider `undefined` to be valid input\r\n  if (typeof options.timeout !== 'undefined') {\r\n    this.timeout(options.timeout === false ? 0 : options.timeout);\r\n  }\r\n\r\n  if ('retries' in options) {\r\n    this.retries(options.retries);\r\n  }\r\n\r\n  [\r\n    'allowUncaught',\r\n    'asyncOnly',\r\n    'bail',\r\n    'checkLeaks',\r\n    'color',\r\n    'delay',\r\n    'diff',\r\n    'forbidOnly',\r\n    'forbidPending',\r\n    'fullTrace',\r\n    'growl',\r\n    'inlineDiffs',\r\n    'invert'\r\n  ].forEach(function(opt) {\r\n    if (options[opt]) {\r\n      this[opt]();\r\n    }\r\n  }, this);\r\n\r\n  if (options.rootHooks) {\r\n    this.rootHooks(options.rootHooks);\r\n  }\r\n}\r\n\r\n/**\r\n * Enables or disables bailing on the first failure.\r\n *\r\n * @public\r\n * @see [CLI option](../#-bail-b)\r\n * @param {boolean} [bail=true] - Whether to bail on first error.\r\n * @returns {Mocha} this\r\n * @chainable\r\n */\r\nMocha.prototype.bail = function(bail) {\r\n  this.suite.bail(bail !== false);\r\n  return this;\r\n};\r\n\r\n/**\r\n * @summary\r\n * Adds `file` to be loaded for execution.\r\n *\r\n * @description\r\n * Useful for generic setup code that must be included within test suite.\r\n *\r\n * @public\r\n * @see [CLI option](../#-file-filedirectoryglob)\r\n * @param {string} file - Pathname of file to be loaded.\r\n * @returns {Mocha} this\r\n * @chainable\r\n */\r\nMocha.prototype.addFile = function(file) {\r\n  this.files.push(file);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Sets reporter to `reporter`, defaults to \"spec\".\r\n *\r\n * @public\r\n * @see [CLI option](../#-reporter-name-r-name)\r\n * @see [Reporters](../#reporters)\r\n * @param {String|Function} reporter - Reporter name or constructor.\r\n * @param {Object} [reporterOptions] - Options used to configure the reporter.\r\n * @returns {Mocha} this\r\n * @chainable\r\n * @throws {Error} if requested reporter cannot be loaded\r\n * @example\r\n *\r\n * // Use XUnit reporter and direct its output to file\r\n * mocha.reporter('xunit', { output: '/path/to/testspec.xunit.xml' });\r\n */\r\nMocha.prototype.reporter = function(reporter, reporterOptions) {\r\n  if (typeof reporter === 'function') {\r\n    this._reporter = reporter;\r\n  } else {\r\n    reporter = reporter || 'spec';\r\n    var _reporter;\r\n    // Try to load a built-in reporter.\r\n    if (builtinReporters[reporter]) {\r\n      _reporter = builtinReporters[reporter];\r\n    }\r\n    // Try to load reporters from process.cwd() and node_modules\r\n    if (!_reporter) {\r\n      try {\r\n        _reporter = __webpack_require__(\"./node_modules/mocha/lib sync recursive\")(reporter);\r\n      } catch (err) {\r\n        if (\r\n          err.code === 'MODULE_NOT_FOUND' ||\r\n          err.message.indexOf('Cannot find module') >= 0\r\n        ) {\r\n          // Try to load reporters from a path (absolute or relative)\r\n          try {\r\n            _reporter = __webpack_require__(\"./node_modules/mocha/lib sync recursive\")(path.resolve(utils.cwd(), reporter));\r\n          } catch (_err) {\r\n            _err.code === 'MODULE_NOT_FOUND' ||\r\n            _err.message.indexOf('Cannot find module') >= 0\r\n              ? utils.warn(sQuote(reporter) + ' reporter not found')\r\n              : utils.warn(\r\n                  sQuote(reporter) +\r\n                    ' reporter blew up with error:\\n' +\r\n                    err.stack\r\n                );\r\n          }\r\n        } else {\r\n          utils.warn(\r\n            sQuote(reporter) + ' reporter blew up with error:\\n' + err.stack\r\n          );\r\n        }\r\n      }\r\n    }\r\n    if (!_reporter) {\r\n      throw createInvalidReporterError(\r\n        'invalid reporter ' + sQuote(reporter),\r\n        reporter\r\n      );\r\n    }\r\n    this._reporter = _reporter;\r\n  }\r\n  this.options.reporterOption = reporterOptions;\r\n  // alias option name is used in public reporters xunit/tap/progress\r\n  this.options.reporterOptions = reporterOptions;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Sets test UI `name`, defaults to \"bdd\".\r\n *\r\n * @public\r\n * @see [CLI option](../#-ui-name-u-name)\r\n * @see [Interface DSLs](../#interfaces)\r\n * @param {string|Function} [ui=bdd] - Interface name or class.\r\n * @returns {Mocha} this\r\n * @chainable\r\n * @throws {Error} if requested interface cannot be loaded\r\n */\r\nMocha.prototype.ui = function(ui) {\r\n  var bindInterface;\r\n  if (typeof ui === 'function') {\r\n    bindInterface = ui;\r\n  } else {\r\n    ui = ui || 'bdd';\r\n    bindInterface = exports.interfaces[ui];\r\n    if (!bindInterface) {\r\n      try {\r\n        bindInterface = __webpack_require__(\"./node_modules/mocha/lib sync recursive\")(ui);\r\n      } catch (err) {\r\n        throw createInvalidInterfaceError(\r\n          'invalid interface ' + sQuote(ui),\r\n          ui\r\n        );\r\n      }\r\n    }\r\n  }\r\n  bindInterface(this.suite);\r\n\r\n  this.suite.on(EVENT_FILE_PRE_REQUIRE, function(context) {\r\n    exports.afterEach = context.afterEach || context.teardown;\r\n    exports.after = context.after || context.suiteTeardown;\r\n    exports.beforeEach = context.beforeEach || context.setup;\r\n    exports.before = context.before || context.suiteSetup;\r\n    exports.describe = context.describe || context.suite;\r\n    exports.it = context.it || context.test;\r\n    exports.xit = context.xit || (context.test && context.test.skip);\r\n    exports.setup = context.setup || context.beforeEach;\r\n    exports.suiteSetup = context.suiteSetup || context.before;\r\n    exports.suiteTeardown = context.suiteTeardown || context.after;\r\n    exports.suite = context.suite || context.describe;\r\n    exports.teardown = context.teardown || context.afterEach;\r\n    exports.test = context.test || context.it;\r\n    exports.run = context.run;\r\n  });\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Loads `files` prior to execution. Does not support ES Modules.\r\n *\r\n * @description\r\n * The implementation relies on Node's `require` to execute\r\n * the test interface functions and will be subject to its cache.\r\n * Supports only CommonJS modules. To load ES modules, use Mocha#loadFilesAsync.\r\n *\r\n * @private\r\n * @see {@link Mocha#addFile}\r\n * @see {@link Mocha#run}\r\n * @see {@link Mocha#unloadFiles}\r\n * @see {@link Mocha#loadFilesAsync}\r\n * @param {Function} [fn] - Callback invoked upon completion.\r\n */\r\nMocha.prototype.loadFiles = function(fn) {\r\n  var self = this;\r\n  var suite = this.suite;\r\n  this.files.forEach(function(file) {\r\n    file = path.resolve(file);\r\n    suite.emit(EVENT_FILE_PRE_REQUIRE, global, file, self);\r\n    suite.emit(EVENT_FILE_REQUIRE, __webpack_require__(\"./node_modules/mocha/lib sync recursive\")(file), file, self);\r\n    suite.emit(EVENT_FILE_POST_REQUIRE, global, file, self);\r\n  });\r\n  fn && fn();\r\n};\r\n\r\n/**\r\n * Loads `files` prior to execution. Supports Node ES Modules.\r\n *\r\n * @description\r\n * The implementation relies on Node's `require` and `import` to execute\r\n * the test interface functions and will be subject to its cache.\r\n * Supports both CJS and ESM modules.\r\n *\r\n * @public\r\n * @see {@link Mocha#addFile}\r\n * @see {@link Mocha#run}\r\n * @see {@link Mocha#unloadFiles}\r\n * @returns {Promise}\r\n * @example\r\n *\r\n * // loads ESM (and CJS) test files asynchronously, then runs root suite\r\n * mocha.loadFilesAsync()\r\n *   .then(() => mocha.run(failures => process.exitCode = failures ? 1 : 0))\r\n *   .catch(() => process.exitCode = 1);\r\n */\r\nMocha.prototype.loadFilesAsync = function() {\r\n  var self = this;\r\n  var suite = this.suite;\r\n  this.loadAsync = true;\r\n\r\n  if (!esmUtils) {\r\n    return new Promise(function(resolve) {\r\n      self.loadFiles(resolve);\r\n    });\r\n  }\r\n\r\n  return esmUtils.loadFilesAsync(\r\n    this.files,\r\n    function(file) {\r\n      suite.emit(EVENT_FILE_PRE_REQUIRE, global, file, self);\r\n    },\r\n    function(file, resultModule) {\r\n      suite.emit(EVENT_FILE_REQUIRE, resultModule, file, self);\r\n      suite.emit(EVENT_FILE_POST_REQUIRE, global, file, self);\r\n    }\r\n  );\r\n};\r\n\r\n/**\r\n * Removes a previously loaded file from Node's `require` cache.\r\n *\r\n * @private\r\n * @static\r\n * @see {@link Mocha#unloadFiles}\r\n * @param {string} file - Pathname of file to be unloaded.\r\n */\r\nMocha.unloadFile = function(file) {\r\n  delete __webpack_require__.c[/*require.resolve*/(__webpack_require__(\"./node_modules/mocha/lib sync recursive\").resolve(file))];\r\n};\r\n\r\n/**\r\n * Unloads `files` from Node's `require` cache.\r\n *\r\n * @description\r\n * This allows required files to be \"freshly\" reloaded, providing the ability\r\n * to reuse a Mocha instance programmatically.\r\n * Note: does not clear ESM module files from the cache\r\n *\r\n * <strong>Intended for consumers &mdash; not used internally</strong>\r\n *\r\n * @public\r\n * @see {@link Mocha#run}\r\n * @returns {Mocha} this\r\n * @chainable\r\n */\r\nMocha.prototype.unloadFiles = function() {\r\n  if (this._state === mochaStates.DISPOSED) {\r\n    throw createMochaInstanceAlreadyDisposedError(\r\n      'Mocha instance is already disposed, it cannot be used again.',\r\n      this._cleanReferencesAfterRun,\r\n      this\r\n    );\r\n  }\r\n\r\n  this.files.forEach(function(file) {\r\n    Mocha.unloadFile(file);\r\n  });\r\n  this._state = mochaStates.INIT;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Sets `grep` filter after escaping RegExp special characters.\r\n *\r\n * @public\r\n * @see {@link Mocha#grep}\r\n * @param {string} str - Value to be converted to a regexp.\r\n * @returns {Mocha} this\r\n * @chainable\r\n * @example\r\n *\r\n * // Select tests whose full title begins with `\"foo\"` followed by a period\r\n * mocha.fgrep('foo.');\r\n */\r\nMocha.prototype.fgrep = function(str) {\r\n  if (!str) {\r\n    return this;\r\n  }\r\n  return this.grep(new RegExp(escapeRe(str)));\r\n};\r\n\r\n/**\r\n * @summary\r\n * Sets `grep` filter used to select specific tests for execution.\r\n *\r\n * @description\r\n * If `re` is a regexp-like string, it will be converted to regexp.\r\n * The regexp is tested against the full title of each test (i.e., the\r\n * name of the test preceded by titles of each its ancestral suites).\r\n * As such, using an <em>exact-match</em> fixed pattern against the\r\n * test name itself will not yield any matches.\r\n * <br>\r\n * <strong>Previous filter value will be overwritten on each call!</strong>\r\n *\r\n * @public\r\n * @see [CLI option](../#-grep-regexp-g-regexp)\r\n * @see {@link Mocha#fgrep}\r\n * @see {@link Mocha#invert}\r\n * @param {RegExp|String} re - Regular expression used to select tests.\r\n * @return {Mocha} this\r\n * @chainable\r\n * @example\r\n *\r\n * // Select tests whose full title contains `\"match\"`, ignoring case\r\n * mocha.grep(/match/i);\r\n * @example\r\n *\r\n * // Same as above but with regexp-like string argument\r\n * mocha.grep('/match/i');\r\n * @example\r\n *\r\n * // ## Anti-example\r\n * // Given embedded test `it('only-this-test')`...\r\n * mocha.grep('/^only-this-test$/');    // NO! Use `.only()` to do this!\r\n */\r\nMocha.prototype.grep = function(re) {\r\n  if (utils.isString(re)) {\r\n    // extract args if it's regex-like, i.e: [string, pattern, flag]\r\n    var arg = re.match(/^\\/(.*)\\/(g|i|)$|.*/);\r\n    this.options.grep = new RegExp(arg[1] || arg[0], arg[2]);\r\n  } else {\r\n    this.options.grep = re;\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Inverts `grep` matches.\r\n *\r\n * @public\r\n * @see {@link Mocha#grep}\r\n * @return {Mocha} this\r\n * @chainable\r\n * @example\r\n *\r\n * // Select tests whose full title does *not* contain `\"match\"`, ignoring case\r\n * mocha.grep(/match/i).invert();\r\n */\r\nMocha.prototype.invert = function() {\r\n  this.options.invert = true;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Enables or disables ignoring global leaks.\r\n *\r\n * @deprecated since v7.0.0\r\n * @public\r\n * @see {@link Mocha#checkLeaks}\r\n * @param {boolean} [ignoreLeaks=false] - Whether to ignore global leaks.\r\n * @return {Mocha} this\r\n * @chainable\r\n */\r\nMocha.prototype.ignoreLeaks = function(ignoreLeaks) {\r\n  utils.deprecate(\r\n    '\"ignoreLeaks()\" is DEPRECATED, please use \"checkLeaks()\" instead.'\r\n  );\r\n  this.options.checkLeaks = !ignoreLeaks;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Enables or disables checking for global variables leaked while running tests.\r\n *\r\n * @public\r\n * @see [CLI option](../#-check-leaks)\r\n * @param {boolean} [checkLeaks=true] - Whether to check for global variable leaks.\r\n * @return {Mocha} this\r\n * @chainable\r\n */\r\nMocha.prototype.checkLeaks = function(checkLeaks) {\r\n  this.options.checkLeaks = checkLeaks !== false;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Enables or disables whether or not to dispose after each test run.\r\n * Disable this to ensure you can run the test suite multiple times.\r\n * If disabled, be sure to dispose mocha when you're done to prevent memory leaks.\r\n * @public\r\n * @see {@link Mocha#dispose}\r\n * @param {boolean} cleanReferencesAfterRun\r\n * @return {Mocha} this\r\n * @chainable\r\n */\r\nMocha.prototype.cleanReferencesAfterRun = function(cleanReferencesAfterRun) {\r\n  this._cleanReferencesAfterRun = cleanReferencesAfterRun !== false;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Manually dispose this mocha instance. Mark this instance as `disposed` and unable to run more tests.\r\n * It also removes function references to tests functions and hooks, so variables trapped in closures can be cleaned by the garbage collector.\r\n * @public\r\n */\r\nMocha.prototype.dispose = function() {\r\n  if (this._state === mochaStates.RUNNING) {\r\n    throw createMochaInstanceAlreadyRunningError(\r\n      'Cannot dispose while the mocha instance is still running tests.'\r\n    );\r\n  }\r\n  this.unloadFiles();\r\n  this._previousRunner && this._previousRunner.dispose();\r\n  this.suite.dispose();\r\n  this._state = mochaStates.DISPOSED;\r\n};\r\n\r\n/**\r\n * Displays full stack trace upon test failure.\r\n *\r\n * @public\r\n * @see [CLI option](../#-full-trace)\r\n * @param {boolean} [fullTrace=true] - Whether to print full stacktrace upon failure.\r\n * @return {Mocha} this\r\n * @chainable\r\n */\r\nMocha.prototype.fullTrace = function(fullTrace) {\r\n  this.options.fullTrace = fullTrace !== false;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Enables desktop notification support if prerequisite software installed.\r\n *\r\n * @public\r\n * @see [CLI option](../#-growl-g)\r\n * @return {Mocha} this\r\n * @chainable\r\n */\r\nMocha.prototype.growl = function() {\r\n  this.options.growl = this.isGrowlCapable();\r\n  if (!this.options.growl) {\r\n    var detail = process.browser\r\n      ? 'notification support not available in this browser...'\r\n      : 'notification support prerequisites not installed...';\r\n    console.error(detail + ' cannot enable!');\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * @summary\r\n * Determines if Growl support seems likely.\r\n *\r\n * @description\r\n * <strong>Not available when run in browser.</strong>\r\n *\r\n * @private\r\n * @see {@link Growl#isCapable}\r\n * @see {@link Mocha#growl}\r\n * @return {boolean} whether Growl support can be expected\r\n */\r\nMocha.prototype.isGrowlCapable = growl.isCapable;\r\n\r\n/**\r\n * Implements desktop notifications using a pseudo-reporter.\r\n *\r\n * @private\r\n * @see {@link Mocha#growl}\r\n * @see {@link Growl#notify}\r\n * @param {Runner} runner - Runner instance.\r\n */\r\nMocha.prototype._growl = growl.notify;\r\n\r\n/**\r\n * Specifies whitelist of variable names to be expected in global scope.\r\n *\r\n * @public\r\n * @see [CLI option](../#-global-variable-name)\r\n * @see {@link Mocha#checkLeaks}\r\n * @param {String[]|String} global - Accepted global variable name(s).\r\n * @return {Mocha} this\r\n * @chainable\r\n * @example\r\n *\r\n * // Specify variables to be expected in global scope\r\n * mocha.global(['jQuery', 'MyLib']);\r\n */\r\nMocha.prototype.global = function(global) {\r\n  this.options.global = (this.options.global || [])\r\n    .concat(global)\r\n    .filter(Boolean)\r\n    .filter(function(elt, idx, arr) {\r\n      return arr.indexOf(elt) === idx;\r\n    });\r\n  return this;\r\n};\r\n// for backwards compability, 'globals' is an alias of 'global'\r\nMocha.prototype.globals = Mocha.prototype.global;\r\n\r\n/**\r\n * Enables or disables TTY color output by screen-oriented reporters.\r\n *\r\n * @deprecated since v7.0.0\r\n * @public\r\n * @see {@link Mocha#color}\r\n * @param {boolean} colors - Whether to enable color output.\r\n * @return {Mocha} this\r\n * @chainable\r\n */\r\nMocha.prototype.useColors = function(colors) {\r\n  utils.deprecate('\"useColors()\" is DEPRECATED, please use \"color()\" instead.');\r\n  if (colors !== undefined) {\r\n    this.options.color = colors;\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Enables or disables TTY color output by screen-oriented reporters.\r\n *\r\n * @public\r\n * @see [CLI option](../#-color-c-colors)\r\n * @param {boolean} [color=true] - Whether to enable color output.\r\n * @return {Mocha} this\r\n * @chainable\r\n */\r\nMocha.prototype.color = function(color) {\r\n  this.options.color = color !== false;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Determines if reporter should use inline diffs (rather than +/-)\r\n * in test failure output.\r\n *\r\n * @deprecated since v7.0.0\r\n * @public\r\n * @see {@link Mocha#inlineDiffs}\r\n * @param {boolean} [inlineDiffs=false] - Whether to use inline diffs.\r\n * @return {Mocha} this\r\n * @chainable\r\n */\r\nMocha.prototype.useInlineDiffs = function(inlineDiffs) {\r\n  utils.deprecate(\r\n    '\"useInlineDiffs()\" is DEPRECATED, please use \"inlineDiffs()\" instead.'\r\n  );\r\n  this.options.inlineDiffs = inlineDiffs !== undefined && inlineDiffs;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Enables or disables reporter to use inline diffs (rather than +/-)\r\n * in test failure output.\r\n *\r\n * @public\r\n * @see [CLI option](../#-inline-diffs)\r\n * @param {boolean} [inlineDiffs=true] - Whether to use inline diffs.\r\n * @return {Mocha} this\r\n * @chainable\r\n */\r\nMocha.prototype.inlineDiffs = function(inlineDiffs) {\r\n  this.options.inlineDiffs = inlineDiffs !== false;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Determines if reporter should include diffs in test failure output.\r\n *\r\n * @deprecated since v7.0.0\r\n * @public\r\n * @see {@link Mocha#diff}\r\n * @param {boolean} [hideDiff=false] - Whether to hide diffs.\r\n * @return {Mocha} this\r\n * @chainable\r\n */\r\nMocha.prototype.hideDiff = function(hideDiff) {\r\n  utils.deprecate('\"hideDiff()\" is DEPRECATED, please use \"diff()\" instead.');\r\n  this.options.diff = !(hideDiff === true);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Enables or disables reporter to include diff in test failure output.\r\n *\r\n * @public\r\n * @see [CLI option](../#-diff)\r\n * @param {boolean} [diff=true] - Whether to show diff on failure.\r\n * @return {Mocha} this\r\n * @chainable\r\n */\r\nMocha.prototype.diff = function(diff) {\r\n  this.options.diff = diff !== false;\r\n  return this;\r\n};\r\n\r\n/**\r\n * @summary\r\n * Sets timeout threshold value.\r\n *\r\n * @description\r\n * A string argument can use shorthand (such as \"2s\") and will be converted.\r\n * If the value is `0`, timeouts will be disabled.\r\n *\r\n * @public\r\n * @see [CLI option](../#-timeout-ms-t-ms)\r\n * @see [Timeouts](../#timeouts)\r\n * @see {@link Mocha#enableTimeouts}\r\n * @param {number|string} msecs - Timeout threshold value.\r\n * @return {Mocha} this\r\n * @chainable\r\n * @example\r\n *\r\n * // Sets timeout to one second\r\n * mocha.timeout(1000);\r\n * @example\r\n *\r\n * // Same as above but using string argument\r\n * mocha.timeout('1s');\r\n */\r\nMocha.prototype.timeout = function(msecs) {\r\n  this.suite.timeout(msecs);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Sets the number of times to retry failed tests.\r\n *\r\n * @public\r\n * @see [CLI option](../#-retries-n)\r\n * @see [Retry Tests](../#retry-tests)\r\n * @param {number} retry - Number of times to retry failed tests.\r\n * @return {Mocha} this\r\n * @chainable\r\n * @example\r\n *\r\n * // Allow any failed test to retry one more time\r\n * mocha.retries(1);\r\n */\r\nMocha.prototype.retries = function(n) {\r\n  this.suite.retries(n);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Sets slowness threshold value.\r\n *\r\n * @public\r\n * @see [CLI option](../#-slow-ms-s-ms)\r\n * @param {number} msecs - Slowness threshold value.\r\n * @return {Mocha} this\r\n * @chainable\r\n * @example\r\n *\r\n * // Sets \"slow\" threshold to half a second\r\n * mocha.slow(500);\r\n * @example\r\n *\r\n * // Same as above but using string argument\r\n * mocha.slow('0.5s');\r\n */\r\nMocha.prototype.slow = function(msecs) {\r\n  this.suite.slow(msecs);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Enables or disables timeouts.\r\n *\r\n * @public\r\n * @see [CLI option](../#-timeout-ms-t-ms)\r\n * @param {boolean} enableTimeouts - Whether to enable timeouts.\r\n * @return {Mocha} this\r\n * @chainable\r\n */\r\nMocha.prototype.enableTimeouts = function(enableTimeouts) {\r\n  this.suite.enableTimeouts(\r\n    arguments.length && enableTimeouts !== undefined ? enableTimeouts : true\r\n  );\r\n  return this;\r\n};\r\n\r\n/**\r\n * Forces all tests to either accept a `done` callback or return a promise.\r\n *\r\n * @public\r\n * @see [CLI option](../#-async-only-a)\r\n * @param {boolean} [asyncOnly=true] - Wether to force `done` callback or promise.\r\n * @return {Mocha} this\r\n * @chainable\r\n */\r\nMocha.prototype.asyncOnly = function(asyncOnly) {\r\n  this.options.asyncOnly = asyncOnly !== false;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Disables syntax highlighting (in browser).\r\n *\r\n * @public\r\n * @return {Mocha} this\r\n * @chainable\r\n */\r\nMocha.prototype.noHighlighting = function() {\r\n  this.options.noHighlighting = true;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Enables or disables uncaught errors to propagate.\r\n *\r\n * @public\r\n * @see [CLI option](../#-allow-uncaught)\r\n * @param {boolean} [allowUncaught=true] - Whether to propagate uncaught errors.\r\n * @return {Mocha} this\r\n * @chainable\r\n */\r\nMocha.prototype.allowUncaught = function(allowUncaught) {\r\n  this.options.allowUncaught = allowUncaught !== false;\r\n  return this;\r\n};\r\n\r\n/**\r\n * @summary\r\n * Delays root suite execution.\r\n *\r\n * @description\r\n * Used to perform asynch operations before any suites are run.\r\n *\r\n * @public\r\n * @see [delayed root suite](../#delayed-root-suite)\r\n * @returns {Mocha} this\r\n * @chainable\r\n */\r\nMocha.prototype.delay = function delay() {\r\n  this.options.delay = true;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Causes tests marked `only` to fail the suite.\r\n *\r\n * @public\r\n * @see [CLI option](../#-forbid-only)\r\n * @param {boolean} [forbidOnly=true] - Whether tests marked `only` fail the suite.\r\n * @returns {Mocha} this\r\n * @chainable\r\n */\r\nMocha.prototype.forbidOnly = function(forbidOnly) {\r\n  this.options.forbidOnly = forbidOnly !== false;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Causes pending tests and tests marked `skip` to fail the suite.\r\n *\r\n * @public\r\n * @see [CLI option](../#-forbid-pending)\r\n * @param {boolean} [forbidPending=true] - Whether pending tests fail the suite.\r\n * @returns {Mocha} this\r\n * @chainable\r\n */\r\nMocha.prototype.forbidPending = function(forbidPending) {\r\n  this.options.forbidPending = forbidPending !== false;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Throws an error if mocha is in the wrong state to be able to transition to a \"running\" state.\r\n */\r\nMocha.prototype._guardRunningStateTransition = function() {\r\n  if (this._state === mochaStates.RUNNING) {\r\n    throw createMochaInstanceAlreadyRunningError(\r\n      'Mocha instance is currently running tests, cannot start a next test run until this one is done',\r\n      this\r\n    );\r\n  }\r\n  if (\r\n    this._state === mochaStates.DISPOSED ||\r\n    this._state === mochaStates.REFERENCES_CLEANED\r\n  ) {\r\n    throw createMochaInstanceAlreadyDisposedError(\r\n      'Mocha instance is already disposed, cannot start a new test run. Please create a new mocha instance. Be sure to set disable `cleanReferencesAfterRun` when you want to reuse the same mocha instance for multiple test runs.',\r\n      this._cleanReferencesAfterRun,\r\n      this\r\n    );\r\n  }\r\n};\r\n\r\n/**\r\n * Mocha version as specified by \"package.json\".\r\n *\r\n * @name Mocha#version\r\n * @type string\r\n * @readonly\r\n */\r\nObject.defineProperty(Mocha.prototype, 'version', {\r\n  value: __webpack_require__(/*! ../package.json */ \"./node_modules/mocha/package.json\").version,\r\n  configurable: false,\r\n  enumerable: true,\r\n  writable: false\r\n});\r\n\r\n/**\r\n * Callback to be invoked when test execution is complete.\r\n *\r\n * @callback DoneCB\r\n * @param {number} failures - Number of failures that occurred.\r\n */\r\n\r\n/**\r\n * Runs root suite and invokes `fn()` when complete.\r\n *\r\n * @description\r\n * To run tests multiple times (or to run tests in files that are\r\n * already in the `require` cache), make sure to clear them from\r\n * the cache first!\r\n *\r\n * @public\r\n * @see {@link Mocha#unloadFiles}\r\n * @see {@link Runner#run}\r\n * @param {DoneCB} [fn] - Callback invoked when test execution completed.\r\n * @returns {Runner} runner instance\r\n * @example\r\n *\r\n * // exit with non-zero status if there were test failures\r\n * mocha.run(failures => process.exitCode = failures ? 1 : 0);\r\n */\r\nMocha.prototype.run = function(fn) {\r\n  this._guardRunningStateTransition();\r\n  this._state = mochaStates.RUNNING;\r\n  if (this._previousRunner) {\r\n    this._previousRunner.dispose();\r\n    this.suite.reset();\r\n  }\r\n  if (this.files.length && !this.loadAsync) {\r\n    this.loadFiles();\r\n  }\r\n  var self = this;\r\n  var suite = this.suite;\r\n  var options = this.options;\r\n  options.files = this.files;\r\n  var runner = new exports.Runner(suite, {\r\n    delay: options.delay,\r\n    cleanReferencesAfterRun: this._cleanReferencesAfterRun\r\n  });\r\n  createStatsCollector(runner);\r\n  var reporter = new this._reporter(runner, options);\r\n  runner.checkLeaks = options.checkLeaks === true;\r\n  runner.fullStackTrace = options.fullTrace;\r\n  runner.asyncOnly = options.asyncOnly;\r\n  runner.allowUncaught = options.allowUncaught;\r\n  runner.forbidOnly = options.forbidOnly;\r\n  runner.forbidPending = options.forbidPending;\r\n  if (options.grep) {\r\n    runner.grep(options.grep, options.invert);\r\n  }\r\n  if (options.global) {\r\n    runner.globals(options.global);\r\n  }\r\n  if (options.growl) {\r\n    this._growl(runner);\r\n  }\r\n  if (options.color !== undefined) {\r\n    exports.reporters.Base.useColors = options.color;\r\n  }\r\n  exports.reporters.Base.inlineDiffs = options.inlineDiffs;\r\n  exports.reporters.Base.hideDiff = !options.diff;\r\n\r\n  function done(failures) {\r\n    self._previousRunner = runner;\r\n    if (self._cleanReferencesAfterRun) {\r\n      self._state = mochaStates.REFERENCES_CLEANED;\r\n    } else {\r\n      self._state = mochaStates.INIT;\r\n    }\r\n    fn = fn || utils.noop;\r\n    if (reporter.done) {\r\n      reporter.done(failures, fn);\r\n    } else {\r\n      fn(failures);\r\n    }\r\n  }\r\n\r\n  return runner.run(done);\r\n};\r\n\r\n/**\r\n * Assigns hooks to the root suite\r\n * @param {MochaRootHookObject} [hooks] - Hooks to assign to root suite\r\n * @chainable\r\n */\r\nMocha.prototype.rootHooks = function rootHooks(hooks) {\r\n  if (utils.type(hooks) === 'object') {\r\n    var beforeAll = [].concat(hooks.beforeAll || []);\r\n    var beforeEach = [].concat(hooks.beforeEach || []);\r\n    var afterAll = [].concat(hooks.afterAll || []);\r\n    var afterEach = [].concat(hooks.afterEach || []);\r\n    var rootSuite = this.suite;\r\n    beforeAll.forEach(function(hook) {\r\n      rootSuite.beforeAll(hook);\r\n    });\r\n    beforeEach.forEach(function(hook) {\r\n      rootSuite.beforeEach(hook);\r\n    });\r\n    afterAll.forEach(function(hook) {\r\n      rootSuite.afterAll(hook);\r\n    });\r\n    afterEach.forEach(function(hook) {\r\n      rootSuite.afterEach(hook);\r\n    });\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * An alternative way to define root hooks that works with parallel runs.\r\n * @typedef {Object} MochaRootHookObject\r\n * @property {Function|Function[]} [beforeAll] - \"Before all\" hook(s)\r\n * @property {Function|Function[]} [beforeEach] - \"Before each\" hook(s)\r\n * @property {Function|Function[]} [afterAll] - \"After all\" hook(s)\r\n * @property {Function|Function[]} [afterEach] - \"After each\" hook(s)\r\n */\r\n\r\n/**\r\n * An function that returns a {@link MochaRootHookObject}, either sync or async.\r\n * @callback MochaRootHookFunction\r\n * @returns {MochaRootHookObject|Promise<MochaRootHookObject>}\r\n */\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \"./node_modules/process/browser.js\"), __webpack_require__(/*! ./../../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module), __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/mocha/lib/mocha.js?");

/***/ }),

/***/ "./node_modules/mocha/lib/mocharc.json":
/*!*********************************************!*\
  !*** ./node_modules/mocha/lib/mocharc.json ***!
  \*********************************************/
/*! exports provided: diff, extension, opts, package, reporter, slow, timeout, ui, watch-ignore, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"diff\\\":true,\\\"extension\\\":[\\\"js\\\",\\\"cjs\\\",\\\"mjs\\\"],\\\"opts\\\":\\\"./test/mocha.opts\\\",\\\"package\\\":\\\"./package.json\\\",\\\"reporter\\\":\\\"spec\\\",\\\"slow\\\":75,\\\"timeout\\\":2000,\\\"ui\\\":\\\"bdd\\\",\\\"watch-ignore\\\":[\\\"node_modules\\\",\\\".git\\\"]}\");\n\n//# sourceURL=webpack:///./node_modules/mocha/lib/mocharc.json?");

/***/ }),

/***/ "./node_modules/mocha/lib/pending.js":
/*!*******************************************!*\
  !*** ./node_modules/mocha/lib/pending.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nmodule.exports = Pending;\r\n\r\n/**\r\n * Initialize a new `Pending` error with the given message.\r\n *\r\n * @param {string} message\r\n */\r\nfunction Pending(message) {\r\n  this.message = message;\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/mocha/lib/pending.js?");

/***/ }),

/***/ "./node_modules/mocha/lib/reporters/base.js":
/*!**************************************************!*\
  !*** ./node_modules/mocha/lib/reporters/base.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\r\n/**\r\n * @module Base\r\n */\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar tty = __webpack_require__(/*! tty */ \"./node_modules/mocha/lib/browser/tty.js\");\r\nvar diff = __webpack_require__(/*! diff */ \"./node_modules/diff/dist/diff.js\");\r\nvar milliseconds = __webpack_require__(/*! ms */ \"./node_modules/mocha/node_modules/ms/index.js\");\r\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/mocha/lib/utils.js\");\r\nvar supportsColor = process.browser ? null : __webpack_require__(/*! supports-color */ 6);\r\nvar constants = __webpack_require__(/*! ../runner */ \"./node_modules/mocha/lib/runner.js\").constants;\r\nvar EVENT_TEST_PASS = constants.EVENT_TEST_PASS;\r\nvar EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;\r\n\r\n/**\r\n * Expose `Base`.\r\n */\r\n\r\nexports = module.exports = Base;\r\n\r\n/**\r\n * Check if both stdio streams are associated with a tty.\r\n */\r\n\r\nvar isatty = process.stdout.isTTY && process.stderr.isTTY;\r\n\r\n/**\r\n * Save log references to avoid tests interfering (see GH-3604).\r\n */\r\nvar consoleLog = console.log;\r\n\r\n/**\r\n * Enable coloring by default, except in the browser interface.\r\n */\r\n\r\nexports.useColors =\r\n  !process.browser &&\r\n  (supportsColor.stdout || process.env.MOCHA_COLORS !== undefined);\r\n\r\n/**\r\n * Inline diffs instead of +/-\r\n */\r\n\r\nexports.inlineDiffs = false;\r\n\r\n/**\r\n * Default color map.\r\n */\r\n\r\nexports.colors = {\r\n  pass: 90,\r\n  fail: 31,\r\n  'bright pass': 92,\r\n  'bright fail': 91,\r\n  'bright yellow': 93,\r\n  pending: 36,\r\n  suite: 0,\r\n  'error title': 0,\r\n  'error message': 31,\r\n  'error stack': 90,\r\n  checkmark: 32,\r\n  fast: 90,\r\n  medium: 33,\r\n  slow: 31,\r\n  green: 32,\r\n  light: 90,\r\n  'diff gutter': 90,\r\n  'diff added': 32,\r\n  'diff removed': 31\r\n};\r\n\r\n/**\r\n * Default symbol map.\r\n */\r\n\r\nexports.symbols = {\r\n  ok: '',\r\n  err: '',\r\n  dot: '',\r\n  comma: ',',\r\n  bang: '!'\r\n};\r\n\r\n// With node.js on Windows: use symbols available in terminal default fonts\r\nif (process.platform === 'win32') {\r\n  exports.symbols.ok = '\\u221A';\r\n  exports.symbols.err = '\\u00D7';\r\n  exports.symbols.dot = '.';\r\n}\r\n\r\n/**\r\n * Color `str` with the given `type`,\r\n * allowing colors to be disabled,\r\n * as well as user-defined color\r\n * schemes.\r\n *\r\n * @private\r\n * @param {string} type\r\n * @param {string} str\r\n * @return {string}\r\n */\r\nvar color = (exports.color = function(type, str) {\r\n  if (!exports.useColors) {\r\n    return String(str);\r\n  }\r\n  return '\\u001b[' + exports.colors[type] + 'm' + str + '\\u001b[0m';\r\n});\r\n\r\n/**\r\n * Expose term window size, with some defaults for when stderr is not a tty.\r\n */\r\n\r\nexports.window = {\r\n  width: 75\r\n};\r\n\r\nif (isatty) {\r\n  exports.window.width = process.stdout.getWindowSize\r\n    ? process.stdout.getWindowSize(1)[0]\r\n    : tty.getWindowSize()[1];\r\n}\r\n\r\n/**\r\n * Expose some basic cursor interactions that are common among reporters.\r\n */\r\n\r\nexports.cursor = {\r\n  hide: function() {\r\n    isatty && process.stdout.write('\\u001b[?25l');\r\n  },\r\n\r\n  show: function() {\r\n    isatty && process.stdout.write('\\u001b[?25h');\r\n  },\r\n\r\n  deleteLine: function() {\r\n    isatty && process.stdout.write('\\u001b[2K');\r\n  },\r\n\r\n  beginningOfLine: function() {\r\n    isatty && process.stdout.write('\\u001b[0G');\r\n  },\r\n\r\n  CR: function() {\r\n    if (isatty) {\r\n      exports.cursor.deleteLine();\r\n      exports.cursor.beginningOfLine();\r\n    } else {\r\n      process.stdout.write('\\r');\r\n    }\r\n  }\r\n};\r\n\r\nvar showDiff = (exports.showDiff = function(err) {\r\n  return (\r\n    err &&\r\n    err.showDiff !== false &&\r\n    sameType(err.actual, err.expected) &&\r\n    err.expected !== undefined\r\n  );\r\n});\r\n\r\nfunction stringifyDiffObjs(err) {\r\n  if (!utils.isString(err.actual) || !utils.isString(err.expected)) {\r\n    err.actual = utils.stringify(err.actual);\r\n    err.expected = utils.stringify(err.expected);\r\n  }\r\n}\r\n\r\n/**\r\n * Returns a diff between 2 strings with coloured ANSI output.\r\n *\r\n * @description\r\n * The diff will be either inline or unified dependent on the value\r\n * of `Base.inlineDiff`.\r\n *\r\n * @param {string} actual\r\n * @param {string} expected\r\n * @return {string} Diff\r\n */\r\nvar generateDiff = (exports.generateDiff = function(actual, expected) {\r\n  try {\r\n    return exports.inlineDiffs\r\n      ? inlineDiff(actual, expected)\r\n      : unifiedDiff(actual, expected);\r\n  } catch (err) {\r\n    var msg =\r\n      '\\n      ' +\r\n      color('diff added', '+ expected') +\r\n      ' ' +\r\n      color('diff removed', '- actual:  failed to generate Mocha diff') +\r\n      '\\n';\r\n    return msg;\r\n  }\r\n});\r\n\r\n/**\r\n * Outputs the given `failures` as a list.\r\n *\r\n * @public\r\n * @memberof Mocha.reporters.Base\r\n * @variation 1\r\n * @param {Object[]} failures - Each is Test instance with corresponding\r\n *     Error property\r\n */\r\nexports.list = function(failures) {\r\n  var multipleErr, multipleTest;\r\n  Base.consoleLog();\r\n  failures.forEach(function(test, i) {\r\n    // format\r\n    var fmt =\r\n      color('error title', '  %s) %s:\\n') +\r\n      color('error message', '     %s') +\r\n      color('error stack', '\\n%s\\n');\r\n\r\n    // msg\r\n    var msg;\r\n    var err;\r\n    if (test.err && test.err.multiple) {\r\n      if (multipleTest !== test) {\r\n        multipleTest = test;\r\n        multipleErr = [test.err].concat(test.err.multiple);\r\n      }\r\n      err = multipleErr.shift();\r\n    } else {\r\n      err = test.err;\r\n    }\r\n    var message;\r\n    if (err.message && typeof err.message.toString === 'function') {\r\n      message = err.message + '';\r\n    } else if (typeof err.inspect === 'function') {\r\n      message = err.inspect() + '';\r\n    } else {\r\n      message = '';\r\n    }\r\n    var stack = err.stack || message;\r\n    var index = message ? stack.indexOf(message) : -1;\r\n\r\n    if (index === -1) {\r\n      msg = message;\r\n    } else {\r\n      index += message.length;\r\n      msg = stack.slice(0, index);\r\n      // remove msg from stack\r\n      stack = stack.slice(index + 1);\r\n    }\r\n\r\n    // uncaught\r\n    if (err.uncaught) {\r\n      msg = 'Uncaught ' + msg;\r\n    }\r\n    // explicitly show diff\r\n    if (!exports.hideDiff && showDiff(err)) {\r\n      stringifyDiffObjs(err);\r\n      fmt =\r\n        color('error title', '  %s) %s:\\n%s') + color('error stack', '\\n%s\\n');\r\n      var match = message.match(/^([^:]+): expected/);\r\n      msg = '\\n      ' + color('error message', match ? match[1] : msg);\r\n\r\n      msg += generateDiff(err.actual, err.expected);\r\n    }\r\n\r\n    // indent stack trace\r\n    stack = stack.replace(/^/gm, '  ');\r\n\r\n    // indented test title\r\n    var testTitle = '';\r\n    test.titlePath().forEach(function(str, index) {\r\n      if (index !== 0) {\r\n        testTitle += '\\n     ';\r\n      }\r\n      for (var i = 0; i < index; i++) {\r\n        testTitle += '  ';\r\n      }\r\n      testTitle += str;\r\n    });\r\n\r\n    Base.consoleLog(fmt, i + 1, testTitle, msg, stack);\r\n  });\r\n};\r\n\r\n/**\r\n * Constructs a new `Base` reporter instance.\r\n *\r\n * @description\r\n * All other reporters generally inherit from this reporter.\r\n *\r\n * @public\r\n * @class\r\n * @memberof Mocha.reporters\r\n * @param {Runner} runner - Instance triggers reporter actions.\r\n * @param {Object} [options] - runner options\r\n */\r\nfunction Base(runner, options) {\r\n  var failures = (this.failures = []);\r\n\r\n  if (!runner) {\r\n    throw new TypeError('Missing runner argument');\r\n  }\r\n  this.options = options || {};\r\n  this.runner = runner;\r\n  this.stats = runner.stats; // assigned so Reporters keep a closer reference\r\n\r\n  runner.on(EVENT_TEST_PASS, function(test) {\r\n    if (test.duration > test.slow()) {\r\n      test.speed = 'slow';\r\n    } else if (test.duration > test.slow() / 2) {\r\n      test.speed = 'medium';\r\n    } else {\r\n      test.speed = 'fast';\r\n    }\r\n  });\r\n\r\n  runner.on(EVENT_TEST_FAIL, function(test, err) {\r\n    if (showDiff(err)) {\r\n      stringifyDiffObjs(err);\r\n    }\r\n    // more than one error per test\r\n    if (test.err && err instanceof Error) {\r\n      test.err.multiple = (test.err.multiple || []).concat(err);\r\n    } else {\r\n      test.err = err;\r\n    }\r\n    failures.push(test);\r\n  });\r\n}\r\n\r\n/**\r\n * Outputs common epilogue used by many of the bundled reporters.\r\n *\r\n * @public\r\n * @memberof Mocha.reporters\r\n */\r\nBase.prototype.epilogue = function() {\r\n  var stats = this.stats;\r\n  var fmt;\r\n\r\n  Base.consoleLog();\r\n\r\n  // passes\r\n  fmt =\r\n    color('bright pass', ' ') +\r\n    color('green', ' %d passing') +\r\n    color('light', ' (%s)');\r\n\r\n  Base.consoleLog(fmt, stats.passes || 0, milliseconds(stats.duration));\r\n\r\n  // pending\r\n  if (stats.pending) {\r\n    fmt = color('pending', ' ') + color('pending', ' %d pending');\r\n\r\n    Base.consoleLog(fmt, stats.pending);\r\n  }\r\n\r\n  // failures\r\n  if (stats.failures) {\r\n    fmt = color('fail', '  %d failing');\r\n\r\n    Base.consoleLog(fmt, stats.failures);\r\n\r\n    Base.list(this.failures);\r\n    Base.consoleLog();\r\n  }\r\n\r\n  Base.consoleLog();\r\n};\r\n\r\n/**\r\n * Pads the given `str` to `len`.\r\n *\r\n * @private\r\n * @param {string} str\r\n * @param {string} len\r\n * @return {string}\r\n */\r\nfunction pad(str, len) {\r\n  str = String(str);\r\n  return Array(len - str.length + 1).join(' ') + str;\r\n}\r\n\r\n/**\r\n * Returns inline diff between 2 strings with coloured ANSI output.\r\n *\r\n * @private\r\n * @param {String} actual\r\n * @param {String} expected\r\n * @return {string} Diff\r\n */\r\nfunction inlineDiff(actual, expected) {\r\n  var msg = errorDiff(actual, expected);\r\n\r\n  // linenos\r\n  var lines = msg.split('\\n');\r\n  if (lines.length > 4) {\r\n    var width = String(lines.length).length;\r\n    msg = lines\r\n      .map(function(str, i) {\r\n        return pad(++i, width) + ' |' + ' ' + str;\r\n      })\r\n      .join('\\n');\r\n  }\r\n\r\n  // legend\r\n  msg =\r\n    '\\n' +\r\n    color('diff removed', 'actual') +\r\n    ' ' +\r\n    color('diff added', 'expected') +\r\n    '\\n\\n' +\r\n    msg +\r\n    '\\n';\r\n\r\n  // indent\r\n  msg = msg.replace(/^/gm, '      ');\r\n  return msg;\r\n}\r\n\r\n/**\r\n * Returns unified diff between two strings with coloured ANSI output.\r\n *\r\n * @private\r\n * @param {String} actual\r\n * @param {String} expected\r\n * @return {string} The diff.\r\n */\r\nfunction unifiedDiff(actual, expected) {\r\n  var indent = '      ';\r\n  function cleanUp(line) {\r\n    if (line[0] === '+') {\r\n      return indent + colorLines('diff added', line);\r\n    }\r\n    if (line[0] === '-') {\r\n      return indent + colorLines('diff removed', line);\r\n    }\r\n    if (line.match(/@@/)) {\r\n      return '--';\r\n    }\r\n    if (line.match(/\\\\ No newline/)) {\r\n      return null;\r\n    }\r\n    return indent + line;\r\n  }\r\n  function notBlank(line) {\r\n    return typeof line !== 'undefined' && line !== null;\r\n  }\r\n  var msg = diff.createPatch('string', actual, expected);\r\n  var lines = msg.split('\\n').splice(5);\r\n  return (\r\n    '\\n      ' +\r\n    colorLines('diff added', '+ expected') +\r\n    ' ' +\r\n    colorLines('diff removed', '- actual') +\r\n    '\\n\\n' +\r\n    lines\r\n      .map(cleanUp)\r\n      .filter(notBlank)\r\n      .join('\\n')\r\n  );\r\n}\r\n\r\n/**\r\n * Returns character diff for `err`.\r\n *\r\n * @private\r\n * @param {String} actual\r\n * @param {String} expected\r\n * @return {string} the diff\r\n */\r\nfunction errorDiff(actual, expected) {\r\n  return diff\r\n    .diffWordsWithSpace(actual, expected)\r\n    .map(function(str) {\r\n      if (str.added) {\r\n        return colorLines('diff added', str.value);\r\n      }\r\n      if (str.removed) {\r\n        return colorLines('diff removed', str.value);\r\n      }\r\n      return str.value;\r\n    })\r\n    .join('');\r\n}\r\n\r\n/**\r\n * Colors lines for `str`, using the color `name`.\r\n *\r\n * @private\r\n * @param {string} name\r\n * @param {string} str\r\n * @return {string}\r\n */\r\nfunction colorLines(name, str) {\r\n  return str\r\n    .split('\\n')\r\n    .map(function(str) {\r\n      return color(name, str);\r\n    })\r\n    .join('\\n');\r\n}\r\n\r\n/**\r\n * Object#toString reference.\r\n */\r\nvar objToString = Object.prototype.toString;\r\n\r\n/**\r\n * Checks that a / b have the same type.\r\n *\r\n * @private\r\n * @param {Object} a\r\n * @param {Object} b\r\n * @return {boolean}\r\n */\r\nfunction sameType(a, b) {\r\n  return objToString.call(a) === objToString.call(b);\r\n}\r\n\r\nBase.consoleLog = consoleLog;\r\n\r\nBase.abstract = true;\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/mocha/lib/reporters/base.js?");

/***/ }),

/***/ "./node_modules/mocha/lib/reporters/doc.js":
/*!*************************************************!*\
  !*** ./node_modules/mocha/lib/reporters/doc.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n/**\r\n * @module Doc\r\n */\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = __webpack_require__(/*! ./base */ \"./node_modules/mocha/lib/reporters/base.js\");\r\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/mocha/lib/utils.js\");\r\nvar constants = __webpack_require__(/*! ../runner */ \"./node_modules/mocha/lib/runner.js\").constants;\r\nvar EVENT_TEST_PASS = constants.EVENT_TEST_PASS;\r\nvar EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;\r\nvar EVENT_SUITE_BEGIN = constants.EVENT_SUITE_BEGIN;\r\nvar EVENT_SUITE_END = constants.EVENT_SUITE_END;\r\n\r\n/**\r\n * Expose `Doc`.\r\n */\r\n\r\nexports = module.exports = Doc;\r\n\r\n/**\r\n * Constructs a new `Doc` reporter instance.\r\n *\r\n * @public\r\n * @class\r\n * @memberof Mocha.reporters\r\n * @extends Mocha.reporters.Base\r\n * @param {Runner} runner - Instance triggers reporter actions.\r\n * @param {Object} [options] - runner options\r\n */\r\nfunction Doc(runner, options) {\r\n  Base.call(this, runner, options);\r\n\r\n  var indents = 2;\r\n\r\n  function indent() {\r\n    return Array(indents).join('  ');\r\n  }\r\n\r\n  runner.on(EVENT_SUITE_BEGIN, function(suite) {\r\n    if (suite.root) {\r\n      return;\r\n    }\r\n    ++indents;\r\n    Base.consoleLog('%s<section class=\"suite\">', indent());\r\n    ++indents;\r\n    Base.consoleLog('%s<h1>%s</h1>', indent(), utils.escape(suite.title));\r\n    Base.consoleLog('%s<dl>', indent());\r\n  });\r\n\r\n  runner.on(EVENT_SUITE_END, function(suite) {\r\n    if (suite.root) {\r\n      return;\r\n    }\r\n    Base.consoleLog('%s</dl>', indent());\r\n    --indents;\r\n    Base.consoleLog('%s</section>', indent());\r\n    --indents;\r\n  });\r\n\r\n  runner.on(EVENT_TEST_PASS, function(test) {\r\n    Base.consoleLog('%s  <dt>%s</dt>', indent(), utils.escape(test.title));\r\n    Base.consoleLog('%s  <dt>%s</dt>', indent(), utils.escape(test.file));\r\n    var code = utils.escape(utils.clean(test.body));\r\n    Base.consoleLog('%s  <dd><pre><code>%s</code></pre></dd>', indent(), code);\r\n  });\r\n\r\n  runner.on(EVENT_TEST_FAIL, function(test, err) {\r\n    Base.consoleLog(\r\n      '%s  <dt class=\"error\">%s</dt>',\r\n      indent(),\r\n      utils.escape(test.title)\r\n    );\r\n    Base.consoleLog(\r\n      '%s  <dt class=\"error\">%s</dt>',\r\n      indent(),\r\n      utils.escape(test.file)\r\n    );\r\n    var code = utils.escape(utils.clean(test.body));\r\n    Base.consoleLog(\r\n      '%s  <dd class=\"error\"><pre><code>%s</code></pre></dd>',\r\n      indent(),\r\n      code\r\n    );\r\n    Base.consoleLog(\r\n      '%s  <dd class=\"error\">%s</dd>',\r\n      indent(),\r\n      utils.escape(err)\r\n    );\r\n  });\r\n}\r\n\r\nDoc.description = 'HTML documentation';\r\n\n\n//# sourceURL=webpack:///./node_modules/mocha/lib/reporters/doc.js?");

/***/ }),

/***/ "./node_modules/mocha/lib/reporters/dot.js":
/*!*************************************************!*\
  !*** ./node_modules/mocha/lib/reporters/dot.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\r\n/**\r\n * @module Dot\r\n */\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = __webpack_require__(/*! ./base */ \"./node_modules/mocha/lib/reporters/base.js\");\r\nvar inherits = __webpack_require__(/*! ../utils */ \"./node_modules/mocha/lib/utils.js\").inherits;\r\nvar constants = __webpack_require__(/*! ../runner */ \"./node_modules/mocha/lib/runner.js\").constants;\r\nvar EVENT_TEST_PASS = constants.EVENT_TEST_PASS;\r\nvar EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;\r\nvar EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;\r\nvar EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;\r\nvar EVENT_RUN_END = constants.EVENT_RUN_END;\r\n\r\n/**\r\n * Expose `Dot`.\r\n */\r\n\r\nexports = module.exports = Dot;\r\n\r\n/**\r\n * Constructs a new `Dot` reporter instance.\r\n *\r\n * @public\r\n * @class\r\n * @memberof Mocha.reporters\r\n * @extends Mocha.reporters.Base\r\n * @param {Runner} runner - Instance triggers reporter actions.\r\n * @param {Object} [options] - runner options\r\n */\r\nfunction Dot(runner, options) {\r\n  Base.call(this, runner, options);\r\n\r\n  var self = this;\r\n  var width = (Base.window.width * 0.75) | 0;\r\n  var n = -1;\r\n\r\n  runner.on(EVENT_RUN_BEGIN, function() {\r\n    process.stdout.write('\\n');\r\n  });\r\n\r\n  runner.on(EVENT_TEST_PENDING, function() {\r\n    if (++n % width === 0) {\r\n      process.stdout.write('\\n  ');\r\n    }\r\n    process.stdout.write(Base.color('pending', Base.symbols.comma));\r\n  });\r\n\r\n  runner.on(EVENT_TEST_PASS, function(test) {\r\n    if (++n % width === 0) {\r\n      process.stdout.write('\\n  ');\r\n    }\r\n    if (test.speed === 'slow') {\r\n      process.stdout.write(Base.color('bright yellow', Base.symbols.dot));\r\n    } else {\r\n      process.stdout.write(Base.color(test.speed, Base.symbols.dot));\r\n    }\r\n  });\r\n\r\n  runner.on(EVENT_TEST_FAIL, function() {\r\n    if (++n % width === 0) {\r\n      process.stdout.write('\\n  ');\r\n    }\r\n    process.stdout.write(Base.color('fail', Base.symbols.bang));\r\n  });\r\n\r\n  runner.once(EVENT_RUN_END, function() {\r\n    process.stdout.write('\\n');\r\n    self.epilogue();\r\n  });\r\n}\r\n\r\n/**\r\n * Inherit from `Base.prototype`.\r\n */\r\ninherits(Dot, Base);\r\n\r\nDot.description = 'dot matrix representation';\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/mocha/lib/reporters/dot.js?");

/***/ }),

/***/ "./node_modules/mocha/lib/reporters/html.js":
/*!**************************************************!*\
  !*** ./node_modules/mocha/lib/reporters/html.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\r\n\r\n/* eslint-env browser */\r\n/**\r\n * @module HTML\r\n */\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = __webpack_require__(/*! ./base */ \"./node_modules/mocha/lib/reporters/base.js\");\r\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/mocha/lib/utils.js\");\r\nvar Progress = __webpack_require__(/*! ../browser/progress */ \"./node_modules/mocha/lib/browser/progress.js\");\r\nvar escapeRe = __webpack_require__(/*! escape-string-regexp */ \"./node_modules/escape-string-regexp/index.js\");\r\nvar constants = __webpack_require__(/*! ../runner */ \"./node_modules/mocha/lib/runner.js\").constants;\r\nvar EVENT_TEST_PASS = constants.EVENT_TEST_PASS;\r\nvar EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;\r\nvar EVENT_SUITE_BEGIN = constants.EVENT_SUITE_BEGIN;\r\nvar EVENT_SUITE_END = constants.EVENT_SUITE_END;\r\nvar EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;\r\nvar escape = utils.escape;\r\n\r\n/**\r\n * Save timer references to avoid Sinon interfering (see GH-237).\r\n */\r\n\r\nvar Date = global.Date;\r\n\r\n/**\r\n * Expose `HTML`.\r\n */\r\n\r\nexports = module.exports = HTML;\r\n\r\n/**\r\n * Stats template.\r\n */\r\n\r\nvar statsTemplate =\r\n  '<ul id=\"mocha-stats\">' +\r\n  '<li class=\"progress\"><canvas width=\"40\" height=\"40\"></canvas></li>' +\r\n  '<li class=\"passes\"><a href=\"javascript:void(0);\">passes:</a> <em>0</em></li>' +\r\n  '<li class=\"failures\"><a href=\"javascript:void(0);\">failures:</a> <em>0</em></li>' +\r\n  '<li class=\"duration\">duration: <em>0</em>s</li>' +\r\n  '</ul>';\r\n\r\nvar playIcon = '&#x2023;';\r\n\r\n/**\r\n * Constructs a new `HTML` reporter instance.\r\n *\r\n * @public\r\n * @class\r\n * @memberof Mocha.reporters\r\n * @extends Mocha.reporters.Base\r\n * @param {Runner} runner - Instance triggers reporter actions.\r\n * @param {Object} [options] - runner options\r\n */\r\nfunction HTML(runner, options) {\r\n  Base.call(this, runner, options);\r\n\r\n  var self = this;\r\n  var stats = this.stats;\r\n  var stat = fragment(statsTemplate);\r\n  var items = stat.getElementsByTagName('li');\r\n  var passes = items[1].getElementsByTagName('em')[0];\r\n  var passesLink = items[1].getElementsByTagName('a')[0];\r\n  var failures = items[2].getElementsByTagName('em')[0];\r\n  var failuresLink = items[2].getElementsByTagName('a')[0];\r\n  var duration = items[3].getElementsByTagName('em')[0];\r\n  var canvas = stat.getElementsByTagName('canvas')[0];\r\n  var report = fragment('<ul id=\"mocha-report\"></ul>');\r\n  var stack = [report];\r\n  var progress;\r\n  var ctx;\r\n  var root = document.getElementById('mocha');\r\n\r\n  if (canvas.getContext) {\r\n    var ratio = window.devicePixelRatio || 1;\r\n    canvas.style.width = canvas.width;\r\n    canvas.style.height = canvas.height;\r\n    canvas.width *= ratio;\r\n    canvas.height *= ratio;\r\n    ctx = canvas.getContext('2d');\r\n    ctx.scale(ratio, ratio);\r\n    progress = new Progress();\r\n  }\r\n\r\n  if (!root) {\r\n    return error('#mocha div missing, add it to your document');\r\n  }\r\n\r\n  // pass toggle\r\n  on(passesLink, 'click', function(evt) {\r\n    evt.preventDefault();\r\n    unhide();\r\n    var name = /pass/.test(report.className) ? '' : ' pass';\r\n    report.className = report.className.replace(/fail|pass/g, '') + name;\r\n    if (report.className.trim()) {\r\n      hideSuitesWithout('test pass');\r\n    }\r\n  });\r\n\r\n  // failure toggle\r\n  on(failuresLink, 'click', function(evt) {\r\n    evt.preventDefault();\r\n    unhide();\r\n    var name = /fail/.test(report.className) ? '' : ' fail';\r\n    report.className = report.className.replace(/fail|pass/g, '') + name;\r\n    if (report.className.trim()) {\r\n      hideSuitesWithout('test fail');\r\n    }\r\n  });\r\n\r\n  root.appendChild(stat);\r\n  root.appendChild(report);\r\n\r\n  if (progress) {\r\n    progress.size(40);\r\n  }\r\n\r\n  runner.on(EVENT_SUITE_BEGIN, function(suite) {\r\n    if (suite.root) {\r\n      return;\r\n    }\r\n\r\n    // suite\r\n    var url = self.suiteURL(suite);\r\n    var el = fragment(\r\n      '<li class=\"suite\"><h1><a href=\"%s\">%s</a></h1></li>',\r\n      url,\r\n      escape(suite.title)\r\n    );\r\n\r\n    // container\r\n    stack[0].appendChild(el);\r\n    stack.unshift(document.createElement('ul'));\r\n    el.appendChild(stack[0]);\r\n  });\r\n\r\n  runner.on(EVENT_SUITE_END, function(suite) {\r\n    if (suite.root) {\r\n      updateStats();\r\n      return;\r\n    }\r\n    stack.shift();\r\n  });\r\n\r\n  runner.on(EVENT_TEST_PASS, function(test) {\r\n    var url = self.testURL(test);\r\n    var markup =\r\n      '<li class=\"test pass %e\"><h2>%e<span class=\"duration\">%ems</span> ' +\r\n      '<a href=\"%s\" class=\"replay\">' +\r\n      playIcon +\r\n      '</a></h2></li>';\r\n    var el = fragment(markup, test.speed, test.title, test.duration, url);\r\n    self.addCodeToggle(el, test.body);\r\n    appendToStack(el);\r\n    updateStats();\r\n  });\r\n\r\n  runner.on(EVENT_TEST_FAIL, function(test) {\r\n    var el = fragment(\r\n      '<li class=\"test fail\"><h2>%e <a href=\"%e\" class=\"replay\">' +\r\n        playIcon +\r\n        '</a></h2></li>',\r\n      test.title,\r\n      self.testURL(test)\r\n    );\r\n    var stackString; // Note: Includes leading newline\r\n    var message = test.err.toString();\r\n\r\n    // <=IE7 stringifies to [Object Error]. Since it can be overloaded, we\r\n    // check for the result of the stringifying.\r\n    if (message === '[object Error]') {\r\n      message = test.err.message;\r\n    }\r\n\r\n    if (test.err.stack) {\r\n      var indexOfMessage = test.err.stack.indexOf(test.err.message);\r\n      if (indexOfMessage === -1) {\r\n        stackString = test.err.stack;\r\n      } else {\r\n        stackString = test.err.stack.substr(\r\n          test.err.message.length + indexOfMessage\r\n        );\r\n      }\r\n    } else if (test.err.sourceURL && test.err.line !== undefined) {\r\n      // Safari doesn't give you a stack. Let's at least provide a source line.\r\n      stackString = '\\n(' + test.err.sourceURL + ':' + test.err.line + ')';\r\n    }\r\n\r\n    stackString = stackString || '';\r\n\r\n    if (test.err.htmlMessage && stackString) {\r\n      el.appendChild(\r\n        fragment(\r\n          '<div class=\"html-error\">%s\\n<pre class=\"error\">%e</pre></div>',\r\n          test.err.htmlMessage,\r\n          stackString\r\n        )\r\n      );\r\n    } else if (test.err.htmlMessage) {\r\n      el.appendChild(\r\n        fragment('<div class=\"html-error\">%s</div>', test.err.htmlMessage)\r\n      );\r\n    } else {\r\n      el.appendChild(\r\n        fragment('<pre class=\"error\">%e%e</pre>', message, stackString)\r\n      );\r\n    }\r\n\r\n    self.addCodeToggle(el, test.body);\r\n    appendToStack(el);\r\n    updateStats();\r\n  });\r\n\r\n  runner.on(EVENT_TEST_PENDING, function(test) {\r\n    var el = fragment(\r\n      '<li class=\"test pass pending\"><h2>%e</h2></li>',\r\n      test.title\r\n    );\r\n    appendToStack(el);\r\n    updateStats();\r\n  });\r\n\r\n  function appendToStack(el) {\r\n    // Don't call .appendChild if #mocha-report was already .shift()'ed off the stack.\r\n    if (stack[0]) {\r\n      stack[0].appendChild(el);\r\n    }\r\n  }\r\n\r\n  function updateStats() {\r\n    // TODO: add to stats\r\n    var percent = ((stats.tests / runner.total) * 100) | 0;\r\n    if (progress) {\r\n      progress.update(percent).draw(ctx);\r\n    }\r\n\r\n    // update stats\r\n    var ms = new Date() - stats.start;\r\n    text(passes, stats.passes);\r\n    text(failures, stats.failures);\r\n    text(duration, (ms / 1000).toFixed(2));\r\n  }\r\n}\r\n\r\n/**\r\n * Makes a URL, preserving querystring (\"search\") parameters.\r\n *\r\n * @param {string} s\r\n * @return {string} A new URL.\r\n */\r\nfunction makeUrl(s) {\r\n  var search = window.location.search;\r\n\r\n  // Remove previous grep query parameter if present\r\n  if (search) {\r\n    search = search.replace(/[?&]grep=[^&\\s]*/g, '').replace(/^&/, '?');\r\n  }\r\n\r\n  return (\r\n    window.location.pathname +\r\n    (search ? search + '&' : '?') +\r\n    'grep=' +\r\n    encodeURIComponent(escapeRe(s))\r\n  );\r\n}\r\n\r\n/**\r\n * Provide suite URL.\r\n *\r\n * @param {Object} [suite]\r\n */\r\nHTML.prototype.suiteURL = function(suite) {\r\n  return makeUrl(suite.fullTitle());\r\n};\r\n\r\n/**\r\n * Provide test URL.\r\n *\r\n * @param {Object} [test]\r\n */\r\nHTML.prototype.testURL = function(test) {\r\n  return makeUrl(test.fullTitle());\r\n};\r\n\r\n/**\r\n * Adds code toggle functionality for the provided test's list element.\r\n *\r\n * @param {HTMLLIElement} el\r\n * @param {string} contents\r\n */\r\nHTML.prototype.addCodeToggle = function(el, contents) {\r\n  var h2 = el.getElementsByTagName('h2')[0];\r\n\r\n  on(h2, 'click', function() {\r\n    pre.style.display = pre.style.display === 'none' ? 'block' : 'none';\r\n  });\r\n\r\n  var pre = fragment('<pre><code>%e</code></pre>', utils.clean(contents));\r\n  el.appendChild(pre);\r\n  pre.style.display = 'none';\r\n};\r\n\r\n/**\r\n * Display error `msg`.\r\n *\r\n * @param {string} msg\r\n */\r\nfunction error(msg) {\r\n  document.body.appendChild(fragment('<div id=\"mocha-error\">%s</div>', msg));\r\n}\r\n\r\n/**\r\n * Return a DOM fragment from `html`.\r\n *\r\n * @param {string} html\r\n */\r\nfunction fragment(html) {\r\n  var args = arguments;\r\n  var div = document.createElement('div');\r\n  var i = 1;\r\n\r\n  div.innerHTML = html.replace(/%([se])/g, function(_, type) {\r\n    switch (type) {\r\n      case 's':\r\n        return String(args[i++]);\r\n      case 'e':\r\n        return escape(args[i++]);\r\n      // no default\r\n    }\r\n  });\r\n\r\n  return div.firstChild;\r\n}\r\n\r\n/**\r\n * Check for suites that do not have elements\r\n * with `classname`, and hide them.\r\n *\r\n * @param {text} classname\r\n */\r\nfunction hideSuitesWithout(classname) {\r\n  var suites = document.getElementsByClassName('suite');\r\n  for (var i = 0; i < suites.length; i++) {\r\n    var els = suites[i].getElementsByClassName(classname);\r\n    if (!els.length) {\r\n      suites[i].className += ' hidden';\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Unhide .hidden suites.\r\n */\r\nfunction unhide() {\r\n  var els = document.getElementsByClassName('suite hidden');\r\n  while (els.length > 0) {\r\n    els[0].className = els[0].className.replace('suite hidden', 'suite');\r\n  }\r\n}\r\n\r\n/**\r\n * Set an element's text contents.\r\n *\r\n * @param {HTMLElement} el\r\n * @param {string} contents\r\n */\r\nfunction text(el, contents) {\r\n  if (el.textContent) {\r\n    el.textContent = contents;\r\n  } else {\r\n    el.innerText = contents;\r\n  }\r\n}\r\n\r\n/**\r\n * Listen on `event` with callback `fn`.\r\n */\r\nfunction on(el, event, fn) {\r\n  if (el.addEventListener) {\r\n    el.addEventListener(event, fn, false);\r\n  } else {\r\n    el.attachEvent('on' + event, fn);\r\n  }\r\n}\r\n\r\nHTML.browserOnly = true;\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/mocha/lib/reporters/html.js?");

/***/ }),

/***/ "./node_modules/mocha/lib/reporters/index.js":
/*!***************************************************!*\
  !*** ./node_modules/mocha/lib/reporters/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\n// Alias exports to a their normalized format Mocha#reporter to prevent a need\r\n// for dynamic (try/catch) requires, which Browserify doesn't handle.\r\nexports.Base = exports.base = __webpack_require__(/*! ./base */ \"./node_modules/mocha/lib/reporters/base.js\");\r\nexports.Dot = exports.dot = __webpack_require__(/*! ./dot */ \"./node_modules/mocha/lib/reporters/dot.js\");\r\nexports.Doc = exports.doc = __webpack_require__(/*! ./doc */ \"./node_modules/mocha/lib/reporters/doc.js\");\r\nexports.TAP = exports.tap = __webpack_require__(/*! ./tap */ \"./node_modules/mocha/lib/reporters/tap.js\");\r\nexports.JSON = exports.json = __webpack_require__(/*! ./json */ \"./node_modules/mocha/lib/reporters/json.js\");\r\nexports.HTML = exports.html = __webpack_require__(/*! ./html */ \"./node_modules/mocha/lib/reporters/html.js\");\r\nexports.List = exports.list = __webpack_require__(/*! ./list */ \"./node_modules/mocha/lib/reporters/list.js\");\r\nexports.Min = exports.min = __webpack_require__(/*! ./min */ \"./node_modules/mocha/lib/reporters/min.js\");\r\nexports.Spec = exports.spec = __webpack_require__(/*! ./spec */ \"./node_modules/mocha/lib/reporters/spec.js\");\r\nexports.Nyan = exports.nyan = __webpack_require__(/*! ./nyan */ \"./node_modules/mocha/lib/reporters/nyan.js\");\r\nexports.XUnit = exports.xunit = __webpack_require__(/*! ./xunit */ \"./node_modules/mocha/lib/reporters/xunit.js\");\r\nexports.Markdown = exports.markdown = __webpack_require__(/*! ./markdown */ \"./node_modules/mocha/lib/reporters/markdown.js\");\r\nexports.Progress = exports.progress = __webpack_require__(/*! ./progress */ \"./node_modules/mocha/lib/reporters/progress.js\");\r\nexports.Landing = exports.landing = __webpack_require__(/*! ./landing */ \"./node_modules/mocha/lib/reporters/landing.js\");\r\nexports.JSONStream = exports['json-stream'] = __webpack_require__(/*! ./json-stream */ \"./node_modules/mocha/lib/reporters/json-stream.js\");\r\n\n\n//# sourceURL=webpack:///./node_modules/mocha/lib/reporters/index.js?");

/***/ }),

/***/ "./node_modules/mocha/lib/reporters/json-stream.js":
/*!*********************************************************!*\
  !*** ./node_modules/mocha/lib/reporters/json-stream.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\r\n/**\r\n * @module JSONStream\r\n */\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = __webpack_require__(/*! ./base */ \"./node_modules/mocha/lib/reporters/base.js\");\r\nvar constants = __webpack_require__(/*! ../runner */ \"./node_modules/mocha/lib/runner.js\").constants;\r\nvar EVENT_TEST_PASS = constants.EVENT_TEST_PASS;\r\nvar EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;\r\nvar EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;\r\nvar EVENT_RUN_END = constants.EVENT_RUN_END;\r\n\r\n/**\r\n * Expose `JSONStream`.\r\n */\r\n\r\nexports = module.exports = JSONStream;\r\n\r\n/**\r\n * Constructs a new `JSONStream` reporter instance.\r\n *\r\n * @public\r\n * @class\r\n * @memberof Mocha.reporters\r\n * @extends Mocha.reporters.Base\r\n * @param {Runner} runner - Instance triggers reporter actions.\r\n * @param {Object} [options] - runner options\r\n */\r\nfunction JSONStream(runner, options) {\r\n  Base.call(this, runner, options);\r\n\r\n  var self = this;\r\n  var total = runner.total;\r\n\r\n  runner.once(EVENT_RUN_BEGIN, function() {\r\n    writeEvent(['start', {total: total}]);\r\n  });\r\n\r\n  runner.on(EVENT_TEST_PASS, function(test) {\r\n    writeEvent(['pass', clean(test)]);\r\n  });\r\n\r\n  runner.on(EVENT_TEST_FAIL, function(test, err) {\r\n    test = clean(test);\r\n    test.err = err.message;\r\n    test.stack = err.stack || null;\r\n    writeEvent(['fail', test]);\r\n  });\r\n\r\n  runner.once(EVENT_RUN_END, function() {\r\n    writeEvent(['end', self.stats]);\r\n  });\r\n}\r\n\r\n/**\r\n * Mocha event to be written to the output stream.\r\n * @typedef {Array} JSONStream~MochaEvent\r\n */\r\n\r\n/**\r\n * Writes Mocha event to reporter output stream.\r\n *\r\n * @private\r\n * @param {JSONStream~MochaEvent} event - Mocha event to be output.\r\n */\r\nfunction writeEvent(event) {\r\n  process.stdout.write(JSON.stringify(event) + '\\n');\r\n}\r\n\r\n/**\r\n * Returns an object literal representation of `test`\r\n * free of cyclic properties, etc.\r\n *\r\n * @private\r\n * @param {Test} test - Instance used as data source.\r\n * @return {Object} object containing pared-down test instance data\r\n */\r\nfunction clean(test) {\r\n  return {\r\n    title: test.title,\r\n    fullTitle: test.fullTitle(),\r\n    file: test.file,\r\n    duration: test.duration,\r\n    currentRetry: test.currentRetry()\r\n  };\r\n}\r\n\r\nJSONStream.description = 'newline delimited JSON events';\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/mocha/lib/reporters/json-stream.js?");

/***/ }),

/***/ "./node_modules/mocha/lib/reporters/json.js":
/*!**************************************************!*\
  !*** ./node_modules/mocha/lib/reporters/json.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\r\n/**\r\n * @module JSON\r\n */\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = __webpack_require__(/*! ./base */ \"./node_modules/mocha/lib/reporters/base.js\");\r\nvar constants = __webpack_require__(/*! ../runner */ \"./node_modules/mocha/lib/runner.js\").constants;\r\nvar EVENT_TEST_PASS = constants.EVENT_TEST_PASS;\r\nvar EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;\r\nvar EVENT_TEST_END = constants.EVENT_TEST_END;\r\nvar EVENT_RUN_END = constants.EVENT_RUN_END;\r\nvar EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;\r\n\r\n/**\r\n * Expose `JSON`.\r\n */\r\n\r\nexports = module.exports = JSONReporter;\r\n\r\n/**\r\n * Constructs a new `JSON` reporter instance.\r\n *\r\n * @public\r\n * @class JSON\r\n * @memberof Mocha.reporters\r\n * @extends Mocha.reporters.Base\r\n * @param {Runner} runner - Instance triggers reporter actions.\r\n * @param {Object} [options] - runner options\r\n */\r\nfunction JSONReporter(runner, options) {\r\n  Base.call(this, runner, options);\r\n\r\n  var self = this;\r\n  var tests = [];\r\n  var pending = [];\r\n  var failures = [];\r\n  var passes = [];\r\n\r\n  runner.on(EVENT_TEST_END, function(test) {\r\n    tests.push(test);\r\n  });\r\n\r\n  runner.on(EVENT_TEST_PASS, function(test) {\r\n    passes.push(test);\r\n  });\r\n\r\n  runner.on(EVENT_TEST_FAIL, function(test) {\r\n    failures.push(test);\r\n  });\r\n\r\n  runner.on(EVENT_TEST_PENDING, function(test) {\r\n    pending.push(test);\r\n  });\r\n\r\n  runner.once(EVENT_RUN_END, function() {\r\n    var obj = {\r\n      stats: self.stats,\r\n      tests: tests.map(clean),\r\n      pending: pending.map(clean),\r\n      failures: failures.map(clean),\r\n      passes: passes.map(clean)\r\n    };\r\n\r\n    runner.testResults = obj;\r\n\r\n    process.stdout.write(JSON.stringify(obj, null, 2));\r\n  });\r\n}\r\n\r\n/**\r\n * Return a plain-object representation of `test`\r\n * free of cyclic properties etc.\r\n *\r\n * @private\r\n * @param {Object} test\r\n * @return {Object}\r\n */\r\nfunction clean(test) {\r\n  var err = test.err || {};\r\n  if (err instanceof Error) {\r\n    err = errorJSON(err);\r\n  }\r\n\r\n  return {\r\n    title: test.title,\r\n    fullTitle: test.fullTitle(),\r\n    file: test.file,\r\n    duration: test.duration,\r\n    currentRetry: test.currentRetry(),\r\n    err: cleanCycles(err)\r\n  };\r\n}\r\n\r\n/**\r\n * Replaces any circular references inside `obj` with '[object Object]'\r\n *\r\n * @private\r\n * @param {Object} obj\r\n * @return {Object}\r\n */\r\nfunction cleanCycles(obj) {\r\n  var cache = [];\r\n  return JSON.parse(\r\n    JSON.stringify(obj, function(key, value) {\r\n      if (typeof value === 'object' && value !== null) {\r\n        if (cache.indexOf(value) !== -1) {\r\n          // Instead of going in a circle, we'll print [object Object]\r\n          return '' + value;\r\n        }\r\n        cache.push(value);\r\n      }\r\n\r\n      return value;\r\n    })\r\n  );\r\n}\r\n\r\n/**\r\n * Transform an Error object into a JSON object.\r\n *\r\n * @private\r\n * @param {Error} err\r\n * @return {Object}\r\n */\r\nfunction errorJSON(err) {\r\n  var res = {};\r\n  Object.getOwnPropertyNames(err).forEach(function(key) {\r\n    res[key] = err[key];\r\n  }, err);\r\n  return res;\r\n}\r\n\r\nJSONReporter.description = 'single JSON object';\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/mocha/lib/reporters/json.js?");

/***/ }),

/***/ "./node_modules/mocha/lib/reporters/landing.js":
/*!*****************************************************!*\
  !*** ./node_modules/mocha/lib/reporters/landing.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\r\n/**\r\n * @module Landing\r\n */\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = __webpack_require__(/*! ./base */ \"./node_modules/mocha/lib/reporters/base.js\");\r\nvar inherits = __webpack_require__(/*! ../utils */ \"./node_modules/mocha/lib/utils.js\").inherits;\r\nvar constants = __webpack_require__(/*! ../runner */ \"./node_modules/mocha/lib/runner.js\").constants;\r\nvar EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;\r\nvar EVENT_RUN_END = constants.EVENT_RUN_END;\r\nvar EVENT_TEST_END = constants.EVENT_TEST_END;\r\nvar STATE_FAILED = __webpack_require__(/*! ../runnable */ \"./node_modules/mocha/lib/runnable.js\").constants.STATE_FAILED;\r\n\r\nvar cursor = Base.cursor;\r\nvar color = Base.color;\r\n\r\n/**\r\n * Expose `Landing`.\r\n */\r\n\r\nexports = module.exports = Landing;\r\n\r\n/**\r\n * Airplane color.\r\n */\r\n\r\nBase.colors.plane = 0;\r\n\r\n/**\r\n * Airplane crash color.\r\n */\r\n\r\nBase.colors['plane crash'] = 31;\r\n\r\n/**\r\n * Runway color.\r\n */\r\n\r\nBase.colors.runway = 90;\r\n\r\n/**\r\n * Constructs a new `Landing` reporter instance.\r\n *\r\n * @public\r\n * @class\r\n * @memberof Mocha.reporters\r\n * @extends Mocha.reporters.Base\r\n * @param {Runner} runner - Instance triggers reporter actions.\r\n * @param {Object} [options] - runner options\r\n */\r\nfunction Landing(runner, options) {\r\n  Base.call(this, runner, options);\r\n\r\n  var self = this;\r\n  var width = (Base.window.width * 0.75) | 0;\r\n  var total = runner.total;\r\n  var stream = process.stdout;\r\n  var plane = color('plane', '');\r\n  var crashed = -1;\r\n  var n = 0;\r\n\r\n  function runway() {\r\n    var buf = Array(width).join('-');\r\n    return '  ' + color('runway', buf);\r\n  }\r\n\r\n  runner.on(EVENT_RUN_BEGIN, function() {\r\n    stream.write('\\n\\n\\n  ');\r\n    cursor.hide();\r\n  });\r\n\r\n  runner.on(EVENT_TEST_END, function(test) {\r\n    // check if the plane crashed\r\n    var col = crashed === -1 ? ((width * ++n) / total) | 0 : crashed;\r\n\r\n    // show the crash\r\n    if (test.state === STATE_FAILED) {\r\n      plane = color('plane crash', '');\r\n      crashed = col;\r\n    }\r\n\r\n    // render landing strip\r\n    stream.write('\\u001b[' + (width + 1) + 'D\\u001b[2A');\r\n    stream.write(runway());\r\n    stream.write('\\n  ');\r\n    stream.write(color('runway', Array(col).join('')));\r\n    stream.write(plane);\r\n    stream.write(color('runway', Array(width - col).join('') + '\\n'));\r\n    stream.write(runway());\r\n    stream.write('\\u001b[0m');\r\n  });\r\n\r\n  runner.once(EVENT_RUN_END, function() {\r\n    cursor.show();\r\n    process.stdout.write('\\n');\r\n    self.epilogue();\r\n  });\r\n\r\n  // if cursor is hidden when we ctrl-C, then it will remain hidden unless...\r\n  process.once('SIGINT', function() {\r\n    cursor.show();\r\n    process.nextTick(function() {\r\n      process.kill(process.pid, 'SIGINT');\r\n    });\r\n  });\r\n}\r\n\r\n/**\r\n * Inherit from `Base.prototype`.\r\n */\r\ninherits(Landing, Base);\r\n\r\nLanding.description = 'Unicode landing strip';\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/mocha/lib/reporters/landing.js?");

/***/ }),

/***/ "./node_modules/mocha/lib/reporters/list.js":
/*!**************************************************!*\
  !*** ./node_modules/mocha/lib/reporters/list.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\r\n/**\r\n * @module List\r\n */\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = __webpack_require__(/*! ./base */ \"./node_modules/mocha/lib/reporters/base.js\");\r\nvar inherits = __webpack_require__(/*! ../utils */ \"./node_modules/mocha/lib/utils.js\").inherits;\r\nvar constants = __webpack_require__(/*! ../runner */ \"./node_modules/mocha/lib/runner.js\").constants;\r\nvar EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;\r\nvar EVENT_RUN_END = constants.EVENT_RUN_END;\r\nvar EVENT_TEST_BEGIN = constants.EVENT_TEST_BEGIN;\r\nvar EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;\r\nvar EVENT_TEST_PASS = constants.EVENT_TEST_PASS;\r\nvar EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;\r\nvar color = Base.color;\r\nvar cursor = Base.cursor;\r\n\r\n/**\r\n * Expose `List`.\r\n */\r\n\r\nexports = module.exports = List;\r\n\r\n/**\r\n * Constructs a new `List` reporter instance.\r\n *\r\n * @public\r\n * @class\r\n * @memberof Mocha.reporters\r\n * @extends Mocha.reporters.Base\r\n * @param {Runner} runner - Instance triggers reporter actions.\r\n * @param {Object} [options] - runner options\r\n */\r\nfunction List(runner, options) {\r\n  Base.call(this, runner, options);\r\n\r\n  var self = this;\r\n  var n = 0;\r\n\r\n  runner.on(EVENT_RUN_BEGIN, function() {\r\n    Base.consoleLog();\r\n  });\r\n\r\n  runner.on(EVENT_TEST_BEGIN, function(test) {\r\n    process.stdout.write(color('pass', '    ' + test.fullTitle() + ': '));\r\n  });\r\n\r\n  runner.on(EVENT_TEST_PENDING, function(test) {\r\n    var fmt = color('checkmark', '  -') + color('pending', ' %s');\r\n    Base.consoleLog(fmt, test.fullTitle());\r\n  });\r\n\r\n  runner.on(EVENT_TEST_PASS, function(test) {\r\n    var fmt =\r\n      color('checkmark', '  ' + Base.symbols.ok) +\r\n      color('pass', ' %s: ') +\r\n      color(test.speed, '%dms');\r\n    cursor.CR();\r\n    Base.consoleLog(fmt, test.fullTitle(), test.duration);\r\n  });\r\n\r\n  runner.on(EVENT_TEST_FAIL, function(test) {\r\n    cursor.CR();\r\n    Base.consoleLog(color('fail', '  %d) %s'), ++n, test.fullTitle());\r\n  });\r\n\r\n  runner.once(EVENT_RUN_END, self.epilogue.bind(self));\r\n}\r\n\r\n/**\r\n * Inherit from `Base.prototype`.\r\n */\r\ninherits(List, Base);\r\n\r\nList.description = 'like \"spec\" reporter but flat';\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/mocha/lib/reporters/list.js?");

/***/ }),

/***/ "./node_modules/mocha/lib/reporters/markdown.js":
/*!******************************************************!*\
  !*** ./node_modules/mocha/lib/reporters/markdown.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\r\n/**\r\n * @module Markdown\r\n */\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = __webpack_require__(/*! ./base */ \"./node_modules/mocha/lib/reporters/base.js\");\r\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/mocha/lib/utils.js\");\r\nvar constants = __webpack_require__(/*! ../runner */ \"./node_modules/mocha/lib/runner.js\").constants;\r\nvar EVENT_RUN_END = constants.EVENT_RUN_END;\r\nvar EVENT_SUITE_BEGIN = constants.EVENT_SUITE_BEGIN;\r\nvar EVENT_SUITE_END = constants.EVENT_SUITE_END;\r\nvar EVENT_TEST_PASS = constants.EVENT_TEST_PASS;\r\n\r\n/**\r\n * Constants\r\n */\r\n\r\nvar SUITE_PREFIX = '$';\r\n\r\n/**\r\n * Expose `Markdown`.\r\n */\r\n\r\nexports = module.exports = Markdown;\r\n\r\n/**\r\n * Constructs a new `Markdown` reporter instance.\r\n *\r\n * @public\r\n * @class\r\n * @memberof Mocha.reporters\r\n * @extends Mocha.reporters.Base\r\n * @param {Runner} runner - Instance triggers reporter actions.\r\n * @param {Object} [options] - runner options\r\n */\r\nfunction Markdown(runner, options) {\r\n  Base.call(this, runner, options);\r\n\r\n  var level = 0;\r\n  var buf = '';\r\n\r\n  function title(str) {\r\n    return Array(level).join('#') + ' ' + str;\r\n  }\r\n\r\n  function mapTOC(suite, obj) {\r\n    var ret = obj;\r\n    var key = SUITE_PREFIX + suite.title;\r\n\r\n    obj = obj[key] = obj[key] || {suite: suite};\r\n    suite.suites.forEach(function(suite) {\r\n      mapTOC(suite, obj);\r\n    });\r\n\r\n    return ret;\r\n  }\r\n\r\n  function stringifyTOC(obj, level) {\r\n    ++level;\r\n    var buf = '';\r\n    var link;\r\n    for (var key in obj) {\r\n      if (key === 'suite') {\r\n        continue;\r\n      }\r\n      if (key !== SUITE_PREFIX) {\r\n        link = ' - [' + key.substring(1) + ']';\r\n        link += '(#' + utils.slug(obj[key].suite.fullTitle()) + ')\\n';\r\n        buf += Array(level).join('  ') + link;\r\n      }\r\n      buf += stringifyTOC(obj[key], level);\r\n    }\r\n    return buf;\r\n  }\r\n\r\n  function generateTOC(suite) {\r\n    var obj = mapTOC(suite, {});\r\n    return stringifyTOC(obj, 0);\r\n  }\r\n\r\n  generateTOC(runner.suite);\r\n\r\n  runner.on(EVENT_SUITE_BEGIN, function(suite) {\r\n    ++level;\r\n    var slug = utils.slug(suite.fullTitle());\r\n    buf += '<a name=\"' + slug + '\"></a>' + '\\n';\r\n    buf += title(suite.title) + '\\n';\r\n  });\r\n\r\n  runner.on(EVENT_SUITE_END, function() {\r\n    --level;\r\n  });\r\n\r\n  runner.on(EVENT_TEST_PASS, function(test) {\r\n    var code = utils.clean(test.body);\r\n    buf += test.title + '.\\n';\r\n    buf += '\\n```js\\n';\r\n    buf += code + '\\n';\r\n    buf += '```\\n\\n';\r\n  });\r\n\r\n  runner.once(EVENT_RUN_END, function() {\r\n    process.stdout.write('# TOC\\n');\r\n    process.stdout.write(generateTOC(runner.suite));\r\n    process.stdout.write(buf);\r\n  });\r\n}\r\n\r\nMarkdown.description = 'GitHub Flavored Markdown';\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/mocha/lib/reporters/markdown.js?");

/***/ }),

/***/ "./node_modules/mocha/lib/reporters/min.js":
/*!*************************************************!*\
  !*** ./node_modules/mocha/lib/reporters/min.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\r\n/**\r\n * @module Min\r\n */\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = __webpack_require__(/*! ./base */ \"./node_modules/mocha/lib/reporters/base.js\");\r\nvar inherits = __webpack_require__(/*! ../utils */ \"./node_modules/mocha/lib/utils.js\").inherits;\r\nvar constants = __webpack_require__(/*! ../runner */ \"./node_modules/mocha/lib/runner.js\").constants;\r\nvar EVENT_RUN_END = constants.EVENT_RUN_END;\r\nvar EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;\r\n\r\n/**\r\n * Expose `Min`.\r\n */\r\n\r\nexports = module.exports = Min;\r\n\r\n/**\r\n * Constructs a new `Min` reporter instance.\r\n *\r\n * @description\r\n * This minimal test reporter is best used with '--watch'.\r\n *\r\n * @public\r\n * @class\r\n * @memberof Mocha.reporters\r\n * @extends Mocha.reporters.Base\r\n * @param {Runner} runner - Instance triggers reporter actions.\r\n * @param {Object} [options] - runner options\r\n */\r\nfunction Min(runner, options) {\r\n  Base.call(this, runner, options);\r\n\r\n  runner.on(EVENT_RUN_BEGIN, function() {\r\n    // clear screen\r\n    process.stdout.write('\\u001b[2J');\r\n    // set cursor position\r\n    process.stdout.write('\\u001b[1;3H');\r\n  });\r\n\r\n  runner.once(EVENT_RUN_END, this.epilogue.bind(this));\r\n}\r\n\r\n/**\r\n * Inherit from `Base.prototype`.\r\n */\r\ninherits(Min, Base);\r\n\r\nMin.description = 'essentially just a summary';\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/mocha/lib/reporters/min.js?");

/***/ }),

/***/ "./node_modules/mocha/lib/reporters/nyan.js":
/*!**************************************************!*\
  !*** ./node_modules/mocha/lib/reporters/nyan.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\r\n/**\r\n * @module Nyan\r\n */\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = __webpack_require__(/*! ./base */ \"./node_modules/mocha/lib/reporters/base.js\");\r\nvar constants = __webpack_require__(/*! ../runner */ \"./node_modules/mocha/lib/runner.js\").constants;\r\nvar inherits = __webpack_require__(/*! ../utils */ \"./node_modules/mocha/lib/utils.js\").inherits;\r\nvar EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;\r\nvar EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;\r\nvar EVENT_TEST_PASS = constants.EVENT_TEST_PASS;\r\nvar EVENT_RUN_END = constants.EVENT_RUN_END;\r\nvar EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;\r\n\r\n/**\r\n * Expose `Dot`.\r\n */\r\n\r\nexports = module.exports = NyanCat;\r\n\r\n/**\r\n * Constructs a new `Nyan` reporter instance.\r\n *\r\n * @public\r\n * @class Nyan\r\n * @memberof Mocha.reporters\r\n * @extends Mocha.reporters.Base\r\n * @param {Runner} runner - Instance triggers reporter actions.\r\n * @param {Object} [options] - runner options\r\n */\r\nfunction NyanCat(runner, options) {\r\n  Base.call(this, runner, options);\r\n\r\n  var self = this;\r\n  var width = (Base.window.width * 0.75) | 0;\r\n  var nyanCatWidth = (this.nyanCatWidth = 11);\r\n\r\n  this.colorIndex = 0;\r\n  this.numberOfLines = 4;\r\n  this.rainbowColors = self.generateColors();\r\n  this.scoreboardWidth = 5;\r\n  this.tick = 0;\r\n  this.trajectories = [[], [], [], []];\r\n  this.trajectoryWidthMax = width - nyanCatWidth;\r\n\r\n  runner.on(EVENT_RUN_BEGIN, function() {\r\n    Base.cursor.hide();\r\n    self.draw();\r\n  });\r\n\r\n  runner.on(EVENT_TEST_PENDING, function() {\r\n    self.draw();\r\n  });\r\n\r\n  runner.on(EVENT_TEST_PASS, function() {\r\n    self.draw();\r\n  });\r\n\r\n  runner.on(EVENT_TEST_FAIL, function() {\r\n    self.draw();\r\n  });\r\n\r\n  runner.once(EVENT_RUN_END, function() {\r\n    Base.cursor.show();\r\n    for (var i = 0; i < self.numberOfLines; i++) {\r\n      write('\\n');\r\n    }\r\n    self.epilogue();\r\n  });\r\n}\r\n\r\n/**\r\n * Inherit from `Base.prototype`.\r\n */\r\ninherits(NyanCat, Base);\r\n\r\n/**\r\n * Draw the nyan cat\r\n *\r\n * @private\r\n */\r\n\r\nNyanCat.prototype.draw = function() {\r\n  this.appendRainbow();\r\n  this.drawScoreboard();\r\n  this.drawRainbow();\r\n  this.drawNyanCat();\r\n  this.tick = !this.tick;\r\n};\r\n\r\n/**\r\n * Draw the \"scoreboard\" showing the number\r\n * of passes, failures and pending tests.\r\n *\r\n * @private\r\n */\r\n\r\nNyanCat.prototype.drawScoreboard = function() {\r\n  var stats = this.stats;\r\n\r\n  function draw(type, n) {\r\n    write(' ');\r\n    write(Base.color(type, n));\r\n    write('\\n');\r\n  }\r\n\r\n  draw('green', stats.passes);\r\n  draw('fail', stats.failures);\r\n  draw('pending', stats.pending);\r\n  write('\\n');\r\n\r\n  this.cursorUp(this.numberOfLines);\r\n};\r\n\r\n/**\r\n * Append the rainbow.\r\n *\r\n * @private\r\n */\r\n\r\nNyanCat.prototype.appendRainbow = function() {\r\n  var segment = this.tick ? '_' : '-';\r\n  var rainbowified = this.rainbowify(segment);\r\n\r\n  for (var index = 0; index < this.numberOfLines; index++) {\r\n    var trajectory = this.trajectories[index];\r\n    if (trajectory.length >= this.trajectoryWidthMax) {\r\n      trajectory.shift();\r\n    }\r\n    trajectory.push(rainbowified);\r\n  }\r\n};\r\n\r\n/**\r\n * Draw the rainbow.\r\n *\r\n * @private\r\n */\r\n\r\nNyanCat.prototype.drawRainbow = function() {\r\n  var self = this;\r\n\r\n  this.trajectories.forEach(function(line) {\r\n    write('\\u001b[' + self.scoreboardWidth + 'C');\r\n    write(line.join(''));\r\n    write('\\n');\r\n  });\r\n\r\n  this.cursorUp(this.numberOfLines);\r\n};\r\n\r\n/**\r\n * Draw the nyan cat\r\n *\r\n * @private\r\n */\r\nNyanCat.prototype.drawNyanCat = function() {\r\n  var self = this;\r\n  var startWidth = this.scoreboardWidth + this.trajectories[0].length;\r\n  var dist = '\\u001b[' + startWidth + 'C';\r\n  var padding = '';\r\n\r\n  write(dist);\r\n  write('_,------,');\r\n  write('\\n');\r\n\r\n  write(dist);\r\n  padding = self.tick ? '  ' : '   ';\r\n  write('_|' + padding + '/\\\\_/\\\\ ');\r\n  write('\\n');\r\n\r\n  write(dist);\r\n  padding = self.tick ? '_' : '__';\r\n  var tail = self.tick ? '~' : '^';\r\n  write(tail + '|' + padding + this.face() + ' ');\r\n  write('\\n');\r\n\r\n  write(dist);\r\n  padding = self.tick ? ' ' : '  ';\r\n  write(padding + '\"\"  \"\" ');\r\n  write('\\n');\r\n\r\n  this.cursorUp(this.numberOfLines);\r\n};\r\n\r\n/**\r\n * Draw nyan cat face.\r\n *\r\n * @private\r\n * @return {string}\r\n */\r\n\r\nNyanCat.prototype.face = function() {\r\n  var stats = this.stats;\r\n  if (stats.failures) {\r\n    return '( x .x)';\r\n  } else if (stats.pending) {\r\n    return '( o .o)';\r\n  } else if (stats.passes) {\r\n    return '( ^ .^)';\r\n  }\r\n  return '( - .-)';\r\n};\r\n\r\n/**\r\n * Move cursor up `n`.\r\n *\r\n * @private\r\n * @param {number} n\r\n */\r\n\r\nNyanCat.prototype.cursorUp = function(n) {\r\n  write('\\u001b[' + n + 'A');\r\n};\r\n\r\n/**\r\n * Move cursor down `n`.\r\n *\r\n * @private\r\n * @param {number} n\r\n */\r\n\r\nNyanCat.prototype.cursorDown = function(n) {\r\n  write('\\u001b[' + n + 'B');\r\n};\r\n\r\n/**\r\n * Generate rainbow colors.\r\n *\r\n * @private\r\n * @return {Array}\r\n */\r\nNyanCat.prototype.generateColors = function() {\r\n  var colors = [];\r\n\r\n  for (var i = 0; i < 6 * 7; i++) {\r\n    var pi3 = Math.floor(Math.PI / 3);\r\n    var n = i * (1.0 / 6);\r\n    var r = Math.floor(3 * Math.sin(n) + 3);\r\n    var g = Math.floor(3 * Math.sin(n + 2 * pi3) + 3);\r\n    var b = Math.floor(3 * Math.sin(n + 4 * pi3) + 3);\r\n    colors.push(36 * r + 6 * g + b + 16);\r\n  }\r\n\r\n  return colors;\r\n};\r\n\r\n/**\r\n * Apply rainbow to the given `str`.\r\n *\r\n * @private\r\n * @param {string} str\r\n * @return {string}\r\n */\r\nNyanCat.prototype.rainbowify = function(str) {\r\n  if (!Base.useColors) {\r\n    return str;\r\n  }\r\n  var color = this.rainbowColors[this.colorIndex % this.rainbowColors.length];\r\n  this.colorIndex += 1;\r\n  return '\\u001b[38;5;' + color + 'm' + str + '\\u001b[0m';\r\n};\r\n\r\n/**\r\n * Stdout helper.\r\n *\r\n * @param {string} string A message to write to stdout.\r\n */\r\nfunction write(string) {\r\n  process.stdout.write(string);\r\n}\r\n\r\nNyanCat.description = '\"nyan cat\"';\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/mocha/lib/reporters/nyan.js?");

/***/ }),

/***/ "./node_modules/mocha/lib/reporters/progress.js":
/*!******************************************************!*\
  !*** ./node_modules/mocha/lib/reporters/progress.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\r\n/**\r\n * @module Progress\r\n */\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = __webpack_require__(/*! ./base */ \"./node_modules/mocha/lib/reporters/base.js\");\r\nvar constants = __webpack_require__(/*! ../runner */ \"./node_modules/mocha/lib/runner.js\").constants;\r\nvar EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;\r\nvar EVENT_TEST_END = constants.EVENT_TEST_END;\r\nvar EVENT_RUN_END = constants.EVENT_RUN_END;\r\nvar inherits = __webpack_require__(/*! ../utils */ \"./node_modules/mocha/lib/utils.js\").inherits;\r\nvar color = Base.color;\r\nvar cursor = Base.cursor;\r\n\r\n/**\r\n * Expose `Progress`.\r\n */\r\n\r\nexports = module.exports = Progress;\r\n\r\n/**\r\n * General progress bar color.\r\n */\r\n\r\nBase.colors.progress = 90;\r\n\r\n/**\r\n * Constructs a new `Progress` reporter instance.\r\n *\r\n * @public\r\n * @class\r\n * @memberof Mocha.reporters\r\n * @extends Mocha.reporters.Base\r\n * @param {Runner} runner - Instance triggers reporter actions.\r\n * @param {Object} [options] - runner options\r\n */\r\nfunction Progress(runner, options) {\r\n  Base.call(this, runner, options);\r\n\r\n  var self = this;\r\n  var width = (Base.window.width * 0.5) | 0;\r\n  var total = runner.total;\r\n  var complete = 0;\r\n  var lastN = -1;\r\n\r\n  // default chars\r\n  options = options || {};\r\n  var reporterOptions = options.reporterOptions || {};\r\n\r\n  options.open = reporterOptions.open || '[';\r\n  options.complete = reporterOptions.complete || '';\r\n  options.incomplete = reporterOptions.incomplete || Base.symbols.dot;\r\n  options.close = reporterOptions.close || ']';\r\n  options.verbose = reporterOptions.verbose || false;\r\n\r\n  // tests started\r\n  runner.on(EVENT_RUN_BEGIN, function() {\r\n    process.stdout.write('\\n');\r\n    cursor.hide();\r\n  });\r\n\r\n  // tests complete\r\n  runner.on(EVENT_TEST_END, function() {\r\n    complete++;\r\n\r\n    var percent = complete / total;\r\n    var n = (width * percent) | 0;\r\n    var i = width - n;\r\n\r\n    if (n === lastN && !options.verbose) {\r\n      // Don't re-render the line if it hasn't changed\r\n      return;\r\n    }\r\n    lastN = n;\r\n\r\n    cursor.CR();\r\n    process.stdout.write('\\u001b[J');\r\n    process.stdout.write(color('progress', '  ' + options.open));\r\n    process.stdout.write(Array(n).join(options.complete));\r\n    process.stdout.write(Array(i).join(options.incomplete));\r\n    process.stdout.write(color('progress', options.close));\r\n    if (options.verbose) {\r\n      process.stdout.write(color('progress', ' ' + complete + ' of ' + total));\r\n    }\r\n  });\r\n\r\n  // tests are complete, output some stats\r\n  // and the failures if any\r\n  runner.once(EVENT_RUN_END, function() {\r\n    cursor.show();\r\n    process.stdout.write('\\n');\r\n    self.epilogue();\r\n  });\r\n}\r\n\r\n/**\r\n * Inherit from `Base.prototype`.\r\n */\r\ninherits(Progress, Base);\r\n\r\nProgress.description = 'a progress bar';\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/mocha/lib/reporters/progress.js?");

/***/ }),

/***/ "./node_modules/mocha/lib/reporters/spec.js":
/*!**************************************************!*\
  !*** ./node_modules/mocha/lib/reporters/spec.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n/**\r\n * @module Spec\r\n */\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = __webpack_require__(/*! ./base */ \"./node_modules/mocha/lib/reporters/base.js\");\r\nvar constants = __webpack_require__(/*! ../runner */ \"./node_modules/mocha/lib/runner.js\").constants;\r\nvar EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;\r\nvar EVENT_RUN_END = constants.EVENT_RUN_END;\r\nvar EVENT_SUITE_BEGIN = constants.EVENT_SUITE_BEGIN;\r\nvar EVENT_SUITE_END = constants.EVENT_SUITE_END;\r\nvar EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;\r\nvar EVENT_TEST_PASS = constants.EVENT_TEST_PASS;\r\nvar EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;\r\nvar inherits = __webpack_require__(/*! ../utils */ \"./node_modules/mocha/lib/utils.js\").inherits;\r\nvar color = Base.color;\r\n\r\n/**\r\n * Expose `Spec`.\r\n */\r\n\r\nexports = module.exports = Spec;\r\n\r\n/**\r\n * Constructs a new `Spec` reporter instance.\r\n *\r\n * @public\r\n * @class\r\n * @memberof Mocha.reporters\r\n * @extends Mocha.reporters.Base\r\n * @param {Runner} runner - Instance triggers reporter actions.\r\n * @param {Object} [options] - runner options\r\n */\r\nfunction Spec(runner, options) {\r\n  Base.call(this, runner, options);\r\n\r\n  var self = this;\r\n  var indents = 0;\r\n  var n = 0;\r\n\r\n  function indent() {\r\n    return Array(indents).join('  ');\r\n  }\r\n\r\n  runner.on(EVENT_RUN_BEGIN, function() {\r\n    Base.consoleLog();\r\n  });\r\n\r\n  runner.on(EVENT_SUITE_BEGIN, function(suite) {\r\n    ++indents;\r\n    Base.consoleLog(color('suite', '%s%s'), indent(), suite.title);\r\n  });\r\n\r\n  runner.on(EVENT_SUITE_END, function() {\r\n    --indents;\r\n    if (indents === 1) {\r\n      Base.consoleLog();\r\n    }\r\n  });\r\n\r\n  runner.on(EVENT_TEST_PENDING, function(test) {\r\n    var fmt = indent() + color('pending', '  - %s');\r\n    Base.consoleLog(fmt, test.title);\r\n  });\r\n\r\n  runner.on(EVENT_TEST_PASS, function(test) {\r\n    var fmt;\r\n    if (test.speed === 'fast') {\r\n      fmt =\r\n        indent() +\r\n        color('checkmark', '  ' + Base.symbols.ok) +\r\n        color('pass', ' %s');\r\n      Base.consoleLog(fmt, test.title);\r\n    } else {\r\n      fmt =\r\n        indent() +\r\n        color('checkmark', '  ' + Base.symbols.ok) +\r\n        color('pass', ' %s') +\r\n        color(test.speed, ' (%dms)');\r\n      Base.consoleLog(fmt, test.title, test.duration);\r\n    }\r\n  });\r\n\r\n  runner.on(EVENT_TEST_FAIL, function(test) {\r\n    Base.consoleLog(indent() + color('fail', '  %d) %s'), ++n, test.title);\r\n  });\r\n\r\n  runner.once(EVENT_RUN_END, self.epilogue.bind(self));\r\n}\r\n\r\n/**\r\n * Inherit from `Base.prototype`.\r\n */\r\ninherits(Spec, Base);\r\n\r\nSpec.description = 'hierarchical & verbose [default]';\r\n\n\n//# sourceURL=webpack:///./node_modules/mocha/lib/reporters/spec.js?");

/***/ }),

/***/ "./node_modules/mocha/lib/reporters/tap.js":
/*!*************************************************!*\
  !*** ./node_modules/mocha/lib/reporters/tap.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\r\n/**\r\n * @module TAP\r\n */\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar util = __webpack_require__(/*! util */ \"./node_modules/util/util.js\");\r\nvar Base = __webpack_require__(/*! ./base */ \"./node_modules/mocha/lib/reporters/base.js\");\r\nvar constants = __webpack_require__(/*! ../runner */ \"./node_modules/mocha/lib/runner.js\").constants;\r\nvar EVENT_TEST_PASS = constants.EVENT_TEST_PASS;\r\nvar EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;\r\nvar EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;\r\nvar EVENT_RUN_END = constants.EVENT_RUN_END;\r\nvar EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;\r\nvar EVENT_TEST_END = constants.EVENT_TEST_END;\r\nvar inherits = __webpack_require__(/*! ../utils */ \"./node_modules/mocha/lib/utils.js\").inherits;\r\nvar sprintf = util.format;\r\n\r\n/**\r\n * Expose `TAP`.\r\n */\r\n\r\nexports = module.exports = TAP;\r\n\r\n/**\r\n * Constructs a new `TAP` reporter instance.\r\n *\r\n * @public\r\n * @class\r\n * @memberof Mocha.reporters\r\n * @extends Mocha.reporters.Base\r\n * @param {Runner} runner - Instance triggers reporter actions.\r\n * @param {Object} [options] - runner options\r\n */\r\nfunction TAP(runner, options) {\r\n  Base.call(this, runner, options);\r\n\r\n  var self = this;\r\n  var n = 1;\r\n\r\n  var tapVersion = '12';\r\n  if (options && options.reporterOptions) {\r\n    if (options.reporterOptions.tapVersion) {\r\n      tapVersion = options.reporterOptions.tapVersion.toString();\r\n    }\r\n  }\r\n\r\n  this._producer = createProducer(tapVersion);\r\n\r\n  runner.once(EVENT_RUN_BEGIN, function() {\r\n    var ntests = runner.grepTotal(runner.suite);\r\n    self._producer.writeVersion();\r\n    self._producer.writePlan(ntests);\r\n  });\r\n\r\n  runner.on(EVENT_TEST_END, function() {\r\n    ++n;\r\n  });\r\n\r\n  runner.on(EVENT_TEST_PENDING, function(test) {\r\n    self._producer.writePending(n, test);\r\n  });\r\n\r\n  runner.on(EVENT_TEST_PASS, function(test) {\r\n    self._producer.writePass(n, test);\r\n  });\r\n\r\n  runner.on(EVENT_TEST_FAIL, function(test, err) {\r\n    self._producer.writeFail(n, test, err);\r\n  });\r\n\r\n  runner.once(EVENT_RUN_END, function() {\r\n    self._producer.writeEpilogue(runner.stats);\r\n  });\r\n}\r\n\r\n/**\r\n * Inherit from `Base.prototype`.\r\n */\r\ninherits(TAP, Base);\r\n\r\n/**\r\n * Returns a TAP-safe title of `test`.\r\n *\r\n * @private\r\n * @param {Test} test - Test instance.\r\n * @return {String} title with any hash character removed\r\n */\r\nfunction title(test) {\r\n  return test.fullTitle().replace(/#/g, '');\r\n}\r\n\r\n/**\r\n * Writes newline-terminated formatted string to reporter output stream.\r\n *\r\n * @private\r\n * @param {string} format - `printf`-like format string\r\n * @param {...*} [varArgs] - Format string arguments\r\n */\r\nfunction println(format, varArgs) {\r\n  var vargs = Array.from(arguments);\r\n  vargs[0] += '\\n';\r\n  process.stdout.write(sprintf.apply(null, vargs));\r\n}\r\n\r\n/**\r\n * Returns a `tapVersion`-appropriate TAP producer instance, if possible.\r\n *\r\n * @private\r\n * @param {string} tapVersion - Version of TAP specification to produce.\r\n * @returns {TAPProducer} specification-appropriate instance\r\n * @throws {Error} if specification version has no associated producer.\r\n */\r\nfunction createProducer(tapVersion) {\r\n  var producers = {\r\n    '12': new TAP12Producer(),\r\n    '13': new TAP13Producer()\r\n  };\r\n  var producer = producers[tapVersion];\r\n\r\n  if (!producer) {\r\n    throw new Error(\r\n      'invalid or unsupported TAP version: ' + JSON.stringify(tapVersion)\r\n    );\r\n  }\r\n\r\n  return producer;\r\n}\r\n\r\n/**\r\n * @summary\r\n * Constructs a new TAPProducer.\r\n *\r\n * @description\r\n * <em>Only</em> to be used as an abstract base class.\r\n *\r\n * @private\r\n * @constructor\r\n */\r\nfunction TAPProducer() {}\r\n\r\n/**\r\n * Writes the TAP version to reporter output stream.\r\n *\r\n * @abstract\r\n */\r\nTAPProducer.prototype.writeVersion = function() {};\r\n\r\n/**\r\n * Writes the plan to reporter output stream.\r\n *\r\n * @abstract\r\n * @param {number} ntests - Number of tests that are planned to run.\r\n */\r\nTAPProducer.prototype.writePlan = function(ntests) {\r\n  println('%d..%d', 1, ntests);\r\n};\r\n\r\n/**\r\n * Writes that test passed to reporter output stream.\r\n *\r\n * @abstract\r\n * @param {number} n - Index of test that passed.\r\n * @param {Test} test - Instance containing test information.\r\n */\r\nTAPProducer.prototype.writePass = function(n, test) {\r\n  println('ok %d %s', n, title(test));\r\n};\r\n\r\n/**\r\n * Writes that test was skipped to reporter output stream.\r\n *\r\n * @abstract\r\n * @param {number} n - Index of test that was skipped.\r\n * @param {Test} test - Instance containing test information.\r\n */\r\nTAPProducer.prototype.writePending = function(n, test) {\r\n  println('ok %d %s # SKIP -', n, title(test));\r\n};\r\n\r\n/**\r\n * Writes that test failed to reporter output stream.\r\n *\r\n * @abstract\r\n * @param {number} n - Index of test that failed.\r\n * @param {Test} test - Instance containing test information.\r\n * @param {Error} err - Reason the test failed.\r\n */\r\nTAPProducer.prototype.writeFail = function(n, test, err) {\r\n  println('not ok %d %s', n, title(test));\r\n};\r\n\r\n/**\r\n * Writes the summary epilogue to reporter output stream.\r\n *\r\n * @abstract\r\n * @param {Object} stats - Object containing run statistics.\r\n */\r\nTAPProducer.prototype.writeEpilogue = function(stats) {\r\n  // :TBD: Why is this not counting pending tests?\r\n  println('# tests ' + (stats.passes + stats.failures));\r\n  println('# pass ' + stats.passes);\r\n  // :TBD: Why are we not showing pending results?\r\n  println('# fail ' + stats.failures);\r\n};\r\n\r\n/**\r\n * @summary\r\n * Constructs a new TAP12Producer.\r\n *\r\n * @description\r\n * Produces output conforming to the TAP12 specification.\r\n *\r\n * @private\r\n * @constructor\r\n * @extends TAPProducer\r\n * @see {@link https://testanything.org/tap-specification.html|Specification}\r\n */\r\nfunction TAP12Producer() {\r\n  /**\r\n   * Writes that test failed to reporter output stream, with error formatting.\r\n   * @override\r\n   */\r\n  this.writeFail = function(n, test, err) {\r\n    TAPProducer.prototype.writeFail.call(this, n, test, err);\r\n    if (err.message) {\r\n      println(err.message.replace(/^/gm, '  '));\r\n    }\r\n    if (err.stack) {\r\n      println(err.stack.replace(/^/gm, '  '));\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Inherit from `TAPProducer.prototype`.\r\n */\r\ninherits(TAP12Producer, TAPProducer);\r\n\r\n/**\r\n * @summary\r\n * Constructs a new TAP13Producer.\r\n *\r\n * @description\r\n * Produces output conforming to the TAP13 specification.\r\n *\r\n * @private\r\n * @constructor\r\n * @extends TAPProducer\r\n * @see {@link https://testanything.org/tap-version-13-specification.html|Specification}\r\n */\r\nfunction TAP13Producer() {\r\n  /**\r\n   * Writes the TAP version to reporter output stream.\r\n   * @override\r\n   */\r\n  this.writeVersion = function() {\r\n    println('TAP version 13');\r\n  };\r\n\r\n  /**\r\n   * Writes that test failed to reporter output stream, with error formatting.\r\n   * @override\r\n   */\r\n  this.writeFail = function(n, test, err) {\r\n    TAPProducer.prototype.writeFail.call(this, n, test, err);\r\n    var emitYamlBlock = err.message != null || err.stack != null;\r\n    if (emitYamlBlock) {\r\n      println(indent(1) + '---');\r\n      if (err.message) {\r\n        println(indent(2) + 'message: |-');\r\n        println(err.message.replace(/^/gm, indent(3)));\r\n      }\r\n      if (err.stack) {\r\n        println(indent(2) + 'stack: |-');\r\n        println(err.stack.replace(/^/gm, indent(3)));\r\n      }\r\n      println(indent(1) + '...');\r\n    }\r\n  };\r\n\r\n  function indent(level) {\r\n    return Array(level + 1).join('  ');\r\n  }\r\n}\r\n\r\n/**\r\n * Inherit from `TAPProducer.prototype`.\r\n */\r\ninherits(TAP13Producer, TAPProducer);\r\n\r\nTAP.description = 'TAP-compatible output';\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/mocha/lib/reporters/tap.js?");

/***/ }),

/***/ "./node_modules/mocha/lib/reporters/xunit.js":
/*!***************************************************!*\
  !*** ./node_modules/mocha/lib/reporters/xunit.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global, process) {\r\n/**\r\n * @module XUnit\r\n */\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = __webpack_require__(/*! ./base */ \"./node_modules/mocha/lib/reporters/base.js\");\r\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/mocha/lib/utils.js\");\r\nvar fs = __webpack_require__(/*! fs */ 7);\r\nvar mkdirp = __webpack_require__(/*! mkdirp */ \"./node_modules/mkdirp/index.js\");\r\nvar path = __webpack_require__(/*! path */ 8);\r\nvar errors = __webpack_require__(/*! ../errors */ \"./node_modules/mocha/lib/errors.js\");\r\nvar createUnsupportedError = errors.createUnsupportedError;\r\nvar constants = __webpack_require__(/*! ../runner */ \"./node_modules/mocha/lib/runner.js\").constants;\r\nvar EVENT_TEST_PASS = constants.EVENT_TEST_PASS;\r\nvar EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;\r\nvar EVENT_RUN_END = constants.EVENT_RUN_END;\r\nvar EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;\r\nvar STATE_FAILED = __webpack_require__(/*! ../runnable */ \"./node_modules/mocha/lib/runnable.js\").constants.STATE_FAILED;\r\nvar inherits = utils.inherits;\r\nvar escape = utils.escape;\r\n\r\n/**\r\n * Save timer references to avoid Sinon interfering (see GH-237).\r\n */\r\nvar Date = global.Date;\r\n\r\n/**\r\n * Expose `XUnit`.\r\n */\r\n\r\nexports = module.exports = XUnit;\r\n\r\n/**\r\n * Constructs a new `XUnit` reporter instance.\r\n *\r\n * @public\r\n * @class\r\n * @memberof Mocha.reporters\r\n * @extends Mocha.reporters.Base\r\n * @param {Runner} runner - Instance triggers reporter actions.\r\n * @param {Object} [options] - runner options\r\n */\r\nfunction XUnit(runner, options) {\r\n  Base.call(this, runner, options);\r\n\r\n  var stats = this.stats;\r\n  var tests = [];\r\n  var self = this;\r\n\r\n  // the name of the test suite, as it will appear in the resulting XML file\r\n  var suiteName;\r\n\r\n  // the default name of the test suite if none is provided\r\n  var DEFAULT_SUITE_NAME = 'Mocha Tests';\r\n\r\n  if (options && options.reporterOptions) {\r\n    if (options.reporterOptions.output) {\r\n      if (!fs.createWriteStream) {\r\n        throw createUnsupportedError('file output not supported in browser');\r\n      }\r\n\r\n      mkdirp.sync(path.dirname(options.reporterOptions.output));\r\n      self.fileStream = fs.createWriteStream(options.reporterOptions.output);\r\n    }\r\n\r\n    // get the suite name from the reporter options (if provided)\r\n    suiteName = options.reporterOptions.suiteName;\r\n  }\r\n\r\n  // fall back to the default suite name\r\n  suiteName = suiteName || DEFAULT_SUITE_NAME;\r\n\r\n  runner.on(EVENT_TEST_PENDING, function(test) {\r\n    tests.push(test);\r\n  });\r\n\r\n  runner.on(EVENT_TEST_PASS, function(test) {\r\n    tests.push(test);\r\n  });\r\n\r\n  runner.on(EVENT_TEST_FAIL, function(test) {\r\n    tests.push(test);\r\n  });\r\n\r\n  runner.once(EVENT_RUN_END, function() {\r\n    self.write(\r\n      tag(\r\n        'testsuite',\r\n        {\r\n          name: suiteName,\r\n          tests: stats.tests,\r\n          failures: 0,\r\n          errors: stats.failures,\r\n          skipped: stats.tests - stats.failures - stats.passes,\r\n          timestamp: new Date().toUTCString(),\r\n          time: stats.duration / 1000 || 0\r\n        },\r\n        false\r\n      )\r\n    );\r\n\r\n    tests.forEach(function(t) {\r\n      self.test(t);\r\n    });\r\n\r\n    self.write('</testsuite>');\r\n  });\r\n}\r\n\r\n/**\r\n * Inherit from `Base.prototype`.\r\n */\r\ninherits(XUnit, Base);\r\n\r\n/**\r\n * Override done to close the stream (if it's a file).\r\n *\r\n * @param failures\r\n * @param {Function} fn\r\n */\r\nXUnit.prototype.done = function(failures, fn) {\r\n  if (this.fileStream) {\r\n    this.fileStream.end(function() {\r\n      fn(failures);\r\n    });\r\n  } else {\r\n    fn(failures);\r\n  }\r\n};\r\n\r\n/**\r\n * Write out the given line.\r\n *\r\n * @param {string} line\r\n */\r\nXUnit.prototype.write = function(line) {\r\n  if (this.fileStream) {\r\n    this.fileStream.write(line + '\\n');\r\n  } else if (typeof process === 'object' && process.stdout) {\r\n    process.stdout.write(line + '\\n');\r\n  } else {\r\n    Base.consoleLog(line);\r\n  }\r\n};\r\n\r\n/**\r\n * Output tag for the given `test.`\r\n *\r\n * @param {Test} test\r\n */\r\nXUnit.prototype.test = function(test) {\r\n  Base.useColors = false;\r\n\r\n  var attrs = {\r\n    classname: test.parent.fullTitle(),\r\n    name: test.title,\r\n    time: test.duration / 1000 || 0\r\n  };\r\n\r\n  if (test.state === STATE_FAILED) {\r\n    var err = test.err;\r\n    var diff =\r\n      !Base.hideDiff && Base.showDiff(err)\r\n        ? '\\n' + Base.generateDiff(err.actual, err.expected)\r\n        : '';\r\n    this.write(\r\n      tag(\r\n        'testcase',\r\n        attrs,\r\n        false,\r\n        tag(\r\n          'failure',\r\n          {},\r\n          false,\r\n          escape(err.message) + escape(diff) + '\\n' + escape(err.stack)\r\n        )\r\n      )\r\n    );\r\n  } else if (test.isPending()) {\r\n    this.write(tag('testcase', attrs, false, tag('skipped', {}, true)));\r\n  } else {\r\n    this.write(tag('testcase', attrs, true));\r\n  }\r\n};\r\n\r\n/**\r\n * HTML tag helper.\r\n *\r\n * @param name\r\n * @param attrs\r\n * @param close\r\n * @param content\r\n * @return {string}\r\n */\r\nfunction tag(name, attrs, close, content) {\r\n  var end = close ? '/>' : '>';\r\n  var pairs = [];\r\n  var tag;\r\n\r\n  for (var key in attrs) {\r\n    if (Object.prototype.hasOwnProperty.call(attrs, key)) {\r\n      pairs.push(key + '=\"' + escape(attrs[key]) + '\"');\r\n    }\r\n  }\r\n\r\n  tag = '<' + name + (pairs.length ? ' ' + pairs.join(' ') : '') + end;\r\n  if (content) {\r\n    tag += content + '</' + name + end;\r\n  }\r\n  return tag;\r\n}\r\n\r\nXUnit.description = 'XUnit-compatible XML output';\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/mocha/lib/reporters/xunit.js?");

/***/ }),

/***/ "./node_modules/mocha/lib/runnable.js":
/*!********************************************!*\
  !*** ./node_modules/mocha/lib/runnable.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\r\n\r\nvar EventEmitter = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\r\nvar Pending = __webpack_require__(/*! ./pending */ \"./node_modules/mocha/lib/pending.js\");\r\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/mocha/node_modules/debug/src/browser.js\")('mocha:runnable');\r\nvar milliseconds = __webpack_require__(/*! ms */ \"./node_modules/mocha/node_modules/ms/index.js\");\r\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/mocha/lib/utils.js\");\r\nvar errors = __webpack_require__(/*! ./errors */ \"./node_modules/mocha/lib/errors.js\");\r\nvar createInvalidExceptionError = errors.createInvalidExceptionError;\r\nvar createMultipleDoneError = errors.createMultipleDoneError;\r\n\r\n/**\r\n * Save timer references to avoid Sinon interfering (see GH-237).\r\n */\r\nvar Date = global.Date;\r\nvar setTimeout = global.setTimeout;\r\nvar clearTimeout = global.clearTimeout;\r\nvar toString = Object.prototype.toString;\r\n\r\nmodule.exports = Runnable;\r\n\r\n/**\r\n * Initialize a new `Runnable` with the given `title` and callback `fn`.\r\n *\r\n * @class\r\n * @extends external:EventEmitter\r\n * @public\r\n * @param {String} title\r\n * @param {Function} fn\r\n */\r\nfunction Runnable(title, fn) {\r\n  this.title = title;\r\n  this.fn = fn;\r\n  this.body = (fn || '').toString();\r\n  this.async = fn && fn.length;\r\n  this.sync = !this.async;\r\n  this._timeout = 2000;\r\n  this._slow = 75;\r\n  this._enableTimeouts = true;\r\n  this._retries = -1;\r\n  this.reset();\r\n}\r\n\r\n/**\r\n * Inherit from `EventEmitter.prototype`.\r\n */\r\nutils.inherits(Runnable, EventEmitter);\r\n\r\n/**\r\n * Resets the state initially or for a next run.\r\n */\r\nRunnable.prototype.reset = function() {\r\n  this.timedOut = false;\r\n  this._currentRetry = 0;\r\n  this.pending = false;\r\n  delete this.state;\r\n  delete this.err;\r\n};\r\n\r\n/**\r\n * Get current timeout value in msecs.\r\n *\r\n * @private\r\n * @returns {number} current timeout threshold value\r\n */\r\n/**\r\n * @summary\r\n * Set timeout threshold value (msecs).\r\n *\r\n * @description\r\n * A string argument can use shorthand (e.g., \"2s\") and will be converted.\r\n * The value will be clamped to range [<code>0</code>, <code>2^<sup>31</sup>-1</code>].\r\n * If clamped value matches either range endpoint, timeouts will be disabled.\r\n *\r\n * @private\r\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout#Maximum_delay_value}\r\n * @param {number|string} ms - Timeout threshold value.\r\n * @returns {Runnable} this\r\n * @chainable\r\n */\r\nRunnable.prototype.timeout = function(ms) {\r\n  if (!arguments.length) {\r\n    return this._timeout;\r\n  }\r\n  if (typeof ms === 'string') {\r\n    ms = milliseconds(ms);\r\n  }\r\n\r\n  // Clamp to range\r\n  var INT_MAX = Math.pow(2, 31) - 1;\r\n  var range = [0, INT_MAX];\r\n  ms = utils.clamp(ms, range);\r\n\r\n  // see #1652 for reasoning\r\n  if (ms === range[0] || ms === range[1]) {\r\n    this._enableTimeouts = false;\r\n  }\r\n  debug('timeout %d', ms);\r\n  this._timeout = ms;\r\n  if (this.timer) {\r\n    this.resetTimeout();\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set or get slow `ms`.\r\n *\r\n * @private\r\n * @param {number|string} ms\r\n * @return {Runnable|number} ms or Runnable instance.\r\n */\r\nRunnable.prototype.slow = function(ms) {\r\n  if (!arguments.length || typeof ms === 'undefined') {\r\n    return this._slow;\r\n  }\r\n  if (typeof ms === 'string') {\r\n    ms = milliseconds(ms);\r\n  }\r\n  debug('slow %d', ms);\r\n  this._slow = ms;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set and get whether timeout is `enabled`.\r\n *\r\n * @private\r\n * @param {boolean} enabled\r\n * @return {Runnable|boolean} enabled or Runnable instance.\r\n */\r\nRunnable.prototype.enableTimeouts = function(enabled) {\r\n  if (!arguments.length) {\r\n    return this._enableTimeouts;\r\n  }\r\n  debug('enableTimeouts %s', enabled);\r\n  this._enableTimeouts = enabled;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Halt and mark as pending.\r\n *\r\n * @memberof Mocha.Runnable\r\n * @public\r\n */\r\nRunnable.prototype.skip = function() {\r\n  this.pending = true;\r\n  throw new Pending('sync skip; aborting execution');\r\n};\r\n\r\n/**\r\n * Check if this runnable or its parent suite is marked as pending.\r\n *\r\n * @private\r\n */\r\nRunnable.prototype.isPending = function() {\r\n  return this.pending || (this.parent && this.parent.isPending());\r\n};\r\n\r\n/**\r\n * Return `true` if this Runnable has failed.\r\n * @return {boolean}\r\n * @private\r\n */\r\nRunnable.prototype.isFailed = function() {\r\n  return !this.isPending() && this.state === constants.STATE_FAILED;\r\n};\r\n\r\n/**\r\n * Return `true` if this Runnable has passed.\r\n * @return {boolean}\r\n * @private\r\n */\r\nRunnable.prototype.isPassed = function() {\r\n  return !this.isPending() && this.state === constants.STATE_PASSED;\r\n};\r\n\r\n/**\r\n * Set or get number of retries.\r\n *\r\n * @private\r\n */\r\nRunnable.prototype.retries = function(n) {\r\n  if (!arguments.length) {\r\n    return this._retries;\r\n  }\r\n  this._retries = n;\r\n};\r\n\r\n/**\r\n * Set or get current retry\r\n *\r\n * @private\r\n */\r\nRunnable.prototype.currentRetry = function(n) {\r\n  if (!arguments.length) {\r\n    return this._currentRetry;\r\n  }\r\n  this._currentRetry = n;\r\n};\r\n\r\n/**\r\n * Return the full title generated by recursively concatenating the parent's\r\n * full title.\r\n *\r\n * @memberof Mocha.Runnable\r\n * @public\r\n * @return {string}\r\n */\r\nRunnable.prototype.fullTitle = function() {\r\n  return this.titlePath().join(' ');\r\n};\r\n\r\n/**\r\n * Return the title path generated by concatenating the parent's title path with the title.\r\n *\r\n * @memberof Mocha.Runnable\r\n * @public\r\n * @return {string}\r\n */\r\nRunnable.prototype.titlePath = function() {\r\n  return this.parent.titlePath().concat([this.title]);\r\n};\r\n\r\n/**\r\n * Clear the timeout.\r\n *\r\n * @private\r\n */\r\nRunnable.prototype.clearTimeout = function() {\r\n  clearTimeout(this.timer);\r\n};\r\n\r\n/**\r\n * Reset the timeout.\r\n *\r\n * @private\r\n */\r\nRunnable.prototype.resetTimeout = function() {\r\n  var self = this;\r\n  var ms = this.timeout() || 1e9;\r\n\r\n  if (!this._enableTimeouts) {\r\n    return;\r\n  }\r\n  this.clearTimeout();\r\n  this.timer = setTimeout(function() {\r\n    if (!self._enableTimeouts) {\r\n      return;\r\n    }\r\n    self.callback(self._timeoutError(ms));\r\n    self.timedOut = true;\r\n  }, ms);\r\n};\r\n\r\n/**\r\n * Set or get a list of whitelisted globals for this test run.\r\n *\r\n * @private\r\n * @param {string[]} globals\r\n */\r\nRunnable.prototype.globals = function(globals) {\r\n  if (!arguments.length) {\r\n    return this._allowedGlobals;\r\n  }\r\n  this._allowedGlobals = globals;\r\n};\r\n\r\n/**\r\n * Run the test and invoke `fn(err)`.\r\n *\r\n * @param {Function} fn\r\n * @private\r\n */\r\nRunnable.prototype.run = function(fn) {\r\n  var self = this;\r\n  var start = new Date();\r\n  var ctx = this.ctx;\r\n  var finished;\r\n  var errorWasHandled = false;\r\n\r\n  // Sometimes the ctx exists, but it is not runnable\r\n  if (ctx && ctx.runnable) {\r\n    ctx.runnable(this);\r\n  }\r\n\r\n  // called multiple times\r\n  function multiple(err) {\r\n    if (errorWasHandled) {\r\n      return;\r\n    }\r\n    errorWasHandled = true;\r\n    self.emit('error', createMultipleDoneError(self, err));\r\n  }\r\n\r\n  // finished\r\n  function done(err) {\r\n    var ms = self.timeout();\r\n    if (self.timedOut) {\r\n      return;\r\n    }\r\n\r\n    if (finished) {\r\n      return multiple(err);\r\n    }\r\n\r\n    self.clearTimeout();\r\n    self.duration = new Date() - start;\r\n    finished = true;\r\n    if (!err && self.duration > ms && self._enableTimeouts) {\r\n      err = self._timeoutError(ms);\r\n    }\r\n    fn(err);\r\n  }\r\n\r\n  // for .resetTimeout() and Runner#uncaught()\r\n  this.callback = done;\r\n\r\n  if (this.fn && typeof this.fn.call !== 'function') {\r\n    done(\r\n      new TypeError(\r\n        'A runnable must be passed a function as its second argument.'\r\n      )\r\n    );\r\n    return;\r\n  }\r\n\r\n  // explicit async with `done` argument\r\n  if (this.async) {\r\n    this.resetTimeout();\r\n\r\n    // allows skip() to be used in an explicit async context\r\n    this.skip = function asyncSkip() {\r\n      this.pending = true;\r\n      done();\r\n      // halt execution, the uncaught handler will ignore the failure.\r\n      throw new Pending('async skip; aborting execution');\r\n    };\r\n\r\n    try {\r\n      callFnAsync(this.fn);\r\n    } catch (err) {\r\n      // handles async runnables which actually run synchronously\r\n      errorWasHandled = true;\r\n      if (err instanceof Pending) {\r\n        return; // done() is already called in this.skip()\r\n      } else if (this.allowUncaught) {\r\n        throw err;\r\n      }\r\n      done(Runnable.toValueOrError(err));\r\n    }\r\n    return;\r\n  }\r\n\r\n  // sync or promise-returning\r\n  try {\r\n    if (this.isPending()) {\r\n      done();\r\n    } else {\r\n      callFn(this.fn);\r\n    }\r\n  } catch (err) {\r\n    errorWasHandled = true;\r\n    if (err instanceof Pending) {\r\n      return done();\r\n    } else if (this.allowUncaught) {\r\n      throw err;\r\n    }\r\n    done(Runnable.toValueOrError(err));\r\n  }\r\n\r\n  function callFn(fn) {\r\n    var result = fn.call(ctx);\r\n    if (result && typeof result.then === 'function') {\r\n      self.resetTimeout();\r\n      result.then(\r\n        function() {\r\n          done();\r\n          // Return null so libraries like bluebird do not warn about\r\n          // subsequently constructed Promises.\r\n          return null;\r\n        },\r\n        function(reason) {\r\n          done(reason || new Error('Promise rejected with no or falsy reason'));\r\n        }\r\n      );\r\n    } else {\r\n      if (self.asyncOnly) {\r\n        return done(\r\n          new Error(\r\n            '--async-only option in use without declaring `done()` or returning a promise'\r\n          )\r\n        );\r\n      }\r\n\r\n      done();\r\n    }\r\n  }\r\n\r\n  function callFnAsync(fn) {\r\n    var result = fn.call(ctx, function(err) {\r\n      if (err instanceof Error || toString.call(err) === '[object Error]') {\r\n        return done(err);\r\n      }\r\n      if (err) {\r\n        if (Object.prototype.toString.call(err) === '[object Object]') {\r\n          return done(\r\n            new Error('done() invoked with non-Error: ' + JSON.stringify(err))\r\n          );\r\n        }\r\n        return done(new Error('done() invoked with non-Error: ' + err));\r\n      }\r\n      if (result && utils.isPromise(result)) {\r\n        return done(\r\n          new Error(\r\n            'Resolution method is overspecified. Specify a callback *or* return a Promise; not both.'\r\n          )\r\n        );\r\n      }\r\n\r\n      done();\r\n    });\r\n  }\r\n};\r\n\r\n/**\r\n * Instantiates a \"timeout\" error\r\n *\r\n * @param {number} ms - Timeout (in milliseconds)\r\n * @returns {Error} a \"timeout\" error\r\n * @private\r\n */\r\nRunnable.prototype._timeoutError = function(ms) {\r\n  var msg =\r\n    'Timeout of ' +\r\n    ms +\r\n    'ms exceeded. For async tests and hooks, ensure \"done()\" is called; if returning a Promise, ensure it resolves.';\r\n  if (this.file) {\r\n    msg += ' (' + this.file + ')';\r\n  }\r\n  return new Error(msg);\r\n};\r\n\r\nvar constants = utils.defineConstants(\r\n  /**\r\n   * {@link Runnable}-related constants.\r\n   * @public\r\n   * @memberof Runnable\r\n   * @readonly\r\n   * @static\r\n   * @alias constants\r\n   * @enum {string}\r\n   */\r\n  {\r\n    /**\r\n     * Value of `state` prop when a `Runnable` has failed\r\n     */\r\n    STATE_FAILED: 'failed',\r\n    /**\r\n     * Value of `state` prop when a `Runnable` has passed\r\n     */\r\n    STATE_PASSED: 'passed'\r\n  }\r\n);\r\n\r\n/**\r\n * Given `value`, return identity if truthy, otherwise create an \"invalid exception\" error and return that.\r\n * @param {*} [value] - Value to return, if present\r\n * @returns {*|Error} `value`, otherwise an `Error`\r\n * @private\r\n */\r\nRunnable.toValueOrError = function(value) {\r\n  return (\r\n    value ||\r\n    createInvalidExceptionError(\r\n      'Runnable failed with falsy or undefined exception. Please throw an Error instead.',\r\n      value\r\n    )\r\n  );\r\n};\r\n\r\nRunnable.constants = constants;\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/mocha/lib/runnable.js?");

/***/ }),

/***/ "./node_modules/mocha/lib/runner.js":
/*!******************************************!*\
  !*** ./node_modules/mocha/lib/runner.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global, process) {\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\nvar util = __webpack_require__(/*! util */ \"./node_modules/util/util.js\");\r\nvar EventEmitter = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\r\nvar Pending = __webpack_require__(/*! ./pending */ \"./node_modules/mocha/lib/pending.js\");\r\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/mocha/lib/utils.js\");\r\nvar inherits = utils.inherits;\r\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/mocha/node_modules/debug/src/browser.js\")('mocha:runner');\r\nvar Runnable = __webpack_require__(/*! ./runnable */ \"./node_modules/mocha/lib/runnable.js\");\r\nvar Suite = __webpack_require__(/*! ./suite */ \"./node_modules/mocha/lib/suite.js\");\r\nvar HOOK_TYPE_BEFORE_EACH = Suite.constants.HOOK_TYPE_BEFORE_EACH;\r\nvar HOOK_TYPE_AFTER_EACH = Suite.constants.HOOK_TYPE_AFTER_EACH;\r\nvar HOOK_TYPE_AFTER_ALL = Suite.constants.HOOK_TYPE_AFTER_ALL;\r\nvar HOOK_TYPE_BEFORE_ALL = Suite.constants.HOOK_TYPE_BEFORE_ALL;\r\nvar EVENT_ROOT_SUITE_RUN = Suite.constants.EVENT_ROOT_SUITE_RUN;\r\nvar STATE_FAILED = Runnable.constants.STATE_FAILED;\r\nvar STATE_PASSED = Runnable.constants.STATE_PASSED;\r\nvar dQuote = utils.dQuote;\r\nvar sQuote = utils.sQuote;\r\nvar stackFilter = utils.stackTraceFilter();\r\nvar stringify = utils.stringify;\r\nvar type = utils.type;\r\nvar errors = __webpack_require__(/*! ./errors */ \"./node_modules/mocha/lib/errors.js\");\r\nvar createInvalidExceptionError = errors.createInvalidExceptionError;\r\nvar createUnsupportedError = errors.createUnsupportedError;\r\nvar createFatalError = errors.createFatalError;\r\n\r\n/**\r\n * Non-enumerable globals.\r\n * @readonly\r\n */\r\nvar globals = [\r\n  'setTimeout',\r\n  'clearTimeout',\r\n  'setInterval',\r\n  'clearInterval',\r\n  'XMLHttpRequest',\r\n  'Date',\r\n  'setImmediate',\r\n  'clearImmediate'\r\n];\r\n\r\nvar constants = utils.defineConstants(\r\n  /**\r\n   * {@link Runner}-related constants.\r\n   * @public\r\n   * @memberof Runner\r\n   * @readonly\r\n   * @alias constants\r\n   * @static\r\n   * @enum {string}\r\n   */\r\n  {\r\n    /**\r\n     * Emitted when {@link Hook} execution begins\r\n     */\r\n    EVENT_HOOK_BEGIN: 'hook',\r\n    /**\r\n     * Emitted when {@link Hook} execution ends\r\n     */\r\n    EVENT_HOOK_END: 'hook end',\r\n    /**\r\n     * Emitted when Root {@link Suite} execution begins (all files have been parsed and hooks/tests are ready for execution)\r\n     */\r\n    EVENT_RUN_BEGIN: 'start',\r\n    /**\r\n     * Emitted when Root {@link Suite} execution has been delayed via `delay` option\r\n     */\r\n    EVENT_DELAY_BEGIN: 'waiting',\r\n    /**\r\n     * Emitted when delayed Root {@link Suite} execution is triggered by user via `global.run()`\r\n     */\r\n    EVENT_DELAY_END: 'ready',\r\n    /**\r\n     * Emitted when Root {@link Suite} execution ends\r\n     */\r\n    EVENT_RUN_END: 'end',\r\n    /**\r\n     * Emitted when {@link Suite} execution begins\r\n     */\r\n    EVENT_SUITE_BEGIN: 'suite',\r\n    /**\r\n     * Emitted when {@link Suite} execution ends\r\n     */\r\n    EVENT_SUITE_END: 'suite end',\r\n    /**\r\n     * Emitted when {@link Test} execution begins\r\n     */\r\n    EVENT_TEST_BEGIN: 'test',\r\n    /**\r\n     * Emitted when {@link Test} execution ends\r\n     */\r\n    EVENT_TEST_END: 'test end',\r\n    /**\r\n     * Emitted when {@link Test} execution fails\r\n     */\r\n    EVENT_TEST_FAIL: 'fail',\r\n    /**\r\n     * Emitted when {@link Test} execution succeeds\r\n     */\r\n    EVENT_TEST_PASS: 'pass',\r\n    /**\r\n     * Emitted when {@link Test} becomes pending\r\n     */\r\n    EVENT_TEST_PENDING: 'pending',\r\n    /**\r\n     * Emitted when {@link Test} execution has failed, but will retry\r\n     */\r\n    EVENT_TEST_RETRY: 'retry',\r\n    /**\r\n     * Initial state of Runner\r\n     */\r\n    STATE_IDLE: 'idle',\r\n    /**\r\n     * State set to this value when the Runner has started running\r\n     */\r\n    STATE_RUNNING: 'running',\r\n    /**\r\n     * State set to this value when the Runner has stopped\r\n     */\r\n    STATE_STOPPED: 'stopped'\r\n  }\r\n);\r\n\r\nmodule.exports = Runner;\r\n\r\n/**\r\n * Initialize a `Runner` at the Root {@link Suite}, which represents a hierarchy of {@link Suite|Suites} and {@link Test|Tests}.\r\n *\r\n * @extends external:EventEmitter\r\n * @public\r\n * @class\r\n * @param {Suite} suite - Root suite\r\n * @param {Object|boolean} [opts] - Options. If `boolean`, whether or not to delay execution of root suite until ready (for backwards compatibility).\r\n * @param {boolean} [opts.delay] - Whether to delay execution of root suite until ready.\r\n * @param {boolean} [opts.cleanReferencesAfterRun] - Whether to clean references to test fns and hooks when a suite is done.\r\n */\r\nfunction Runner(suite, opts) {\r\n  if (opts === undefined) {\r\n    opts = {};\r\n  }\r\n  if (typeof opts === 'boolean') {\r\n    this._delay = opts;\r\n    opts = {};\r\n  } else {\r\n    this._delay = opts.delay;\r\n  }\r\n  var self = this;\r\n  this._globals = [];\r\n  this._abort = false;\r\n  this.suite = suite;\r\n  this._opts = opts;\r\n  this.state = constants.STATE_IDLE;\r\n  this.total = suite.total();\r\n  this.failures = 0;\r\n  this._eventListeners = [];\r\n  this.on(constants.EVENT_TEST_END, function(test) {\r\n    if (test.type === 'test' && test.retriedTest() && test.parent) {\r\n      var idx =\r\n        test.parent.tests && test.parent.tests.indexOf(test.retriedTest());\r\n      if (idx > -1) test.parent.tests[idx] = test;\r\n    }\r\n    self.checkGlobals(test);\r\n  });\r\n  this.on(constants.EVENT_HOOK_END, function(hook) {\r\n    self.checkGlobals(hook);\r\n  });\r\n  this._defaultGrep = /.*/;\r\n  this.grep(this._defaultGrep);\r\n  this.globals(this.globalProps());\r\n\r\n  this.uncaught = this._uncaught.bind(this);\r\n}\r\n\r\n/**\r\n * Wrapper for setImmediate, process.nextTick, or browser polyfill.\r\n *\r\n * @param {Function} fn\r\n * @private\r\n */\r\nRunner.immediately = global.setImmediate || process.nextTick;\r\n\r\n/**\r\n * Inherit from `EventEmitter.prototype`.\r\n */\r\ninherits(Runner, EventEmitter);\r\n\r\n/**\r\n * Replacement for `target.on(eventName, listener)` that does bookkeeping to remove them when this runner instance is disposed.\r\n * @param {EventEmitter} target - The `EventEmitter`\r\n * @param {string} eventName - The event name\r\n * @param {string} fn - Listener function\r\n */\r\nRunner.prototype._addEventListener = function(target, eventName, listener) {\r\n  target.on(eventName, listener);\r\n  this._eventListeners.push([target, eventName, listener]);\r\n};\r\n\r\n/**\r\n * Replacement for `target.removeListener(eventName, listener)` that also updates the bookkeeping.\r\n * @param {EventEmitter} target - The `EventEmitter`\r\n * @param {string} eventName - The event anme\r\n * @param {function} listener - Listener function\r\n */\r\nRunner.prototype._removeEventListener = function(target, eventName, listener) {\r\n  var eventListenerIndex = -1;\r\n  for (var i = 0; i < this._eventListeners.length; i++) {\r\n    var eventListenerDescriptor = this._eventListeners[i];\r\n    if (\r\n      eventListenerDescriptor[0] === target &&\r\n      eventListenerDescriptor[1] === eventName &&\r\n      eventListenerDescriptor[2] === listener\r\n    ) {\r\n      eventListenerIndex = i;\r\n      break;\r\n    }\r\n  }\r\n  if (eventListenerIndex !== -1) {\r\n    var removedListener = this._eventListeners.splice(eventListenerIndex, 1)[0];\r\n    removedListener[0].removeListener(removedListener[1], removedListener[2]);\r\n  }\r\n};\r\n\r\n/**\r\n * Removes all event handlers set during a run on this instance.\r\n * Remark: this does _not_ clean/dispose the tests or suites themselves.\r\n */\r\nRunner.prototype.dispose = function() {\r\n  this.removeAllListeners();\r\n  this._eventListeners.forEach(function(eventListenerDescriptor) {\r\n    eventListenerDescriptor[0].removeListener(\r\n      eventListenerDescriptor[1],\r\n      eventListenerDescriptor[2]\r\n    );\r\n  });\r\n};\r\n\r\n/**\r\n * Run tests with full titles matching `re`. Updates runner.total\r\n * with number of tests matched.\r\n *\r\n * @public\r\n * @memberof Runner\r\n * @param {RegExp} re\r\n * @param {boolean} invert\r\n * @return {Runner} Runner instance.\r\n */\r\nRunner.prototype.grep = function(re, invert) {\r\n  debug('grep(): setting to %s', re);\r\n  this._grep = re;\r\n  this._invert = invert;\r\n  this.total = this.grepTotal(this.suite);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Returns the number of tests matching the grep search for the\r\n * given suite.\r\n *\r\n * @memberof Runner\r\n * @public\r\n * @param {Suite} suite\r\n * @return {number}\r\n */\r\nRunner.prototype.grepTotal = function(suite) {\r\n  var self = this;\r\n  var total = 0;\r\n\r\n  suite.eachTest(function(test) {\r\n    var match = self._grep.test(test.fullTitle());\r\n    if (self._invert) {\r\n      match = !match;\r\n    }\r\n    if (match) {\r\n      total++;\r\n    }\r\n  });\r\n\r\n  return total;\r\n};\r\n\r\n/**\r\n * Return a list of global properties.\r\n *\r\n * @return {Array}\r\n * @private\r\n */\r\nRunner.prototype.globalProps = function() {\r\n  var props = Object.keys(global);\r\n\r\n  // non-enumerables\r\n  for (var i = 0; i < globals.length; ++i) {\r\n    if (~props.indexOf(globals[i])) {\r\n      continue;\r\n    }\r\n    props.push(globals[i]);\r\n  }\r\n\r\n  return props;\r\n};\r\n\r\n/**\r\n * Allow the given `arr` of globals.\r\n *\r\n * @public\r\n * @memberof Runner\r\n * @param {Array} arr\r\n * @return {Runner} Runner instance.\r\n */\r\nRunner.prototype.globals = function(arr) {\r\n  if (!arguments.length) {\r\n    return this._globals;\r\n  }\r\n  debug('globals(): setting to %O', arr);\r\n  this._globals = this._globals.concat(arr);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Check for global variable leaks.\r\n *\r\n * @private\r\n */\r\nRunner.prototype.checkGlobals = function(test) {\r\n  if (!this.checkLeaks) {\r\n    return;\r\n  }\r\n  var ok = this._globals;\r\n\r\n  var globals = this.globalProps();\r\n  var leaks;\r\n\r\n  if (test) {\r\n    ok = ok.concat(test._allowedGlobals || []);\r\n  }\r\n\r\n  if (this.prevGlobalsLength === globals.length) {\r\n    return;\r\n  }\r\n  this.prevGlobalsLength = globals.length;\r\n\r\n  leaks = filterLeaks(ok, globals);\r\n  this._globals = this._globals.concat(leaks);\r\n\r\n  if (leaks.length) {\r\n    var msg = 'global leak(s) detected: %s';\r\n    var error = new Error(util.format(msg, leaks.map(sQuote).join(', ')));\r\n    this.fail(test, error);\r\n  }\r\n};\r\n\r\n/**\r\n * Fail the given `test`.\r\n *\r\n * @private\r\n * @param {Test} test\r\n * @param {Error} err\r\n */\r\nRunner.prototype.fail = function(test, err) {\r\n  if (test.isPending()) {\r\n    return;\r\n  }\r\n  if (this.state === constants.STATE_STOPPED) {\r\n    if (err.code === errors.constants.MULTIPLE_DONE) {\r\n      throw err;\r\n    }\r\n    throw createFatalError(\r\n      'Test failed after root suite execution completed!',\r\n      err\r\n    );\r\n  }\r\n\r\n  ++this.failures;\r\n  debug('total number of failures: %d', this.failures);\r\n  test.state = STATE_FAILED;\r\n\r\n  if (!isError(err)) {\r\n    err = thrown2Error(err);\r\n  }\r\n\r\n  try {\r\n    err.stack =\r\n      this.fullStackTrace || !err.stack ? err.stack : stackFilter(err.stack);\r\n  } catch (ignore) {\r\n    // some environments do not take kindly to monkeying with the stack\r\n  }\r\n\r\n  this.emit(constants.EVENT_TEST_FAIL, test, err);\r\n};\r\n\r\n/**\r\n * Fail the given `hook` with `err`.\r\n *\r\n * Hook failures work in the following pattern:\r\n * - If bail, run corresponding `after each` and `after` hooks,\r\n *   then exit\r\n * - Failed `before` hook skips all tests in a suite and subsuites,\r\n *   but jumps to corresponding `after` hook\r\n * - Failed `before each` hook skips remaining tests in a\r\n *   suite and jumps to corresponding `after each` hook,\r\n *   which is run only once\r\n * - Failed `after` hook does not alter execution order\r\n * - Failed `after each` hook skips remaining tests in a\r\n *   suite and subsuites, but executes other `after each`\r\n *   hooks\r\n *\r\n * @private\r\n * @param {Hook} hook\r\n * @param {Error} err\r\n */\r\nRunner.prototype.failHook = function(hook, err) {\r\n  hook.originalTitle = hook.originalTitle || hook.title;\r\n  if (hook.ctx && hook.ctx.currentTest) {\r\n    hook.title =\r\n      hook.originalTitle + ' for ' + dQuote(hook.ctx.currentTest.title);\r\n  } else {\r\n    var parentTitle;\r\n    if (hook.parent.title) {\r\n      parentTitle = hook.parent.title;\r\n    } else {\r\n      parentTitle = hook.parent.root ? '{root}' : '';\r\n    }\r\n    hook.title = hook.originalTitle + ' in ' + dQuote(parentTitle);\r\n  }\r\n\r\n  this.fail(hook, err);\r\n};\r\n\r\n/**\r\n * Run hook `name` callbacks and then invoke `fn()`.\r\n *\r\n * @private\r\n * @param {string} name\r\n * @param {Function} fn\r\n */\r\n\r\nRunner.prototype.hook = function(name, fn) {\r\n  var suite = this.suite;\r\n  var hooks = suite.getHooks(name);\r\n  var self = this;\r\n\r\n  function next(i) {\r\n    var hook = hooks[i];\r\n    if (!hook) {\r\n      return fn();\r\n    }\r\n    self.currentRunnable = hook;\r\n\r\n    if (name === HOOK_TYPE_BEFORE_ALL) {\r\n      hook.ctx.currentTest = hook.parent.tests[0];\r\n    } else if (name === HOOK_TYPE_AFTER_ALL) {\r\n      hook.ctx.currentTest = hook.parent.tests[hook.parent.tests.length - 1];\r\n    } else {\r\n      hook.ctx.currentTest = self.test;\r\n    }\r\n\r\n    hook.allowUncaught = self.allowUncaught;\r\n\r\n    self.emit(constants.EVENT_HOOK_BEGIN, hook);\r\n\r\n    if (!hook.listeners('error').length) {\r\n      self._addEventListener(hook, 'error', function(err) {\r\n        self.failHook(hook, err);\r\n      });\r\n    }\r\n\r\n    hook.run(function(err) {\r\n      var testError = hook.error();\r\n      if (testError) {\r\n        self.fail(self.test, testError);\r\n      }\r\n      // conditional skip\r\n      if (hook.pending) {\r\n        if (name === HOOK_TYPE_AFTER_EACH) {\r\n          // TODO define and implement use case\r\n          if (self.test) {\r\n            self.test.pending = true;\r\n          }\r\n        } else if (name === HOOK_TYPE_BEFORE_EACH) {\r\n          if (self.test) {\r\n            self.test.pending = true;\r\n          }\r\n          self.emit(constants.EVENT_HOOK_END, hook);\r\n          hook.pending = false; // activates hook for next test\r\n          return fn(new Error('abort hookDown'));\r\n        } else if (name === HOOK_TYPE_BEFORE_ALL) {\r\n          suite.tests.forEach(function(test) {\r\n            test.pending = true;\r\n          });\r\n          suite.suites.forEach(function(suite) {\r\n            suite.pending = true;\r\n          });\r\n        } else {\r\n          hook.pending = false;\r\n          var errForbid = createUnsupportedError('`this.skip` forbidden');\r\n          self.failHook(hook, errForbid);\r\n          return fn(errForbid);\r\n        }\r\n      } else if (err) {\r\n        self.failHook(hook, err);\r\n        // stop executing hooks, notify callee of hook err\r\n        return fn(err);\r\n      }\r\n      self.emit(constants.EVENT_HOOK_END, hook);\r\n      delete hook.ctx.currentTest;\r\n      next(++i);\r\n    });\r\n  }\r\n\r\n  Runner.immediately(function() {\r\n    next(0);\r\n  });\r\n};\r\n\r\n/**\r\n * Run hook `name` for the given array of `suites`\r\n * in order, and callback `fn(err, errSuite)`.\r\n *\r\n * @private\r\n * @param {string} name\r\n * @param {Array} suites\r\n * @param {Function} fn\r\n */\r\nRunner.prototype.hooks = function(name, suites, fn) {\r\n  var self = this;\r\n  var orig = this.suite;\r\n\r\n  function next(suite) {\r\n    self.suite = suite;\r\n\r\n    if (!suite) {\r\n      self.suite = orig;\r\n      return fn();\r\n    }\r\n\r\n    self.hook(name, function(err) {\r\n      if (err) {\r\n        var errSuite = self.suite;\r\n        self.suite = orig;\r\n        return fn(err, errSuite);\r\n      }\r\n\r\n      next(suites.pop());\r\n    });\r\n  }\r\n\r\n  next(suites.pop());\r\n};\r\n\r\n/**\r\n * Run hooks from the top level down.\r\n *\r\n * @param {String} name\r\n * @param {Function} fn\r\n * @private\r\n */\r\nRunner.prototype.hookUp = function(name, fn) {\r\n  var suites = [this.suite].concat(this.parents()).reverse();\r\n  this.hooks(name, suites, fn);\r\n};\r\n\r\n/**\r\n * Run hooks from the bottom up.\r\n *\r\n * @param {String} name\r\n * @param {Function} fn\r\n * @private\r\n */\r\nRunner.prototype.hookDown = function(name, fn) {\r\n  var suites = [this.suite].concat(this.parents());\r\n  this.hooks(name, suites, fn);\r\n};\r\n\r\n/**\r\n * Return an array of parent Suites from\r\n * closest to furthest.\r\n *\r\n * @return {Array}\r\n * @private\r\n */\r\nRunner.prototype.parents = function() {\r\n  var suite = this.suite;\r\n  var suites = [];\r\n  while (suite.parent) {\r\n    suite = suite.parent;\r\n    suites.push(suite);\r\n  }\r\n  return suites;\r\n};\r\n\r\n/**\r\n * Run the current test and callback `fn(err)`.\r\n *\r\n * @param {Function} fn\r\n * @private\r\n */\r\nRunner.prototype.runTest = function(fn) {\r\n  var self = this;\r\n  var test = this.test;\r\n\r\n  if (!test) {\r\n    return;\r\n  }\r\n\r\n  if (this.asyncOnly) {\r\n    test.asyncOnly = true;\r\n  }\r\n  this._addEventListener(test, 'error', function(err) {\r\n    self.fail(test, err);\r\n  });\r\n  if (this.allowUncaught) {\r\n    test.allowUncaught = true;\r\n    return test.run(fn);\r\n  }\r\n  try {\r\n    test.run(fn);\r\n  } catch (err) {\r\n    fn(err);\r\n  }\r\n};\r\n\r\n/**\r\n * Run tests in the given `suite` and invoke the callback `fn()` when complete.\r\n *\r\n * @private\r\n * @param {Suite} suite\r\n * @param {Function} fn\r\n */\r\nRunner.prototype.runTests = function(suite, fn) {\r\n  var self = this;\r\n  var tests = suite.tests.slice();\r\n  var test;\r\n\r\n  function hookErr(_, errSuite, after) {\r\n    // before/after Each hook for errSuite failed:\r\n    var orig = self.suite;\r\n\r\n    // for failed 'after each' hook start from errSuite parent,\r\n    // otherwise start from errSuite itself\r\n    self.suite = after ? errSuite.parent : errSuite;\r\n\r\n    if (self.suite) {\r\n      // call hookUp afterEach\r\n      self.hookUp(HOOK_TYPE_AFTER_EACH, function(err2, errSuite2) {\r\n        self.suite = orig;\r\n        // some hooks may fail even now\r\n        if (err2) {\r\n          return hookErr(err2, errSuite2, true);\r\n        }\r\n        // report error suite\r\n        fn(errSuite);\r\n      });\r\n    } else {\r\n      // there is no need calling other 'after each' hooks\r\n      self.suite = orig;\r\n      fn(errSuite);\r\n    }\r\n  }\r\n\r\n  function next(err, errSuite) {\r\n    // if we bail after first err\r\n    if (self.failures && suite._bail) {\r\n      tests = [];\r\n    }\r\n\r\n    if (self._abort) {\r\n      return fn();\r\n    }\r\n\r\n    if (err) {\r\n      return hookErr(err, errSuite, true);\r\n    }\r\n\r\n    // next test\r\n    test = tests.shift();\r\n\r\n    // all done\r\n    if (!test) {\r\n      return fn();\r\n    }\r\n\r\n    // grep\r\n    var match = self._grep.test(test.fullTitle());\r\n    if (self._invert) {\r\n      match = !match;\r\n    }\r\n    if (!match) {\r\n      // Run immediately only if we have defined a grep. When we\r\n      // define a grep  It can cause maximum callstack error if\r\n      // the grep is doing a large recursive loop by neglecting\r\n      // all tests. The run immediately function also comes with\r\n      // a performance cost. So we don't want to run immediately\r\n      // if we run the whole test suite, because running the whole\r\n      // test suite don't do any immediate recursive loops. Thus,\r\n      // allowing a JS runtime to breathe.\r\n      if (self._grep !== self._defaultGrep) {\r\n        Runner.immediately(next);\r\n      } else {\r\n        next();\r\n      }\r\n      return;\r\n    }\r\n\r\n    // static skip, no hooks are executed\r\n    if (test.isPending()) {\r\n      if (self.forbidPending) {\r\n        test.isPending = alwaysFalse;\r\n        self.fail(test, new Error('Pending test forbidden'));\r\n        delete test.isPending;\r\n      } else {\r\n        self.emit(constants.EVENT_TEST_PENDING, test);\r\n      }\r\n      self.emit(constants.EVENT_TEST_END, test);\r\n      return next();\r\n    }\r\n\r\n    // execute test and hook(s)\r\n    self.emit(constants.EVENT_TEST_BEGIN, (self.test = test));\r\n    self.hookDown(HOOK_TYPE_BEFORE_EACH, function(err, errSuite) {\r\n      // conditional skip within beforeEach\r\n      if (test.isPending()) {\r\n        if (self.forbidPending) {\r\n          test.isPending = alwaysFalse;\r\n          self.fail(test, new Error('Pending test forbidden'));\r\n          delete test.isPending;\r\n        } else {\r\n          self.emit(constants.EVENT_TEST_PENDING, test);\r\n        }\r\n        self.emit(constants.EVENT_TEST_END, test);\r\n        // skip inner afterEach hooks below errSuite level\r\n        var origSuite = self.suite;\r\n        self.suite = errSuite || self.suite;\r\n        return self.hookUp(HOOK_TYPE_AFTER_EACH, function(e, eSuite) {\r\n          self.suite = origSuite;\r\n          next(e, eSuite);\r\n        });\r\n      }\r\n      if (err) {\r\n        return hookErr(err, errSuite, false);\r\n      }\r\n      self.currentRunnable = self.test;\r\n      self.runTest(function(err) {\r\n        test = self.test;\r\n        // conditional skip within it\r\n        if (test.pending) {\r\n          if (self.forbidPending) {\r\n            test.isPending = alwaysFalse;\r\n            self.fail(test, new Error('Pending test forbidden'));\r\n            delete test.isPending;\r\n          } else {\r\n            self.emit(constants.EVENT_TEST_PENDING, test);\r\n          }\r\n          self.emit(constants.EVENT_TEST_END, test);\r\n          return self.hookUp(HOOK_TYPE_AFTER_EACH, next);\r\n        } else if (err) {\r\n          var retry = test.currentRetry();\r\n          if (retry < test.retries()) {\r\n            var clonedTest = test.clone();\r\n            clonedTest.currentRetry(retry + 1);\r\n            tests.unshift(clonedTest);\r\n\r\n            self.emit(constants.EVENT_TEST_RETRY, test, err);\r\n\r\n            // Early return + hook trigger so that it doesn't\r\n            // increment the count wrong\r\n            return self.hookUp(HOOK_TYPE_AFTER_EACH, next);\r\n          } else {\r\n            self.fail(test, err);\r\n          }\r\n          self.emit(constants.EVENT_TEST_END, test);\r\n          return self.hookUp(HOOK_TYPE_AFTER_EACH, next);\r\n        }\r\n\r\n        test.state = STATE_PASSED;\r\n        self.emit(constants.EVENT_TEST_PASS, test);\r\n        self.emit(constants.EVENT_TEST_END, test);\r\n        self.hookUp(HOOK_TYPE_AFTER_EACH, next);\r\n      });\r\n    });\r\n  }\r\n\r\n  this.next = next;\r\n  this.hookErr = hookErr;\r\n  next();\r\n};\r\n\r\nfunction alwaysFalse() {\r\n  return false;\r\n}\r\n\r\n/**\r\n * Run the given `suite` and invoke the callback `fn()` when complete.\r\n *\r\n * @private\r\n * @param {Suite} suite\r\n * @param {Function} fn\r\n */\r\nRunner.prototype.runSuite = function(suite, fn) {\r\n  var i = 0;\r\n  var self = this;\r\n  var total = this.grepTotal(suite);\r\n\r\n  debug('runSuite(): running %s', suite.fullTitle());\r\n\r\n  if (!total || (self.failures && suite._bail)) {\r\n    debug('runSuite(): bailing');\r\n    return fn();\r\n  }\r\n\r\n  this.emit(constants.EVENT_SUITE_BEGIN, (this.suite = suite));\r\n\r\n  function next(errSuite) {\r\n    if (errSuite) {\r\n      // current suite failed on a hook from errSuite\r\n      if (errSuite === suite) {\r\n        // if errSuite is current suite\r\n        // continue to the next sibling suite\r\n        return done();\r\n      }\r\n      // errSuite is among the parents of current suite\r\n      // stop execution of errSuite and all sub-suites\r\n      return done(errSuite);\r\n    }\r\n\r\n    if (self._abort) {\r\n      return done();\r\n    }\r\n\r\n    var curr = suite.suites[i++];\r\n    if (!curr) {\r\n      return done();\r\n    }\r\n\r\n    // Avoid grep neglecting large number of tests causing a\r\n    // huge recursive loop and thus a maximum call stack error.\r\n    // See comment in `this.runTests()` for more information.\r\n    if (self._grep !== self._defaultGrep) {\r\n      Runner.immediately(function() {\r\n        self.runSuite(curr, next);\r\n      });\r\n    } else {\r\n      self.runSuite(curr, next);\r\n    }\r\n  }\r\n\r\n  function done(errSuite) {\r\n    self.suite = suite;\r\n    self.nextSuite = next;\r\n\r\n    // remove reference to test\r\n    delete self.test;\r\n\r\n    self.hook(HOOK_TYPE_AFTER_ALL, function() {\r\n      self.emit(constants.EVENT_SUITE_END, suite);\r\n      fn(errSuite);\r\n    });\r\n  }\r\n\r\n  this.nextSuite = next;\r\n\r\n  this.hook(HOOK_TYPE_BEFORE_ALL, function(err) {\r\n    if (err) {\r\n      return done();\r\n    }\r\n    self.runTests(suite, next);\r\n  });\r\n};\r\n\r\n/**\r\n * Handle uncaught exceptions within runner.\r\n *\r\n * This function is bound to the instance as `Runner#uncaught` at instantiation\r\n * time. It's intended to be listening on the `Process.uncaughtException` event.\r\n * In order to not leak EE listeners, we need to ensure no more than a single\r\n * `uncaughtException` listener exists per `Runner`.  The only way to do\r\n * this--because this function needs the context (and we don't have lambdas)--is\r\n * to use `Function.prototype.bind`. We need strict equality to unregister and\r\n * _only_ unregister the _one_ listener we set from the\r\n * `Process.uncaughtException` event; would be poor form to just remove\r\n * everything. See {@link Runner#run} for where the event listener is registered\r\n * and unregistered.\r\n * @param {Error} err - Some uncaught error\r\n * @private\r\n */\r\nRunner.prototype._uncaught = function(err) {\r\n  // this is defensive to prevent future developers from mis-calling this function.\r\n  // it's more likely that it'd be called with the incorrect context--say, the global\r\n  // `process` object--than it would to be called with a context that is not a \"subclass\"\r\n  // of `Runner`.\r\n  if (!(this instanceof Runner)) {\r\n    throw createFatalError(\r\n      'Runner#uncaught() called with invalid context',\r\n      this\r\n    );\r\n  }\r\n  if (err instanceof Pending) {\r\n    debug('uncaught(): caught a Pending');\r\n    return;\r\n  }\r\n  // browser does not exit script when throwing in global.onerror()\r\n  if (this.allowUncaught && !process.browser) {\r\n    debug('uncaught(): bubbling exception due to --allow-uncaught');\r\n    throw err;\r\n  }\r\n\r\n  if (this.state === constants.STATE_STOPPED) {\r\n    debug('uncaught(): throwing after run has completed!');\r\n    throw err;\r\n  }\r\n\r\n  if (err) {\r\n    debug('uncaught(): got truthy exception %O', err);\r\n  } else {\r\n    debug('uncaught(): undefined/falsy exception');\r\n    err = createInvalidExceptionError(\r\n      'Caught falsy/undefined exception which would otherwise be uncaught. No stack trace found; try a debugger',\r\n      err\r\n    );\r\n  }\r\n\r\n  if (!isError(err)) {\r\n    err = thrown2Error(err);\r\n    debug('uncaught(): converted \"error\" %o to Error', err);\r\n  }\r\n  err.uncaught = true;\r\n\r\n  var runnable = this.currentRunnable;\r\n\r\n  if (!runnable) {\r\n    runnable = new Runnable('Uncaught error outside test suite');\r\n    debug('uncaught(): no current Runnable; created a phony one');\r\n    runnable.parent = this.suite;\r\n\r\n    if (this.state === constants.STATE_RUNNING) {\r\n      debug('uncaught(): failing gracefully');\r\n      this.fail(runnable, err);\r\n    } else {\r\n      // Can't recover from this failure\r\n      debug('uncaught(): test run has not yet started; unrecoverable');\r\n      this.emit(constants.EVENT_RUN_BEGIN);\r\n      this.fail(runnable, err);\r\n      this.emit(constants.EVENT_RUN_END);\r\n    }\r\n\r\n    return;\r\n  }\r\n\r\n  runnable.clearTimeout();\r\n\r\n  if (runnable.isFailed()) {\r\n    debug('uncaught(): Runnable has already failed');\r\n    // Ignore error if already failed\r\n    return;\r\n  } else if (runnable.isPending()) {\r\n    debug('uncaught(): pending Runnable wound up failing!');\r\n    // report 'pending test' retrospectively as failed\r\n    runnable.isPending = alwaysFalse;\r\n    this.fail(runnable, err);\r\n    delete runnable.isPending;\r\n    return;\r\n  }\r\n\r\n  // we cannot recover gracefully if a Runnable has already passed\r\n  // then fails asynchronously\r\n  if (runnable.isPassed()) {\r\n    debug('uncaught(): Runnable has already passed; bailing gracefully');\r\n    this.fail(runnable, err);\r\n    this.abort();\r\n  } else {\r\n    debug('uncaught(): forcing Runnable to complete with Error');\r\n    return runnable.callback(err);\r\n  }\r\n};\r\n\r\n/**\r\n * Run the root suite and invoke `fn(failures)`\r\n * on completion.\r\n *\r\n * @public\r\n * @memberof Runner\r\n * @param {Function} fn\r\n * @return {Runner} Runner instance.\r\n */\r\nRunner.prototype.run = function(fn) {\r\n  var self = this;\r\n  var rootSuite = this.suite;\r\n\r\n  fn = fn || function() {};\r\n\r\n  function start() {\r\n    debug('run(): starting');\r\n    // If there is an `only` filter\r\n    if (rootSuite.hasOnly()) {\r\n      rootSuite.filterOnly();\r\n      debug('run(): filtered exclusive Runnables');\r\n    }\r\n    self.state = constants.STATE_RUNNING;\r\n    if (self._delay) {\r\n      self.emit(constants.EVENT_DELAY_END);\r\n      debug('run(): \"delay\" ended');\r\n    }\r\n    debug('run(): emitting %s', constants.EVENT_RUN_BEGIN);\r\n    self.emit(constants.EVENT_RUN_BEGIN);\r\n    debug('run(): emitted %s', constants.EVENT_RUN_BEGIN);\r\n\r\n    self.runSuite(rootSuite, function() {\r\n      debug(\r\n        'run(): root suite completed; emitting %s',\r\n        constants.EVENT_RUN_END\r\n      );\r\n      self.emit(constants.EVENT_RUN_END);\r\n      debug('run(): emitted %s', constants.EVENT_RUN_END);\r\n    });\r\n  }\r\n\r\n  // references cleanup to avoid memory leaks\r\n  if (this._opts.cleanReferencesAfterRun) {\r\n    this.on(constants.EVENT_SUITE_END, function(suite) {\r\n      suite.cleanReferences();\r\n    });\r\n  }\r\n\r\n  // callback\r\n  this.on(constants.EVENT_RUN_END, function() {\r\n    self.state = constants.STATE_STOPPED;\r\n    debug(constants.EVENT_RUN_END);\r\n    debug('run(): emitted %s', constants.EVENT_RUN_END);\r\n    fn(self.failures);\r\n  });\r\n\r\n  self._removeEventListener(process, 'uncaughtException', self.uncaught);\r\n  self._addEventListener(process, 'uncaughtException', self.uncaught);\r\n\r\n  if (this._delay) {\r\n    // for reporters, I guess.\r\n    // might be nice to debounce some dots while we wait.\r\n    this.emit(constants.EVENT_DELAY_BEGIN, rootSuite);\r\n    rootSuite.once(EVENT_ROOT_SUITE_RUN, start);\r\n    debug('run(): waiting for green light due to --delay');\r\n  } else {\r\n    Runner.immediately(function() {\r\n      start();\r\n    });\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Cleanly abort execution.\r\n *\r\n * @memberof Runner\r\n * @public\r\n * @return {Runner} Runner instance.\r\n */\r\nRunner.prototype.abort = function() {\r\n  debug('abort(): aborting');\r\n  this._abort = true;\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Filter leaks with the given globals flagged as `ok`.\r\n *\r\n * @private\r\n * @param {Array} ok\r\n * @param {Array} globals\r\n * @return {Array}\r\n */\r\nfunction filterLeaks(ok, globals) {\r\n  return globals.filter(function(key) {\r\n    // Firefox and Chrome exposes iframes as index inside the window object\r\n    if (/^\\d+/.test(key)) {\r\n      return false;\r\n    }\r\n\r\n    // in firefox\r\n    // if runner runs in an iframe, this iframe's window.getInterface method\r\n    // not init at first it is assigned in some seconds\r\n    if (global.navigator && /^getInterface/.test(key)) {\r\n      return false;\r\n    }\r\n\r\n    // an iframe could be approached by window[iframeIndex]\r\n    // in ie6,7,8 and opera, iframeIndex is enumerable, this could cause leak\r\n    if (global.navigator && /^\\d+/.test(key)) {\r\n      return false;\r\n    }\r\n\r\n    // Opera and IE expose global variables for HTML element IDs (issue #243)\r\n    if (/^mocha-/.test(key)) {\r\n      return false;\r\n    }\r\n\r\n    var matched = ok.filter(function(ok) {\r\n      if (~ok.indexOf('*')) {\r\n        return key.indexOf(ok.split('*')[0]) === 0;\r\n      }\r\n      return key === ok;\r\n    });\r\n    return !matched.length && (!global.navigator || key !== 'onerror');\r\n  });\r\n}\r\n\r\n/**\r\n * Check if argument is an instance of Error object or a duck-typed equivalent.\r\n *\r\n * @private\r\n * @param {Object} err - object to check\r\n * @param {string} err.message - error message\r\n * @returns {boolean}\r\n */\r\nfunction isError(err) {\r\n  return err instanceof Error || (err && typeof err.message === 'string');\r\n}\r\n\r\n/**\r\n *\r\n * Converts thrown non-extensible type into proper Error.\r\n *\r\n * @private\r\n * @param {*} thrown - Non-extensible type thrown by code\r\n * @return {Error}\r\n */\r\nfunction thrown2Error(err) {\r\n  return new Error(\r\n    'the ' + type(err) + ' ' + stringify(err) + ' was thrown, throw an Error :)'\r\n  );\r\n}\r\n\r\nRunner.constants = constants;\r\n\r\n/**\r\n * Node.js' `EventEmitter`\r\n * @external EventEmitter\r\n * @see {@link https://nodejs.org/api/events.html#events_class_eventemitter}\r\n */\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/mocha/lib/runner.js?");

/***/ }),

/***/ "./node_modules/mocha/lib/stats-collector.js":
/*!***************************************************!*\
  !*** ./node_modules/mocha/lib/stats-collector.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\r\n\r\n/**\r\n * Provides a factory function for a {@link StatsCollector} object.\r\n * @module\r\n */\r\n\r\nvar constants = __webpack_require__(/*! ./runner */ \"./node_modules/mocha/lib/runner.js\").constants;\r\nvar EVENT_TEST_PASS = constants.EVENT_TEST_PASS;\r\nvar EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;\r\nvar EVENT_SUITE_BEGIN = constants.EVENT_SUITE_BEGIN;\r\nvar EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;\r\nvar EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;\r\nvar EVENT_RUN_END = constants.EVENT_RUN_END;\r\nvar EVENT_TEST_END = constants.EVENT_TEST_END;\r\n\r\n/**\r\n * Test statistics collector.\r\n *\r\n * @public\r\n * @typedef {Object} StatsCollector\r\n * @property {number} suites - integer count of suites run.\r\n * @property {number} tests - integer count of tests run.\r\n * @property {number} passes - integer count of passing tests.\r\n * @property {number} pending - integer count of pending tests.\r\n * @property {number} failures - integer count of failed tests.\r\n * @property {Date} start - time when testing began.\r\n * @property {Date} end - time when testing concluded.\r\n * @property {number} duration - number of msecs that testing took.\r\n */\r\n\r\nvar Date = global.Date;\r\n\r\n/**\r\n * Provides stats such as test duration, number of tests passed / failed etc., by listening for events emitted by `runner`.\r\n *\r\n * @private\r\n * @param {Runner} runner - Runner instance\r\n * @throws {TypeError} If falsy `runner`\r\n */\r\nfunction createStatsCollector(runner) {\r\n  /**\r\n   * @type StatsCollector\r\n   */\r\n  var stats = {\r\n    suites: 0,\r\n    tests: 0,\r\n    passes: 0,\r\n    pending: 0,\r\n    failures: 0\r\n  };\r\n\r\n  if (!runner) {\r\n    throw new TypeError('Missing runner argument');\r\n  }\r\n\r\n  runner.stats = stats;\r\n\r\n  runner.once(EVENT_RUN_BEGIN, function() {\r\n    stats.start = new Date();\r\n  });\r\n  runner.on(EVENT_SUITE_BEGIN, function(suite) {\r\n    suite.root || stats.suites++;\r\n  });\r\n  runner.on(EVENT_TEST_PASS, function() {\r\n    stats.passes++;\r\n  });\r\n  runner.on(EVENT_TEST_FAIL, function() {\r\n    stats.failures++;\r\n  });\r\n  runner.on(EVENT_TEST_PENDING, function() {\r\n    stats.pending++;\r\n  });\r\n  runner.on(EVENT_TEST_END, function() {\r\n    stats.tests++;\r\n  });\r\n  runner.once(EVENT_RUN_END, function() {\r\n    stats.end = new Date();\r\n    stats.duration = stats.end - stats.start;\r\n  });\r\n}\r\n\r\nmodule.exports = createStatsCollector;\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/mocha/lib/stats-collector.js?");

/***/ }),

/***/ "./node_modules/mocha/lib/suite.js":
/*!*****************************************!*\
  !*** ./node_modules/mocha/lib/suite.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\nvar EventEmitter = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\r\nvar Hook = __webpack_require__(/*! ./hook */ \"./node_modules/mocha/lib/hook.js\");\r\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/mocha/lib/utils.js\");\r\nvar inherits = utils.inherits;\r\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/mocha/node_modules/debug/src/browser.js\")('mocha:suite');\r\nvar milliseconds = __webpack_require__(/*! ms */ \"./node_modules/mocha/node_modules/ms/index.js\");\r\nvar errors = __webpack_require__(/*! ./errors */ \"./node_modules/mocha/lib/errors.js\");\r\nvar createInvalidArgumentTypeError = errors.createInvalidArgumentTypeError;\r\n\r\n/**\r\n * Expose `Suite`.\r\n */\r\n\r\nexports = module.exports = Suite;\r\n\r\n/**\r\n * Create a new `Suite` with the given `title` and parent `Suite`.\r\n *\r\n * @public\r\n * @param {Suite} parent - Parent suite (required!)\r\n * @param {string} title - Title\r\n * @return {Suite}\r\n */\r\nSuite.create = function(parent, title) {\r\n  var suite = new Suite(title, parent.ctx);\r\n  suite.parent = parent;\r\n  title = suite.fullTitle();\r\n  parent.addSuite(suite);\r\n  return suite;\r\n};\r\n\r\n/**\r\n * Constructs a new `Suite` instance with the given `title`, `ctx`, and `isRoot`.\r\n *\r\n * @public\r\n * @class\r\n * @extends EventEmitter\r\n * @see {@link https://nodejs.org/api/events.html#events_class_eventemitter|EventEmitter}\r\n * @param {string} title - Suite title.\r\n * @param {Context} parentContext - Parent context instance.\r\n * @param {boolean} [isRoot=false] - Whether this is the root suite.\r\n */\r\nfunction Suite(title, parentContext, isRoot) {\r\n  if (!utils.isString(title)) {\r\n    throw createInvalidArgumentTypeError(\r\n      'Suite argument \"title\" must be a string. Received type \"' +\r\n        typeof title +\r\n        '\"',\r\n      'title',\r\n      'string'\r\n    );\r\n  }\r\n  this.title = title;\r\n  function Context() {}\r\n  Context.prototype = parentContext;\r\n  this.ctx = new Context();\r\n  this.suites = [];\r\n  this.tests = [];\r\n  this.root = isRoot === true;\r\n  this.pending = false;\r\n  this._retries = -1;\r\n  this._beforeEach = [];\r\n  this._beforeAll = [];\r\n  this._afterEach = [];\r\n  this._afterAll = [];\r\n  this._timeout = 2000;\r\n  this._enableTimeouts = true;\r\n  this._slow = 75;\r\n  this._bail = false;\r\n  this._onlyTests = [];\r\n  this._onlySuites = [];\r\n  this.reset();\r\n\r\n  this.on('newListener', function(event) {\r\n    if (deprecatedEvents[event]) {\r\n      utils.deprecate(\r\n        'Event \"' +\r\n          event +\r\n          '\" is deprecated.  Please let the Mocha team know about your use case: https://git.io/v6Lwm'\r\n      );\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Inherit from `EventEmitter.prototype`.\r\n */\r\ninherits(Suite, EventEmitter);\r\n\r\n/**\r\n * Resets the state initially or for a next run.\r\n */\r\nSuite.prototype.reset = function() {\r\n  this.delayed = false;\r\n  function doReset(thingToReset) {\r\n    thingToReset.reset();\r\n  }\r\n  this.suites.forEach(doReset);\r\n  this.tests.forEach(doReset);\r\n  this._beforeEach.forEach(doReset);\r\n  this._afterEach.forEach(doReset);\r\n  this._beforeAll.forEach(doReset);\r\n  this._afterAll.forEach(doReset);\r\n};\r\n\r\n/**\r\n * Return a clone of this `Suite`.\r\n *\r\n * @private\r\n * @return {Suite}\r\n */\r\nSuite.prototype.clone = function() {\r\n  var suite = new Suite(this.title);\r\n  debug('clone');\r\n  suite.ctx = this.ctx;\r\n  suite.root = this.root;\r\n  suite.timeout(this.timeout());\r\n  suite.retries(this.retries());\r\n  suite.enableTimeouts(this.enableTimeouts());\r\n  suite.slow(this.slow());\r\n  suite.bail(this.bail());\r\n  return suite;\r\n};\r\n\r\n/**\r\n * Set or get timeout `ms` or short-hand such as \"2s\".\r\n *\r\n * @private\r\n * @todo Do not attempt to set value if `ms` is undefined\r\n * @param {number|string} ms\r\n * @return {Suite|number} for chaining\r\n */\r\nSuite.prototype.timeout = function(ms) {\r\n  if (!arguments.length) {\r\n    return this._timeout;\r\n  }\r\n  if (ms.toString() === '0') {\r\n    this._enableTimeouts = false;\r\n  }\r\n  if (typeof ms === 'string') {\r\n    ms = milliseconds(ms);\r\n  }\r\n  debug('timeout %d', ms);\r\n  this._timeout = parseInt(ms, 10);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set or get number of times to retry a failed test.\r\n *\r\n * @private\r\n * @param {number|string} n\r\n * @return {Suite|number} for chaining\r\n */\r\nSuite.prototype.retries = function(n) {\r\n  if (!arguments.length) {\r\n    return this._retries;\r\n  }\r\n  debug('retries %d', n);\r\n  this._retries = parseInt(n, 10) || 0;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set or get timeout to `enabled`.\r\n *\r\n * @private\r\n * @param {boolean} enabled\r\n * @return {Suite|boolean} self or enabled\r\n */\r\nSuite.prototype.enableTimeouts = function(enabled) {\r\n  if (!arguments.length) {\r\n    return this._enableTimeouts;\r\n  }\r\n  debug('enableTimeouts %s', enabled);\r\n  this._enableTimeouts = enabled;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set or get slow `ms` or short-hand such as \"2s\".\r\n *\r\n * @private\r\n * @param {number|string} ms\r\n * @return {Suite|number} for chaining\r\n */\r\nSuite.prototype.slow = function(ms) {\r\n  if (!arguments.length) {\r\n    return this._slow;\r\n  }\r\n  if (typeof ms === 'string') {\r\n    ms = milliseconds(ms);\r\n  }\r\n  debug('slow %d', ms);\r\n  this._slow = ms;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set or get whether to bail after first error.\r\n *\r\n * @private\r\n * @param {boolean} bail\r\n * @return {Suite|number} for chaining\r\n */\r\nSuite.prototype.bail = function(bail) {\r\n  if (!arguments.length) {\r\n    return this._bail;\r\n  }\r\n  debug('bail %s', bail);\r\n  this._bail = bail;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Check if this suite or its parent suite is marked as pending.\r\n *\r\n * @private\r\n */\r\nSuite.prototype.isPending = function() {\r\n  return this.pending || (this.parent && this.parent.isPending());\r\n};\r\n\r\n/**\r\n * Generic hook-creator.\r\n * @private\r\n * @param {string} title - Title of hook\r\n * @param {Function} fn - Hook callback\r\n * @returns {Hook} A new hook\r\n */\r\nSuite.prototype._createHook = function(title, fn) {\r\n  var hook = new Hook(title, fn);\r\n  hook.parent = this;\r\n  hook.timeout(this.timeout());\r\n  hook.retries(this.retries());\r\n  hook.enableTimeouts(this.enableTimeouts());\r\n  hook.slow(this.slow());\r\n  hook.ctx = this.ctx;\r\n  hook.file = this.file;\r\n  return hook;\r\n};\r\n\r\n/**\r\n * Run `fn(test[, done])` before running tests.\r\n *\r\n * @private\r\n * @param {string} title\r\n * @param {Function} fn\r\n * @return {Suite} for chaining\r\n */\r\nSuite.prototype.beforeAll = function(title, fn) {\r\n  if (this.isPending()) {\r\n    return this;\r\n  }\r\n  if (typeof title === 'function') {\r\n    fn = title;\r\n    title = fn.name;\r\n  }\r\n  title = '\"before all\" hook' + (title ? ': ' + title : '');\r\n\r\n  var hook = this._createHook(title, fn);\r\n  this._beforeAll.push(hook);\r\n  this.emit(constants.EVENT_SUITE_ADD_HOOK_BEFORE_ALL, hook);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Run `fn(test[, done])` after running tests.\r\n *\r\n * @private\r\n * @param {string} title\r\n * @param {Function} fn\r\n * @return {Suite} for chaining\r\n */\r\nSuite.prototype.afterAll = function(title, fn) {\r\n  if (this.isPending()) {\r\n    return this;\r\n  }\r\n  if (typeof title === 'function') {\r\n    fn = title;\r\n    title = fn.name;\r\n  }\r\n  title = '\"after all\" hook' + (title ? ': ' + title : '');\r\n\r\n  var hook = this._createHook(title, fn);\r\n  this._afterAll.push(hook);\r\n  this.emit(constants.EVENT_SUITE_ADD_HOOK_AFTER_ALL, hook);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Run `fn(test[, done])` before each test case.\r\n *\r\n * @private\r\n * @param {string} title\r\n * @param {Function} fn\r\n * @return {Suite} for chaining\r\n */\r\nSuite.prototype.beforeEach = function(title, fn) {\r\n  if (this.isPending()) {\r\n    return this;\r\n  }\r\n  if (typeof title === 'function') {\r\n    fn = title;\r\n    title = fn.name;\r\n  }\r\n  title = '\"before each\" hook' + (title ? ': ' + title : '');\r\n\r\n  var hook = this._createHook(title, fn);\r\n  this._beforeEach.push(hook);\r\n  this.emit(constants.EVENT_SUITE_ADD_HOOK_BEFORE_EACH, hook);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Run `fn(test[, done])` after each test case.\r\n *\r\n * @private\r\n * @param {string} title\r\n * @param {Function} fn\r\n * @return {Suite} for chaining\r\n */\r\nSuite.prototype.afterEach = function(title, fn) {\r\n  if (this.isPending()) {\r\n    return this;\r\n  }\r\n  if (typeof title === 'function') {\r\n    fn = title;\r\n    title = fn.name;\r\n  }\r\n  title = '\"after each\" hook' + (title ? ': ' + title : '');\r\n\r\n  var hook = this._createHook(title, fn);\r\n  this._afterEach.push(hook);\r\n  this.emit(constants.EVENT_SUITE_ADD_HOOK_AFTER_EACH, hook);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Add a test `suite`.\r\n *\r\n * @private\r\n * @param {Suite} suite\r\n * @return {Suite} for chaining\r\n */\r\nSuite.prototype.addSuite = function(suite) {\r\n  suite.parent = this;\r\n  suite.root = false;\r\n  suite.timeout(this.timeout());\r\n  suite.retries(this.retries());\r\n  suite.enableTimeouts(this.enableTimeouts());\r\n  suite.slow(this.slow());\r\n  suite.bail(this.bail());\r\n  this.suites.push(suite);\r\n  this.emit(constants.EVENT_SUITE_ADD_SUITE, suite);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Add a `test` to this suite.\r\n *\r\n * @private\r\n * @param {Test} test\r\n * @return {Suite} for chaining\r\n */\r\nSuite.prototype.addTest = function(test) {\r\n  test.parent = this;\r\n  test.timeout(this.timeout());\r\n  test.retries(this.retries());\r\n  test.enableTimeouts(this.enableTimeouts());\r\n  test.slow(this.slow());\r\n  test.ctx = this.ctx;\r\n  this.tests.push(test);\r\n  this.emit(constants.EVENT_SUITE_ADD_TEST, test);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Return the full title generated by recursively concatenating the parent's\r\n * full title.\r\n *\r\n * @memberof Suite\r\n * @public\r\n * @return {string}\r\n */\r\nSuite.prototype.fullTitle = function() {\r\n  return this.titlePath().join(' ');\r\n};\r\n\r\n/**\r\n * Return the title path generated by recursively concatenating the parent's\r\n * title path.\r\n *\r\n * @memberof Suite\r\n * @public\r\n * @return {string}\r\n */\r\nSuite.prototype.titlePath = function() {\r\n  var result = [];\r\n  if (this.parent) {\r\n    result = result.concat(this.parent.titlePath());\r\n  }\r\n  if (!this.root) {\r\n    result.push(this.title);\r\n  }\r\n  return result;\r\n};\r\n\r\n/**\r\n * Return the total number of tests.\r\n *\r\n * @memberof Suite\r\n * @public\r\n * @return {number}\r\n */\r\nSuite.prototype.total = function() {\r\n  return (\r\n    this.suites.reduce(function(sum, suite) {\r\n      return sum + suite.total();\r\n    }, 0) + this.tests.length\r\n  );\r\n};\r\n\r\n/**\r\n * Iterates through each suite recursively to find all tests. Applies a\r\n * function in the format `fn(test)`.\r\n *\r\n * @private\r\n * @param {Function} fn\r\n * @return {Suite}\r\n */\r\nSuite.prototype.eachTest = function(fn) {\r\n  this.tests.forEach(fn);\r\n  this.suites.forEach(function(suite) {\r\n    suite.eachTest(fn);\r\n  });\r\n  return this;\r\n};\r\n\r\n/**\r\n * This will run the root suite if we happen to be running in delayed mode.\r\n * @private\r\n */\r\nSuite.prototype.run = function run() {\r\n  if (this.root) {\r\n    this.emit(constants.EVENT_ROOT_SUITE_RUN);\r\n  }\r\n};\r\n\r\n/**\r\n * Determines whether a suite has an `only` test or suite as a descendant.\r\n *\r\n * @private\r\n * @returns {Boolean}\r\n */\r\nSuite.prototype.hasOnly = function hasOnly() {\r\n  return (\r\n    this._onlyTests.length > 0 ||\r\n    this._onlySuites.length > 0 ||\r\n    this.suites.some(function(suite) {\r\n      return suite.hasOnly();\r\n    })\r\n  );\r\n};\r\n\r\n/**\r\n * Filter suites based on `isOnly` logic.\r\n *\r\n * @private\r\n * @returns {Boolean}\r\n */\r\nSuite.prototype.filterOnly = function filterOnly() {\r\n  if (this._onlyTests.length) {\r\n    // If the suite contains `only` tests, run those and ignore any nested suites.\r\n    this.tests = this._onlyTests;\r\n    this.suites = [];\r\n  } else {\r\n    // Otherwise, do not run any of the tests in this suite.\r\n    this.tests = [];\r\n    this._onlySuites.forEach(function(onlySuite) {\r\n      // If there are other `only` tests/suites nested in the current `only` suite, then filter that `only` suite.\r\n      // Otherwise, all of the tests on this `only` suite should be run, so don't filter it.\r\n      if (onlySuite.hasOnly()) {\r\n        onlySuite.filterOnly();\r\n      }\r\n    });\r\n    // Run the `only` suites, as well as any other suites that have `only` tests/suites as descendants.\r\n    var onlySuites = this._onlySuites;\r\n    this.suites = this.suites.filter(function(childSuite) {\r\n      return onlySuites.indexOf(childSuite) !== -1 || childSuite.filterOnly();\r\n    });\r\n  }\r\n  // Keep the suite only if there is something to run\r\n  return this.tests.length > 0 || this.suites.length > 0;\r\n};\r\n\r\n/**\r\n * Adds a suite to the list of subsuites marked `only`.\r\n *\r\n * @private\r\n * @param {Suite} suite\r\n */\r\nSuite.prototype.appendOnlySuite = function(suite) {\r\n  this._onlySuites.push(suite);\r\n};\r\n\r\n/**\r\n * Adds a test to the list of tests marked `only`.\r\n *\r\n * @private\r\n * @param {Test} test\r\n */\r\nSuite.prototype.appendOnlyTest = function(test) {\r\n  this._onlyTests.push(test);\r\n};\r\n\r\n/**\r\n * Returns the array of hooks by hook name; see `HOOK_TYPE_*` constants.\r\n * @private\r\n */\r\nSuite.prototype.getHooks = function getHooks(name) {\r\n  return this['_' + name];\r\n};\r\n\r\n/**\r\n * cleans all references from this suite and all child suites.\r\n */\r\nSuite.prototype.dispose = function() {\r\n  this.suites.forEach(function(suite) {\r\n    suite.dispose();\r\n  });\r\n  this.cleanReferences();\r\n};\r\n\r\n/**\r\n * Cleans up the references to all the deferred functions\r\n * (before/after/beforeEach/afterEach) and tests of a Suite.\r\n * These must be deleted otherwise a memory leak can happen,\r\n * as those functions may reference variables from closures,\r\n * thus those variables can never be garbage collected as long\r\n * as the deferred functions exist.\r\n *\r\n * @private\r\n */\r\nSuite.prototype.cleanReferences = function cleanReferences() {\r\n  function cleanArrReferences(arr) {\r\n    for (var i = 0; i < arr.length; i++) {\r\n      delete arr[i].fn;\r\n    }\r\n  }\r\n\r\n  if (Array.isArray(this._beforeAll)) {\r\n    cleanArrReferences(this._beforeAll);\r\n  }\r\n\r\n  if (Array.isArray(this._beforeEach)) {\r\n    cleanArrReferences(this._beforeEach);\r\n  }\r\n\r\n  if (Array.isArray(this._afterAll)) {\r\n    cleanArrReferences(this._afterAll);\r\n  }\r\n\r\n  if (Array.isArray(this._afterEach)) {\r\n    cleanArrReferences(this._afterEach);\r\n  }\r\n\r\n  for (var i = 0; i < this.tests.length; i++) {\r\n    delete this.tests[i].fn;\r\n  }\r\n};\r\n\r\nvar constants = utils.defineConstants(\r\n  /**\r\n   * {@link Suite}-related constants.\r\n   * @public\r\n   * @memberof Suite\r\n   * @alias constants\r\n   * @readonly\r\n   * @static\r\n   * @enum {string}\r\n   */\r\n  {\r\n    /**\r\n     * Event emitted after a test file has been loaded Not emitted in browser.\r\n     */\r\n    EVENT_FILE_POST_REQUIRE: 'post-require',\r\n    /**\r\n     * Event emitted before a test file has been loaded. In browser, this is emitted once an interface has been selected.\r\n     */\r\n    EVENT_FILE_PRE_REQUIRE: 'pre-require',\r\n    /**\r\n     * Event emitted immediately after a test file has been loaded. Not emitted in browser.\r\n     */\r\n    EVENT_FILE_REQUIRE: 'require',\r\n    /**\r\n     * Event emitted when `global.run()` is called (use with `delay` option)\r\n     */\r\n    EVENT_ROOT_SUITE_RUN: 'run',\r\n\r\n    /**\r\n     * Namespace for collection of a `Suite`'s \"after all\" hooks\r\n     */\r\n    HOOK_TYPE_AFTER_ALL: 'afterAll',\r\n    /**\r\n     * Namespace for collection of a `Suite`'s \"after each\" hooks\r\n     */\r\n    HOOK_TYPE_AFTER_EACH: 'afterEach',\r\n    /**\r\n     * Namespace for collection of a `Suite`'s \"before all\" hooks\r\n     */\r\n    HOOK_TYPE_BEFORE_ALL: 'beforeAll',\r\n    /**\r\n     * Namespace for collection of a `Suite`'s \"before all\" hooks\r\n     */\r\n    HOOK_TYPE_BEFORE_EACH: 'beforeEach',\r\n\r\n    // the following events are all deprecated\r\n\r\n    /**\r\n     * Emitted after an \"after all\" `Hook` has been added to a `Suite`. Deprecated\r\n     */\r\n    EVENT_SUITE_ADD_HOOK_AFTER_ALL: 'afterAll',\r\n    /**\r\n     * Emitted after an \"after each\" `Hook` has been added to a `Suite` Deprecated\r\n     */\r\n    EVENT_SUITE_ADD_HOOK_AFTER_EACH: 'afterEach',\r\n    /**\r\n     * Emitted after an \"before all\" `Hook` has been added to a `Suite` Deprecated\r\n     */\r\n    EVENT_SUITE_ADD_HOOK_BEFORE_ALL: 'beforeAll',\r\n    /**\r\n     * Emitted after an \"before each\" `Hook` has been added to a `Suite` Deprecated\r\n     */\r\n    EVENT_SUITE_ADD_HOOK_BEFORE_EACH: 'beforeEach',\r\n    /**\r\n     * Emitted after a child `Suite` has been added to a `Suite`. Deprecated\r\n     */\r\n    EVENT_SUITE_ADD_SUITE: 'suite',\r\n    /**\r\n     * Emitted after a `Test` has been added to a `Suite`. Deprecated\r\n     */\r\n    EVENT_SUITE_ADD_TEST: 'test'\r\n  }\r\n);\r\n\r\n/**\r\n * @summary There are no known use cases for these events.\r\n * @desc This is a `Set`-like object having all keys being the constant's string value and the value being `true`.\r\n * @todo Remove eventually\r\n * @type {Object<string,boolean>}\r\n * @ignore\r\n */\r\nvar deprecatedEvents = Object.keys(constants)\r\n  .filter(function(constant) {\r\n    return constant.substring(0, 15) === 'EVENT_SUITE_ADD';\r\n  })\r\n  .reduce(function(acc, constant) {\r\n    acc[constants[constant]] = true;\r\n    return acc;\r\n  }, utils.createMap());\r\n\r\nSuite.constants = constants;\r\n\n\n//# sourceURL=webpack:///./node_modules/mocha/lib/suite.js?");

/***/ }),

/***/ "./node_modules/mocha/lib/test.js":
/*!****************************************!*\
  !*** ./node_modules/mocha/lib/test.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar Runnable = __webpack_require__(/*! ./runnable */ \"./node_modules/mocha/lib/runnable.js\");\r\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/mocha/lib/utils.js\");\r\nvar errors = __webpack_require__(/*! ./errors */ \"./node_modules/mocha/lib/errors.js\");\r\nvar createInvalidArgumentTypeError = errors.createInvalidArgumentTypeError;\r\nvar isString = utils.isString;\r\n\r\nmodule.exports = Test;\r\n\r\n/**\r\n * Initialize a new `Test` with the given `title` and callback `fn`.\r\n *\r\n * @public\r\n * @class\r\n * @extends Runnable\r\n * @param {String} title - Test title (required)\r\n * @param {Function} [fn] - Test callback.  If omitted, the Test is considered \"pending\"\r\n */\r\nfunction Test(title, fn) {\r\n  if (!isString(title)) {\r\n    throw createInvalidArgumentTypeError(\r\n      'Test argument \"title\" should be a string. Received type \"' +\r\n        typeof title +\r\n        '\"',\r\n      'title',\r\n      'string'\r\n    );\r\n  }\r\n  this.type = 'test';\r\n  Runnable.call(this, title, fn);\r\n  this.reset();\r\n}\r\n\r\n/**\r\n * Inherit from `Runnable.prototype`.\r\n */\r\nutils.inherits(Test, Runnable);\r\n\r\n/**\r\n * Resets the state initially or for a next run.\r\n */\r\nTest.prototype.reset = function() {\r\n  Runnable.prototype.reset.call(this);\r\n  this.pending = !this.fn;\r\n  delete this.state;\r\n};\r\n\r\n/**\r\n * Set or get retried test\r\n *\r\n * @private\r\n */\r\nTest.prototype.retriedTest = function(n) {\r\n  if (!arguments.length) {\r\n    return this._retriedTest;\r\n  }\r\n  this._retriedTest = n;\r\n};\r\n\r\n/**\r\n * Add test to the list of tests marked `only`.\r\n *\r\n * @private\r\n */\r\nTest.prototype.markOnly = function() {\r\n  this.parent.appendOnlyTest(this);\r\n};\r\n\r\nTest.prototype.clone = function() {\r\n  var test = new Test(this.title, this.fn);\r\n  test.timeout(this.timeout());\r\n  test.slow(this.slow());\r\n  test.enableTimeouts(this.enableTimeouts());\r\n  test.retries(this.retries());\r\n  test.currentRetry(this.currentRetry());\r\n  test.retriedTest(this.retriedTest() || this);\r\n  test.globals(this.globals());\r\n  test.parent = this.parent;\r\n  test.file = this.file;\r\n  test.ctx = this.ctx;\r\n  return test;\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/mocha/lib/test.js?");

/***/ }),

/***/ "./node_modules/mocha/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/mocha/lib/utils.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Buffer, process) {\r\n\r\n/**\r\n * Various utility functions used throughout Mocha's codebase.\r\n * @module utils\r\n */\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar fs = __webpack_require__(/*! fs */ 4);\r\nvar path = __webpack_require__(/*! path */ 3);\r\nvar util = __webpack_require__(/*! util */ \"./node_modules/util/util.js\");\r\nvar glob = __webpack_require__(/*! glob */ 5);\r\nvar he = __webpack_require__(/*! he */ \"./node_modules/he/he.js\");\r\nvar errors = __webpack_require__(/*! ./errors */ \"./node_modules/mocha/lib/errors.js\");\r\nvar createNoFilesMatchPatternError = errors.createNoFilesMatchPatternError;\r\nvar createMissingArgumentError = errors.createMissingArgumentError;\r\n\r\nvar assign = (exports.assign = __webpack_require__(/*! object.assign */ \"./node_modules/object.assign/index.js\").getPolyfill());\r\n\r\n/**\r\n * Inherit the prototype methods from one constructor into another.\r\n *\r\n * @param {function} ctor - Constructor function which needs to inherit the\r\n *     prototype.\r\n * @param {function} superCtor - Constructor function to inherit prototype from.\r\n * @throws {TypeError} if either constructor is null, or if super constructor\r\n *     lacks a prototype.\r\n */\r\nexports.inherits = util.inherits;\r\n\r\n/**\r\n * Escape special characters in the given string of html.\r\n *\r\n * @private\r\n * @param  {string} html\r\n * @return {string}\r\n */\r\nexports.escape = function(html) {\r\n  return he.encode(String(html), {useNamedReferences: false});\r\n};\r\n\r\n/**\r\n * Test if the given obj is type of string.\r\n *\r\n * @private\r\n * @param {Object} obj\r\n * @return {boolean}\r\n */\r\nexports.isString = function(obj) {\r\n  return typeof obj === 'string';\r\n};\r\n\r\n/**\r\n * Compute a slug from the given `str`.\r\n *\r\n * @private\r\n * @param {string} str\r\n * @return {string}\r\n */\r\nexports.slug = function(str) {\r\n  return str\r\n    .toLowerCase()\r\n    .replace(/\\s+/g, '-')\r\n    .replace(/[^-\\w]/g, '')\r\n    .replace(/-{2,}/g, '-');\r\n};\r\n\r\n/**\r\n * Strip the function definition from `str`, and re-indent for pre whitespace.\r\n *\r\n * @param {string} str\r\n * @return {string}\r\n */\r\nexports.clean = function(str) {\r\n  str = str\r\n    .replace(/\\r\\n?|[\\n\\u2028\\u2029]/g, '\\n')\r\n    .replace(/^\\uFEFF/, '')\r\n    // (traditional)->  space/name     parameters    body     (lambda)-> parameters       body   multi-statement/single          keep body content\r\n    .replace(\r\n      /^function(?:\\s*|\\s+[^(]*)\\([^)]*\\)\\s*\\{((?:.|\\n)*?)\\s*\\}$|^\\([^)]*\\)\\s*=>\\s*(?:\\{((?:.|\\n)*?)\\s*\\}|((?:.|\\n)*))$/,\r\n      '$1$2$3'\r\n    );\r\n\r\n  var spaces = str.match(/^\\n?( *)/)[1].length;\r\n  var tabs = str.match(/^\\n?(\\t*)/)[1].length;\r\n  var re = new RegExp(\r\n    '^\\n?' + (tabs ? '\\t' : ' ') + '{' + (tabs || spaces) + '}',\r\n    'gm'\r\n  );\r\n\r\n  str = str.replace(re, '');\r\n\r\n  return str.trim();\r\n};\r\n\r\n/**\r\n * Parse the given `qs`.\r\n *\r\n * @private\r\n * @param {string} qs\r\n * @return {Object}\r\n */\r\nexports.parseQuery = function(qs) {\r\n  return qs\r\n    .replace('?', '')\r\n    .split('&')\r\n    .reduce(function(obj, pair) {\r\n      var i = pair.indexOf('=');\r\n      var key = pair.slice(0, i);\r\n      var val = pair.slice(++i);\r\n\r\n      // Due to how the URLSearchParams API treats spaces\r\n      obj[key] = decodeURIComponent(val.replace(/\\+/g, '%20'));\r\n\r\n      return obj;\r\n    }, {});\r\n};\r\n\r\n/**\r\n * Highlight the given string of `js`.\r\n *\r\n * @private\r\n * @param {string} js\r\n * @return {string}\r\n */\r\nfunction highlight(js) {\r\n  return js\r\n    .replace(/</g, '&lt;')\r\n    .replace(/>/g, '&gt;')\r\n    .replace(/\\/\\/(.*)/gm, '<span class=\"comment\">//$1</span>')\r\n    .replace(/('.*?')/gm, '<span class=\"string\">$1</span>')\r\n    .replace(/(\\d+\\.\\d+)/gm, '<span class=\"number\">$1</span>')\r\n    .replace(/(\\d+)/gm, '<span class=\"number\">$1</span>')\r\n    .replace(\r\n      /\\bnew[ \\t]+(\\w+)/gm,\r\n      '<span class=\"keyword\">new</span> <span class=\"init\">$1</span>'\r\n    )\r\n    .replace(\r\n      /\\b(function|new|throw|return|var|if|else)\\b/gm,\r\n      '<span class=\"keyword\">$1</span>'\r\n    );\r\n}\r\n\r\n/**\r\n * Highlight the contents of tag `name`.\r\n *\r\n * @private\r\n * @param {string} name\r\n */\r\nexports.highlightTags = function(name) {\r\n  var code = document.getElementById('mocha').getElementsByTagName(name);\r\n  for (var i = 0, len = code.length; i < len; ++i) {\r\n    code[i].innerHTML = highlight(code[i].innerHTML);\r\n  }\r\n};\r\n\r\n/**\r\n * If a value could have properties, and has none, this function is called,\r\n * which returns a string representation of the empty value.\r\n *\r\n * Functions w/ no properties return `'[Function]'`\r\n * Arrays w/ length === 0 return `'[]'`\r\n * Objects w/ no properties return `'{}'`\r\n * All else: return result of `value.toString()`\r\n *\r\n * @private\r\n * @param {*} value The value to inspect.\r\n * @param {string} typeHint The type of the value\r\n * @returns {string}\r\n */\r\nfunction emptyRepresentation(value, typeHint) {\r\n  switch (typeHint) {\r\n    case 'function':\r\n      return '[Function]';\r\n    case 'object':\r\n      return '{}';\r\n    case 'array':\r\n      return '[]';\r\n    default:\r\n      return value.toString();\r\n  }\r\n}\r\n\r\n/**\r\n * Takes some variable and asks `Object.prototype.toString()` what it thinks it\r\n * is.\r\n *\r\n * @private\r\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString\r\n * @param {*} value The value to test.\r\n * @returns {string} Computed type\r\n * @example\r\n * type({}) // 'object'\r\n * type([]) // 'array'\r\n * type(1) // 'number'\r\n * type(false) // 'boolean'\r\n * type(Infinity) // 'number'\r\n * type(null) // 'null'\r\n * type(new Date()) // 'date'\r\n * type(/foo/) // 'regexp'\r\n * type('type') // 'string'\r\n * type(global) // 'global'\r\n * type(new String('foo') // 'object'\r\n */\r\nvar type = (exports.type = function type(value) {\r\n  if (value === undefined) {\r\n    return 'undefined';\r\n  } else if (value === null) {\r\n    return 'null';\r\n  } else if (Buffer.isBuffer(value)) {\r\n    return 'buffer';\r\n  }\r\n  return Object.prototype.toString\r\n    .call(value)\r\n    .replace(/^\\[.+\\s(.+?)]$/, '$1')\r\n    .toLowerCase();\r\n});\r\n\r\n/**\r\n * Stringify `value`. Different behavior depending on type of value:\r\n *\r\n * - If `value` is undefined or null, return `'[undefined]'` or `'[null]'`, respectively.\r\n * - If `value` is not an object, function or array, return result of `value.toString()` wrapped in double-quotes.\r\n * - If `value` is an *empty* object, function, or array, return result of function\r\n *   {@link emptyRepresentation}.\r\n * - If `value` has properties, call {@link exports.canonicalize} on it, then return result of\r\n *   JSON.stringify().\r\n *\r\n * @private\r\n * @see exports.type\r\n * @param {*} value\r\n * @return {string}\r\n */\r\nexports.stringify = function(value) {\r\n  var typeHint = type(value);\r\n\r\n  if (!~['object', 'array', 'function'].indexOf(typeHint)) {\r\n    if (typeHint === 'buffer') {\r\n      var json = Buffer.prototype.toJSON.call(value);\r\n      // Based on the toJSON result\r\n      return jsonStringify(\r\n        json.data && json.type ? json.data : json,\r\n        2\r\n      ).replace(/,(\\n|$)/g, '$1');\r\n    }\r\n\r\n    // IE7/IE8 has a bizarre String constructor; needs to be coerced\r\n    // into an array and back to obj.\r\n    if (typeHint === 'string' && typeof value === 'object') {\r\n      value = value.split('').reduce(function(acc, char, idx) {\r\n        acc[idx] = char;\r\n        return acc;\r\n      }, {});\r\n      typeHint = 'object';\r\n    } else {\r\n      return jsonStringify(value);\r\n    }\r\n  }\r\n\r\n  for (var prop in value) {\r\n    if (Object.prototype.hasOwnProperty.call(value, prop)) {\r\n      return jsonStringify(\r\n        exports.canonicalize(value, null, typeHint),\r\n        2\r\n      ).replace(/,(\\n|$)/g, '$1');\r\n    }\r\n  }\r\n\r\n  return emptyRepresentation(value, typeHint);\r\n};\r\n\r\n/**\r\n * like JSON.stringify but more sense.\r\n *\r\n * @private\r\n * @param {Object}  object\r\n * @param {number=} spaces\r\n * @param {number=} depth\r\n * @returns {*}\r\n */\r\nfunction jsonStringify(object, spaces, depth) {\r\n  if (typeof spaces === 'undefined') {\r\n    // primitive types\r\n    return _stringify(object);\r\n  }\r\n\r\n  depth = depth || 1;\r\n  var space = spaces * depth;\r\n  var str = Array.isArray(object) ? '[' : '{';\r\n  var end = Array.isArray(object) ? ']' : '}';\r\n  var length =\r\n    typeof object.length === 'number'\r\n      ? object.length\r\n      : Object.keys(object).length;\r\n  // `.repeat()` polyfill\r\n  function repeat(s, n) {\r\n    return new Array(n).join(s);\r\n  }\r\n\r\n  function _stringify(val) {\r\n    switch (type(val)) {\r\n      case 'null':\r\n      case 'undefined':\r\n        val = '[' + val + ']';\r\n        break;\r\n      case 'array':\r\n      case 'object':\r\n        val = jsonStringify(val, spaces, depth + 1);\r\n        break;\r\n      case 'boolean':\r\n      case 'regexp':\r\n      case 'symbol':\r\n      case 'number':\r\n        val =\r\n          val === 0 && 1 / val === -Infinity // `-0`\r\n            ? '-0'\r\n            : val.toString();\r\n        break;\r\n      case 'date':\r\n        var sDate = isNaN(val.getTime()) ? val.toString() : val.toISOString();\r\n        val = '[Date: ' + sDate + ']';\r\n        break;\r\n      case 'buffer':\r\n        var json = val.toJSON();\r\n        // Based on the toJSON result\r\n        json = json.data && json.type ? json.data : json;\r\n        val = '[Buffer: ' + jsonStringify(json, 2, depth + 1) + ']';\r\n        break;\r\n      default:\r\n        val =\r\n          val === '[Function]' || val === '[Circular]'\r\n            ? val\r\n            : JSON.stringify(val); // string\r\n    }\r\n    return val;\r\n  }\r\n\r\n  for (var i in object) {\r\n    if (!Object.prototype.hasOwnProperty.call(object, i)) {\r\n      continue; // not my business\r\n    }\r\n    --length;\r\n    str +=\r\n      '\\n ' +\r\n      repeat(' ', space) +\r\n      (Array.isArray(object) ? '' : '\"' + i + '\": ') + // key\r\n      _stringify(object[i]) + // value\r\n      (length ? ',' : ''); // comma\r\n  }\r\n\r\n  return (\r\n    str +\r\n    // [], {}\r\n    (str.length !== 1 ? '\\n' + repeat(' ', --space) + end : end)\r\n  );\r\n}\r\n\r\n/**\r\n * Return a new Thing that has the keys in sorted order. Recursive.\r\n *\r\n * If the Thing...\r\n * - has already been seen, return string `'[Circular]'`\r\n * - is `undefined`, return string `'[undefined]'`\r\n * - is `null`, return value `null`\r\n * - is some other primitive, return the value\r\n * - is not a primitive or an `Array`, `Object`, or `Function`, return the value of the Thing's `toString()` method\r\n * - is a non-empty `Array`, `Object`, or `Function`, return the result of calling this function again.\r\n * - is an empty `Array`, `Object`, or `Function`, return the result of calling `emptyRepresentation()`\r\n *\r\n * @private\r\n * @see {@link exports.stringify}\r\n * @param {*} value Thing to inspect.  May or may not have properties.\r\n * @param {Array} [stack=[]] Stack of seen values\r\n * @param {string} [typeHint] Type hint\r\n * @return {(Object|Array|Function|string|undefined)}\r\n */\r\nexports.canonicalize = function canonicalize(value, stack, typeHint) {\r\n  var canonicalizedObj;\r\n  /* eslint-disable no-unused-vars */\r\n  var prop;\r\n  /* eslint-enable no-unused-vars */\r\n  typeHint = typeHint || type(value);\r\n  function withStack(value, fn) {\r\n    stack.push(value);\r\n    fn();\r\n    stack.pop();\r\n  }\r\n\r\n  stack = stack || [];\r\n\r\n  if (stack.indexOf(value) !== -1) {\r\n    return '[Circular]';\r\n  }\r\n\r\n  switch (typeHint) {\r\n    case 'undefined':\r\n    case 'buffer':\r\n    case 'null':\r\n      canonicalizedObj = value;\r\n      break;\r\n    case 'array':\r\n      withStack(value, function() {\r\n        canonicalizedObj = value.map(function(item) {\r\n          return exports.canonicalize(item, stack);\r\n        });\r\n      });\r\n      break;\r\n    case 'function':\r\n      /* eslint-disable guard-for-in */\r\n      for (prop in value) {\r\n        canonicalizedObj = {};\r\n        break;\r\n      }\r\n      /* eslint-enable guard-for-in */\r\n      if (!canonicalizedObj) {\r\n        canonicalizedObj = emptyRepresentation(value, typeHint);\r\n        break;\r\n      }\r\n    /* falls through */\r\n    case 'object':\r\n      canonicalizedObj = canonicalizedObj || {};\r\n      withStack(value, function() {\r\n        Object.keys(value)\r\n          .sort()\r\n          .forEach(function(key) {\r\n            canonicalizedObj[key] = exports.canonicalize(value[key], stack);\r\n          });\r\n      });\r\n      break;\r\n    case 'date':\r\n    case 'number':\r\n    case 'regexp':\r\n    case 'boolean':\r\n    case 'symbol':\r\n      canonicalizedObj = value;\r\n      break;\r\n    default:\r\n      canonicalizedObj = value + '';\r\n  }\r\n\r\n  return canonicalizedObj;\r\n};\r\n\r\n/**\r\n * Determines if pathname has a matching file extension.\r\n *\r\n * @private\r\n * @param {string} pathname - Pathname to check for match.\r\n * @param {string[]} exts - List of file extensions (sans period).\r\n * @return {boolean} whether file extension matches.\r\n * @example\r\n * hasMatchingExtname('foo.html', ['js', 'css']); // => false\r\n */\r\nfunction hasMatchingExtname(pathname, exts) {\r\n  var suffix = path.extname(pathname).slice(1);\r\n  return exts.some(function(element) {\r\n    return suffix === element;\r\n  });\r\n}\r\n\r\n/**\r\n * Determines if pathname would be a \"hidden\" file (or directory) on UN*X.\r\n *\r\n * @description\r\n * On UN*X, pathnames beginning with a full stop (aka dot) are hidden during\r\n * typical usage. Dotfiles, plain-text configuration files, are prime examples.\r\n *\r\n * @see {@link http://xahlee.info/UnixResource_dir/writ/unix_origin_of_dot_filename.html|Origin of Dot File Names}\r\n *\r\n * @private\r\n * @param {string} pathname - Pathname to check for match.\r\n * @return {boolean} whether pathname would be considered a hidden file.\r\n * @example\r\n * isHiddenOnUnix('.profile'); // => true\r\n */\r\nfunction isHiddenOnUnix(pathname) {\r\n  return path.basename(pathname)[0] === '.';\r\n}\r\n\r\n/**\r\n * Lookup file names at the given `path`.\r\n *\r\n * @description\r\n * Filenames are returned in _traversal_ order by the OS/filesystem.\r\n * **Make no assumption that the names will be sorted in any fashion.**\r\n *\r\n * @public\r\n * @memberof Mocha.utils\r\n * @param {string} filepath - Base path to start searching from.\r\n * @param {string[]} [extensions=[]] - File extensions to look for.\r\n * @param {boolean} [recursive=false] - Whether to recurse into subdirectories.\r\n * @return {string[]} An array of paths.\r\n * @throws {Error} if no files match pattern.\r\n * @throws {TypeError} if `filepath` is directory and `extensions` not provided.\r\n */\r\nexports.lookupFiles = function lookupFiles(filepath, extensions, recursive) {\r\n  extensions = extensions || [];\r\n  recursive = recursive || false;\r\n  var files = [];\r\n  var stat;\r\n\r\n  if (!fs.existsSync(filepath)) {\r\n    var pattern;\r\n    if (glob.hasMagic(filepath)) {\r\n      // Handle glob as is without extensions\r\n      pattern = filepath;\r\n    } else {\r\n      // glob pattern e.g. 'filepath+(.js|.ts)'\r\n      var strExtensions = extensions\r\n        .map(function(v) {\r\n          return '.' + v;\r\n        })\r\n        .join('|');\r\n      pattern = filepath + '+(' + strExtensions + ')';\r\n    }\r\n    files = glob.sync(pattern, {nodir: true});\r\n    if (!files.length) {\r\n      throw createNoFilesMatchPatternError(\r\n        'Cannot find any files matching pattern ' + exports.dQuote(filepath),\r\n        filepath\r\n      );\r\n    }\r\n    return files;\r\n  }\r\n\r\n  // Handle file\r\n  try {\r\n    stat = fs.statSync(filepath);\r\n    if (stat.isFile()) {\r\n      return filepath;\r\n    }\r\n  } catch (err) {\r\n    // ignore error\r\n    return;\r\n  }\r\n\r\n  // Handle directory\r\n  fs.readdirSync(filepath).forEach(function(dirent) {\r\n    var pathname = path.join(filepath, dirent);\r\n    var stat;\r\n\r\n    try {\r\n      stat = fs.statSync(pathname);\r\n      if (stat.isDirectory()) {\r\n        if (recursive) {\r\n          files = files.concat(lookupFiles(pathname, extensions, recursive));\r\n        }\r\n        return;\r\n      }\r\n    } catch (err) {\r\n      // ignore error\r\n      return;\r\n    }\r\n    if (!extensions.length) {\r\n      throw createMissingArgumentError(\r\n        util.format(\r\n          'Argument %s required when argument %s is a directory',\r\n          exports.sQuote('extensions'),\r\n          exports.sQuote('filepath')\r\n        ),\r\n        'extensions',\r\n        'array'\r\n      );\r\n    }\r\n\r\n    if (\r\n      !stat.isFile() ||\r\n      !hasMatchingExtname(pathname, extensions) ||\r\n      isHiddenOnUnix(pathname)\r\n    ) {\r\n      return;\r\n    }\r\n    files.push(pathname);\r\n  });\r\n\r\n  return files;\r\n};\r\n\r\n/**\r\n * process.emitWarning or a polyfill\r\n * @see https://nodejs.org/api/process.html#process_process_emitwarning_warning_options\r\n * @ignore\r\n */\r\nfunction emitWarning(msg, type) {\r\n  if (process.emitWarning) {\r\n    process.emitWarning(msg, type);\r\n  } else {\r\n    process.nextTick(function() {\r\n      console.warn(type + ': ' + msg);\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Show a deprecation warning. Each distinct message is only displayed once.\r\n * Ignores empty messages.\r\n *\r\n * @param {string} [msg] - Warning to print\r\n * @private\r\n */\r\nexports.deprecate = function deprecate(msg) {\r\n  msg = String(msg);\r\n  if (msg && !deprecate.cache[msg]) {\r\n    deprecate.cache[msg] = true;\r\n    emitWarning(msg, 'DeprecationWarning');\r\n  }\r\n};\r\nexports.deprecate.cache = {};\r\n\r\n/**\r\n * Show a generic warning.\r\n * Ignores empty messages.\r\n *\r\n * @param {string} [msg] - Warning to print\r\n * @private\r\n */\r\nexports.warn = function warn(msg) {\r\n  if (msg) {\r\n    emitWarning(msg);\r\n  }\r\n};\r\n\r\n/**\r\n * @summary\r\n * This Filter based on `mocha-clean` module.(see: `github.com/rstacruz/mocha-clean`)\r\n * @description\r\n * When invoking this function you get a filter function that get the Error.stack as an input,\r\n * and return a prettify output.\r\n * (i.e: strip Mocha and internal node functions from stack trace).\r\n * @returns {Function}\r\n */\r\nexports.stackTraceFilter = function() {\r\n  // TODO: Replace with `process.browser`\r\n  var is = typeof document === 'undefined' ? {node: true} : {browser: true};\r\n  var slash = path.sep;\r\n  var cwd;\r\n  if (is.node) {\r\n    cwd = exports.cwd() + slash;\r\n  } else {\r\n    cwd = (typeof location === 'undefined'\r\n      ? window.location\r\n      : location\r\n    ).href.replace(/\\/[^/]*$/, '/');\r\n    slash = '/';\r\n  }\r\n\r\n  function isMochaInternal(line) {\r\n    return (\r\n      ~line.indexOf('node_modules' + slash + 'mocha' + slash) ||\r\n      ~line.indexOf(slash + 'mocha.js') ||\r\n      ~line.indexOf(slash + 'mocha.min.js')\r\n    );\r\n  }\r\n\r\n  function isNodeInternal(line) {\r\n    return (\r\n      ~line.indexOf('(timers.js:') ||\r\n      ~line.indexOf('(events.js:') ||\r\n      ~line.indexOf('(node.js:') ||\r\n      ~line.indexOf('(module.js:') ||\r\n      ~line.indexOf('GeneratorFunctionPrototype.next (native)') ||\r\n      false\r\n    );\r\n  }\r\n\r\n  return function(stack) {\r\n    stack = stack.split('\\n');\r\n\r\n    stack = stack.reduce(function(list, line) {\r\n      if (isMochaInternal(line)) {\r\n        return list;\r\n      }\r\n\r\n      if (is.node && isNodeInternal(line)) {\r\n        return list;\r\n      }\r\n\r\n      // Clean up cwd(absolute)\r\n      if (/:\\d+:\\d+\\)?$/.test(line)) {\r\n        line = line.replace('(' + cwd, '(');\r\n      }\r\n\r\n      list.push(line);\r\n      return list;\r\n    }, []);\r\n\r\n    return stack.join('\\n');\r\n  };\r\n};\r\n\r\n/**\r\n * Crude, but effective.\r\n * @public\r\n * @param {*} value\r\n * @returns {boolean} Whether or not `value` is a Promise\r\n */\r\nexports.isPromise = function isPromise(value) {\r\n  return (\r\n    typeof value === 'object' &&\r\n    value !== null &&\r\n    typeof value.then === 'function'\r\n  );\r\n};\r\n\r\n/**\r\n * Clamps a numeric value to an inclusive range.\r\n *\r\n * @param {number} value - Value to be clamped.\r\n * @param {numer[]} range - Two element array specifying [min, max] range.\r\n * @returns {number} clamped value\r\n */\r\nexports.clamp = function clamp(value, range) {\r\n  return Math.min(Math.max(value, range[0]), range[1]);\r\n};\r\n\r\n/**\r\n * Single quote text by combining with undirectional ASCII quotation marks.\r\n *\r\n * @description\r\n * Provides a simple means of markup for quoting text to be used in output.\r\n * Use this to quote names of variables, methods, and packages.\r\n *\r\n * <samp>package 'foo' cannot be found</samp>\r\n *\r\n * @private\r\n * @param {string} str - Value to be quoted.\r\n * @returns {string} quoted value\r\n * @example\r\n * sQuote('n') // => 'n'\r\n */\r\nexports.sQuote = function(str) {\r\n  return \"'\" + str + \"'\";\r\n};\r\n\r\n/**\r\n * Double quote text by combining with undirectional ASCII quotation marks.\r\n *\r\n * @description\r\n * Provides a simple means of markup for quoting text to be used in output.\r\n * Use this to quote names of datatypes, classes, pathnames, and strings.\r\n *\r\n * <samp>argument 'value' must be \"string\" or \"number\"</samp>\r\n *\r\n * @private\r\n * @param {string} str - Value to be quoted.\r\n * @returns {string} quoted value\r\n * @example\r\n * dQuote('number') // => \"number\"\r\n */\r\nexports.dQuote = function(str) {\r\n  return '\"' + str + '\"';\r\n};\r\n\r\n/**\r\n * It's a noop.\r\n * @public\r\n */\r\nexports.noop = function() {};\r\n\r\n/**\r\n * Creates a map-like object.\r\n *\r\n * @description\r\n * A \"map\" is an object with no prototype, for our purposes. In some cases\r\n * this would be more appropriate than a `Map`, especially if your environment\r\n * doesn't support it. Recommended for use in Mocha's public APIs.\r\n *\r\n * @public\r\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map|MDN:Map}\r\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create#Custom_and_Null_objects|MDN:Object.create - Custom objects}\r\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign|MDN:Object.assign}\r\n * @param {...*} [obj] - Arguments to `Object.assign()`.\r\n * @returns {Object} An object with no prototype, having `...obj` properties\r\n */\r\nexports.createMap = function(obj) {\r\n  return assign.apply(\r\n    null,\r\n    [Object.create(null)].concat(Array.prototype.slice.call(arguments))\r\n  );\r\n};\r\n\r\n/**\r\n * Creates a read-only map-like object.\r\n *\r\n * @description\r\n * This differs from {@link module:utils.createMap createMap} only in that\r\n * the argument must be non-empty, because the result is frozen.\r\n *\r\n * @see {@link module:utils.createMap createMap}\r\n * @param {...*} [obj] - Arguments to `Object.assign()`.\r\n * @returns {Object} A frozen object with no prototype, having `...obj` properties\r\n * @throws {TypeError} if argument is not a non-empty object.\r\n */\r\nexports.defineConstants = function(obj) {\r\n  if (type(obj) !== 'object' || !Object.keys(obj).length) {\r\n    throw new TypeError('Invalid argument; expected a non-empty object');\r\n  }\r\n  return Object.freeze(exports.createMap(obj));\r\n};\r\n\r\n/**\r\n * Whether current version of Node support ES modules\r\n *\r\n * @description\r\n * Versions prior to 10 did not support ES Modules, and version 10 has an old incompatibile version of ESM.\r\n * This function returns whether Node.JS has ES Module supports that is compatible with Mocha's needs,\r\n * which is version >=12.11.\r\n *\r\n * @returns {Boolean} whether the current version of Node.JS supports ES Modules in a way that is compatible with Mocha\r\n */\r\nexports.supportsEsModules = function() {\r\n  if (!process.browser && process.versions && process.versions.node) {\r\n    var versionFields = process.versions.node.split('.');\r\n    var major = +versionFields[0];\r\n    var minor = +versionFields[1];\r\n\r\n    if (major >= 13 || (major === 12 && minor >= 11)) {\r\n      return true;\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Returns current working directory\r\n *\r\n * Wrapper around `process.cwd()` for isolation\r\n * @private\r\n */\r\nexports.cwd = function cwd() {\r\n  return process.cwd();\r\n};\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer, __webpack_require__(/*! ./../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/mocha/lib/utils.js?");

/***/ }),

/***/ "./node_modules/mocha/node_modules/debug/src/browser.js":
/*!**************************************************************!*\
  !*** ./node_modules/mocha/node_modules/debug/src/browser.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\r\n\r\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\r\n\r\n/* eslint-env browser */\r\n\r\n/**\r\n * This is the web browser implementation of `debug()`.\r\n */\r\nexports.log = log;\r\nexports.formatArgs = formatArgs;\r\nexports.save = save;\r\nexports.load = load;\r\nexports.useColors = useColors;\r\nexports.storage = localstorage();\r\n/**\r\n * Colors.\r\n */\r\n\r\nexports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];\r\n/**\r\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\r\n * and the Firebug extension (any Firefox version) are known\r\n * to support \"%c\" CSS customizations.\r\n *\r\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\r\n */\r\n// eslint-disable-next-line complexity\r\n\r\nfunction useColors() {\r\n  // NB: In an Electron preload script, document will be defined but not fully\r\n  // initialized. Since we know we're in Chrome, we'll just detect this case\r\n  // explicitly\r\n  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\r\n    return true;\r\n  } // Internet Explorer and Edge do not support colors.\r\n\r\n\r\n  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\r\n    return false;\r\n  } // Is webkit? http://stackoverflow.com/a/16459606/376773\r\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\r\n\r\n\r\n  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773\r\n  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?\r\n  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\r\n  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker\r\n  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\r\n}\r\n/**\r\n * Colorize log arguments if enabled.\r\n *\r\n * @api public\r\n */\r\n\r\n\r\nfunction formatArgs(args) {\r\n  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);\r\n\r\n  if (!this.useColors) {\r\n    return;\r\n  }\r\n\r\n  var c = 'color: ' + this.color;\r\n  args.splice(1, 0, c, 'color: inherit'); // The final \"%c\" is somewhat tricky, because there could be other\r\n  // arguments passed either before or after the %c, so we need to\r\n  // figure out the correct index to insert the CSS into\r\n\r\n  var index = 0;\r\n  var lastC = 0;\r\n  args[0].replace(/%[a-zA-Z%]/g, function (match) {\r\n    if (match === '%%') {\r\n      return;\r\n    }\r\n\r\n    index++;\r\n\r\n    if (match === '%c') {\r\n      // We only are interested in the *last* %c\r\n      // (the user may have provided their own)\r\n      lastC = index;\r\n    }\r\n  });\r\n  args.splice(lastC, 0, c);\r\n}\r\n/**\r\n * Invokes `console.log()` when available.\r\n * No-op when `console.log` is not a \"function\".\r\n *\r\n * @api public\r\n */\r\n\r\n\r\nfunction log() {\r\n  var _console;\r\n\r\n  // This hackery is required for IE8/9, where\r\n  // the `console.log` function doesn't have 'apply'\r\n  return (typeof console === \"undefined\" ? \"undefined\" : _typeof(console)) === 'object' && console.log && (_console = console).log.apply(_console, arguments);\r\n}\r\n/**\r\n * Save `namespaces`.\r\n *\r\n * @param {String} namespaces\r\n * @api private\r\n */\r\n\r\n\r\nfunction save(namespaces) {\r\n  try {\r\n    if (namespaces) {\r\n      exports.storage.setItem('debug', namespaces);\r\n    } else {\r\n      exports.storage.removeItem('debug');\r\n    }\r\n  } catch (error) {// Swallow\r\n    // XXX (@Qix-) should we be logging these?\r\n  }\r\n}\r\n/**\r\n * Load `namespaces`.\r\n *\r\n * @return {String} returns the previously persisted debug modes\r\n * @api private\r\n */\r\n\r\n\r\nfunction load() {\r\n  var r;\r\n\r\n  try {\r\n    r = exports.storage.getItem('debug');\r\n  } catch (error) {} // Swallow\r\n  // XXX (@Qix-) should we be logging these?\r\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\r\n\r\n\r\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\r\n    r = process.env.DEBUG;\r\n  }\r\n\r\n  return r;\r\n}\r\n/**\r\n * Localstorage attempts to return the localstorage.\r\n *\r\n * This is necessary because safari throws\r\n * when a user disables cookies/localstorage\r\n * and you attempt to access it.\r\n *\r\n * @return {LocalStorage}\r\n * @api private\r\n */\r\n\r\n\r\nfunction localstorage() {\r\n  try {\r\n    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\r\n    // The Browser also has localStorage in the global context.\r\n    return localStorage;\r\n  } catch (error) {// Swallow\r\n    // XXX (@Qix-) should we be logging these?\r\n  }\r\n}\r\n\r\nmodule.exports = __webpack_require__(/*! ./common */ \"./node_modules/mocha/node_modules/debug/src/common.js\")(exports);\r\nvar formatters = module.exports.formatters;\r\n/**\r\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\r\n */\r\n\r\nformatters.j = function (v) {\r\n  try {\r\n    return JSON.stringify(v);\r\n  } catch (error) {\r\n    return '[UnexpectedJSONParseError]: ' + error.message;\r\n  }\r\n};\r\n\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/mocha/node_modules/debug/src/browser.js?");

/***/ }),

/***/ "./node_modules/mocha/node_modules/debug/src/common.js":
/*!*************************************************************!*\
  !*** ./node_modules/mocha/node_modules/debug/src/common.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\n/**\r\n * This is the common logic for both the Node.js and web browser\r\n * implementations of `debug()`.\r\n */\r\nfunction setup(env) {\r\n  createDebug.debug = createDebug;\r\n  createDebug.default = createDebug;\r\n  createDebug.coerce = coerce;\r\n  createDebug.disable = disable;\r\n  createDebug.enable = enable;\r\n  createDebug.enabled = enabled;\r\n  createDebug.humanize = __webpack_require__(/*! ms */ \"./node_modules/mocha/node_modules/ms/index.js\");\r\n  Object.keys(env).forEach(function (key) {\r\n    createDebug[key] = env[key];\r\n  });\r\n  /**\r\n  * Active `debug` instances.\r\n  */\r\n\r\n  createDebug.instances = [];\r\n  /**\r\n  * The currently active debug mode names, and names to skip.\r\n  */\r\n\r\n  createDebug.names = [];\r\n  createDebug.skips = [];\r\n  /**\r\n  * Map of special \"%n\" handling functions, for the debug \"format\" argument.\r\n  *\r\n  * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\r\n  */\r\n\r\n  createDebug.formatters = {};\r\n  /**\r\n  * Selects a color for a debug namespace\r\n  * @param {String} namespace The namespace string for the for the debug instance to be colored\r\n  * @return {Number|String} An ANSI color code for the given namespace\r\n  * @api private\r\n  */\r\n\r\n  function selectColor(namespace) {\r\n    var hash = 0;\r\n\r\n    for (var i = 0; i < namespace.length; i++) {\r\n      hash = (hash << 5) - hash + namespace.charCodeAt(i);\r\n      hash |= 0; // Convert to 32bit integer\r\n    }\r\n\r\n    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];\r\n  }\r\n\r\n  createDebug.selectColor = selectColor;\r\n  /**\r\n  * Create a debugger with the given `namespace`.\r\n  *\r\n  * @param {String} namespace\r\n  * @return {Function}\r\n  * @api public\r\n  */\r\n\r\n  function createDebug(namespace) {\r\n    var prevTime;\r\n\r\n    function debug() {\r\n      // Disabled?\r\n      if (!debug.enabled) {\r\n        return;\r\n      }\r\n\r\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\r\n        args[_key] = arguments[_key];\r\n      }\r\n\r\n      var self = debug; // Set `diff` timestamp\r\n\r\n      var curr = Number(new Date());\r\n      var ms = curr - (prevTime || curr);\r\n      self.diff = ms;\r\n      self.prev = prevTime;\r\n      self.curr = curr;\r\n      prevTime = curr;\r\n      args[0] = createDebug.coerce(args[0]);\r\n\r\n      if (typeof args[0] !== 'string') {\r\n        // Anything else let's inspect with %O\r\n        args.unshift('%O');\r\n      } // Apply any `formatters` transformations\r\n\r\n\r\n      var index = 0;\r\n      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {\r\n        // If we encounter an escaped % then don't increase the array index\r\n        if (match === '%%') {\r\n          return match;\r\n        }\r\n\r\n        index++;\r\n        var formatter = createDebug.formatters[format];\r\n\r\n        if (typeof formatter === 'function') {\r\n          var val = args[index];\r\n          match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`\r\n\r\n          args.splice(index, 1);\r\n          index--;\r\n        }\r\n\r\n        return match;\r\n      }); // Apply env-specific formatting (colors, etc.)\r\n\r\n      createDebug.formatArgs.call(self, args);\r\n      var logFn = self.log || createDebug.log;\r\n      logFn.apply(self, args);\r\n    }\r\n\r\n    debug.namespace = namespace;\r\n    debug.enabled = createDebug.enabled(namespace);\r\n    debug.useColors = createDebug.useColors();\r\n    debug.color = selectColor(namespace);\r\n    debug.destroy = destroy;\r\n    debug.extend = extend; // Debug.formatArgs = formatArgs;\r\n    // debug.rawLog = rawLog;\r\n    // env-specific initialization logic for debug instances\r\n\r\n    if (typeof createDebug.init === 'function') {\r\n      createDebug.init(debug);\r\n    }\r\n\r\n    createDebug.instances.push(debug);\r\n    return debug;\r\n  }\r\n\r\n  function destroy() {\r\n    var index = createDebug.instances.indexOf(this);\r\n\r\n    if (index !== -1) {\r\n      createDebug.instances.splice(index, 1);\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  function extend(namespace, delimiter) {\r\n    return createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\r\n  }\r\n  /**\r\n  * Enables a debug mode by namespaces. This can include modes\r\n  * separated by a colon and wildcards.\r\n  *\r\n  * @param {String} namespaces\r\n  * @api public\r\n  */\r\n\r\n\r\n  function enable(namespaces) {\r\n    createDebug.save(namespaces);\r\n    createDebug.names = [];\r\n    createDebug.skips = [];\r\n    var i;\r\n    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\r\n    var len = split.length;\r\n\r\n    for (i = 0; i < len; i++) {\r\n      if (!split[i]) {\r\n        // ignore empty strings\r\n        continue;\r\n      }\r\n\r\n      namespaces = split[i].replace(/\\*/g, '.*?');\r\n\r\n      if (namespaces[0] === '-') {\r\n        createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\r\n      } else {\r\n        createDebug.names.push(new RegExp('^' + namespaces + '$'));\r\n      }\r\n    }\r\n\r\n    for (i = 0; i < createDebug.instances.length; i++) {\r\n      var instance = createDebug.instances[i];\r\n      instance.enabled = createDebug.enabled(instance.namespace);\r\n    }\r\n  }\r\n  /**\r\n  * Disable debug output.\r\n  *\r\n  * @api public\r\n  */\r\n\r\n\r\n  function disable() {\r\n    createDebug.enable('');\r\n  }\r\n  /**\r\n  * Returns true if the given mode name is enabled, false otherwise.\r\n  *\r\n  * @param {String} name\r\n  * @return {Boolean}\r\n  * @api public\r\n  */\r\n\r\n\r\n  function enabled(name) {\r\n    if (name[name.length - 1] === '*') {\r\n      return true;\r\n    }\r\n\r\n    var i;\r\n    var len;\r\n\r\n    for (i = 0, len = createDebug.skips.length; i < len; i++) {\r\n      if (createDebug.skips[i].test(name)) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    for (i = 0, len = createDebug.names.length; i < len; i++) {\r\n      if (createDebug.names[i].test(name)) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n  /**\r\n  * Coerce `val`.\r\n  *\r\n  * @param {Mixed} val\r\n  * @return {Mixed}\r\n  * @api private\r\n  */\r\n\r\n\r\n  function coerce(val) {\r\n    if (val instanceof Error) {\r\n      return val.stack || val.message;\r\n    }\r\n\r\n    return val;\r\n  }\r\n\r\n  createDebug.enable(createDebug.load());\r\n  return createDebug;\r\n}\r\n\r\nmodule.exports = setup;\r\n\r\n\n\n//# sourceURL=webpack:///./node_modules/mocha/node_modules/debug/src/common.js?");

/***/ }),

/***/ "./node_modules/mocha/node_modules/ms/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/mocha/node_modules/ms/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * Helpers.\r\n */\r\n\r\nvar s = 1000;\r\nvar m = s * 60;\r\nvar h = m * 60;\r\nvar d = h * 24;\r\nvar w = d * 7;\r\nvar y = d * 365.25;\r\n\r\n/**\r\n * Parse or format the given `val`.\r\n *\r\n * Options:\r\n *\r\n *  - `long` verbose formatting [false]\r\n *\r\n * @param {String|Number} val\r\n * @param {Object} [options]\r\n * @throws {Error} throw an error if val is not a non-empty string or a number\r\n * @return {String|Number}\r\n * @api public\r\n */\r\n\r\nmodule.exports = function(val, options) {\r\n  options = options || {};\r\n  var type = typeof val;\r\n  if (type === 'string' && val.length > 0) {\r\n    return parse(val);\r\n  } else if (type === 'number' && isNaN(val) === false) {\r\n    return options.long ? fmtLong(val) : fmtShort(val);\r\n  }\r\n  throw new Error(\r\n    'val is not a non-empty string or a valid number. val=' +\r\n      JSON.stringify(val)\r\n  );\r\n};\r\n\r\n/**\r\n * Parse the given `str` and return milliseconds.\r\n *\r\n * @param {String} str\r\n * @return {Number}\r\n * @api private\r\n */\r\n\r\nfunction parse(str) {\r\n  str = String(str);\r\n  if (str.length > 100) {\r\n    return;\r\n  }\r\n  var match = /^((?:\\d+)?\\-?\\d?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\r\n    str\r\n  );\r\n  if (!match) {\r\n    return;\r\n  }\r\n  var n = parseFloat(match[1]);\r\n  var type = (match[2] || 'ms').toLowerCase();\r\n  switch (type) {\r\n    case 'years':\r\n    case 'year':\r\n    case 'yrs':\r\n    case 'yr':\r\n    case 'y':\r\n      return n * y;\r\n    case 'weeks':\r\n    case 'week':\r\n    case 'w':\r\n      return n * w;\r\n    case 'days':\r\n    case 'day':\r\n    case 'd':\r\n      return n * d;\r\n    case 'hours':\r\n    case 'hour':\r\n    case 'hrs':\r\n    case 'hr':\r\n    case 'h':\r\n      return n * h;\r\n    case 'minutes':\r\n    case 'minute':\r\n    case 'mins':\r\n    case 'min':\r\n    case 'm':\r\n      return n * m;\r\n    case 'seconds':\r\n    case 'second':\r\n    case 'secs':\r\n    case 'sec':\r\n    case 's':\r\n      return n * s;\r\n    case 'milliseconds':\r\n    case 'millisecond':\r\n    case 'msecs':\r\n    case 'msec':\r\n    case 'ms':\r\n      return n;\r\n    default:\r\n      return undefined;\r\n  }\r\n}\r\n\r\n/**\r\n * Short format for `ms`.\r\n *\r\n * @param {Number} ms\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nfunction fmtShort(ms) {\r\n  var msAbs = Math.abs(ms);\r\n  if (msAbs >= d) {\r\n    return Math.round(ms / d) + 'd';\r\n  }\r\n  if (msAbs >= h) {\r\n    return Math.round(ms / h) + 'h';\r\n  }\r\n  if (msAbs >= m) {\r\n    return Math.round(ms / m) + 'm';\r\n  }\r\n  if (msAbs >= s) {\r\n    return Math.round(ms / s) + 's';\r\n  }\r\n  return ms + 'ms';\r\n}\r\n\r\n/**\r\n * Long format for `ms`.\r\n *\r\n * @param {Number} ms\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nfunction fmtLong(ms) {\r\n  var msAbs = Math.abs(ms);\r\n  if (msAbs >= d) {\r\n    return plural(ms, msAbs, d, 'day');\r\n  }\r\n  if (msAbs >= h) {\r\n    return plural(ms, msAbs, h, 'hour');\r\n  }\r\n  if (msAbs >= m) {\r\n    return plural(ms, msAbs, m, 'minute');\r\n  }\r\n  if (msAbs >= s) {\r\n    return plural(ms, msAbs, s, 'second');\r\n  }\r\n  return ms + ' ms';\r\n}\r\n\r\n/**\r\n * Pluralization helper.\r\n */\r\n\r\nfunction plural(ms, msAbs, n, name) {\r\n  var isPlural = msAbs >= n * 1.5;\r\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/mocha/node_modules/ms/index.js?");

/***/ }),

/***/ "./node_modules/mocha/package.json":
/*!*****************************************!*\
  !*** ./node_modules/mocha/package.json ***!
  \*****************************************/
/*! exports provided: _from, _id, _inBundle, _integrity, _location, _phantomChildren, _requested, _requiredBy, _resolved, _shasum, _spec, _where, author, bin, browser, browserify, bugs, bundleDependencies, dependencies, deprecated, description, devDependencies, directories, engines, files, funding, gitter, homepage, husky, keywords, license, logo, name, notifyLogo, prettier, repository, scripts, version, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"_from\\\":\\\"mocha\\\",\\\"_id\\\":\\\"mocha@7.2.0\\\",\\\"_inBundle\\\":false,\\\"_integrity\\\":\\\"sha512-O9CIypScywTVpNaRrCAgoUnJgozpIofjKUYmJhiCIJMiuYnLI6otcb1/kpW9/n/tJODHGZ7i8aLQoDVsMtOKQQ==\\\",\\\"_location\\\":\\\"/mocha\\\",\\\"_phantomChildren\\\":{\\\"anymatch\\\":\\\"3.1.1\\\",\\\"braces\\\":\\\"3.0.2\\\",\\\"cliui\\\":\\\"5.0.0\\\",\\\"find-up\\\":\\\"3.0.0\\\",\\\"fs.realpath\\\":\\\"1.0.0\\\",\\\"fsevents\\\":\\\"2.1.3\\\",\\\"get-caller-file\\\":\\\"2.0.5\\\",\\\"glob-parent\\\":\\\"5.1.1\\\",\\\"has-flag\\\":\\\"3.0.0\\\",\\\"inflight\\\":\\\"1.0.6\\\",\\\"inherits\\\":\\\"2.0.4\\\",\\\"is-binary-path\\\":\\\"2.1.0\\\",\\\"is-glob\\\":\\\"4.0.1\\\",\\\"minimatch\\\":\\\"3.0.4\\\",\\\"normalize-path\\\":\\\"3.0.0\\\",\\\"once\\\":\\\"1.4.0\\\",\\\"path-is-absolute\\\":\\\"1.0.1\\\",\\\"picomatch\\\":\\\"2.2.2\\\",\\\"require-directory\\\":\\\"2.1.1\\\",\\\"require-main-filename\\\":\\\"2.0.0\\\",\\\"set-blocking\\\":\\\"2.0.0\\\",\\\"string-width\\\":\\\"3.1.0\\\",\\\"which-module\\\":\\\"2.0.0\\\",\\\"y18n\\\":\\\"4.0.0\\\",\\\"yargs-parser\\\":\\\"13.1.2\\\"},\\\"_requested\\\":{\\\"type\\\":\\\"tag\\\",\\\"registry\\\":true,\\\"raw\\\":\\\"mocha\\\",\\\"name\\\":\\\"mocha\\\",\\\"escapedName\\\":\\\"mocha\\\",\\\"rawSpec\\\":\\\"\\\",\\\"saveSpec\\\":null,\\\"fetchSpec\\\":\\\"latest\\\"},\\\"_requiredBy\\\":[\\\"#DEV:/\\\",\\\"#USER\\\"],\\\"_resolved\\\":\\\"https://registry.npmjs.org/mocha/-/mocha-7.2.0.tgz\\\",\\\"_shasum\\\":\\\"01cc227b00d875ab1eed03a75106689cfed5a604\\\",\\\"_spec\\\":\\\"mocha\\\",\\\"_where\\\":\\\"C:\\\\\\\\Users\\\\\\\\Sub\\\\\\\\Documents\\\\\\\\GitHub\\\\\\\\CommunicationRobot\\\",\\\"author\\\":{\\\"name\\\":\\\"TJ Holowaychuk\\\",\\\"email\\\":\\\"tj@vision-media.ca\\\"},\\\"bin\\\":{\\\"mocha\\\":\\\"bin/mocha\\\",\\\"_mocha\\\":\\\"bin/_mocha\\\"},\\\"browser\\\":{\\\"./index.js\\\":\\\"./browser-entry.js\\\",\\\"./lib/growl.js\\\":\\\"./lib/browser/growl.js\\\",\\\"tty\\\":\\\"./lib/browser/tty.js\\\",\\\"./lib/cli/*.js\\\":false,\\\"chokidar\\\":false,\\\"fs\\\":false,\\\"glob\\\":false,\\\"path\\\":false,\\\"supports-color\\\":false},\\\"browserify\\\":{\\\"transform\\\":[\\\"./scripts/package-json-cullify\\\"]},\\\"bugs\\\":{\\\"url\\\":\\\"https://github.com/mochajs/mocha/issues/\\\"},\\\"bundleDependencies\\\":false,\\\"dependencies\\\":{\\\"ansi-colors\\\":\\\"3.2.3\\\",\\\"browser-stdout\\\":\\\"1.3.1\\\",\\\"chokidar\\\":\\\"3.3.0\\\",\\\"debug\\\":\\\"3.2.6\\\",\\\"diff\\\":\\\"3.5.0\\\",\\\"escape-string-regexp\\\":\\\"1.0.5\\\",\\\"find-up\\\":\\\"3.0.0\\\",\\\"glob\\\":\\\"7.1.3\\\",\\\"growl\\\":\\\"1.10.5\\\",\\\"he\\\":\\\"1.2.0\\\",\\\"js-yaml\\\":\\\"3.13.1\\\",\\\"log-symbols\\\":\\\"3.0.0\\\",\\\"minimatch\\\":\\\"3.0.4\\\",\\\"mkdirp\\\":\\\"0.5.5\\\",\\\"ms\\\":\\\"2.1.1\\\",\\\"node-environment-flags\\\":\\\"1.0.6\\\",\\\"object.assign\\\":\\\"4.1.0\\\",\\\"strip-json-comments\\\":\\\"2.0.1\\\",\\\"supports-color\\\":\\\"6.0.0\\\",\\\"which\\\":\\\"1.3.1\\\",\\\"wide-align\\\":\\\"1.1.3\\\",\\\"yargs\\\":\\\"13.3.2\\\",\\\"yargs-parser\\\":\\\"13.1.2\\\",\\\"yargs-unparser\\\":\\\"1.6.0\\\"},\\\"deprecated\\\":false,\\\"description\\\":\\\"simple, flexible, fun test framework\\\",\\\"devDependencies\\\":{\\\"@11ty/eleventy\\\":\\\"^0.10.0\\\",\\\"@11ty/eleventy-plugin-inclusive-language\\\":\\\"^1.0.0\\\",\\\"@mocha/docdash\\\":\\\"^2.1.3\\\",\\\"assetgraph-builder\\\":\\\"^8.0.0\\\",\\\"autoprefixer\\\":\\\"^9.7.4\\\",\\\"babel-eslint\\\":\\\"^10.1.0\\\",\\\"browserify\\\":\\\"^16.5.0\\\",\\\"browserify-package-json\\\":\\\"^1.0.1\\\",\\\"chai\\\":\\\"^4.2.0\\\",\\\"coffee-script\\\":\\\"^1.12.7\\\",\\\"coveralls\\\":\\\"^3.0.3\\\",\\\"cross-env\\\":\\\"^5.2.0\\\",\\\"cross-spawn\\\":\\\"^6.0.5\\\",\\\"eslint\\\":\\\"^6.8.0\\\",\\\"eslint-config-prettier\\\":\\\"^6.9.0\\\",\\\"eslint-config-semistandard\\\":\\\"^15.0.0\\\",\\\"eslint-config-standard\\\":\\\"^14.1.0\\\",\\\"eslint-plugin-import\\\":\\\"^2.19.1\\\",\\\"eslint-plugin-node\\\":\\\"^11.0.0\\\",\\\"eslint-plugin-prettier\\\":\\\"^3.1.2\\\",\\\"eslint-plugin-promise\\\":\\\"^4.2.1\\\",\\\"eslint-plugin-standard\\\":\\\"^4.0.1\\\",\\\"fs-extra\\\":\\\"^8.0.1\\\",\\\"husky\\\":\\\"^4.2.3\\\",\\\"hyperlink\\\":\\\"^4.4.3\\\",\\\"image-size\\\":\\\"^0.8.3\\\",\\\"jsdoc\\\":\\\"^3.6.3\\\",\\\"karma\\\":\\\"^4.1.0\\\",\\\"karma-browserify\\\":\\\"^6.0.0\\\",\\\"karma-chrome-launcher\\\":\\\"^2.2.0\\\",\\\"karma-mocha\\\":\\\"^1.3.0\\\",\\\"karma-mocha-reporter\\\":\\\"^2.2.5\\\",\\\"karma-sauce-launcher\\\":\\\"^2.0.2\\\",\\\"lint-staged\\\":\\\"^9.5.0\\\",\\\"markdown-it\\\":\\\"^10.0.0\\\",\\\"markdown-it-anchor\\\":\\\"^5.2.5\\\",\\\"markdown-it-attrs\\\":\\\"^3.0.2\\\",\\\"markdown-it-emoji\\\":\\\"^1.4.0\\\",\\\"markdown-it-prism\\\":\\\"^2.0.5\\\",\\\"markdown-toc\\\":\\\"^1.2.0\\\",\\\"markdownlint-cli\\\":\\\"^0.22.0\\\",\\\"needle\\\":\\\"^2.4.1\\\",\\\"nps\\\":\\\"^5.9.12\\\",\\\"nyc\\\":\\\"^15.0.0\\\",\\\"prettier\\\":\\\"^1.19.1\\\",\\\"remark\\\":\\\"^11.0.2\\\",\\\"remark-github\\\":\\\"^8.0.0\\\",\\\"remark-inline-links\\\":\\\"^3.1.3\\\",\\\"rewiremock\\\":\\\"^3.14.1\\\",\\\"rimraf\\\":\\\"^3.0.2\\\",\\\"sinon\\\":\\\"^9.0.1\\\",\\\"strip-ansi\\\":\\\"^6.0.0\\\",\\\"svgo\\\":\\\"^1.3.2\\\",\\\"through2\\\":\\\"^3.0.1\\\",\\\"to-vfile\\\":\\\"^6.1.0\\\",\\\"unexpected\\\":\\\"^11.13.0\\\",\\\"unexpected-eventemitter\\\":\\\"^2.2.0\\\",\\\"unexpected-sinon\\\":\\\"^10.11.2\\\",\\\"uslug\\\":\\\"^1.0.4\\\",\\\"watchify\\\":\\\"^3.11.1\\\"},\\\"directories\\\":{\\\"lib\\\":\\\"./lib\\\",\\\"test\\\":\\\"./test\\\"},\\\"engines\\\":{\\\"node\\\":\\\">= 8.10.0\\\"},\\\"files\\\":[\\\"bin/*mocha\\\",\\\"assets/growl/*.png\\\",\\\"lib/**/*.{js,html,json}\\\",\\\"index.js\\\",\\\"mocha.css\\\",\\\"mocha.js\\\",\\\"browser-entry.js\\\"],\\\"funding\\\":{\\\"type\\\":\\\"opencollective\\\",\\\"url\\\":\\\"https://opencollective.com/mochajs\\\"},\\\"gitter\\\":\\\"https://gitter.im/mochajs/mocha\\\",\\\"homepage\\\":\\\"https://mochajs.org/\\\",\\\"husky\\\":{\\\"hooks\\\":{\\\"pre-commit\\\":\\\"lint-staged\\\"}},\\\"keywords\\\":[\\\"mocha\\\",\\\"test\\\",\\\"bdd\\\",\\\"tdd\\\",\\\"tap\\\",\\\"testing\\\",\\\"chai\\\",\\\"assertion\\\",\\\"ava\\\",\\\"jest\\\",\\\"tape\\\",\\\"jasmine\\\",\\\"karma\\\"],\\\"license\\\":\\\"MIT\\\",\\\"logo\\\":\\\"https://cldup.com/S9uQ-cOLYz.svg\\\",\\\"name\\\":\\\"mocha\\\",\\\"notifyLogo\\\":\\\"https://ibin.co/4QuRuGjXvl36.png\\\",\\\"prettier\\\":{\\\"singleQuote\\\":true,\\\"bracketSpacing\\\":false,\\\"endOfLine\\\":\\\"auto\\\"},\\\"repository\\\":{\\\"type\\\":\\\"git\\\",\\\"url\\\":\\\"git+https://github.com/mochajs/mocha.git\\\"},\\\"scripts\\\":{\\\"prepublishOnly\\\":\\\"nps test clean build\\\",\\\"start\\\":\\\"nps\\\",\\\"test\\\":\\\"nps test\\\",\\\"version\\\":\\\"nps version\\\"},\\\"version\\\":\\\"7.2.0\\\"}\");\n\n//# sourceURL=webpack:///./node_modules/mocha/package.json?");

/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/punycode/punycode.js":
/*!**************************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/punycode/punycode.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */\r\n;(function(root) {\r\n\r\n\t/** Detect free variables */\r\n\tvar freeExports =  true && exports &&\r\n\t\t!exports.nodeType && exports;\r\n\tvar freeModule =  true && module &&\r\n\t\t!module.nodeType && module;\r\n\tvar freeGlobal = typeof global == 'object' && global;\r\n\tif (\r\n\t\tfreeGlobal.global === freeGlobal ||\r\n\t\tfreeGlobal.window === freeGlobal ||\r\n\t\tfreeGlobal.self === freeGlobal\r\n\t) {\r\n\t\troot = freeGlobal;\r\n\t}\r\n\r\n\t/**\r\n\t * The `punycode` object.\r\n\t * @name punycode\r\n\t * @type Object\r\n\t */\r\n\tvar punycode,\r\n\r\n\t/** Highest positive signed 32-bit float value */\r\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\r\n\r\n\t/** Bootstring parameters */\r\n\tbase = 36,\r\n\ttMin = 1,\r\n\ttMax = 26,\r\n\tskew = 38,\r\n\tdamp = 700,\r\n\tinitialBias = 72,\r\n\tinitialN = 128, // 0x80\r\n\tdelimiter = '-', // '\\x2D'\r\n\r\n\t/** Regular expressions */\r\n\tregexPunycode = /^xn--/,\r\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\r\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\r\n\r\n\t/** Error messages */\r\n\terrors = {\r\n\t\t'overflow': 'Overflow: input needs wider integers to process',\r\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\r\n\t\t'invalid-input': 'Invalid input'\r\n\t},\r\n\r\n\t/** Convenience shortcuts */\r\n\tbaseMinusTMin = base - tMin,\r\n\tfloor = Math.floor,\r\n\tstringFromCharCode = String.fromCharCode,\r\n\r\n\t/** Temporary variable */\r\n\tkey;\r\n\r\n\t/*--------------------------------------------------------------------------*/\r\n\r\n\t/**\r\n\t * A generic error utility function.\r\n\t * @private\r\n\t * @param {String} type The error type.\r\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\r\n\t */\r\n\tfunction error(type) {\r\n\t\tthrow new RangeError(errors[type]);\r\n\t}\r\n\r\n\t/**\r\n\t * A generic `Array#map` utility function.\r\n\t * @private\r\n\t * @param {Array} array The array to iterate over.\r\n\t * @param {Function} callback The function that gets called for every array\r\n\t * item.\r\n\t * @returns {Array} A new array of values returned by the callback function.\r\n\t */\r\n\tfunction map(array, fn) {\r\n\t\tvar length = array.length;\r\n\t\tvar result = [];\r\n\t\twhile (length--) {\r\n\t\t\tresult[length] = fn(array[length]);\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/**\r\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\r\n\t * addresses.\r\n\t * @private\r\n\t * @param {String} domain The domain name or email address.\r\n\t * @param {Function} callback The function that gets called for every\r\n\t * character.\r\n\t * @returns {Array} A new string of characters returned by the callback\r\n\t * function.\r\n\t */\r\n\tfunction mapDomain(string, fn) {\r\n\t\tvar parts = string.split('@');\r\n\t\tvar result = '';\r\n\t\tif (parts.length > 1) {\r\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\r\n\t\t\t// the local part (i.e. everything up to `@`) intact.\r\n\t\t\tresult = parts[0] + '@';\r\n\t\t\tstring = parts[1];\r\n\t\t}\r\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\r\n\t\tstring = string.replace(regexSeparators, '\\x2E');\r\n\t\tvar labels = string.split('.');\r\n\t\tvar encoded = map(labels, fn).join('.');\r\n\t\treturn result + encoded;\r\n\t}\r\n\r\n\t/**\r\n\t * Creates an array containing the numeric code points of each Unicode\r\n\t * character in the string. While JavaScript uses UCS-2 internally,\r\n\t * this function will convert a pair of surrogate halves (each of which\r\n\t * UCS-2 exposes as separate characters) into a single code point,\r\n\t * matching UTF-16.\r\n\t * @see `punycode.ucs2.encode`\r\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\r\n\t * @memberOf punycode.ucs2\r\n\t * @name decode\r\n\t * @param {String} string The Unicode input string (UCS-2).\r\n\t * @returns {Array} The new array of code points.\r\n\t */\r\n\tfunction ucs2decode(string) {\r\n\t\tvar output = [],\r\n\t\t    counter = 0,\r\n\t\t    length = string.length,\r\n\t\t    value,\r\n\t\t    extra;\r\n\t\twhile (counter < length) {\r\n\t\t\tvalue = string.charCodeAt(counter++);\r\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\r\n\t\t\t\t// high surrogate, and there is a next character\r\n\t\t\t\textra = string.charCodeAt(counter++);\r\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\r\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\r\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\r\n\t\t\t\t\toutput.push(value);\r\n\t\t\t\t\tcounter--;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\toutput.push(value);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn output;\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a string based on an array of numeric code points.\r\n\t * @see `punycode.ucs2.decode`\r\n\t * @memberOf punycode.ucs2\r\n\t * @name encode\r\n\t * @param {Array} codePoints The array of numeric code points.\r\n\t * @returns {String} The new Unicode string (UCS-2).\r\n\t */\r\n\tfunction ucs2encode(array) {\r\n\t\treturn map(array, function(value) {\r\n\t\t\tvar output = '';\r\n\t\t\tif (value > 0xFFFF) {\r\n\t\t\t\tvalue -= 0x10000;\r\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\r\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\r\n\t\t\t}\r\n\t\t\toutput += stringFromCharCode(value);\r\n\t\t\treturn output;\r\n\t\t}).join('');\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a basic code point into a digit/integer.\r\n\t * @see `digitToBasic()`\r\n\t * @private\r\n\t * @param {Number} codePoint The basic numeric code point value.\r\n\t * @returns {Number} The numeric value of a basic code point (for use in\r\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\r\n\t * the code point does not represent a value.\r\n\t */\r\n\tfunction basicToDigit(codePoint) {\r\n\t\tif (codePoint - 48 < 10) {\r\n\t\t\treturn codePoint - 22;\r\n\t\t}\r\n\t\tif (codePoint - 65 < 26) {\r\n\t\t\treturn codePoint - 65;\r\n\t\t}\r\n\t\tif (codePoint - 97 < 26) {\r\n\t\t\treturn codePoint - 97;\r\n\t\t}\r\n\t\treturn base;\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a digit/integer into a basic code point.\r\n\t * @see `basicToDigit()`\r\n\t * @private\r\n\t * @param {Number} digit The numeric value of a basic code point.\r\n\t * @returns {Number} The basic code point whose value (when used for\r\n\t * representing integers) is `digit`, which needs to be in the range\r\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\r\n\t * used; else, the lowercase form is used. The behavior is undefined\r\n\t * if `flag` is non-zero and `digit` has no uppercase form.\r\n\t */\r\n\tfunction digitToBasic(digit, flag) {\r\n\t\t//  0..25 map to ASCII a..z or A..Z\r\n\t\t// 26..35 map to ASCII 0..9\r\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\r\n\t}\r\n\r\n\t/**\r\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\r\n\t * https://tools.ietf.org/html/rfc3492#section-3.4\r\n\t * @private\r\n\t */\r\n\tfunction adapt(delta, numPoints, firstTime) {\r\n\t\tvar k = 0;\r\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\r\n\t\tdelta += floor(delta / numPoints);\r\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\r\n\t\t\tdelta = floor(delta / baseMinusTMin);\r\n\t\t}\r\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\r\n\t * symbols.\r\n\t * @memberOf punycode\r\n\t * @param {String} input The Punycode string of ASCII-only symbols.\r\n\t * @returns {String} The resulting string of Unicode symbols.\r\n\t */\r\n\tfunction decode(input) {\r\n\t\t// Don't use UCS-2\r\n\t\tvar output = [],\r\n\t\t    inputLength = input.length,\r\n\t\t    out,\r\n\t\t    i = 0,\r\n\t\t    n = initialN,\r\n\t\t    bias = initialBias,\r\n\t\t    basic,\r\n\t\t    j,\r\n\t\t    index,\r\n\t\t    oldi,\r\n\t\t    w,\r\n\t\t    k,\r\n\t\t    digit,\r\n\t\t    t,\r\n\t\t    /** Cached calculation results */\r\n\t\t    baseMinusT;\r\n\r\n\t\t// Handle the basic code points: let `basic` be the number of input code\r\n\t\t// points before the last delimiter, or `0` if there is none, then copy\r\n\t\t// the first basic code points to the output.\r\n\r\n\t\tbasic = input.lastIndexOf(delimiter);\r\n\t\tif (basic < 0) {\r\n\t\t\tbasic = 0;\r\n\t\t}\r\n\r\n\t\tfor (j = 0; j < basic; ++j) {\r\n\t\t\t// if it's not a basic code point\r\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\r\n\t\t\t\terror('not-basic');\r\n\t\t\t}\r\n\t\t\toutput.push(input.charCodeAt(j));\r\n\t\t}\r\n\r\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\r\n\t\t// points were copied; start at the beginning otherwise.\r\n\r\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\r\n\r\n\t\t\t// `index` is the index of the next character to be consumed.\r\n\t\t\t// Decode a generalized variable-length integer into `delta`,\r\n\t\t\t// which gets added to `i`. The overflow checking is easier\r\n\t\t\t// if we increase `i` as we go, then subtract off its starting\r\n\t\t\t// value at the end to obtain `delta`.\r\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\r\n\r\n\t\t\t\tif (index >= inputLength) {\r\n\t\t\t\t\terror('invalid-input');\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\r\n\r\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\r\n\t\t\t\t\terror('overflow');\r\n\t\t\t\t}\r\n\r\n\t\t\t\ti += digit * w;\r\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\r\n\r\n\t\t\t\tif (digit < t) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbaseMinusT = base - t;\r\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\r\n\t\t\t\t\terror('overflow');\r\n\t\t\t\t}\r\n\r\n\t\t\t\tw *= baseMinusT;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tout = output.length + 1;\r\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\r\n\r\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\r\n\t\t\t// incrementing `n` each time, so we'll fix that now:\r\n\t\t\tif (floor(i / out) > maxInt - n) {\r\n\t\t\t\terror('overflow');\r\n\t\t\t}\r\n\r\n\t\t\tn += floor(i / out);\r\n\t\t\ti %= out;\r\n\r\n\t\t\t// Insert `n` at position `i` of the output\r\n\t\t\toutput.splice(i++, 0, n);\r\n\r\n\t\t}\r\n\r\n\t\treturn ucs2encode(output);\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\r\n\t * Punycode string of ASCII-only symbols.\r\n\t * @memberOf punycode\r\n\t * @param {String} input The string of Unicode symbols.\r\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\r\n\t */\r\n\tfunction encode(input) {\r\n\t\tvar n,\r\n\t\t    delta,\r\n\t\t    handledCPCount,\r\n\t\t    basicLength,\r\n\t\t    bias,\r\n\t\t    j,\r\n\t\t    m,\r\n\t\t    q,\r\n\t\t    k,\r\n\t\t    t,\r\n\t\t    currentValue,\r\n\t\t    output = [],\r\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\r\n\t\t    inputLength,\r\n\t\t    /** Cached calculation results */\r\n\t\t    handledCPCountPlusOne,\r\n\t\t    baseMinusT,\r\n\t\t    qMinusT;\r\n\r\n\t\t// Convert the input in UCS-2 to Unicode\r\n\t\tinput = ucs2decode(input);\r\n\r\n\t\t// Cache the length\r\n\t\tinputLength = input.length;\r\n\r\n\t\t// Initialize the state\r\n\t\tn = initialN;\r\n\t\tdelta = 0;\r\n\t\tbias = initialBias;\r\n\r\n\t\t// Handle the basic code points\r\n\t\tfor (j = 0; j < inputLength; ++j) {\r\n\t\t\tcurrentValue = input[j];\r\n\t\t\tif (currentValue < 0x80) {\r\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\thandledCPCount = basicLength = output.length;\r\n\r\n\t\t// `handledCPCount` is the number of code points that have been handled;\r\n\t\t// `basicLength` is the number of basic code points.\r\n\r\n\t\t// Finish the basic string - if it is not empty - with a delimiter\r\n\t\tif (basicLength) {\r\n\t\t\toutput.push(delimiter);\r\n\t\t}\r\n\r\n\t\t// Main encoding loop:\r\n\t\twhile (handledCPCount < inputLength) {\r\n\r\n\t\t\t// All non-basic code points < n have been handled already. Find the next\r\n\t\t\t// larger one:\r\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\r\n\t\t\t\tcurrentValue = input[j];\r\n\t\t\t\tif (currentValue >= n && currentValue < m) {\r\n\t\t\t\t\tm = currentValue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\r\n\t\t\t// but guard against overflow\r\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\r\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\r\n\t\t\t\terror('overflow');\r\n\t\t\t}\r\n\r\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\r\n\t\t\tn = m;\r\n\r\n\t\t\tfor (j = 0; j < inputLength; ++j) {\r\n\t\t\t\tcurrentValue = input[j];\r\n\r\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\r\n\t\t\t\t\terror('overflow');\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (currentValue == n) {\r\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\r\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\r\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\r\n\t\t\t\t\t\tif (q < t) {\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tqMinusT = q - t;\r\n\t\t\t\t\t\tbaseMinusT = base - t;\r\n\t\t\t\t\t\toutput.push(\r\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\r\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\r\n\t\t\t\t\tdelta = 0;\r\n\t\t\t\t\t++handledCPCount;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t++delta;\r\n\t\t\t++n;\r\n\r\n\t\t}\r\n\t\treturn output.join('');\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a Punycode string representing a domain name or an email address\r\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\r\n\t * it doesn't matter if you call it on a string that has already been\r\n\t * converted to Unicode.\r\n\t * @memberOf punycode\r\n\t * @param {String} input The Punycoded domain name or email address to\r\n\t * convert to Unicode.\r\n\t * @returns {String} The Unicode representation of the given Punycode\r\n\t * string.\r\n\t */\r\n\tfunction toUnicode(input) {\r\n\t\treturn mapDomain(input, function(string) {\r\n\t\t\treturn regexPunycode.test(string)\r\n\t\t\t\t? decode(string.slice(4).toLowerCase())\r\n\t\t\t\t: string;\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a Unicode string representing a domain name or an email address to\r\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\r\n\t * i.e. it doesn't matter if you call it with a domain that's already in\r\n\t * ASCII.\r\n\t * @memberOf punycode\r\n\t * @param {String} input The domain name or email address to convert, as a\r\n\t * Unicode string.\r\n\t * @returns {String} The Punycode representation of the given domain name or\r\n\t * email address.\r\n\t */\r\n\tfunction toASCII(input) {\r\n\t\treturn mapDomain(input, function(string) {\r\n\t\t\treturn regexNonASCII.test(string)\r\n\t\t\t\t? 'xn--' + encode(string)\r\n\t\t\t\t: string;\r\n\t\t});\r\n\t}\r\n\r\n\t/*--------------------------------------------------------------------------*/\r\n\r\n\t/** Define the public API */\r\n\tpunycode = {\r\n\t\t/**\r\n\t\t * A string representing the current Punycode.js version number.\r\n\t\t * @memberOf punycode\r\n\t\t * @type String\r\n\t\t */\r\n\t\t'version': '1.4.1',\r\n\t\t/**\r\n\t\t * An object of methods to convert from JavaScript's internal character\r\n\t\t * representation (UCS-2) to Unicode code points, and back.\r\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\r\n\t\t * @memberOf punycode\r\n\t\t * @type Object\r\n\t\t */\r\n\t\t'ucs2': {\r\n\t\t\t'decode': ucs2decode,\r\n\t\t\t'encode': ucs2encode\r\n\t\t},\r\n\t\t'decode': decode,\r\n\t\t'encode': encode,\r\n\t\t'toASCII': toASCII,\r\n\t\t'toUnicode': toUnicode\r\n\t};\r\n\r\n\t/** Expose `punycode` */\r\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\r\n\t// like the following:\r\n\tif (\r\n\t\ttrue\r\n\t) {\r\n\t\t!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\r\n\t\t\treturn punycode;\r\n\t\t}).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t} else {}\r\n\r\n}(this));\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module), __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/node-libs-browser/node_modules/punycode/punycode.js?");

/***/ }),

/***/ "./node_modules/object-keys/implementation.js":
/*!****************************************************!*\
  !*** ./node_modules/object-keys/implementation.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar keysShim;\r\nif (!Object.keys) {\r\n\t// modified from https://github.com/es-shims/es5-shim\r\n\tvar has = Object.prototype.hasOwnProperty;\r\n\tvar toStr = Object.prototype.toString;\r\n\tvar isArgs = __webpack_require__(/*! ./isArguments */ \"./node_modules/object-keys/isArguments.js\"); // eslint-disable-line global-require\r\n\tvar isEnumerable = Object.prototype.propertyIsEnumerable;\r\n\tvar hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');\r\n\tvar hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');\r\n\tvar dontEnums = [\r\n\t\t'toString',\r\n\t\t'toLocaleString',\r\n\t\t'valueOf',\r\n\t\t'hasOwnProperty',\r\n\t\t'isPrototypeOf',\r\n\t\t'propertyIsEnumerable',\r\n\t\t'constructor'\r\n\t];\r\n\tvar equalsConstructorPrototype = function (o) {\r\n\t\tvar ctor = o.constructor;\r\n\t\treturn ctor && ctor.prototype === o;\r\n\t};\r\n\tvar excludedKeys = {\r\n\t\t$applicationCache: true,\r\n\t\t$console: true,\r\n\t\t$external: true,\r\n\t\t$frame: true,\r\n\t\t$frameElement: true,\r\n\t\t$frames: true,\r\n\t\t$innerHeight: true,\r\n\t\t$innerWidth: true,\r\n\t\t$onmozfullscreenchange: true,\r\n\t\t$onmozfullscreenerror: true,\r\n\t\t$outerHeight: true,\r\n\t\t$outerWidth: true,\r\n\t\t$pageXOffset: true,\r\n\t\t$pageYOffset: true,\r\n\t\t$parent: true,\r\n\t\t$scrollLeft: true,\r\n\t\t$scrollTop: true,\r\n\t\t$scrollX: true,\r\n\t\t$scrollY: true,\r\n\t\t$self: true,\r\n\t\t$webkitIndexedDB: true,\r\n\t\t$webkitStorageInfo: true,\r\n\t\t$window: true\r\n\t};\r\n\tvar hasAutomationEqualityBug = (function () {\r\n\t\t/* global window */\r\n\t\tif (typeof window === 'undefined') { return false; }\r\n\t\tfor (var k in window) {\r\n\t\t\ttry {\r\n\t\t\t\tif (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tequalsConstructorPrototype(window[k]);\r\n\t\t\t\t\t} catch (e) {\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} catch (e) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}());\r\n\tvar equalsConstructorPrototypeIfNotBuggy = function (o) {\r\n\t\t/* global window */\r\n\t\tif (typeof window === 'undefined' || !hasAutomationEqualityBug) {\r\n\t\t\treturn equalsConstructorPrototype(o);\r\n\t\t}\r\n\t\ttry {\r\n\t\t\treturn equalsConstructorPrototype(o);\r\n\t\t} catch (e) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t};\r\n\r\n\tkeysShim = function keys(object) {\r\n\t\tvar isObject = object !== null && typeof object === 'object';\r\n\t\tvar isFunction = toStr.call(object) === '[object Function]';\r\n\t\tvar isArguments = isArgs(object);\r\n\t\tvar isString = isObject && toStr.call(object) === '[object String]';\r\n\t\tvar theKeys = [];\r\n\r\n\t\tif (!isObject && !isFunction && !isArguments) {\r\n\t\t\tthrow new TypeError('Object.keys called on a non-object');\r\n\t\t}\r\n\r\n\t\tvar skipProto = hasProtoEnumBug && isFunction;\r\n\t\tif (isString && object.length > 0 && !has.call(object, 0)) {\r\n\t\t\tfor (var i = 0; i < object.length; ++i) {\r\n\t\t\t\ttheKeys.push(String(i));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (isArguments && object.length > 0) {\r\n\t\t\tfor (var j = 0; j < object.length; ++j) {\r\n\t\t\t\ttheKeys.push(String(j));\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor (var name in object) {\r\n\t\t\t\tif (!(skipProto && name === 'prototype') && has.call(object, name)) {\r\n\t\t\t\t\ttheKeys.push(String(name));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (hasDontEnumBug) {\r\n\t\t\tvar skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);\r\n\r\n\t\t\tfor (var k = 0; k < dontEnums.length; ++k) {\r\n\t\t\t\tif (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {\r\n\t\t\t\t\ttheKeys.push(dontEnums[k]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn theKeys;\r\n\t};\r\n}\r\nmodule.exports = keysShim;\r\n\n\n//# sourceURL=webpack:///./node_modules/object-keys/implementation.js?");

/***/ }),

/***/ "./node_modules/object-keys/index.js":
/*!*******************************************!*\
  !*** ./node_modules/object-keys/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar slice = Array.prototype.slice;\r\nvar isArgs = __webpack_require__(/*! ./isArguments */ \"./node_modules/object-keys/isArguments.js\");\r\n\r\nvar origKeys = Object.keys;\r\nvar keysShim = origKeys ? function keys(o) { return origKeys(o); } : __webpack_require__(/*! ./implementation */ \"./node_modules/object-keys/implementation.js\");\r\n\r\nvar originalKeys = Object.keys;\r\n\r\nkeysShim.shim = function shimObjectKeys() {\r\n\tif (Object.keys) {\r\n\t\tvar keysWorksWithArguments = (function () {\r\n\t\t\t// Safari 5.0 bug\r\n\t\t\tvar args = Object.keys(arguments);\r\n\t\t\treturn args && args.length === arguments.length;\r\n\t\t}(1, 2));\r\n\t\tif (!keysWorksWithArguments) {\r\n\t\t\tObject.keys = function keys(object) { // eslint-disable-line func-name-matching\r\n\t\t\t\tif (isArgs(object)) {\r\n\t\t\t\t\treturn originalKeys(slice.call(object));\r\n\t\t\t\t}\r\n\t\t\t\treturn originalKeys(object);\r\n\t\t\t};\r\n\t\t}\r\n\t} else {\r\n\t\tObject.keys = keysShim;\r\n\t}\r\n\treturn Object.keys || keysShim;\r\n};\r\n\r\nmodule.exports = keysShim;\r\n\n\n//# sourceURL=webpack:///./node_modules/object-keys/index.js?");

/***/ }),

/***/ "./node_modules/object-keys/isArguments.js":
/*!*************************************************!*\
  !*** ./node_modules/object-keys/isArguments.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar toStr = Object.prototype.toString;\r\n\r\nmodule.exports = function isArguments(value) {\r\n\tvar str = toStr.call(value);\r\n\tvar isArgs = str === '[object Arguments]';\r\n\tif (!isArgs) {\r\n\t\tisArgs = str !== '[object Array]' &&\r\n\t\t\tvalue !== null &&\r\n\t\t\ttypeof value === 'object' &&\r\n\t\t\ttypeof value.length === 'number' &&\r\n\t\t\tvalue.length >= 0 &&\r\n\t\t\ttoStr.call(value.callee) === '[object Function]';\r\n\t}\r\n\treturn isArgs;\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/object-keys/isArguments.js?");

/***/ }),

/***/ "./node_modules/object.assign/implementation.js":
/*!******************************************************!*\
  !*** ./node_modules/object.assign/implementation.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\n// modified from https://github.com/es-shims/es6-shim\r\nvar keys = __webpack_require__(/*! object-keys */ \"./node_modules/object-keys/index.js\");\r\nvar bind = __webpack_require__(/*! function-bind */ \"./node_modules/function-bind/index.js\");\r\nvar canBeObject = function (obj) {\r\n\treturn typeof obj !== 'undefined' && obj !== null;\r\n};\r\nvar hasSymbols = __webpack_require__(/*! has-symbols/shams */ \"./node_modules/has-symbols/shams.js\")();\r\nvar toObject = Object;\r\nvar push = bind.call(Function.call, Array.prototype.push);\r\nvar propIsEnumerable = bind.call(Function.call, Object.prototype.propertyIsEnumerable);\r\nvar originalGetSymbols = hasSymbols ? Object.getOwnPropertySymbols : null;\r\n\r\nmodule.exports = function assign(target, source1) {\r\n\tif (!canBeObject(target)) { throw new TypeError('target must be an object'); }\r\n\tvar objTarget = toObject(target);\r\n\tvar s, source, i, props, syms, value, key;\r\n\tfor (s = 1; s < arguments.length; ++s) {\r\n\t\tsource = toObject(arguments[s]);\r\n\t\tprops = keys(source);\r\n\t\tvar getSymbols = hasSymbols && (Object.getOwnPropertySymbols || originalGetSymbols);\r\n\t\tif (getSymbols) {\r\n\t\t\tsyms = getSymbols(source);\r\n\t\t\tfor (i = 0; i < syms.length; ++i) {\r\n\t\t\t\tkey = syms[i];\r\n\t\t\t\tif (propIsEnumerable(source, key)) {\r\n\t\t\t\t\tpush(props, key);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (i = 0; i < props.length; ++i) {\r\n\t\t\tkey = props[i];\r\n\t\t\tvalue = source[key];\r\n\t\t\tif (propIsEnumerable(source, key)) {\r\n\t\t\t\tobjTarget[key] = value;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn objTarget;\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/object.assign/implementation.js?");

/***/ }),

/***/ "./node_modules/object.assign/index.js":
/*!*********************************************!*\
  !*** ./node_modules/object.assign/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar defineProperties = __webpack_require__(/*! define-properties */ \"./node_modules/define-properties/index.js\");\r\n\r\nvar implementation = __webpack_require__(/*! ./implementation */ \"./node_modules/object.assign/implementation.js\");\r\nvar getPolyfill = __webpack_require__(/*! ./polyfill */ \"./node_modules/object.assign/polyfill.js\");\r\nvar shim = __webpack_require__(/*! ./shim */ \"./node_modules/object.assign/shim.js\");\r\n\r\nvar polyfill = getPolyfill();\r\n\r\ndefineProperties(polyfill, {\r\n\tgetPolyfill: getPolyfill,\r\n\timplementation: implementation,\r\n\tshim: shim\r\n});\r\n\r\nmodule.exports = polyfill;\r\n\n\n//# sourceURL=webpack:///./node_modules/object.assign/index.js?");

/***/ }),

/***/ "./node_modules/object.assign/polyfill.js":
/*!************************************************!*\
  !*** ./node_modules/object.assign/polyfill.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar implementation = __webpack_require__(/*! ./implementation */ \"./node_modules/object.assign/implementation.js\");\r\n\r\nvar lacksProperEnumerationOrder = function () {\r\n\tif (!Object.assign) {\r\n\t\treturn false;\r\n\t}\r\n\t// v8, specifically in node 4.x, has a bug with incorrect property enumeration order\r\n\t// note: this does not detect the bug unless there's 20 characters\r\n\tvar str = 'abcdefghijklmnopqrst';\r\n\tvar letters = str.split('');\r\n\tvar map = {};\r\n\tfor (var i = 0; i < letters.length; ++i) {\r\n\t\tmap[letters[i]] = letters[i];\r\n\t}\r\n\tvar obj = Object.assign({}, map);\r\n\tvar actual = '';\r\n\tfor (var k in obj) {\r\n\t\tactual += k;\r\n\t}\r\n\treturn str !== actual;\r\n};\r\n\r\nvar assignHasPendingExceptions = function () {\r\n\tif (!Object.assign || !Object.preventExtensions) {\r\n\t\treturn false;\r\n\t}\r\n\t// Firefox 37 still has \"pending exception\" logic in its Object.assign implementation,\r\n\t// which is 72% slower than our shim, and Firefox 40's native implementation.\r\n\tvar thrower = Object.preventExtensions({ 1: 2 });\r\n\ttry {\r\n\t\tObject.assign(thrower, 'xy');\r\n\t} catch (e) {\r\n\t\treturn thrower[1] === 'y';\r\n\t}\r\n\treturn false;\r\n};\r\n\r\nmodule.exports = function getPolyfill() {\r\n\tif (!Object.assign) {\r\n\t\treturn implementation;\r\n\t}\r\n\tif (lacksProperEnumerationOrder()) {\r\n\t\treturn implementation;\r\n\t}\r\n\tif (assignHasPendingExceptions()) {\r\n\t\treturn implementation;\r\n\t}\r\n\treturn Object.assign;\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/object.assign/polyfill.js?");

/***/ }),

/***/ "./node_modules/object.assign/shim.js":
/*!********************************************!*\
  !*** ./node_modules/object.assign/shim.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar define = __webpack_require__(/*! define-properties */ \"./node_modules/define-properties/index.js\");\r\nvar getPolyfill = __webpack_require__(/*! ./polyfill */ \"./node_modules/object.assign/polyfill.js\");\r\n\r\nmodule.exports = function shimAssign() {\r\n\tvar polyfill = getPolyfill();\r\n\tdefine(\r\n\t\tObject,\r\n\t\t{ assign: polyfill },\r\n\t\t{ assign: function () { return Object.assign !== polyfill; } }\r\n\t);\r\n\treturn polyfill;\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/object.assign/shim.js?");

/***/ }),

/***/ "./node_modules/path-browserify/index.js":
/*!***********************************************!*\
  !*** ./node_modules/path-browserify/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,\r\n// backported and transplited with Babel, with backwards-compat fixes\r\n\r\n// Copyright Joyent, Inc. and other Node contributors.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the\r\n// \"Software\"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n// persons to whom the Software is furnished to do so, subject to the\r\n// following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n// resolves . and .. elements in a path array with directory names there\r\n// must be no slashes, empty elements, or device names (c:\\) in the array\r\n// (so also no leading and trailing slashes - it does not distinguish\r\n// relative and absolute paths)\r\nfunction normalizeArray(parts, allowAboveRoot) {\r\n  // if the path tries to go above the root, `up` ends up > 0\r\n  var up = 0;\r\n  for (var i = parts.length - 1; i >= 0; i--) {\r\n    var last = parts[i];\r\n    if (last === '.') {\r\n      parts.splice(i, 1);\r\n    } else if (last === '..') {\r\n      parts.splice(i, 1);\r\n      up++;\r\n    } else if (up) {\r\n      parts.splice(i, 1);\r\n      up--;\r\n    }\r\n  }\r\n\r\n  // if the path is allowed to go above the root, restore leading ..s\r\n  if (allowAboveRoot) {\r\n    for (; up--; up) {\r\n      parts.unshift('..');\r\n    }\r\n  }\r\n\r\n  return parts;\r\n}\r\n\r\n// path.resolve([from ...], to)\r\n// posix version\r\nexports.resolve = function() {\r\n  var resolvedPath = '',\r\n      resolvedAbsolute = false;\r\n\r\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\r\n    var path = (i >= 0) ? arguments[i] : process.cwd();\r\n\r\n    // Skip empty and invalid entries\r\n    if (typeof path !== 'string') {\r\n      throw new TypeError('Arguments to path.resolve must be strings');\r\n    } else if (!path) {\r\n      continue;\r\n    }\r\n\r\n    resolvedPath = path + '/' + resolvedPath;\r\n    resolvedAbsolute = path.charAt(0) === '/';\r\n  }\r\n\r\n  // At this point the path should be resolved to a full absolute path, but\r\n  // handle relative paths to be safe (might happen when process.cwd() fails)\r\n\r\n  // Normalize the path\r\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\r\n    return !!p;\r\n  }), !resolvedAbsolute).join('/');\r\n\r\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\r\n};\r\n\r\n// path.normalize(path)\r\n// posix version\r\nexports.normalize = function(path) {\r\n  var isAbsolute = exports.isAbsolute(path),\r\n      trailingSlash = substr(path, -1) === '/';\r\n\r\n  // Normalize the path\r\n  path = normalizeArray(filter(path.split('/'), function(p) {\r\n    return !!p;\r\n  }), !isAbsolute).join('/');\r\n\r\n  if (!path && !isAbsolute) {\r\n    path = '.';\r\n  }\r\n  if (path && trailingSlash) {\r\n    path += '/';\r\n  }\r\n\r\n  return (isAbsolute ? '/' : '') + path;\r\n};\r\n\r\n// posix version\r\nexports.isAbsolute = function(path) {\r\n  return path.charAt(0) === '/';\r\n};\r\n\r\n// posix version\r\nexports.join = function() {\r\n  var paths = Array.prototype.slice.call(arguments, 0);\r\n  return exports.normalize(filter(paths, function(p, index) {\r\n    if (typeof p !== 'string') {\r\n      throw new TypeError('Arguments to path.join must be strings');\r\n    }\r\n    return p;\r\n  }).join('/'));\r\n};\r\n\r\n\r\n// path.relative(from, to)\r\n// posix version\r\nexports.relative = function(from, to) {\r\n  from = exports.resolve(from).substr(1);\r\n  to = exports.resolve(to).substr(1);\r\n\r\n  function trim(arr) {\r\n    var start = 0;\r\n    for (; start < arr.length; start++) {\r\n      if (arr[start] !== '') break;\r\n    }\r\n\r\n    var end = arr.length - 1;\r\n    for (; end >= 0; end--) {\r\n      if (arr[end] !== '') break;\r\n    }\r\n\r\n    if (start > end) return [];\r\n    return arr.slice(start, end - start + 1);\r\n  }\r\n\r\n  var fromParts = trim(from.split('/'));\r\n  var toParts = trim(to.split('/'));\r\n\r\n  var length = Math.min(fromParts.length, toParts.length);\r\n  var samePartsLength = length;\r\n  for (var i = 0; i < length; i++) {\r\n    if (fromParts[i] !== toParts[i]) {\r\n      samePartsLength = i;\r\n      break;\r\n    }\r\n  }\r\n\r\n  var outputParts = [];\r\n  for (var i = samePartsLength; i < fromParts.length; i++) {\r\n    outputParts.push('..');\r\n  }\r\n\r\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\r\n\r\n  return outputParts.join('/');\r\n};\r\n\r\nexports.sep = '/';\r\nexports.delimiter = ':';\r\n\r\nexports.dirname = function (path) {\r\n  if (typeof path !== 'string') path = path + '';\r\n  if (path.length === 0) return '.';\r\n  var code = path.charCodeAt(0);\r\n  var hasRoot = code === 47 /*/*/;\r\n  var end = -1;\r\n  var matchedSlash = true;\r\n  for (var i = path.length - 1; i >= 1; --i) {\r\n    code = path.charCodeAt(i);\r\n    if (code === 47 /*/*/) {\r\n        if (!matchedSlash) {\r\n          end = i;\r\n          break;\r\n        }\r\n      } else {\r\n      // We saw the first non-path separator\r\n      matchedSlash = false;\r\n    }\r\n  }\r\n\r\n  if (end === -1) return hasRoot ? '/' : '.';\r\n  if (hasRoot && end === 1) {\r\n    // return '//';\r\n    // Backwards-compat fix:\r\n    return '/';\r\n  }\r\n  return path.slice(0, end);\r\n};\r\n\r\nfunction basename(path) {\r\n  if (typeof path !== 'string') path = path + '';\r\n\r\n  var start = 0;\r\n  var end = -1;\r\n  var matchedSlash = true;\r\n  var i;\r\n\r\n  for (i = path.length - 1; i >= 0; --i) {\r\n    if (path.charCodeAt(i) === 47 /*/*/) {\r\n        // If we reached a path separator that was not part of a set of path\r\n        // separators at the end of the string, stop now\r\n        if (!matchedSlash) {\r\n          start = i + 1;\r\n          break;\r\n        }\r\n      } else if (end === -1) {\r\n      // We saw the first non-path separator, mark this as the end of our\r\n      // path component\r\n      matchedSlash = false;\r\n      end = i + 1;\r\n    }\r\n  }\r\n\r\n  if (end === -1) return '';\r\n  return path.slice(start, end);\r\n}\r\n\r\n// Uses a mixed approach for backwards-compatibility, as ext behavior changed\r\n// in new Node.js versions, so only basename() above is backported here\r\nexports.basename = function (path, ext) {\r\n  var f = basename(path);\r\n  if (ext && f.substr(-1 * ext.length) === ext) {\r\n    f = f.substr(0, f.length - ext.length);\r\n  }\r\n  return f;\r\n};\r\n\r\nexports.extname = function (path) {\r\n  if (typeof path !== 'string') path = path + '';\r\n  var startDot = -1;\r\n  var startPart = 0;\r\n  var end = -1;\r\n  var matchedSlash = true;\r\n  // Track the state of characters (if any) we see before our first dot and\r\n  // after any path separator we find\r\n  var preDotState = 0;\r\n  for (var i = path.length - 1; i >= 0; --i) {\r\n    var code = path.charCodeAt(i);\r\n    if (code === 47 /*/*/) {\r\n        // If we reached a path separator that was not part of a set of path\r\n        // separators at the end of the string, stop now\r\n        if (!matchedSlash) {\r\n          startPart = i + 1;\r\n          break;\r\n        }\r\n        continue;\r\n      }\r\n    if (end === -1) {\r\n      // We saw the first non-path separator, mark this as the end of our\r\n      // extension\r\n      matchedSlash = false;\r\n      end = i + 1;\r\n    }\r\n    if (code === 46 /*.*/) {\r\n        // If this is our first dot, mark it as the start of our extension\r\n        if (startDot === -1)\r\n          startDot = i;\r\n        else if (preDotState !== 1)\r\n          preDotState = 1;\r\n    } else if (startDot !== -1) {\r\n      // We saw a non-dot and non-path separator before our dot, so we should\r\n      // have a good chance at having a non-empty extension\r\n      preDotState = -1;\r\n    }\r\n  }\r\n\r\n  if (startDot === -1 || end === -1 ||\r\n      // We saw a non-dot character immediately before the dot\r\n      preDotState === 0 ||\r\n      // The (right-most) trimmed path component is exactly '..'\r\n      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\r\n    return '';\r\n  }\r\n  return path.slice(startDot, end);\r\n};\r\n\r\nfunction filter (xs, f) {\r\n    if (xs.filter) return xs.filter(f);\r\n    var res = [];\r\n    for (var i = 0; i < xs.length; i++) {\r\n        if (f(xs[i], i, xs)) res.push(xs[i]);\r\n    }\r\n    return res;\r\n}\r\n\r\n// String.prototype.substr - negative index don't work in IE8\r\nvar substr = 'ab'.substr(-1) === 'b'\r\n    ? function (str, start, len) { return str.substr(start, len) }\r\n    : function (str, start, len) {\r\n        if (start < 0) start = str.length + start;\r\n        return str.substr(start, len);\r\n    }\r\n;\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/path-browserify/index.js?");

/***/ }),

/***/ "./node_modules/process-nextick-args/index.js":
/*!****************************************************!*\
  !*** ./node_modules/process-nextick-args/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\r\n\r\nif (typeof process === 'undefined' ||\r\n    !process.version ||\r\n    process.version.indexOf('v0.') === 0 ||\r\n    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\r\n  module.exports = { nextTick: nextTick };\r\n} else {\r\n  module.exports = process\r\n}\r\n\r\nfunction nextTick(fn, arg1, arg2, arg3) {\r\n  if (typeof fn !== 'function') {\r\n    throw new TypeError('\"callback\" argument must be a function');\r\n  }\r\n  var len = arguments.length;\r\n  var args, i;\r\n  switch (len) {\r\n  case 0:\r\n  case 1:\r\n    return process.nextTick(fn);\r\n  case 2:\r\n    return process.nextTick(function afterTickOne() {\r\n      fn.call(null, arg1);\r\n    });\r\n  case 3:\r\n    return process.nextTick(function afterTickTwo() {\r\n      fn.call(null, arg1, arg2);\r\n    });\r\n  case 4:\r\n    return process.nextTick(function afterTickThree() {\r\n      fn.call(null, arg1, arg2, arg3);\r\n    });\r\n  default:\r\n    args = new Array(len - 1);\r\n    i = 0;\r\n    while (i < args.length) {\r\n      args[i++] = arguments[i];\r\n    }\r\n    return process.nextTick(function afterTick() {\r\n      fn.apply(null, args);\r\n    });\r\n  }\r\n}\r\n\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/process-nextick-args/index.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\r\nvar process = module.exports = {};\r\n\r\n// cached from whatever global is present so that test runners that stub it\r\n// don't break things.  But we need to wrap it in a try catch in case it is\r\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\r\n// function because try/catches deoptimize in certain engines.\r\n\r\nvar cachedSetTimeout;\r\nvar cachedClearTimeout;\r\n\r\nfunction defaultSetTimout() {\r\n    throw new Error('setTimeout has not been defined');\r\n}\r\nfunction defaultClearTimeout () {\r\n    throw new Error('clearTimeout has not been defined');\r\n}\r\n(function () {\r\n    try {\r\n        if (typeof setTimeout === 'function') {\r\n            cachedSetTimeout = setTimeout;\r\n        } else {\r\n            cachedSetTimeout = defaultSetTimout;\r\n        }\r\n    } catch (e) {\r\n        cachedSetTimeout = defaultSetTimout;\r\n    }\r\n    try {\r\n        if (typeof clearTimeout === 'function') {\r\n            cachedClearTimeout = clearTimeout;\r\n        } else {\r\n            cachedClearTimeout = defaultClearTimeout;\r\n        }\r\n    } catch (e) {\r\n        cachedClearTimeout = defaultClearTimeout;\r\n    }\r\n} ())\r\nfunction runTimeout(fun) {\r\n    if (cachedSetTimeout === setTimeout) {\r\n        //normal enviroments in sane situations\r\n        return setTimeout(fun, 0);\r\n    }\r\n    // if setTimeout wasn't available but was latter defined\r\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\r\n        cachedSetTimeout = setTimeout;\r\n        return setTimeout(fun, 0);\r\n    }\r\n    try {\r\n        // when when somebody has screwed with setTimeout but no I.E. maddness\r\n        return cachedSetTimeout(fun, 0);\r\n    } catch(e){\r\n        try {\r\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\r\n            return cachedSetTimeout.call(null, fun, 0);\r\n        } catch(e){\r\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\r\n            return cachedSetTimeout.call(this, fun, 0);\r\n        }\r\n    }\r\n\r\n\r\n}\r\nfunction runClearTimeout(marker) {\r\n    if (cachedClearTimeout === clearTimeout) {\r\n        //normal enviroments in sane situations\r\n        return clearTimeout(marker);\r\n    }\r\n    // if clearTimeout wasn't available but was latter defined\r\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\r\n        cachedClearTimeout = clearTimeout;\r\n        return clearTimeout(marker);\r\n    }\r\n    try {\r\n        // when when somebody has screwed with setTimeout but no I.E. maddness\r\n        return cachedClearTimeout(marker);\r\n    } catch (e){\r\n        try {\r\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\r\n            return cachedClearTimeout.call(null, marker);\r\n        } catch (e){\r\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\r\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\r\n            return cachedClearTimeout.call(this, marker);\r\n        }\r\n    }\r\n\r\n\r\n\r\n}\r\nvar queue = [];\r\nvar draining = false;\r\nvar currentQueue;\r\nvar queueIndex = -1;\r\n\r\nfunction cleanUpNextTick() {\r\n    if (!draining || !currentQueue) {\r\n        return;\r\n    }\r\n    draining = false;\r\n    if (currentQueue.length) {\r\n        queue = currentQueue.concat(queue);\r\n    } else {\r\n        queueIndex = -1;\r\n    }\r\n    if (queue.length) {\r\n        drainQueue();\r\n    }\r\n}\r\n\r\nfunction drainQueue() {\r\n    if (draining) {\r\n        return;\r\n    }\r\n    var timeout = runTimeout(cleanUpNextTick);\r\n    draining = true;\r\n\r\n    var len = queue.length;\r\n    while(len) {\r\n        currentQueue = queue;\r\n        queue = [];\r\n        while (++queueIndex < len) {\r\n            if (currentQueue) {\r\n                currentQueue[queueIndex].run();\r\n            }\r\n        }\r\n        queueIndex = -1;\r\n        len = queue.length;\r\n    }\r\n    currentQueue = null;\r\n    draining = false;\r\n    runClearTimeout(timeout);\r\n}\r\n\r\nprocess.nextTick = function (fun) {\r\n    var args = new Array(arguments.length - 1);\r\n    if (arguments.length > 1) {\r\n        for (var i = 1; i < arguments.length; i++) {\r\n            args[i - 1] = arguments[i];\r\n        }\r\n    }\r\n    queue.push(new Item(fun, args));\r\n    if (queue.length === 1 && !draining) {\r\n        runTimeout(drainQueue);\r\n    }\r\n};\r\n\r\n// v8 likes predictible objects\r\nfunction Item(fun, array) {\r\n    this.fun = fun;\r\n    this.array = array;\r\n}\r\nItem.prototype.run = function () {\r\n    this.fun.apply(null, this.array);\r\n};\r\nprocess.title = 'browser';\r\nprocess.browser = true;\r\nprocess.env = {};\r\nprocess.argv = [];\r\nprocess.version = ''; // empty string to avoid regexp issues\r\nprocess.versions = {};\r\n\r\nfunction noop() {}\r\n\r\nprocess.on = noop;\r\nprocess.addListener = noop;\r\nprocess.once = noop;\r\nprocess.off = noop;\r\nprocess.removeListener = noop;\r\nprocess.removeAllListeners = noop;\r\nprocess.emit = noop;\r\nprocess.prependListener = noop;\r\nprocess.prependOnceListener = noop;\r\n\r\nprocess.listeners = function (name) { return [] }\r\n\r\nprocess.binding = function (name) {\r\n    throw new Error('process.binding is not supported');\r\n};\r\n\r\nprocess.cwd = function () { return '/' };\r\nprocess.chdir = function (dir) {\r\n    throw new Error('process.chdir is not supported');\r\n};\r\nprocess.umask = function() { return 0; };\r\n\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/querystring-es3/decode.js":
/*!************************************************!*\
  !*** ./node_modules/querystring-es3/decode.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the\r\n// \"Software\"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n// persons to whom the Software is furnished to do so, subject to the\r\n// following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n\r\n\r\n// If obj.hasOwnProperty has been overridden, then calling\r\n// obj.hasOwnProperty(prop) will break.\r\n// See: https://github.com/joyent/node/issues/1707\r\nfunction hasOwnProperty(obj, prop) {\r\n  return Object.prototype.hasOwnProperty.call(obj, prop);\r\n}\r\n\r\nmodule.exports = function(qs, sep, eq, options) {\r\n  sep = sep || '&';\r\n  eq = eq || '=';\r\n  var obj = {};\r\n\r\n  if (typeof qs !== 'string' || qs.length === 0) {\r\n    return obj;\r\n  }\r\n\r\n  var regexp = /\\+/g;\r\n  qs = qs.split(sep);\r\n\r\n  var maxKeys = 1000;\r\n  if (options && typeof options.maxKeys === 'number') {\r\n    maxKeys = options.maxKeys;\r\n  }\r\n\r\n  var len = qs.length;\r\n  // maxKeys <= 0 means that we should not limit keys count\r\n  if (maxKeys > 0 && len > maxKeys) {\r\n    len = maxKeys;\r\n  }\r\n\r\n  for (var i = 0; i < len; ++i) {\r\n    var x = qs[i].replace(regexp, '%20'),\r\n        idx = x.indexOf(eq),\r\n        kstr, vstr, k, v;\r\n\r\n    if (idx >= 0) {\r\n      kstr = x.substr(0, idx);\r\n      vstr = x.substr(idx + 1);\r\n    } else {\r\n      kstr = x;\r\n      vstr = '';\r\n    }\r\n\r\n    k = decodeURIComponent(kstr);\r\n    v = decodeURIComponent(vstr);\r\n\r\n    if (!hasOwnProperty(obj, k)) {\r\n      obj[k] = v;\r\n    } else if (isArray(obj[k])) {\r\n      obj[k].push(v);\r\n    } else {\r\n      obj[k] = [obj[k], v];\r\n    }\r\n  }\r\n\r\n  return obj;\r\n};\r\n\r\nvar isArray = Array.isArray || function (xs) {\r\n  return Object.prototype.toString.call(xs) === '[object Array]';\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/querystring-es3/decode.js?");

/***/ }),

/***/ "./node_modules/querystring-es3/encode.js":
/*!************************************************!*\
  !*** ./node_modules/querystring-es3/encode.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the\r\n// \"Software\"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n// persons to whom the Software is furnished to do so, subject to the\r\n// following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n\r\n\r\nvar stringifyPrimitive = function(v) {\r\n  switch (typeof v) {\r\n    case 'string':\r\n      return v;\r\n\r\n    case 'boolean':\r\n      return v ? 'true' : 'false';\r\n\r\n    case 'number':\r\n      return isFinite(v) ? v : '';\r\n\r\n    default:\r\n      return '';\r\n  }\r\n};\r\n\r\nmodule.exports = function(obj, sep, eq, name) {\r\n  sep = sep || '&';\r\n  eq = eq || '=';\r\n  if (obj === null) {\r\n    obj = undefined;\r\n  }\r\n\r\n  if (typeof obj === 'object') {\r\n    return map(objectKeys(obj), function(k) {\r\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\r\n      if (isArray(obj[k])) {\r\n        return map(obj[k], function(v) {\r\n          return ks + encodeURIComponent(stringifyPrimitive(v));\r\n        }).join(sep);\r\n      } else {\r\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\r\n      }\r\n    }).join(sep);\r\n\r\n  }\r\n\r\n  if (!name) return '';\r\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\r\n         encodeURIComponent(stringifyPrimitive(obj));\r\n};\r\n\r\nvar isArray = Array.isArray || function (xs) {\r\n  return Object.prototype.toString.call(xs) === '[object Array]';\r\n};\r\n\r\nfunction map (xs, f) {\r\n  if (xs.map) return xs.map(f);\r\n  var res = [];\r\n  for (var i = 0; i < xs.length; i++) {\r\n    res.push(f(xs[i], i));\r\n  }\r\n  return res;\r\n}\r\n\r\nvar objectKeys = Object.keys || function (obj) {\r\n  var res = [];\r\n  for (var key in obj) {\r\n    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\r\n  }\r\n  return res;\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/querystring-es3/encode.js?");

/***/ }),

/***/ "./node_modules/querystring-es3/index.js":
/*!***********************************************!*\
  !*** ./node_modules/querystring-es3/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nexports.decode = exports.parse = __webpack_require__(/*! ./decode */ \"./node_modules/querystring-es3/decode.js\");\r\nexports.encode = exports.stringify = __webpack_require__(/*! ./encode */ \"./node_modules/querystring-es3/encode.js\");\r\n\n\n//# sourceURL=webpack:///./node_modules/querystring-es3/index.js?");

/***/ }),

/***/ "./node_modules/readable-stream/duplex-browser.js":
/*!********************************************************!*\
  !*** ./node_modules/readable-stream/duplex-browser.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./lib/_stream_duplex.js */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\r\n\n\n//# sourceURL=webpack:///./node_modules/readable-stream/duplex-browser.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_duplex.js":
/*!************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_duplex.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the\r\n// \"Software\"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n// persons to whom the Software is furnished to do so, subject to the\r\n// following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n// a duplex stream is just a stream that is both readable and writable.\r\n// Since JS doesn't have multiple prototypal inheritance, this class\r\n// prototypally inherits from Readable, and then parasitically from\r\n// Writable.\r\n\r\n\r\n\r\n/*<replacement>*/\r\n\r\nvar pna = __webpack_require__(/*! process-nextick-args */ \"./node_modules/process-nextick-args/index.js\");\r\n/*</replacement>*/\r\n\r\n/*<replacement>*/\r\nvar objectKeys = Object.keys || function (obj) {\r\n  var keys = [];\r\n  for (var key in obj) {\r\n    keys.push(key);\r\n  }return keys;\r\n};\r\n/*</replacement>*/\r\n\r\nmodule.exports = Duplex;\r\n\r\n/*<replacement>*/\r\nvar util = Object.create(__webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\"));\r\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\r\n/*</replacement>*/\r\n\r\nvar Readable = __webpack_require__(/*! ./_stream_readable */ \"./node_modules/readable-stream/lib/_stream_readable.js\");\r\nvar Writable = __webpack_require__(/*! ./_stream_writable */ \"./node_modules/readable-stream/lib/_stream_writable.js\");\r\n\r\nutil.inherits(Duplex, Readable);\r\n\r\n{\r\n  // avoid scope creep, the keys array can then be collected\r\n  var keys = objectKeys(Writable.prototype);\r\n  for (var v = 0; v < keys.length; v++) {\r\n    var method = keys[v];\r\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\r\n  }\r\n}\r\n\r\nfunction Duplex(options) {\r\n  if (!(this instanceof Duplex)) return new Duplex(options);\r\n\r\n  Readable.call(this, options);\r\n  Writable.call(this, options);\r\n\r\n  if (options && options.readable === false) this.readable = false;\r\n\r\n  if (options && options.writable === false) this.writable = false;\r\n\r\n  this.allowHalfOpen = true;\r\n  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\r\n\r\n  this.once('end', onend);\r\n}\r\n\r\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\r\n  // making it explicit this property is not enumerable\r\n  // because otherwise some prototype manipulation in\r\n  // userland will fail\r\n  enumerable: false,\r\n  get: function () {\r\n    return this._writableState.highWaterMark;\r\n  }\r\n});\r\n\r\n// the no-half-open enforcer\r\nfunction onend() {\r\n  // if we allow half-open state, or if the writable side ended,\r\n  // then we're ok.\r\n  if (this.allowHalfOpen || this._writableState.ended) return;\r\n\r\n  // no more data can be written.\r\n  // But allow more writes to happen in this tick.\r\n  pna.nextTick(onEndNT, this);\r\n}\r\n\r\nfunction onEndNT(self) {\r\n  self.end();\r\n}\r\n\r\nObject.defineProperty(Duplex.prototype, 'destroyed', {\r\n  get: function () {\r\n    if (this._readableState === undefined || this._writableState === undefined) {\r\n      return false;\r\n    }\r\n    return this._readableState.destroyed && this._writableState.destroyed;\r\n  },\r\n  set: function (value) {\r\n    // we ignore the value if the stream\r\n    // has not been initialized yet\r\n    if (this._readableState === undefined || this._writableState === undefined) {\r\n      return;\r\n    }\r\n\r\n    // backward compatibility, the user is explicitly\r\n    // managing destroyed\r\n    this._readableState.destroyed = value;\r\n    this._writableState.destroyed = value;\r\n  }\r\n});\r\n\r\nDuplex.prototype._destroy = function (err, cb) {\r\n  this.push(null);\r\n  this.end();\r\n\r\n  pna.nextTick(cb, err);\r\n};\n\n//# sourceURL=webpack:///./node_modules/readable-stream/lib/_stream_duplex.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_passthrough.js":
/*!*****************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_passthrough.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the\r\n// \"Software\"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n// persons to whom the Software is furnished to do so, subject to the\r\n// following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n// a passthrough stream.\r\n// basically just the most minimal sort of Transform stream.\r\n// Every written chunk gets output as-is.\r\n\r\n\r\n\r\nmodule.exports = PassThrough;\r\n\r\nvar Transform = __webpack_require__(/*! ./_stream_transform */ \"./node_modules/readable-stream/lib/_stream_transform.js\");\r\n\r\n/*<replacement>*/\r\nvar util = Object.create(__webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\"));\r\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\r\n/*</replacement>*/\r\n\r\nutil.inherits(PassThrough, Transform);\r\n\r\nfunction PassThrough(options) {\r\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\r\n\r\n  Transform.call(this, options);\r\n}\r\n\r\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\r\n  cb(null, chunk);\r\n};\n\n//# sourceURL=webpack:///./node_modules/readable-stream/lib/_stream_passthrough.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_readable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_readable.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the\r\n// \"Software\"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n// persons to whom the Software is furnished to do so, subject to the\r\n// following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n\r\n\r\n/*<replacement>*/\r\n\r\nvar pna = __webpack_require__(/*! process-nextick-args */ \"./node_modules/process-nextick-args/index.js\");\r\n/*</replacement>*/\r\n\r\nmodule.exports = Readable;\r\n\r\n/*<replacement>*/\r\nvar isArray = __webpack_require__(/*! isarray */ \"./node_modules/isarray/index.js\");\r\n/*</replacement>*/\r\n\r\n/*<replacement>*/\r\nvar Duplex;\r\n/*</replacement>*/\r\n\r\nReadable.ReadableState = ReadableState;\r\n\r\n/*<replacement>*/\r\nvar EE = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\r\n\r\nvar EElistenerCount = function (emitter, type) {\r\n  return emitter.listeners(type).length;\r\n};\r\n/*</replacement>*/\r\n\r\n/*<replacement>*/\r\nvar Stream = __webpack_require__(/*! ./internal/streams/stream */ \"./node_modules/readable-stream/lib/internal/streams/stream-browser.js\");\r\n/*</replacement>*/\r\n\r\n/*<replacement>*/\r\n\r\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer;\r\nvar OurUint8Array = global.Uint8Array || function () {};\r\nfunction _uint8ArrayToBuffer(chunk) {\r\n  return Buffer.from(chunk);\r\n}\r\nfunction _isUint8Array(obj) {\r\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\r\n}\r\n\r\n/*</replacement>*/\r\n\r\n/*<replacement>*/\r\nvar util = Object.create(__webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\"));\r\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\r\n/*</replacement>*/\r\n\r\n/*<replacement>*/\r\nvar debugUtil = __webpack_require__(/*! util */ 1);\r\nvar debug = void 0;\r\nif (debugUtil && debugUtil.debuglog) {\r\n  debug = debugUtil.debuglog('stream');\r\n} else {\r\n  debug = function () {};\r\n}\r\n/*</replacement>*/\r\n\r\nvar BufferList = __webpack_require__(/*! ./internal/streams/BufferList */ \"./node_modules/readable-stream/lib/internal/streams/BufferList.js\");\r\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \"./node_modules/readable-stream/lib/internal/streams/destroy.js\");\r\nvar StringDecoder;\r\n\r\nutil.inherits(Readable, Stream);\r\n\r\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\r\n\r\nfunction prependListener(emitter, event, fn) {\r\n  // Sadly this is not cacheable as some libraries bundle their own\r\n  // event emitter implementation with them.\r\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);\r\n\r\n  // This is a hack to make sure that our error handler is attached before any\r\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\r\n  // to continue to work with older versions of Node.js that do not include\r\n  // the prependListener() method. The goal is to eventually remove this hack.\r\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\r\n}\r\n\r\nfunction ReadableState(options, stream) {\r\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\r\n\r\n  options = options || {};\r\n\r\n  // Duplex streams are both readable and writable, but share\r\n  // the same options object.\r\n  // However, some cases require setting options to different\r\n  // values for the readable and the writable sides of the duplex stream.\r\n  // These options can be provided separately as readableXXX and writableXXX.\r\n  var isDuplex = stream instanceof Duplex;\r\n\r\n  // object stream flag. Used to make read(n) ignore n and to\r\n  // make all the buffer merging and length checks go away\r\n  this.objectMode = !!options.objectMode;\r\n\r\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\r\n\r\n  // the point at which it stops calling _read() to fill the buffer\r\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\r\n  var hwm = options.highWaterMark;\r\n  var readableHwm = options.readableHighWaterMark;\r\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\r\n\r\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;\r\n\r\n  // cast to ints.\r\n  this.highWaterMark = Math.floor(this.highWaterMark);\r\n\r\n  // A linked list is used to store data chunks instead of an array because the\r\n  // linked list can remove elements from the beginning faster than\r\n  // array.shift()\r\n  this.buffer = new BufferList();\r\n  this.length = 0;\r\n  this.pipes = null;\r\n  this.pipesCount = 0;\r\n  this.flowing = null;\r\n  this.ended = false;\r\n  this.endEmitted = false;\r\n  this.reading = false;\r\n\r\n  // a flag to be able to tell if the event 'readable'/'data' is emitted\r\n  // immediately, or on a later tick.  We set this to true at first, because\r\n  // any actions that shouldn't happen until \"later\" should generally also\r\n  // not happen before the first read call.\r\n  this.sync = true;\r\n\r\n  // whenever we return null, then we set a flag to say\r\n  // that we're awaiting a 'readable' event emission.\r\n  this.needReadable = false;\r\n  this.emittedReadable = false;\r\n  this.readableListening = false;\r\n  this.resumeScheduled = false;\r\n\r\n  // has it been destroyed\r\n  this.destroyed = false;\r\n\r\n  // Crypto is kind of old and crusty.  Historically, its default string\r\n  // encoding is 'binary' so we have to make this configurable.\r\n  // Everything else in the universe uses 'utf8', though.\r\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\r\n\r\n  // the number of writers that are awaiting a drain event in .pipe()s\r\n  this.awaitDrain = 0;\r\n\r\n  // if true, a maybeReadMore has been scheduled\r\n  this.readingMore = false;\r\n\r\n  this.decoder = null;\r\n  this.encoding = null;\r\n  if (options.encoding) {\r\n    if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ \"./node_modules/string_decoder/lib/string_decoder.js\").StringDecoder;\r\n    this.decoder = new StringDecoder(options.encoding);\r\n    this.encoding = options.encoding;\r\n  }\r\n}\r\n\r\nfunction Readable(options) {\r\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\r\n\r\n  if (!(this instanceof Readable)) return new Readable(options);\r\n\r\n  this._readableState = new ReadableState(options, this);\r\n\r\n  // legacy\r\n  this.readable = true;\r\n\r\n  if (options) {\r\n    if (typeof options.read === 'function') this._read = options.read;\r\n\r\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\r\n  }\r\n\r\n  Stream.call(this);\r\n}\r\n\r\nObject.defineProperty(Readable.prototype, 'destroyed', {\r\n  get: function () {\r\n    if (this._readableState === undefined) {\r\n      return false;\r\n    }\r\n    return this._readableState.destroyed;\r\n  },\r\n  set: function (value) {\r\n    // we ignore the value if the stream\r\n    // has not been initialized yet\r\n    if (!this._readableState) {\r\n      return;\r\n    }\r\n\r\n    // backward compatibility, the user is explicitly\r\n    // managing destroyed\r\n    this._readableState.destroyed = value;\r\n  }\r\n});\r\n\r\nReadable.prototype.destroy = destroyImpl.destroy;\r\nReadable.prototype._undestroy = destroyImpl.undestroy;\r\nReadable.prototype._destroy = function (err, cb) {\r\n  this.push(null);\r\n  cb(err);\r\n};\r\n\r\n// Manually shove something into the read() buffer.\r\n// This returns true if the highWaterMark has not been hit yet,\r\n// similar to how Writable.write() returns true if you should\r\n// write() some more.\r\nReadable.prototype.push = function (chunk, encoding) {\r\n  var state = this._readableState;\r\n  var skipChunkCheck;\r\n\r\n  if (!state.objectMode) {\r\n    if (typeof chunk === 'string') {\r\n      encoding = encoding || state.defaultEncoding;\r\n      if (encoding !== state.encoding) {\r\n        chunk = Buffer.from(chunk, encoding);\r\n        encoding = '';\r\n      }\r\n      skipChunkCheck = true;\r\n    }\r\n  } else {\r\n    skipChunkCheck = true;\r\n  }\r\n\r\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\r\n};\r\n\r\n// Unshift should *always* be something directly out of read()\r\nReadable.prototype.unshift = function (chunk) {\r\n  return readableAddChunk(this, chunk, null, true, false);\r\n};\r\n\r\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\r\n  var state = stream._readableState;\r\n  if (chunk === null) {\r\n    state.reading = false;\r\n    onEofChunk(stream, state);\r\n  } else {\r\n    var er;\r\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\r\n    if (er) {\r\n      stream.emit('error', er);\r\n    } else if (state.objectMode || chunk && chunk.length > 0) {\r\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\r\n        chunk = _uint8ArrayToBuffer(chunk);\r\n      }\r\n\r\n      if (addToFront) {\r\n        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);\r\n      } else if (state.ended) {\r\n        stream.emit('error', new Error('stream.push() after EOF'));\r\n      } else {\r\n        state.reading = false;\r\n        if (state.decoder && !encoding) {\r\n          chunk = state.decoder.write(chunk);\r\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\r\n        } else {\r\n          addChunk(stream, state, chunk, false);\r\n        }\r\n      }\r\n    } else if (!addToFront) {\r\n      state.reading = false;\r\n    }\r\n  }\r\n\r\n  return needMoreData(state);\r\n}\r\n\r\nfunction addChunk(stream, state, chunk, addToFront) {\r\n  if (state.flowing && state.length === 0 && !state.sync) {\r\n    stream.emit('data', chunk);\r\n    stream.read(0);\r\n  } else {\r\n    // update the buffer info.\r\n    state.length += state.objectMode ? 1 : chunk.length;\r\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\r\n\r\n    if (state.needReadable) emitReadable(stream);\r\n  }\r\n  maybeReadMore(stream, state);\r\n}\r\n\r\nfunction chunkInvalid(state, chunk) {\r\n  var er;\r\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\r\n    er = new TypeError('Invalid non-string/buffer chunk');\r\n  }\r\n  return er;\r\n}\r\n\r\n// if it's past the high water mark, we can push in some more.\r\n// Also, if we have no data yet, we can stand some\r\n// more bytes.  This is to work around cases where hwm=0,\r\n// such as the repl.  Also, if the push() triggered a\r\n// readable event, and the user called read(largeNumber) such that\r\n// needReadable was set, then we ought to push more, so that another\r\n// 'readable' event will be triggered.\r\nfunction needMoreData(state) {\r\n  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\r\n}\r\n\r\nReadable.prototype.isPaused = function () {\r\n  return this._readableState.flowing === false;\r\n};\r\n\r\n// backwards compatibility.\r\nReadable.prototype.setEncoding = function (enc) {\r\n  if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ \"./node_modules/string_decoder/lib/string_decoder.js\").StringDecoder;\r\n  this._readableState.decoder = new StringDecoder(enc);\r\n  this._readableState.encoding = enc;\r\n  return this;\r\n};\r\n\r\n// Don't raise the hwm > 8MB\r\nvar MAX_HWM = 0x800000;\r\nfunction computeNewHighWaterMark(n) {\r\n  if (n >= MAX_HWM) {\r\n    n = MAX_HWM;\r\n  } else {\r\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\r\n    // tiny amounts\r\n    n--;\r\n    n |= n >>> 1;\r\n    n |= n >>> 2;\r\n    n |= n >>> 4;\r\n    n |= n >>> 8;\r\n    n |= n >>> 16;\r\n    n++;\r\n  }\r\n  return n;\r\n}\r\n\r\n// This function is designed to be inlinable, so please take care when making\r\n// changes to the function body.\r\nfunction howMuchToRead(n, state) {\r\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\r\n  if (state.objectMode) return 1;\r\n  if (n !== n) {\r\n    // Only flow one buffer at a time\r\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\r\n  }\r\n  // If we're asking for more than the current hwm, then raise the hwm.\r\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\r\n  if (n <= state.length) return n;\r\n  // Don't have enough\r\n  if (!state.ended) {\r\n    state.needReadable = true;\r\n    return 0;\r\n  }\r\n  return state.length;\r\n}\r\n\r\n// you can override either this method, or the async _read(n) below.\r\nReadable.prototype.read = function (n) {\r\n  debug('read', n);\r\n  n = parseInt(n, 10);\r\n  var state = this._readableState;\r\n  var nOrig = n;\r\n\r\n  if (n !== 0) state.emittedReadable = false;\r\n\r\n  // if we're doing read(0) to trigger a readable event, but we\r\n  // already have a bunch of data in the buffer, then just trigger\r\n  // the 'readable' event and move on.\r\n  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\r\n    debug('read: emitReadable', state.length, state.ended);\r\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\r\n    return null;\r\n  }\r\n\r\n  n = howMuchToRead(n, state);\r\n\r\n  // if we've ended, and we're now clear, then finish it up.\r\n  if (n === 0 && state.ended) {\r\n    if (state.length === 0) endReadable(this);\r\n    return null;\r\n  }\r\n\r\n  // All the actual chunk generation logic needs to be\r\n  // *below* the call to _read.  The reason is that in certain\r\n  // synthetic stream cases, such as passthrough streams, _read\r\n  // may be a completely synchronous operation which may change\r\n  // the state of the read buffer, providing enough data when\r\n  // before there was *not* enough.\r\n  //\r\n  // So, the steps are:\r\n  // 1. Figure out what the state of things will be after we do\r\n  // a read from the buffer.\r\n  //\r\n  // 2. If that resulting state will trigger a _read, then call _read.\r\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\r\n  // deeply ugly to write APIs this way, but that still doesn't mean\r\n  // that the Readable class should behave improperly, as streams are\r\n  // designed to be sync/async agnostic.\r\n  // Take note if the _read call is sync or async (ie, if the read call\r\n  // has returned yet), so that we know whether or not it's safe to emit\r\n  // 'readable' etc.\r\n  //\r\n  // 3. Actually pull the requested chunks out of the buffer and return.\r\n\r\n  // if we need a readable event, then we need to do some reading.\r\n  var doRead = state.needReadable;\r\n  debug('need readable', doRead);\r\n\r\n  // if we currently have less than the highWaterMark, then also read some\r\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\r\n    doRead = true;\r\n    debug('length less than watermark', doRead);\r\n  }\r\n\r\n  // however, if we've ended, then there's no point, and if we're already\r\n  // reading, then it's unnecessary.\r\n  if (state.ended || state.reading) {\r\n    doRead = false;\r\n    debug('reading or ended', doRead);\r\n  } else if (doRead) {\r\n    debug('do read');\r\n    state.reading = true;\r\n    state.sync = true;\r\n    // if the length is currently zero, then we *need* a readable event.\r\n    if (state.length === 0) state.needReadable = true;\r\n    // call internal read method\r\n    this._read(state.highWaterMark);\r\n    state.sync = false;\r\n    // If _read pushed data synchronously, then `reading` will be false,\r\n    // and we need to re-evaluate how much data we can return to the user.\r\n    if (!state.reading) n = howMuchToRead(nOrig, state);\r\n  }\r\n\r\n  var ret;\r\n  if (n > 0) ret = fromList(n, state);else ret = null;\r\n\r\n  if (ret === null) {\r\n    state.needReadable = true;\r\n    n = 0;\r\n  } else {\r\n    state.length -= n;\r\n  }\r\n\r\n  if (state.length === 0) {\r\n    // If we have nothing in the buffer, then we want to know\r\n    // as soon as we *do* get something into the buffer.\r\n    if (!state.ended) state.needReadable = true;\r\n\r\n    // If we tried to read() past the EOF, then emit end on the next tick.\r\n    if (nOrig !== n && state.ended) endReadable(this);\r\n  }\r\n\r\n  if (ret !== null) this.emit('data', ret);\r\n\r\n  return ret;\r\n};\r\n\r\nfunction onEofChunk(stream, state) {\r\n  if (state.ended) return;\r\n  if (state.decoder) {\r\n    var chunk = state.decoder.end();\r\n    if (chunk && chunk.length) {\r\n      state.buffer.push(chunk);\r\n      state.length += state.objectMode ? 1 : chunk.length;\r\n    }\r\n  }\r\n  state.ended = true;\r\n\r\n  // emit 'readable' now to make sure it gets picked up.\r\n  emitReadable(stream);\r\n}\r\n\r\n// Don't emit readable right away in sync mode, because this can trigger\r\n// another read() call => stack overflow.  This way, it might trigger\r\n// a nextTick recursion warning, but that's not so bad.\r\nfunction emitReadable(stream) {\r\n  var state = stream._readableState;\r\n  state.needReadable = false;\r\n  if (!state.emittedReadable) {\r\n    debug('emitReadable', state.flowing);\r\n    state.emittedReadable = true;\r\n    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);\r\n  }\r\n}\r\n\r\nfunction emitReadable_(stream) {\r\n  debug('emit readable');\r\n  stream.emit('readable');\r\n  flow(stream);\r\n}\r\n\r\n// at this point, the user has presumably seen the 'readable' event,\r\n// and called read() to consume some data.  that may have triggered\r\n// in turn another _read(n) call, in which case reading = true if\r\n// it's in progress.\r\n// However, if we're not ended, or reading, and the length < hwm,\r\n// then go ahead and try to read some more preemptively.\r\nfunction maybeReadMore(stream, state) {\r\n  if (!state.readingMore) {\r\n    state.readingMore = true;\r\n    pna.nextTick(maybeReadMore_, stream, state);\r\n  }\r\n}\r\n\r\nfunction maybeReadMore_(stream, state) {\r\n  var len = state.length;\r\n  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\r\n    debug('maybeReadMore read 0');\r\n    stream.read(0);\r\n    if (len === state.length)\r\n      // didn't get any data, stop spinning.\r\n      break;else len = state.length;\r\n  }\r\n  state.readingMore = false;\r\n}\r\n\r\n// abstract method.  to be overridden in specific implementation classes.\r\n// call cb(er, data) where data is <= n in length.\r\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\r\n// arbitrary, and perhaps not very meaningful.\r\nReadable.prototype._read = function (n) {\r\n  this.emit('error', new Error('_read() is not implemented'));\r\n};\r\n\r\nReadable.prototype.pipe = function (dest, pipeOpts) {\r\n  var src = this;\r\n  var state = this._readableState;\r\n\r\n  switch (state.pipesCount) {\r\n    case 0:\r\n      state.pipes = dest;\r\n      break;\r\n    case 1:\r\n      state.pipes = [state.pipes, dest];\r\n      break;\r\n    default:\r\n      state.pipes.push(dest);\r\n      break;\r\n  }\r\n  state.pipesCount += 1;\r\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\r\n\r\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\r\n\r\n  var endFn = doEnd ? onend : unpipe;\r\n  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);\r\n\r\n  dest.on('unpipe', onunpipe);\r\n  function onunpipe(readable, unpipeInfo) {\r\n    debug('onunpipe');\r\n    if (readable === src) {\r\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\r\n        unpipeInfo.hasUnpiped = true;\r\n        cleanup();\r\n      }\r\n    }\r\n  }\r\n\r\n  function onend() {\r\n    debug('onend');\r\n    dest.end();\r\n  }\r\n\r\n  // when the dest drains, it reduces the awaitDrain counter\r\n  // on the source.  This would be more elegant with a .once()\r\n  // handler in flow(), but adding and removing repeatedly is\r\n  // too slow.\r\n  var ondrain = pipeOnDrain(src);\r\n  dest.on('drain', ondrain);\r\n\r\n  var cleanedUp = false;\r\n  function cleanup() {\r\n    debug('cleanup');\r\n    // cleanup event handlers once the pipe is broken\r\n    dest.removeListener('close', onclose);\r\n    dest.removeListener('finish', onfinish);\r\n    dest.removeListener('drain', ondrain);\r\n    dest.removeListener('error', onerror);\r\n    dest.removeListener('unpipe', onunpipe);\r\n    src.removeListener('end', onend);\r\n    src.removeListener('end', unpipe);\r\n    src.removeListener('data', ondata);\r\n\r\n    cleanedUp = true;\r\n\r\n    // if the reader is waiting for a drain event from this\r\n    // specific writer, then it would cause it to never start\r\n    // flowing again.\r\n    // So, if this is awaiting a drain, then we just call it now.\r\n    // If we don't know, then assume that we are waiting for one.\r\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\r\n  }\r\n\r\n  // If the user pushes more data while we're writing to dest then we'll end up\r\n  // in ondata again. However, we only want to increase awaitDrain once because\r\n  // dest will only emit one 'drain' event for the multiple writes.\r\n  // => Introduce a guard on increasing awaitDrain.\r\n  var increasedAwaitDrain = false;\r\n  src.on('data', ondata);\r\n  function ondata(chunk) {\r\n    debug('ondata');\r\n    increasedAwaitDrain = false;\r\n    var ret = dest.write(chunk);\r\n    if (false === ret && !increasedAwaitDrain) {\r\n      // If the user unpiped during `dest.write()`, it is possible\r\n      // to get stuck in a permanently paused state if that write\r\n      // also returned false.\r\n      // => Check whether `dest` is still a piping destination.\r\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\r\n        debug('false write response, pause', src._readableState.awaitDrain);\r\n        src._readableState.awaitDrain++;\r\n        increasedAwaitDrain = true;\r\n      }\r\n      src.pause();\r\n    }\r\n  }\r\n\r\n  // if the dest has an error, then stop piping into it.\r\n  // however, don't suppress the throwing behavior for this.\r\n  function onerror(er) {\r\n    debug('onerror', er);\r\n    unpipe();\r\n    dest.removeListener('error', onerror);\r\n    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\r\n  }\r\n\r\n  // Make sure our error handler is attached before userland ones.\r\n  prependListener(dest, 'error', onerror);\r\n\r\n  // Both close and finish should trigger unpipe, but only once.\r\n  function onclose() {\r\n    dest.removeListener('finish', onfinish);\r\n    unpipe();\r\n  }\r\n  dest.once('close', onclose);\r\n  function onfinish() {\r\n    debug('onfinish');\r\n    dest.removeListener('close', onclose);\r\n    unpipe();\r\n  }\r\n  dest.once('finish', onfinish);\r\n\r\n  function unpipe() {\r\n    debug('unpipe');\r\n    src.unpipe(dest);\r\n  }\r\n\r\n  // tell the dest that it's being piped to\r\n  dest.emit('pipe', src);\r\n\r\n  // start the flow if it hasn't been started already.\r\n  if (!state.flowing) {\r\n    debug('pipe resume');\r\n    src.resume();\r\n  }\r\n\r\n  return dest;\r\n};\r\n\r\nfunction pipeOnDrain(src) {\r\n  return function () {\r\n    var state = src._readableState;\r\n    debug('pipeOnDrain', state.awaitDrain);\r\n    if (state.awaitDrain) state.awaitDrain--;\r\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\r\n      state.flowing = true;\r\n      flow(src);\r\n    }\r\n  };\r\n}\r\n\r\nReadable.prototype.unpipe = function (dest) {\r\n  var state = this._readableState;\r\n  var unpipeInfo = { hasUnpiped: false };\r\n\r\n  // if we're not piping anywhere, then do nothing.\r\n  if (state.pipesCount === 0) return this;\r\n\r\n  // just one destination.  most common case.\r\n  if (state.pipesCount === 1) {\r\n    // passed in one, but it's not the right one.\r\n    if (dest && dest !== state.pipes) return this;\r\n\r\n    if (!dest) dest = state.pipes;\r\n\r\n    // got a match.\r\n    state.pipes = null;\r\n    state.pipesCount = 0;\r\n    state.flowing = false;\r\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\r\n    return this;\r\n  }\r\n\r\n  // slow case. multiple pipe destinations.\r\n\r\n  if (!dest) {\r\n    // remove all.\r\n    var dests = state.pipes;\r\n    var len = state.pipesCount;\r\n    state.pipes = null;\r\n    state.pipesCount = 0;\r\n    state.flowing = false;\r\n\r\n    for (var i = 0; i < len; i++) {\r\n      dests[i].emit('unpipe', this, unpipeInfo);\r\n    }return this;\r\n  }\r\n\r\n  // try to find the right one.\r\n  var index = indexOf(state.pipes, dest);\r\n  if (index === -1) return this;\r\n\r\n  state.pipes.splice(index, 1);\r\n  state.pipesCount -= 1;\r\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\r\n\r\n  dest.emit('unpipe', this, unpipeInfo);\r\n\r\n  return this;\r\n};\r\n\r\n// set up data events if they are asked for\r\n// Ensure readable listeners eventually get something\r\nReadable.prototype.on = function (ev, fn) {\r\n  var res = Stream.prototype.on.call(this, ev, fn);\r\n\r\n  if (ev === 'data') {\r\n    // Start flowing on next tick if stream isn't explicitly paused\r\n    if (this._readableState.flowing !== false) this.resume();\r\n  } else if (ev === 'readable') {\r\n    var state = this._readableState;\r\n    if (!state.endEmitted && !state.readableListening) {\r\n      state.readableListening = state.needReadable = true;\r\n      state.emittedReadable = false;\r\n      if (!state.reading) {\r\n        pna.nextTick(nReadingNextTick, this);\r\n      } else if (state.length) {\r\n        emitReadable(this);\r\n      }\r\n    }\r\n  }\r\n\r\n  return res;\r\n};\r\nReadable.prototype.addListener = Readable.prototype.on;\r\n\r\nfunction nReadingNextTick(self) {\r\n  debug('readable nexttick read 0');\r\n  self.read(0);\r\n}\r\n\r\n// pause() and resume() are remnants of the legacy readable stream API\r\n// If the user uses them, then switch into old mode.\r\nReadable.prototype.resume = function () {\r\n  var state = this._readableState;\r\n  if (!state.flowing) {\r\n    debug('resume');\r\n    state.flowing = true;\r\n    resume(this, state);\r\n  }\r\n  return this;\r\n};\r\n\r\nfunction resume(stream, state) {\r\n  if (!state.resumeScheduled) {\r\n    state.resumeScheduled = true;\r\n    pna.nextTick(resume_, stream, state);\r\n  }\r\n}\r\n\r\nfunction resume_(stream, state) {\r\n  if (!state.reading) {\r\n    debug('resume read 0');\r\n    stream.read(0);\r\n  }\r\n\r\n  state.resumeScheduled = false;\r\n  state.awaitDrain = 0;\r\n  stream.emit('resume');\r\n  flow(stream);\r\n  if (state.flowing && !state.reading) stream.read(0);\r\n}\r\n\r\nReadable.prototype.pause = function () {\r\n  debug('call pause flowing=%j', this._readableState.flowing);\r\n  if (false !== this._readableState.flowing) {\r\n    debug('pause');\r\n    this._readableState.flowing = false;\r\n    this.emit('pause');\r\n  }\r\n  return this;\r\n};\r\n\r\nfunction flow(stream) {\r\n  var state = stream._readableState;\r\n  debug('flow', state.flowing);\r\n  while (state.flowing && stream.read() !== null) {}\r\n}\r\n\r\n// wrap an old-style stream as the async data source.\r\n// This is *not* part of the readable stream interface.\r\n// It is an ugly unfortunate mess of history.\r\nReadable.prototype.wrap = function (stream) {\r\n  var _this = this;\r\n\r\n  var state = this._readableState;\r\n  var paused = false;\r\n\r\n  stream.on('end', function () {\r\n    debug('wrapped end');\r\n    if (state.decoder && !state.ended) {\r\n      var chunk = state.decoder.end();\r\n      if (chunk && chunk.length) _this.push(chunk);\r\n    }\r\n\r\n    _this.push(null);\r\n  });\r\n\r\n  stream.on('data', function (chunk) {\r\n    debug('wrapped data');\r\n    if (state.decoder) chunk = state.decoder.write(chunk);\r\n\r\n    // don't skip over falsy values in objectMode\r\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\r\n\r\n    var ret = _this.push(chunk);\r\n    if (!ret) {\r\n      paused = true;\r\n      stream.pause();\r\n    }\r\n  });\r\n\r\n  // proxy all the other methods.\r\n  // important when wrapping filters and duplexes.\r\n  for (var i in stream) {\r\n    if (this[i] === undefined && typeof stream[i] === 'function') {\r\n      this[i] = function (method) {\r\n        return function () {\r\n          return stream[method].apply(stream, arguments);\r\n        };\r\n      }(i);\r\n    }\r\n  }\r\n\r\n  // proxy certain important events.\r\n  for (var n = 0; n < kProxyEvents.length; n++) {\r\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\r\n  }\r\n\r\n  // when we try to consume some more bytes, simply unpause the\r\n  // underlying stream.\r\n  this._read = function (n) {\r\n    debug('wrapped _read', n);\r\n    if (paused) {\r\n      paused = false;\r\n      stream.resume();\r\n    }\r\n  };\r\n\r\n  return this;\r\n};\r\n\r\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\r\n  // making it explicit this property is not enumerable\r\n  // because otherwise some prototype manipulation in\r\n  // userland will fail\r\n  enumerable: false,\r\n  get: function () {\r\n    return this._readableState.highWaterMark;\r\n  }\r\n});\r\n\r\n// exposed for testing purposes only.\r\nReadable._fromList = fromList;\r\n\r\n// Pluck off n bytes from an array of buffers.\r\n// Length is the combined lengths of all the buffers in the list.\r\n// This function is designed to be inlinable, so please take care when making\r\n// changes to the function body.\r\nfunction fromList(n, state) {\r\n  // nothing buffered\r\n  if (state.length === 0) return null;\r\n\r\n  var ret;\r\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\r\n    // read it all, truncate the list\r\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\r\n    state.buffer.clear();\r\n  } else {\r\n    // read part of list\r\n    ret = fromListPartial(n, state.buffer, state.decoder);\r\n  }\r\n\r\n  return ret;\r\n}\r\n\r\n// Extracts only enough buffered data to satisfy the amount requested.\r\n// This function is designed to be inlinable, so please take care when making\r\n// changes to the function body.\r\nfunction fromListPartial(n, list, hasStrings) {\r\n  var ret;\r\n  if (n < list.head.data.length) {\r\n    // slice is the same for buffers and strings\r\n    ret = list.head.data.slice(0, n);\r\n    list.head.data = list.head.data.slice(n);\r\n  } else if (n === list.head.data.length) {\r\n    // first chunk is a perfect match\r\n    ret = list.shift();\r\n  } else {\r\n    // result spans more than one buffer\r\n    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\r\n  }\r\n  return ret;\r\n}\r\n\r\n// Copies a specified amount of characters from the list of buffered data\r\n// chunks.\r\n// This function is designed to be inlinable, so please take care when making\r\n// changes to the function body.\r\nfunction copyFromBufferString(n, list) {\r\n  var p = list.head;\r\n  var c = 1;\r\n  var ret = p.data;\r\n  n -= ret.length;\r\n  while (p = p.next) {\r\n    var str = p.data;\r\n    var nb = n > str.length ? str.length : n;\r\n    if (nb === str.length) ret += str;else ret += str.slice(0, n);\r\n    n -= nb;\r\n    if (n === 0) {\r\n      if (nb === str.length) {\r\n        ++c;\r\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\r\n      } else {\r\n        list.head = p;\r\n        p.data = str.slice(nb);\r\n      }\r\n      break;\r\n    }\r\n    ++c;\r\n  }\r\n  list.length -= c;\r\n  return ret;\r\n}\r\n\r\n// Copies a specified amount of bytes from the list of buffered data chunks.\r\n// This function is designed to be inlinable, so please take care when making\r\n// changes to the function body.\r\nfunction copyFromBuffer(n, list) {\r\n  var ret = Buffer.allocUnsafe(n);\r\n  var p = list.head;\r\n  var c = 1;\r\n  p.data.copy(ret);\r\n  n -= p.data.length;\r\n  while (p = p.next) {\r\n    var buf = p.data;\r\n    var nb = n > buf.length ? buf.length : n;\r\n    buf.copy(ret, ret.length - n, 0, nb);\r\n    n -= nb;\r\n    if (n === 0) {\r\n      if (nb === buf.length) {\r\n        ++c;\r\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\r\n      } else {\r\n        list.head = p;\r\n        p.data = buf.slice(nb);\r\n      }\r\n      break;\r\n    }\r\n    ++c;\r\n  }\r\n  list.length -= c;\r\n  return ret;\r\n}\r\n\r\nfunction endReadable(stream) {\r\n  var state = stream._readableState;\r\n\r\n  // If we get here before consuming all the bytes, then that is a\r\n  // bug in node.  Should never happen.\r\n  if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\r\n\r\n  if (!state.endEmitted) {\r\n    state.ended = true;\r\n    pna.nextTick(endReadableNT, state, stream);\r\n  }\r\n}\r\n\r\nfunction endReadableNT(state, stream) {\r\n  // Check that we didn't get one last unshift.\r\n  if (!state.endEmitted && state.length === 0) {\r\n    state.endEmitted = true;\r\n    stream.readable = false;\r\n    stream.emit('end');\r\n  }\r\n}\r\n\r\nfunction indexOf(xs, x) {\r\n  for (var i = 0, l = xs.length; i < l; i++) {\r\n    if (xs[i] === x) return i;\r\n  }\r\n  return -1;\r\n}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/readable-stream/lib/_stream_readable.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_transform.js":
/*!***************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_transform.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the\r\n// \"Software\"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n// persons to whom the Software is furnished to do so, subject to the\r\n// following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n// a transform stream is a readable/writable stream where you do\r\n// something with the data.  Sometimes it's called a \"filter\",\r\n// but that's not a great name for it, since that implies a thing where\r\n// some bits pass through, and others are simply ignored.  (That would\r\n// be a valid example of a transform, of course.)\r\n//\r\n// While the output is causally related to the input, it's not a\r\n// necessarily symmetric or synchronous transformation.  For example,\r\n// a zlib stream might take multiple plain-text writes(), and then\r\n// emit a single compressed chunk some time in the future.\r\n//\r\n// Here's how this works:\r\n//\r\n// The Transform stream has all the aspects of the readable and writable\r\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\r\n// internally, and returns false if there's a lot of pending writes\r\n// buffered up.  When you call read(), that calls _read(n) until\r\n// there's enough pending readable data buffered up.\r\n//\r\n// In a transform stream, the written data is placed in a buffer.  When\r\n// _read(n) is called, it transforms the queued up data, calling the\r\n// buffered _write cb's as it consumes chunks.  If consuming a single\r\n// written chunk would result in multiple output chunks, then the first\r\n// outputted bit calls the readcb, and subsequent chunks just go into\r\n// the read buffer, and will cause it to emit 'readable' if necessary.\r\n//\r\n// This way, back-pressure is actually determined by the reading side,\r\n// since _read has to be called to start processing a new chunk.  However,\r\n// a pathological inflate type of transform can cause excessive buffering\r\n// here.  For example, imagine a stream where every byte of input is\r\n// interpreted as an integer from 0-255, and then results in that many\r\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\r\n// 1kb of data being output.  In this case, you could write a very small\r\n// amount of input, and end up with a very large amount of output.  In\r\n// such a pathological inflating mechanism, there'd be no way to tell\r\n// the system to stop doing the transform.  A single 4MB write could\r\n// cause the system to run out of memory.\r\n//\r\n// However, even in such a pathological case, only a single written chunk\r\n// would be consumed, and then the rest would wait (un-transformed) until\r\n// the results of the previous transformed chunk were consumed.\r\n\r\n\r\n\r\nmodule.exports = Transform;\r\n\r\nvar Duplex = __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\r\n\r\n/*<replacement>*/\r\nvar util = Object.create(__webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\"));\r\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\r\n/*</replacement>*/\r\n\r\nutil.inherits(Transform, Duplex);\r\n\r\nfunction afterTransform(er, data) {\r\n  var ts = this._transformState;\r\n  ts.transforming = false;\r\n\r\n  var cb = ts.writecb;\r\n\r\n  if (!cb) {\r\n    return this.emit('error', new Error('write callback called multiple times'));\r\n  }\r\n\r\n  ts.writechunk = null;\r\n  ts.writecb = null;\r\n\r\n  if (data != null) // single equals check for both `null` and `undefined`\r\n    this.push(data);\r\n\r\n  cb(er);\r\n\r\n  var rs = this._readableState;\r\n  rs.reading = false;\r\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\r\n    this._read(rs.highWaterMark);\r\n  }\r\n}\r\n\r\nfunction Transform(options) {\r\n  if (!(this instanceof Transform)) return new Transform(options);\r\n\r\n  Duplex.call(this, options);\r\n\r\n  this._transformState = {\r\n    afterTransform: afterTransform.bind(this),\r\n    needTransform: false,\r\n    transforming: false,\r\n    writecb: null,\r\n    writechunk: null,\r\n    writeencoding: null\r\n  };\r\n\r\n  // start out asking for a readable event once data is transformed.\r\n  this._readableState.needReadable = true;\r\n\r\n  // we have implemented the _read method, and done the other things\r\n  // that Readable wants before the first _read call, so unset the\r\n  // sync guard flag.\r\n  this._readableState.sync = false;\r\n\r\n  if (options) {\r\n    if (typeof options.transform === 'function') this._transform = options.transform;\r\n\r\n    if (typeof options.flush === 'function') this._flush = options.flush;\r\n  }\r\n\r\n  // When the writable side finishes, then flush out anything remaining.\r\n  this.on('prefinish', prefinish);\r\n}\r\n\r\nfunction prefinish() {\r\n  var _this = this;\r\n\r\n  if (typeof this._flush === 'function') {\r\n    this._flush(function (er, data) {\r\n      done(_this, er, data);\r\n    });\r\n  } else {\r\n    done(this, null, null);\r\n  }\r\n}\r\n\r\nTransform.prototype.push = function (chunk, encoding) {\r\n  this._transformState.needTransform = false;\r\n  return Duplex.prototype.push.call(this, chunk, encoding);\r\n};\r\n\r\n// This is the part where you do stuff!\r\n// override this function in implementation classes.\r\n// 'chunk' is an input chunk.\r\n//\r\n// Call `push(newChunk)` to pass along transformed output\r\n// to the readable side.  You may call 'push' zero or more times.\r\n//\r\n// Call `cb(err)` when you are done with this chunk.  If you pass\r\n// an error, then that'll put the hurt on the whole operation.  If you\r\n// never call cb(), then you'll never get another chunk.\r\nTransform.prototype._transform = function (chunk, encoding, cb) {\r\n  throw new Error('_transform() is not implemented');\r\n};\r\n\r\nTransform.prototype._write = function (chunk, encoding, cb) {\r\n  var ts = this._transformState;\r\n  ts.writecb = cb;\r\n  ts.writechunk = chunk;\r\n  ts.writeencoding = encoding;\r\n  if (!ts.transforming) {\r\n    var rs = this._readableState;\r\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\r\n  }\r\n};\r\n\r\n// Doesn't matter what the args are here.\r\n// _transform does all the work.\r\n// That we got here means that the readable side wants more data.\r\nTransform.prototype._read = function (n) {\r\n  var ts = this._transformState;\r\n\r\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\r\n    ts.transforming = true;\r\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\r\n  } else {\r\n    // mark that we need a transform, so that any data that comes in\r\n    // will get processed, now that we've asked for it.\r\n    ts.needTransform = true;\r\n  }\r\n};\r\n\r\nTransform.prototype._destroy = function (err, cb) {\r\n  var _this2 = this;\r\n\r\n  Duplex.prototype._destroy.call(this, err, function (err2) {\r\n    cb(err2);\r\n    _this2.emit('close');\r\n  });\r\n};\r\n\r\nfunction done(stream, er, data) {\r\n  if (er) return stream.emit('error', er);\r\n\r\n  if (data != null) // single equals check for both `null` and `undefined`\r\n    stream.push(data);\r\n\r\n  // if there's nothing in the write buffer, then that means\r\n  // that nothing more will ever be provided\r\n  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');\r\n\r\n  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');\r\n\r\n  return stream.push(null);\r\n}\n\n//# sourceURL=webpack:///./node_modules/readable-stream/lib/_stream_transform.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_writable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_writable.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process, setImmediate, global) {// Copyright Joyent, Inc. and other Node contributors.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the\r\n// \"Software\"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n// persons to whom the Software is furnished to do so, subject to the\r\n// following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n// A bit simpler than readable streams.\r\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\r\n// the drain event emission and buffering.\r\n\r\n\r\n\r\n/*<replacement>*/\r\n\r\nvar pna = __webpack_require__(/*! process-nextick-args */ \"./node_modules/process-nextick-args/index.js\");\r\n/*</replacement>*/\r\n\r\nmodule.exports = Writable;\r\n\r\n/* <replacement> */\r\nfunction WriteReq(chunk, encoding, cb) {\r\n  this.chunk = chunk;\r\n  this.encoding = encoding;\r\n  this.callback = cb;\r\n  this.next = null;\r\n}\r\n\r\n// It seems a linked list but it is not\r\n// there will be only 2 of these for each stream\r\nfunction CorkedRequest(state) {\r\n  var _this = this;\r\n\r\n  this.next = null;\r\n  this.entry = null;\r\n  this.finish = function () {\r\n    onCorkedFinish(_this, state);\r\n  };\r\n}\r\n/* </replacement> */\r\n\r\n/*<replacement>*/\r\nvar asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;\r\n/*</replacement>*/\r\n\r\n/*<replacement>*/\r\nvar Duplex;\r\n/*</replacement>*/\r\n\r\nWritable.WritableState = WritableState;\r\n\r\n/*<replacement>*/\r\nvar util = Object.create(__webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\"));\r\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\r\n/*</replacement>*/\r\n\r\n/*<replacement>*/\r\nvar internalUtil = {\r\n  deprecate: __webpack_require__(/*! util-deprecate */ \"./node_modules/util-deprecate/browser.js\")\r\n};\r\n/*</replacement>*/\r\n\r\n/*<replacement>*/\r\nvar Stream = __webpack_require__(/*! ./internal/streams/stream */ \"./node_modules/readable-stream/lib/internal/streams/stream-browser.js\");\r\n/*</replacement>*/\r\n\r\n/*<replacement>*/\r\n\r\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer;\r\nvar OurUint8Array = global.Uint8Array || function () {};\r\nfunction _uint8ArrayToBuffer(chunk) {\r\n  return Buffer.from(chunk);\r\n}\r\nfunction _isUint8Array(obj) {\r\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\r\n}\r\n\r\n/*</replacement>*/\r\n\r\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \"./node_modules/readable-stream/lib/internal/streams/destroy.js\");\r\n\r\nutil.inherits(Writable, Stream);\r\n\r\nfunction nop() {}\r\n\r\nfunction WritableState(options, stream) {\r\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\r\n\r\n  options = options || {};\r\n\r\n  // Duplex streams are both readable and writable, but share\r\n  // the same options object.\r\n  // However, some cases require setting options to different\r\n  // values for the readable and the writable sides of the duplex stream.\r\n  // These options can be provided separately as readableXXX and writableXXX.\r\n  var isDuplex = stream instanceof Duplex;\r\n\r\n  // object stream flag to indicate whether or not this stream\r\n  // contains buffers or objects.\r\n  this.objectMode = !!options.objectMode;\r\n\r\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\r\n\r\n  // the point at which write() starts returning false\r\n  // Note: 0 is a valid value, means that we always return false if\r\n  // the entire buffer is not flushed immediately on write()\r\n  var hwm = options.highWaterMark;\r\n  var writableHwm = options.writableHighWaterMark;\r\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\r\n\r\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;\r\n\r\n  // cast to ints.\r\n  this.highWaterMark = Math.floor(this.highWaterMark);\r\n\r\n  // if _final has been called\r\n  this.finalCalled = false;\r\n\r\n  // drain event flag.\r\n  this.needDrain = false;\r\n  // at the start of calling end()\r\n  this.ending = false;\r\n  // when end() has been called, and returned\r\n  this.ended = false;\r\n  // when 'finish' is emitted\r\n  this.finished = false;\r\n\r\n  // has it been destroyed\r\n  this.destroyed = false;\r\n\r\n  // should we decode strings into buffers before passing to _write?\r\n  // this is here so that some node-core streams can optimize string\r\n  // handling at a lower level.\r\n  var noDecode = options.decodeStrings === false;\r\n  this.decodeStrings = !noDecode;\r\n\r\n  // Crypto is kind of old and crusty.  Historically, its default string\r\n  // encoding is 'binary' so we have to make this configurable.\r\n  // Everything else in the universe uses 'utf8', though.\r\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\r\n\r\n  // not an actual buffer we keep track of, but a measurement\r\n  // of how much we're waiting to get pushed to some underlying\r\n  // socket or file.\r\n  this.length = 0;\r\n\r\n  // a flag to see when we're in the middle of a write.\r\n  this.writing = false;\r\n\r\n  // when true all writes will be buffered until .uncork() call\r\n  this.corked = 0;\r\n\r\n  // a flag to be able to tell if the onwrite cb is called immediately,\r\n  // or on a later tick.  We set this to true at first, because any\r\n  // actions that shouldn't happen until \"later\" should generally also\r\n  // not happen before the first write call.\r\n  this.sync = true;\r\n\r\n  // a flag to know if we're processing previously buffered items, which\r\n  // may call the _write() callback in the same tick, so that we don't\r\n  // end up in an overlapped onwrite situation.\r\n  this.bufferProcessing = false;\r\n\r\n  // the callback that's passed to _write(chunk,cb)\r\n  this.onwrite = function (er) {\r\n    onwrite(stream, er);\r\n  };\r\n\r\n  // the callback that the user supplies to write(chunk,encoding,cb)\r\n  this.writecb = null;\r\n\r\n  // the amount that is being written when _write is called.\r\n  this.writelen = 0;\r\n\r\n  this.bufferedRequest = null;\r\n  this.lastBufferedRequest = null;\r\n\r\n  // number of pending user-supplied write callbacks\r\n  // this must be 0 before 'finish' can be emitted\r\n  this.pendingcb = 0;\r\n\r\n  // emit prefinish if the only thing we're waiting for is _write cbs\r\n  // This is relevant for synchronous Transform streams\r\n  this.prefinished = false;\r\n\r\n  // True if the error was already emitted and should not be thrown again\r\n  this.errorEmitted = false;\r\n\r\n  // count buffered requests\r\n  this.bufferedRequestCount = 0;\r\n\r\n  // allocate the first CorkedRequest, there is always\r\n  // one allocated and free to use, and we maintain at most two\r\n  this.corkedRequestsFree = new CorkedRequest(this);\r\n}\r\n\r\nWritableState.prototype.getBuffer = function getBuffer() {\r\n  var current = this.bufferedRequest;\r\n  var out = [];\r\n  while (current) {\r\n    out.push(current);\r\n    current = current.next;\r\n  }\r\n  return out;\r\n};\r\n\r\n(function () {\r\n  try {\r\n    Object.defineProperty(WritableState.prototype, 'buffer', {\r\n      get: internalUtil.deprecate(function () {\r\n        return this.getBuffer();\r\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\r\n    });\r\n  } catch (_) {}\r\n})();\r\n\r\n// Test _writableState for inheritance to account for Duplex streams,\r\n// whose prototype chain only points to Readable.\r\nvar realHasInstance;\r\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\r\n  realHasInstance = Function.prototype[Symbol.hasInstance];\r\n  Object.defineProperty(Writable, Symbol.hasInstance, {\r\n    value: function (object) {\r\n      if (realHasInstance.call(this, object)) return true;\r\n      if (this !== Writable) return false;\r\n\r\n      return object && object._writableState instanceof WritableState;\r\n    }\r\n  });\r\n} else {\r\n  realHasInstance = function (object) {\r\n    return object instanceof this;\r\n  };\r\n}\r\n\r\nfunction Writable(options) {\r\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\r\n\r\n  // Writable ctor is applied to Duplexes, too.\r\n  // `realHasInstance` is necessary because using plain `instanceof`\r\n  // would return false, as no `_writableState` property is attached.\r\n\r\n  // Trying to use the custom `instanceof` for Writable here will also break the\r\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\r\n  // `_writableState` that would lead to infinite recursion.\r\n  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {\r\n    return new Writable(options);\r\n  }\r\n\r\n  this._writableState = new WritableState(options, this);\r\n\r\n  // legacy.\r\n  this.writable = true;\r\n\r\n  if (options) {\r\n    if (typeof options.write === 'function') this._write = options.write;\r\n\r\n    if (typeof options.writev === 'function') this._writev = options.writev;\r\n\r\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\r\n\r\n    if (typeof options.final === 'function') this._final = options.final;\r\n  }\r\n\r\n  Stream.call(this);\r\n}\r\n\r\n// Otherwise people can pipe Writable streams, which is just wrong.\r\nWritable.prototype.pipe = function () {\r\n  this.emit('error', new Error('Cannot pipe, not readable'));\r\n};\r\n\r\nfunction writeAfterEnd(stream, cb) {\r\n  var er = new Error('write after end');\r\n  // TODO: defer error events consistently everywhere, not just the cb\r\n  stream.emit('error', er);\r\n  pna.nextTick(cb, er);\r\n}\r\n\r\n// Checks that a user-supplied chunk is valid, especially for the particular\r\n// mode the stream is in. Currently this means that `null` is never accepted\r\n// and undefined/non-string values are only allowed in object mode.\r\nfunction validChunk(stream, state, chunk, cb) {\r\n  var valid = true;\r\n  var er = false;\r\n\r\n  if (chunk === null) {\r\n    er = new TypeError('May not write null values to stream');\r\n  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\r\n    er = new TypeError('Invalid non-string/buffer chunk');\r\n  }\r\n  if (er) {\r\n    stream.emit('error', er);\r\n    pna.nextTick(cb, er);\r\n    valid = false;\r\n  }\r\n  return valid;\r\n}\r\n\r\nWritable.prototype.write = function (chunk, encoding, cb) {\r\n  var state = this._writableState;\r\n  var ret = false;\r\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\r\n\r\n  if (isBuf && !Buffer.isBuffer(chunk)) {\r\n    chunk = _uint8ArrayToBuffer(chunk);\r\n  }\r\n\r\n  if (typeof encoding === 'function') {\r\n    cb = encoding;\r\n    encoding = null;\r\n  }\r\n\r\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\r\n\r\n  if (typeof cb !== 'function') cb = nop;\r\n\r\n  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\r\n    state.pendingcb++;\r\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\r\n  }\r\n\r\n  return ret;\r\n};\r\n\r\nWritable.prototype.cork = function () {\r\n  var state = this._writableState;\r\n\r\n  state.corked++;\r\n};\r\n\r\nWritable.prototype.uncork = function () {\r\n  var state = this._writableState;\r\n\r\n  if (state.corked) {\r\n    state.corked--;\r\n\r\n    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\r\n  }\r\n};\r\n\r\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\r\n  // node::ParseEncoding() requires lower case.\r\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\r\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\r\n  this._writableState.defaultEncoding = encoding;\r\n  return this;\r\n};\r\n\r\nfunction decodeChunk(state, chunk, encoding) {\r\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\r\n    chunk = Buffer.from(chunk, encoding);\r\n  }\r\n  return chunk;\r\n}\r\n\r\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\r\n  // making it explicit this property is not enumerable\r\n  // because otherwise some prototype manipulation in\r\n  // userland will fail\r\n  enumerable: false,\r\n  get: function () {\r\n    return this._writableState.highWaterMark;\r\n  }\r\n});\r\n\r\n// if we're already writing something, then just put this\r\n// in the queue, and wait our turn.  Otherwise, call _write\r\n// If we return false, then we need a drain event, so set that flag.\r\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\r\n  if (!isBuf) {\r\n    var newChunk = decodeChunk(state, chunk, encoding);\r\n    if (chunk !== newChunk) {\r\n      isBuf = true;\r\n      encoding = 'buffer';\r\n      chunk = newChunk;\r\n    }\r\n  }\r\n  var len = state.objectMode ? 1 : chunk.length;\r\n\r\n  state.length += len;\r\n\r\n  var ret = state.length < state.highWaterMark;\r\n  // we must ensure that previous needDrain will not be reset to false.\r\n  if (!ret) state.needDrain = true;\r\n\r\n  if (state.writing || state.corked) {\r\n    var last = state.lastBufferedRequest;\r\n    state.lastBufferedRequest = {\r\n      chunk: chunk,\r\n      encoding: encoding,\r\n      isBuf: isBuf,\r\n      callback: cb,\r\n      next: null\r\n    };\r\n    if (last) {\r\n      last.next = state.lastBufferedRequest;\r\n    } else {\r\n      state.bufferedRequest = state.lastBufferedRequest;\r\n    }\r\n    state.bufferedRequestCount += 1;\r\n  } else {\r\n    doWrite(stream, state, false, len, chunk, encoding, cb);\r\n  }\r\n\r\n  return ret;\r\n}\r\n\r\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\r\n  state.writelen = len;\r\n  state.writecb = cb;\r\n  state.writing = true;\r\n  state.sync = true;\r\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\r\n  state.sync = false;\r\n}\r\n\r\nfunction onwriteError(stream, state, sync, er, cb) {\r\n  --state.pendingcb;\r\n\r\n  if (sync) {\r\n    // defer the callback if we are being called synchronously\r\n    // to avoid piling up things on the stack\r\n    pna.nextTick(cb, er);\r\n    // this can emit finish, and it will always happen\r\n    // after error\r\n    pna.nextTick(finishMaybe, stream, state);\r\n    stream._writableState.errorEmitted = true;\r\n    stream.emit('error', er);\r\n  } else {\r\n    // the caller expect this to happen before if\r\n    // it is async\r\n    cb(er);\r\n    stream._writableState.errorEmitted = true;\r\n    stream.emit('error', er);\r\n    // this can emit finish, but finish must\r\n    // always follow error\r\n    finishMaybe(stream, state);\r\n  }\r\n}\r\n\r\nfunction onwriteStateUpdate(state) {\r\n  state.writing = false;\r\n  state.writecb = null;\r\n  state.length -= state.writelen;\r\n  state.writelen = 0;\r\n}\r\n\r\nfunction onwrite(stream, er) {\r\n  var state = stream._writableState;\r\n  var sync = state.sync;\r\n  var cb = state.writecb;\r\n\r\n  onwriteStateUpdate(state);\r\n\r\n  if (er) onwriteError(stream, state, sync, er, cb);else {\r\n    // Check if we're actually ready to finish, but don't emit yet\r\n    var finished = needFinish(state);\r\n\r\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\r\n      clearBuffer(stream, state);\r\n    }\r\n\r\n    if (sync) {\r\n      /*<replacement>*/\r\n      asyncWrite(afterWrite, stream, state, finished, cb);\r\n      /*</replacement>*/\r\n    } else {\r\n      afterWrite(stream, state, finished, cb);\r\n    }\r\n  }\r\n}\r\n\r\nfunction afterWrite(stream, state, finished, cb) {\r\n  if (!finished) onwriteDrain(stream, state);\r\n  state.pendingcb--;\r\n  cb();\r\n  finishMaybe(stream, state);\r\n}\r\n\r\n// Must force callback to be called on nextTick, so that we don't\r\n// emit 'drain' before the write() consumer gets the 'false' return\r\n// value, and has a chance to attach a 'drain' listener.\r\nfunction onwriteDrain(stream, state) {\r\n  if (state.length === 0 && state.needDrain) {\r\n    state.needDrain = false;\r\n    stream.emit('drain');\r\n  }\r\n}\r\n\r\n// if there's something in the buffer waiting, then process it\r\nfunction clearBuffer(stream, state) {\r\n  state.bufferProcessing = true;\r\n  var entry = state.bufferedRequest;\r\n\r\n  if (stream._writev && entry && entry.next) {\r\n    // Fast case, write everything using _writev()\r\n    var l = state.bufferedRequestCount;\r\n    var buffer = new Array(l);\r\n    var holder = state.corkedRequestsFree;\r\n    holder.entry = entry;\r\n\r\n    var count = 0;\r\n    var allBuffers = true;\r\n    while (entry) {\r\n      buffer[count] = entry;\r\n      if (!entry.isBuf) allBuffers = false;\r\n      entry = entry.next;\r\n      count += 1;\r\n    }\r\n    buffer.allBuffers = allBuffers;\r\n\r\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\r\n\r\n    // doWrite is almost always async, defer these to save a bit of time\r\n    // as the hot path ends with doWrite\r\n    state.pendingcb++;\r\n    state.lastBufferedRequest = null;\r\n    if (holder.next) {\r\n      state.corkedRequestsFree = holder.next;\r\n      holder.next = null;\r\n    } else {\r\n      state.corkedRequestsFree = new CorkedRequest(state);\r\n    }\r\n    state.bufferedRequestCount = 0;\r\n  } else {\r\n    // Slow case, write chunks one-by-one\r\n    while (entry) {\r\n      var chunk = entry.chunk;\r\n      var encoding = entry.encoding;\r\n      var cb = entry.callback;\r\n      var len = state.objectMode ? 1 : chunk.length;\r\n\r\n      doWrite(stream, state, false, len, chunk, encoding, cb);\r\n      entry = entry.next;\r\n      state.bufferedRequestCount--;\r\n      // if we didn't call the onwrite immediately, then\r\n      // it means that we need to wait until it does.\r\n      // also, that means that the chunk and cb are currently\r\n      // being processed, so move the buffer counter past them.\r\n      if (state.writing) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (entry === null) state.lastBufferedRequest = null;\r\n  }\r\n\r\n  state.bufferedRequest = entry;\r\n  state.bufferProcessing = false;\r\n}\r\n\r\nWritable.prototype._write = function (chunk, encoding, cb) {\r\n  cb(new Error('_write() is not implemented'));\r\n};\r\n\r\nWritable.prototype._writev = null;\r\n\r\nWritable.prototype.end = function (chunk, encoding, cb) {\r\n  var state = this._writableState;\r\n\r\n  if (typeof chunk === 'function') {\r\n    cb = chunk;\r\n    chunk = null;\r\n    encoding = null;\r\n  } else if (typeof encoding === 'function') {\r\n    cb = encoding;\r\n    encoding = null;\r\n  }\r\n\r\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\r\n\r\n  // .end() fully uncorks\r\n  if (state.corked) {\r\n    state.corked = 1;\r\n    this.uncork();\r\n  }\r\n\r\n  // ignore unnecessary end() calls.\r\n  if (!state.ending && !state.finished) endWritable(this, state, cb);\r\n};\r\n\r\nfunction needFinish(state) {\r\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\r\n}\r\nfunction callFinal(stream, state) {\r\n  stream._final(function (err) {\r\n    state.pendingcb--;\r\n    if (err) {\r\n      stream.emit('error', err);\r\n    }\r\n    state.prefinished = true;\r\n    stream.emit('prefinish');\r\n    finishMaybe(stream, state);\r\n  });\r\n}\r\nfunction prefinish(stream, state) {\r\n  if (!state.prefinished && !state.finalCalled) {\r\n    if (typeof stream._final === 'function') {\r\n      state.pendingcb++;\r\n      state.finalCalled = true;\r\n      pna.nextTick(callFinal, stream, state);\r\n    } else {\r\n      state.prefinished = true;\r\n      stream.emit('prefinish');\r\n    }\r\n  }\r\n}\r\n\r\nfunction finishMaybe(stream, state) {\r\n  var need = needFinish(state);\r\n  if (need) {\r\n    prefinish(stream, state);\r\n    if (state.pendingcb === 0) {\r\n      state.finished = true;\r\n      stream.emit('finish');\r\n    }\r\n  }\r\n  return need;\r\n}\r\n\r\nfunction endWritable(stream, state, cb) {\r\n  state.ending = true;\r\n  finishMaybe(stream, state);\r\n  if (cb) {\r\n    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);\r\n  }\r\n  state.ended = true;\r\n  stream.writable = false;\r\n}\r\n\r\nfunction onCorkedFinish(corkReq, state, err) {\r\n  var entry = corkReq.entry;\r\n  corkReq.entry = null;\r\n  while (entry) {\r\n    var cb = entry.callback;\r\n    state.pendingcb--;\r\n    cb(err);\r\n    entry = entry.next;\r\n  }\r\n  if (state.corkedRequestsFree) {\r\n    state.corkedRequestsFree.next = corkReq;\r\n  } else {\r\n    state.corkedRequestsFree = corkReq;\r\n  }\r\n}\r\n\r\nObject.defineProperty(Writable.prototype, 'destroyed', {\r\n  get: function () {\r\n    if (this._writableState === undefined) {\r\n      return false;\r\n    }\r\n    return this._writableState.destroyed;\r\n  },\r\n  set: function (value) {\r\n    // we ignore the value if the stream\r\n    // has not been initialized yet\r\n    if (!this._writableState) {\r\n      return;\r\n    }\r\n\r\n    // backward compatibility, the user is explicitly\r\n    // managing destroyed\r\n    this._writableState.destroyed = value;\r\n  }\r\n});\r\n\r\nWritable.prototype.destroy = destroyImpl.destroy;\r\nWritable.prototype._undestroy = destroyImpl.undestroy;\r\nWritable.prototype._destroy = function (err, cb) {\r\n  this.end();\r\n  cb(err);\r\n};\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \"./node_modules/process/browser.js\"), __webpack_require__(/*! ./../../timers-browserify/main.js */ \"./node_modules/timers-browserify/main.js\").setImmediate, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/readable-stream/lib/_stream_writable.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/BufferList.js":
/*!*************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/BufferList.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer;\r\nvar util = __webpack_require__(/*! util */ 2);\r\n\r\nfunction copyBuffer(src, target, offset) {\r\n  src.copy(target, offset);\r\n}\r\n\r\nmodule.exports = function () {\r\n  function BufferList() {\r\n    _classCallCheck(this, BufferList);\r\n\r\n    this.head = null;\r\n    this.tail = null;\r\n    this.length = 0;\r\n  }\r\n\r\n  BufferList.prototype.push = function push(v) {\r\n    var entry = { data: v, next: null };\r\n    if (this.length > 0) this.tail.next = entry;else this.head = entry;\r\n    this.tail = entry;\r\n    ++this.length;\r\n  };\r\n\r\n  BufferList.prototype.unshift = function unshift(v) {\r\n    var entry = { data: v, next: this.head };\r\n    if (this.length === 0) this.tail = entry;\r\n    this.head = entry;\r\n    ++this.length;\r\n  };\r\n\r\n  BufferList.prototype.shift = function shift() {\r\n    if (this.length === 0) return;\r\n    var ret = this.head.data;\r\n    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\r\n    --this.length;\r\n    return ret;\r\n  };\r\n\r\n  BufferList.prototype.clear = function clear() {\r\n    this.head = this.tail = null;\r\n    this.length = 0;\r\n  };\r\n\r\n  BufferList.prototype.join = function join(s) {\r\n    if (this.length === 0) return '';\r\n    var p = this.head;\r\n    var ret = '' + p.data;\r\n    while (p = p.next) {\r\n      ret += s + p.data;\r\n    }return ret;\r\n  };\r\n\r\n  BufferList.prototype.concat = function concat(n) {\r\n    if (this.length === 0) return Buffer.alloc(0);\r\n    if (this.length === 1) return this.head.data;\r\n    var ret = Buffer.allocUnsafe(n >>> 0);\r\n    var p = this.head;\r\n    var i = 0;\r\n    while (p) {\r\n      copyBuffer(p.data, ret, i);\r\n      i += p.data.length;\r\n      p = p.next;\r\n    }\r\n    return ret;\r\n  };\r\n\r\n  return BufferList;\r\n}();\r\n\r\nif (util && util.inspect && util.inspect.custom) {\r\n  module.exports.prototype[util.inspect.custom] = function () {\r\n    var obj = util.inspect({ length: this.length });\r\n    return this.constructor.name + ' ' + obj;\r\n  };\r\n}\n\n//# sourceURL=webpack:///./node_modules/readable-stream/lib/internal/streams/BufferList.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/destroy.js":
/*!**********************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/destroy.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\n/*<replacement>*/\r\n\r\nvar pna = __webpack_require__(/*! process-nextick-args */ \"./node_modules/process-nextick-args/index.js\");\r\n/*</replacement>*/\r\n\r\n// undocumented cb() API, needed for core, not for public API\r\nfunction destroy(err, cb) {\r\n  var _this = this;\r\n\r\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\r\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\r\n\r\n  if (readableDestroyed || writableDestroyed) {\r\n    if (cb) {\r\n      cb(err);\r\n    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {\r\n      pna.nextTick(emitErrorNT, this, err);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  // we set destroyed to true before firing error callbacks in order\r\n  // to make it re-entrance safe in case destroy() is called within callbacks\r\n\r\n  if (this._readableState) {\r\n    this._readableState.destroyed = true;\r\n  }\r\n\r\n  // if this is a duplex stream mark the writable part as destroyed as well\r\n  if (this._writableState) {\r\n    this._writableState.destroyed = true;\r\n  }\r\n\r\n  this._destroy(err || null, function (err) {\r\n    if (!cb && err) {\r\n      pna.nextTick(emitErrorNT, _this, err);\r\n      if (_this._writableState) {\r\n        _this._writableState.errorEmitted = true;\r\n      }\r\n    } else if (cb) {\r\n      cb(err);\r\n    }\r\n  });\r\n\r\n  return this;\r\n}\r\n\r\nfunction undestroy() {\r\n  if (this._readableState) {\r\n    this._readableState.destroyed = false;\r\n    this._readableState.reading = false;\r\n    this._readableState.ended = false;\r\n    this._readableState.endEmitted = false;\r\n  }\r\n\r\n  if (this._writableState) {\r\n    this._writableState.destroyed = false;\r\n    this._writableState.ended = false;\r\n    this._writableState.ending = false;\r\n    this._writableState.finished = false;\r\n    this._writableState.errorEmitted = false;\r\n  }\r\n}\r\n\r\nfunction emitErrorNT(self, err) {\r\n  self.emit('error', err);\r\n}\r\n\r\nmodule.exports = {\r\n  destroy: destroy,\r\n  undestroy: undestroy\r\n};\n\n//# sourceURL=webpack:///./node_modules/readable-stream/lib/internal/streams/destroy.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/stream-browser.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/stream-browser.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\r\n\n\n//# sourceURL=webpack:///./node_modules/readable-stream/lib/internal/streams/stream-browser.js?");

/***/ }),

/***/ "./node_modules/readable-stream/passthrough.js":
/*!*****************************************************!*\
  !*** ./node_modules/readable-stream/passthrough.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./readable */ \"./node_modules/readable-stream/readable-browser.js\").PassThrough\r\n\n\n//# sourceURL=webpack:///./node_modules/readable-stream/passthrough.js?");

/***/ }),

/***/ "./node_modules/readable-stream/readable-browser.js":
/*!**********************************************************!*\
  !*** ./node_modules/readable-stream/readable-browser.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ./lib/_stream_readable.js */ \"./node_modules/readable-stream/lib/_stream_readable.js\");\r\nexports.Stream = exports;\r\nexports.Readable = exports;\r\nexports.Writable = __webpack_require__(/*! ./lib/_stream_writable.js */ \"./node_modules/readable-stream/lib/_stream_writable.js\");\r\nexports.Duplex = __webpack_require__(/*! ./lib/_stream_duplex.js */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\r\nexports.Transform = __webpack_require__(/*! ./lib/_stream_transform.js */ \"./node_modules/readable-stream/lib/_stream_transform.js\");\r\nexports.PassThrough = __webpack_require__(/*! ./lib/_stream_passthrough.js */ \"./node_modules/readable-stream/lib/_stream_passthrough.js\");\r\n\n\n//# sourceURL=webpack:///./node_modules/readable-stream/readable-browser.js?");

/***/ }),

/***/ "./node_modules/readable-stream/transform.js":
/*!***************************************************!*\
  !*** ./node_modules/readable-stream/transform.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./readable */ \"./node_modules/readable-stream/readable-browser.js\").Transform\r\n\n\n//# sourceURL=webpack:///./node_modules/readable-stream/transform.js?");

/***/ }),

/***/ "./node_modules/readable-stream/writable-browser.js":
/*!**********************************************************!*\
  !*** ./node_modules/readable-stream/writable-browser.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./lib/_stream_writable.js */ \"./node_modules/readable-stream/lib/_stream_writable.js\");\r\n\n\n//# sourceURL=webpack:///./node_modules/readable-stream/writable-browser.js?");

/***/ }),

/***/ "./node_modules/safe-buffer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/safe-buffer/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* eslint-disable node/no-deprecated-api */\r\nvar buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")\r\nvar Buffer = buffer.Buffer\r\n\r\n// alternative to using Object.keys for old browsers\r\nfunction copyProps (src, dst) {\r\n  for (var key in src) {\r\n    dst[key] = src[key]\r\n  }\r\n}\r\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\r\n  module.exports = buffer\r\n} else {\r\n  // Copy properties from require('buffer')\r\n  copyProps(buffer, exports)\r\n  exports.Buffer = SafeBuffer\r\n}\r\n\r\nfunction SafeBuffer (arg, encodingOrOffset, length) {\r\n  return Buffer(arg, encodingOrOffset, length)\r\n}\r\n\r\n// Copy static methods from Buffer\r\ncopyProps(Buffer, SafeBuffer)\r\n\r\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\r\n  if (typeof arg === 'number') {\r\n    throw new TypeError('Argument must not be a number')\r\n  }\r\n  return Buffer(arg, encodingOrOffset, length)\r\n}\r\n\r\nSafeBuffer.alloc = function (size, fill, encoding) {\r\n  if (typeof size !== 'number') {\r\n    throw new TypeError('Argument must be a number')\r\n  }\r\n  var buf = Buffer(size)\r\n  if (fill !== undefined) {\r\n    if (typeof encoding === 'string') {\r\n      buf.fill(fill, encoding)\r\n    } else {\r\n      buf.fill(fill)\r\n    }\r\n  } else {\r\n    buf.fill(0)\r\n  }\r\n  return buf\r\n}\r\n\r\nSafeBuffer.allocUnsafe = function (size) {\r\n  if (typeof size !== 'number') {\r\n    throw new TypeError('Argument must be a number')\r\n  }\r\n  return Buffer(size)\r\n}\r\n\r\nSafeBuffer.allocUnsafeSlow = function (size) {\r\n  if (typeof size !== 'number') {\r\n    throw new TypeError('Argument must be a number')\r\n  }\r\n  return buffer.SlowBuffer(size)\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/safe-buffer/index.js?");

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\r\n    \"use strict\";\r\n\r\n    if (global.setImmediate) {\r\n        return;\r\n    }\r\n\r\n    var nextHandle = 1; // Spec says greater than zero\r\n    var tasksByHandle = {};\r\n    var currentlyRunningATask = false;\r\n    var doc = global.document;\r\n    var registerImmediate;\r\n\r\n    function setImmediate(callback) {\r\n      // Callback can either be a function or a string\r\n      if (typeof callback !== \"function\") {\r\n        callback = new Function(\"\" + callback);\r\n      }\r\n      // Copy function arguments\r\n      var args = new Array(arguments.length - 1);\r\n      for (var i = 0; i < args.length; i++) {\r\n          args[i] = arguments[i + 1];\r\n      }\r\n      // Store and register the task\r\n      var task = { callback: callback, args: args };\r\n      tasksByHandle[nextHandle] = task;\r\n      registerImmediate(nextHandle);\r\n      return nextHandle++;\r\n    }\r\n\r\n    function clearImmediate(handle) {\r\n        delete tasksByHandle[handle];\r\n    }\r\n\r\n    function run(task) {\r\n        var callback = task.callback;\r\n        var args = task.args;\r\n        switch (args.length) {\r\n        case 0:\r\n            callback();\r\n            break;\r\n        case 1:\r\n            callback(args[0]);\r\n            break;\r\n        case 2:\r\n            callback(args[0], args[1]);\r\n            break;\r\n        case 3:\r\n            callback(args[0], args[1], args[2]);\r\n            break;\r\n        default:\r\n            callback.apply(undefined, args);\r\n            break;\r\n        }\r\n    }\r\n\r\n    function runIfPresent(handle) {\r\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\r\n        // So if we're currently running a task, we'll need to delay this invocation.\r\n        if (currentlyRunningATask) {\r\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\r\n            // \"too much recursion\" error.\r\n            setTimeout(runIfPresent, 0, handle);\r\n        } else {\r\n            var task = tasksByHandle[handle];\r\n            if (task) {\r\n                currentlyRunningATask = true;\r\n                try {\r\n                    run(task);\r\n                } finally {\r\n                    clearImmediate(handle);\r\n                    currentlyRunningATask = false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function installNextTickImplementation() {\r\n        registerImmediate = function(handle) {\r\n            process.nextTick(function () { runIfPresent(handle); });\r\n        };\r\n    }\r\n\r\n    function canUsePostMessage() {\r\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\r\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\r\n        if (global.postMessage && !global.importScripts) {\r\n            var postMessageIsAsynchronous = true;\r\n            var oldOnMessage = global.onmessage;\r\n            global.onmessage = function() {\r\n                postMessageIsAsynchronous = false;\r\n            };\r\n            global.postMessage(\"\", \"*\");\r\n            global.onmessage = oldOnMessage;\r\n            return postMessageIsAsynchronous;\r\n        }\r\n    }\r\n\r\n    function installPostMessageImplementation() {\r\n        // Installs an event handler on `global` for the `message` event: see\r\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\r\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\r\n\r\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\r\n        var onGlobalMessage = function(event) {\r\n            if (event.source === global &&\r\n                typeof event.data === \"string\" &&\r\n                event.data.indexOf(messagePrefix) === 0) {\r\n                runIfPresent(+event.data.slice(messagePrefix.length));\r\n            }\r\n        };\r\n\r\n        if (global.addEventListener) {\r\n            global.addEventListener(\"message\", onGlobalMessage, false);\r\n        } else {\r\n            global.attachEvent(\"onmessage\", onGlobalMessage);\r\n        }\r\n\r\n        registerImmediate = function(handle) {\r\n            global.postMessage(messagePrefix + handle, \"*\");\r\n        };\r\n    }\r\n\r\n    function installMessageChannelImplementation() {\r\n        var channel = new MessageChannel();\r\n        channel.port1.onmessage = function(event) {\r\n            var handle = event.data;\r\n            runIfPresent(handle);\r\n        };\r\n\r\n        registerImmediate = function(handle) {\r\n            channel.port2.postMessage(handle);\r\n        };\r\n    }\r\n\r\n    function installReadyStateChangeImplementation() {\r\n        var html = doc.documentElement;\r\n        registerImmediate = function(handle) {\r\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\r\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\r\n            var script = doc.createElement(\"script\");\r\n            script.onreadystatechange = function () {\r\n                runIfPresent(handle);\r\n                script.onreadystatechange = null;\r\n                html.removeChild(script);\r\n                script = null;\r\n            };\r\n            html.appendChild(script);\r\n        };\r\n    }\r\n\r\n    function installSetTimeoutImplementation() {\r\n        registerImmediate = function(handle) {\r\n            setTimeout(runIfPresent, 0, handle);\r\n        };\r\n    }\r\n\r\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\r\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\r\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\r\n\r\n    // Don't get fooled by e.g. browserify environments.\r\n    if ({}.toString.call(global.process) === \"[object process]\") {\r\n        // For Node.js before 0.9\r\n        installNextTickImplementation();\r\n\r\n    } else if (canUsePostMessage()) {\r\n        // For non-IE10 modern browsers\r\n        installPostMessageImplementation();\r\n\r\n    } else if (global.MessageChannel) {\r\n        // For web workers, where supported\r\n        installMessageChannelImplementation();\r\n\r\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\r\n        // For IE 68\r\n        installReadyStateChangeImplementation();\r\n\r\n    } else {\r\n        // For older browsers\r\n        installSetTimeoutImplementation();\r\n    }\r\n\r\n    attachTo.setImmediate = setImmediate;\r\n    attachTo.clearImmediate = clearImmediate;\r\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/setimmediate/setImmediate.js?");

/***/ }),

/***/ "./node_modules/stream-browserify/index.js":
/*!*************************************************!*\
  !*** ./node_modules/stream-browserify/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Copyright Joyent, Inc. and other Node contributors.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the\r\n// \"Software\"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n// persons to whom the Software is furnished to do so, subject to the\r\n// following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\nmodule.exports = Stream;\r\n\r\nvar EE = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\r\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\r\n\r\ninherits(Stream, EE);\r\nStream.Readable = __webpack_require__(/*! readable-stream/readable.js */ \"./node_modules/readable-stream/readable-browser.js\");\r\nStream.Writable = __webpack_require__(/*! readable-stream/writable.js */ \"./node_modules/readable-stream/writable-browser.js\");\r\nStream.Duplex = __webpack_require__(/*! readable-stream/duplex.js */ \"./node_modules/readable-stream/duplex-browser.js\");\r\nStream.Transform = __webpack_require__(/*! readable-stream/transform.js */ \"./node_modules/readable-stream/transform.js\");\r\nStream.PassThrough = __webpack_require__(/*! readable-stream/passthrough.js */ \"./node_modules/readable-stream/passthrough.js\");\r\n\r\n// Backwards-compat with node 0.4.x\r\nStream.Stream = Stream;\r\n\r\n\r\n\r\n// old-style streams.  Note that the pipe method (the only relevant\r\n// part of this class) is overridden in the Readable class.\r\n\r\nfunction Stream() {\r\n  EE.call(this);\r\n}\r\n\r\nStream.prototype.pipe = function(dest, options) {\r\n  var source = this;\r\n\r\n  function ondata(chunk) {\r\n    if (dest.writable) {\r\n      if (false === dest.write(chunk) && source.pause) {\r\n        source.pause();\r\n      }\r\n    }\r\n  }\r\n\r\n  source.on('data', ondata);\r\n\r\n  function ondrain() {\r\n    if (source.readable && source.resume) {\r\n      source.resume();\r\n    }\r\n  }\r\n\r\n  dest.on('drain', ondrain);\r\n\r\n  // If the 'end' option is not supplied, dest.end() will be called when\r\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\r\n  if (!dest._isStdio && (!options || options.end !== false)) {\r\n    source.on('end', onend);\r\n    source.on('close', onclose);\r\n  }\r\n\r\n  var didOnEnd = false;\r\n  function onend() {\r\n    if (didOnEnd) return;\r\n    didOnEnd = true;\r\n\r\n    dest.end();\r\n  }\r\n\r\n\r\n  function onclose() {\r\n    if (didOnEnd) return;\r\n    didOnEnd = true;\r\n\r\n    if (typeof dest.destroy === 'function') dest.destroy();\r\n  }\r\n\r\n  // don't leave dangling pipes when there are errors.\r\n  function onerror(er) {\r\n    cleanup();\r\n    if (EE.listenerCount(this, 'error') === 0) {\r\n      throw er; // Unhandled stream error in pipe.\r\n    }\r\n  }\r\n\r\n  source.on('error', onerror);\r\n  dest.on('error', onerror);\r\n\r\n  // remove all the event listeners that were added.\r\n  function cleanup() {\r\n    source.removeListener('data', ondata);\r\n    dest.removeListener('drain', ondrain);\r\n\r\n    source.removeListener('end', onend);\r\n    source.removeListener('close', onclose);\r\n\r\n    source.removeListener('error', onerror);\r\n    dest.removeListener('error', onerror);\r\n\r\n    source.removeListener('end', cleanup);\r\n    source.removeListener('close', cleanup);\r\n\r\n    dest.removeListener('close', cleanup);\r\n  }\r\n\r\n  source.on('end', cleanup);\r\n  source.on('close', cleanup);\r\n\r\n  dest.on('close', cleanup);\r\n\r\n  dest.emit('pipe', source);\r\n\r\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\r\n  return dest;\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/stream-browserify/index.js?");

/***/ }),

/***/ "./node_modules/string_decoder/lib/string_decoder.js":
/*!***********************************************************!*\
  !*** ./node_modules/string_decoder/lib/string_decoder.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the\r\n// \"Software\"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n// persons to whom the Software is furnished to do so, subject to the\r\n// following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n\r\n\r\n/*<replacement>*/\r\n\r\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer;\r\n/*</replacement>*/\r\n\r\nvar isEncoding = Buffer.isEncoding || function (encoding) {\r\n  encoding = '' + encoding;\r\n  switch (encoding && encoding.toLowerCase()) {\r\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\r\n      return true;\r\n    default:\r\n      return false;\r\n  }\r\n};\r\n\r\nfunction _normalizeEncoding(enc) {\r\n  if (!enc) return 'utf8';\r\n  var retried;\r\n  while (true) {\r\n    switch (enc) {\r\n      case 'utf8':\r\n      case 'utf-8':\r\n        return 'utf8';\r\n      case 'ucs2':\r\n      case 'ucs-2':\r\n      case 'utf16le':\r\n      case 'utf-16le':\r\n        return 'utf16le';\r\n      case 'latin1':\r\n      case 'binary':\r\n        return 'latin1';\r\n      case 'base64':\r\n      case 'ascii':\r\n      case 'hex':\r\n        return enc;\r\n      default:\r\n        if (retried) return; // undefined\r\n        enc = ('' + enc).toLowerCase();\r\n        retried = true;\r\n    }\r\n  }\r\n};\r\n\r\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\r\n// modules monkey-patch it to support additional encodings\r\nfunction normalizeEncoding(enc) {\r\n  var nenc = _normalizeEncoding(enc);\r\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\r\n  return nenc || enc;\r\n}\r\n\r\n// StringDecoder provides an interface for efficiently splitting a series of\r\n// buffers into a series of JS strings without breaking apart multi-byte\r\n// characters.\r\nexports.StringDecoder = StringDecoder;\r\nfunction StringDecoder(encoding) {\r\n  this.encoding = normalizeEncoding(encoding);\r\n  var nb;\r\n  switch (this.encoding) {\r\n    case 'utf16le':\r\n      this.text = utf16Text;\r\n      this.end = utf16End;\r\n      nb = 4;\r\n      break;\r\n    case 'utf8':\r\n      this.fillLast = utf8FillLast;\r\n      nb = 4;\r\n      break;\r\n    case 'base64':\r\n      this.text = base64Text;\r\n      this.end = base64End;\r\n      nb = 3;\r\n      break;\r\n    default:\r\n      this.write = simpleWrite;\r\n      this.end = simpleEnd;\r\n      return;\r\n  }\r\n  this.lastNeed = 0;\r\n  this.lastTotal = 0;\r\n  this.lastChar = Buffer.allocUnsafe(nb);\r\n}\r\n\r\nStringDecoder.prototype.write = function (buf) {\r\n  if (buf.length === 0) return '';\r\n  var r;\r\n  var i;\r\n  if (this.lastNeed) {\r\n    r = this.fillLast(buf);\r\n    if (r === undefined) return '';\r\n    i = this.lastNeed;\r\n    this.lastNeed = 0;\r\n  } else {\r\n    i = 0;\r\n  }\r\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\r\n  return r || '';\r\n};\r\n\r\nStringDecoder.prototype.end = utf8End;\r\n\r\n// Returns only complete characters in a Buffer\r\nStringDecoder.prototype.text = utf8Text;\r\n\r\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\r\nStringDecoder.prototype.fillLast = function (buf) {\r\n  if (this.lastNeed <= buf.length) {\r\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\r\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\r\n  }\r\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\r\n  this.lastNeed -= buf.length;\r\n};\r\n\r\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\r\n// continuation byte. If an invalid byte is detected, -2 is returned.\r\nfunction utf8CheckByte(byte) {\r\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\r\n  return byte >> 6 === 0x02 ? -1 : -2;\r\n}\r\n\r\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\r\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\r\n// needed to complete the UTF-8 character (if applicable) are returned.\r\nfunction utf8CheckIncomplete(self, buf, i) {\r\n  var j = buf.length - 1;\r\n  if (j < i) return 0;\r\n  var nb = utf8CheckByte(buf[j]);\r\n  if (nb >= 0) {\r\n    if (nb > 0) self.lastNeed = nb - 1;\r\n    return nb;\r\n  }\r\n  if (--j < i || nb === -2) return 0;\r\n  nb = utf8CheckByte(buf[j]);\r\n  if (nb >= 0) {\r\n    if (nb > 0) self.lastNeed = nb - 2;\r\n    return nb;\r\n  }\r\n  if (--j < i || nb === -2) return 0;\r\n  nb = utf8CheckByte(buf[j]);\r\n  if (nb >= 0) {\r\n    if (nb > 0) {\r\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\r\n    }\r\n    return nb;\r\n  }\r\n  return 0;\r\n}\r\n\r\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\r\n// needed or are available. If we see a non-continuation byte where we expect\r\n// one, we \"replace\" the validated continuation bytes we've seen so far with\r\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\r\n// behavior. The continuation byte check is included three times in the case\r\n// where all of the continuation bytes for a character exist in the same buffer.\r\n// It is also done this way as a slight performance increase instead of using a\r\n// loop.\r\nfunction utf8CheckExtraBytes(self, buf, p) {\r\n  if ((buf[0] & 0xC0) !== 0x80) {\r\n    self.lastNeed = 0;\r\n    return '\\ufffd';\r\n  }\r\n  if (self.lastNeed > 1 && buf.length > 1) {\r\n    if ((buf[1] & 0xC0) !== 0x80) {\r\n      self.lastNeed = 1;\r\n      return '\\ufffd';\r\n    }\r\n    if (self.lastNeed > 2 && buf.length > 2) {\r\n      if ((buf[2] & 0xC0) !== 0x80) {\r\n        self.lastNeed = 2;\r\n        return '\\ufffd';\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\r\nfunction utf8FillLast(buf) {\r\n  var p = this.lastTotal - this.lastNeed;\r\n  var r = utf8CheckExtraBytes(this, buf, p);\r\n  if (r !== undefined) return r;\r\n  if (this.lastNeed <= buf.length) {\r\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\r\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\r\n  }\r\n  buf.copy(this.lastChar, p, 0, buf.length);\r\n  this.lastNeed -= buf.length;\r\n}\r\n\r\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\r\n// partial character, the character's bytes are buffered until the required\r\n// number of bytes are available.\r\nfunction utf8Text(buf, i) {\r\n  var total = utf8CheckIncomplete(this, buf, i);\r\n  if (!this.lastNeed) return buf.toString('utf8', i);\r\n  this.lastTotal = total;\r\n  var end = buf.length - (total - this.lastNeed);\r\n  buf.copy(this.lastChar, 0, end);\r\n  return buf.toString('utf8', i, end);\r\n}\r\n\r\n// For UTF-8, a replacement character is added when ending on a partial\r\n// character.\r\nfunction utf8End(buf) {\r\n  var r = buf && buf.length ? this.write(buf) : '';\r\n  if (this.lastNeed) return r + '\\ufffd';\r\n  return r;\r\n}\r\n\r\n// UTF-16LE typically needs two bytes per character, but even if we have an even\r\n// number of bytes available, we need to check if we end on a leading/high\r\n// surrogate. In that case, we need to wait for the next two bytes in order to\r\n// decode the last character properly.\r\nfunction utf16Text(buf, i) {\r\n  if ((buf.length - i) % 2 === 0) {\r\n    var r = buf.toString('utf16le', i);\r\n    if (r) {\r\n      var c = r.charCodeAt(r.length - 1);\r\n      if (c >= 0xD800 && c <= 0xDBFF) {\r\n        this.lastNeed = 2;\r\n        this.lastTotal = 4;\r\n        this.lastChar[0] = buf[buf.length - 2];\r\n        this.lastChar[1] = buf[buf.length - 1];\r\n        return r.slice(0, -1);\r\n      }\r\n    }\r\n    return r;\r\n  }\r\n  this.lastNeed = 1;\r\n  this.lastTotal = 2;\r\n  this.lastChar[0] = buf[buf.length - 1];\r\n  return buf.toString('utf16le', i, buf.length - 1);\r\n}\r\n\r\n// For UTF-16LE we do not explicitly append special replacement characters if we\r\n// end on a partial character, we simply let v8 handle that.\r\nfunction utf16End(buf) {\r\n  var r = buf && buf.length ? this.write(buf) : '';\r\n  if (this.lastNeed) {\r\n    var end = this.lastTotal - this.lastNeed;\r\n    return r + this.lastChar.toString('utf16le', 0, end);\r\n  }\r\n  return r;\r\n}\r\n\r\nfunction base64Text(buf, i) {\r\n  var n = (buf.length - i) % 3;\r\n  if (n === 0) return buf.toString('base64', i);\r\n  this.lastNeed = 3 - n;\r\n  this.lastTotal = 3;\r\n  if (n === 1) {\r\n    this.lastChar[0] = buf[buf.length - 1];\r\n  } else {\r\n    this.lastChar[0] = buf[buf.length - 2];\r\n    this.lastChar[1] = buf[buf.length - 1];\r\n  }\r\n  return buf.toString('base64', i, buf.length - n);\r\n}\r\n\r\nfunction base64End(buf) {\r\n  var r = buf && buf.length ? this.write(buf) : '';\r\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\r\n  return r;\r\n}\r\n\r\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\r\nfunction simpleWrite(buf) {\r\n  return buf.toString(this.encoding);\r\n}\r\n\r\nfunction simpleEnd(buf) {\r\n  return buf && buf.length ? this.write(buf) : '';\r\n}\n\n//# sourceURL=webpack:///./node_modules/string_decoder/lib/string_decoder.js?");

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== \"undefined\" && global) ||\r\n            (typeof self !== \"undefined\" && self) ||\r\n            window;\r\nvar apply = Function.prototype.apply;\r\n\r\n// DOM APIs, for completeness\r\n\r\nexports.setTimeout = function() {\r\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\r\n};\r\nexports.setInterval = function() {\r\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\r\n};\r\nexports.clearTimeout =\r\nexports.clearInterval = function(timeout) {\r\n  if (timeout) {\r\n    timeout.close();\r\n  }\r\n};\r\n\r\nfunction Timeout(id, clearFn) {\r\n  this._id = id;\r\n  this._clearFn = clearFn;\r\n}\r\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\r\nTimeout.prototype.close = function() {\r\n  this._clearFn.call(scope, this._id);\r\n};\r\n\r\n// Does not start the time, just sets up the members needed.\r\nexports.enroll = function(item, msecs) {\r\n  clearTimeout(item._idleTimeoutId);\r\n  item._idleTimeout = msecs;\r\n};\r\n\r\nexports.unenroll = function(item) {\r\n  clearTimeout(item._idleTimeoutId);\r\n  item._idleTimeout = -1;\r\n};\r\n\r\nexports._unrefActive = exports.active = function(item) {\r\n  clearTimeout(item._idleTimeoutId);\r\n\r\n  var msecs = item._idleTimeout;\r\n  if (msecs >= 0) {\r\n    item._idleTimeoutId = setTimeout(function onTimeout() {\r\n      if (item._onTimeout)\r\n        item._onTimeout();\r\n    }, msecs);\r\n  }\r\n};\r\n\r\n// setimmediate attaches itself to the global object\r\n__webpack_require__(/*! setimmediate */ \"./node_modules/setimmediate/setImmediate.js\");\r\n// On some exotic environments, it's not clear which object `setimmediate` was\r\n// able to install onto.  Search each possibility in the same order as the\r\n// `setimmediate` library.\r\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\r\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\r\n                       (this && this.setImmediate);\r\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\r\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\r\n                         (this && this.clearImmediate);\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/timers-browserify/main.js?");

/***/ }),

/***/ "./node_modules/url/url.js":
/*!*********************************!*\
  !*** ./node_modules/url/url.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the\r\n// \"Software\"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n// persons to whom the Software is furnished to do so, subject to the\r\n// following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n\r\n\r\nvar punycode = __webpack_require__(/*! punycode */ \"./node_modules/node-libs-browser/node_modules/punycode/punycode.js\");\r\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/url/util.js\");\r\n\r\nexports.parse = urlParse;\r\nexports.resolve = urlResolve;\r\nexports.resolveObject = urlResolveObject;\r\nexports.format = urlFormat;\r\n\r\nexports.Url = Url;\r\n\r\nfunction Url() {\r\n  this.protocol = null;\r\n  this.slashes = null;\r\n  this.auth = null;\r\n  this.host = null;\r\n  this.port = null;\r\n  this.hostname = null;\r\n  this.hash = null;\r\n  this.search = null;\r\n  this.query = null;\r\n  this.pathname = null;\r\n  this.path = null;\r\n  this.href = null;\r\n}\r\n\r\n// Reference: RFC 3986, RFC 1808, RFC 2396\r\n\r\n// define these here so at least they only have to be\r\n// compiled once on the first module load.\r\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\r\n    portPattern = /:[0-9]*$/,\r\n\r\n    // Special case for a simple path URL\r\n    simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\r\n\r\n    // RFC 2396: characters reserved for delimiting URLs.\r\n    // We actually just auto-escape these.\r\n    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\r\n\r\n    // RFC 2396: characters not allowed for various reasons.\r\n    unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\r\n\r\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\r\n    autoEscape = ['\\''].concat(unwise),\r\n    // Characters that are never ever allowed in a hostname.\r\n    // Note that any invalid chars are also handled, but these\r\n    // are the ones that are *expected* to be seen, so we fast-path\r\n    // them.\r\n    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\r\n    hostEndingChars = ['/', '?', '#'],\r\n    hostnameMaxLen = 255,\r\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\r\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\r\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\r\n    unsafeProtocol = {\r\n      'javascript': true,\r\n      'javascript:': true\r\n    },\r\n    // protocols that never have a hostname.\r\n    hostlessProtocol = {\r\n      'javascript': true,\r\n      'javascript:': true\r\n    },\r\n    // protocols that always contain a // bit.\r\n    slashedProtocol = {\r\n      'http': true,\r\n      'https': true,\r\n      'ftp': true,\r\n      'gopher': true,\r\n      'file': true,\r\n      'http:': true,\r\n      'https:': true,\r\n      'ftp:': true,\r\n      'gopher:': true,\r\n      'file:': true\r\n    },\r\n    querystring = __webpack_require__(/*! querystring */ \"./node_modules/querystring-es3/index.js\");\r\n\r\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\r\n  if (url && util.isObject(url) && url instanceof Url) return url;\r\n\r\n  var u = new Url;\r\n  u.parse(url, parseQueryString, slashesDenoteHost);\r\n  return u;\r\n}\r\n\r\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\r\n  if (!util.isString(url)) {\r\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\r\n  }\r\n\r\n  // Copy chrome, IE, opera backslash-handling behavior.\r\n  // Back slashes before the query string get converted to forward slashes\r\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\r\n  var queryIndex = url.indexOf('?'),\r\n      splitter =\r\n          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',\r\n      uSplit = url.split(splitter),\r\n      slashRegex = /\\\\/g;\r\n  uSplit[0] = uSplit[0].replace(slashRegex, '/');\r\n  url = uSplit.join(splitter);\r\n\r\n  var rest = url;\r\n\r\n  // trim before proceeding.\r\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\r\n  rest = rest.trim();\r\n\r\n  if (!slashesDenoteHost && url.split('#').length === 1) {\r\n    // Try fast path regexp\r\n    var simplePath = simplePathPattern.exec(rest);\r\n    if (simplePath) {\r\n      this.path = rest;\r\n      this.href = rest;\r\n      this.pathname = simplePath[1];\r\n      if (simplePath[2]) {\r\n        this.search = simplePath[2];\r\n        if (parseQueryString) {\r\n          this.query = querystring.parse(this.search.substr(1));\r\n        } else {\r\n          this.query = this.search.substr(1);\r\n        }\r\n      } else if (parseQueryString) {\r\n        this.search = '';\r\n        this.query = {};\r\n      }\r\n      return this;\r\n    }\r\n  }\r\n\r\n  var proto = protocolPattern.exec(rest);\r\n  if (proto) {\r\n    proto = proto[0];\r\n    var lowerProto = proto.toLowerCase();\r\n    this.protocol = lowerProto;\r\n    rest = rest.substr(proto.length);\r\n  }\r\n\r\n  // figure out if it's got a host\r\n  // user@server is *always* interpreted as a hostname, and url\r\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\r\n  // how the browser resolves relative URLs.\r\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\r\n    var slashes = rest.substr(0, 2) === '//';\r\n    if (slashes && !(proto && hostlessProtocol[proto])) {\r\n      rest = rest.substr(2);\r\n      this.slashes = true;\r\n    }\r\n  }\r\n\r\n  if (!hostlessProtocol[proto] &&\r\n      (slashes || (proto && !slashedProtocol[proto]))) {\r\n\r\n    // there's a hostname.\r\n    // the first instance of /, ?, ;, or # ends the host.\r\n    //\r\n    // If there is an @ in the hostname, then non-host chars *are* allowed\r\n    // to the left of the last @ sign, unless some host-ending character\r\n    // comes *before* the @-sign.\r\n    // URLs are obnoxious.\r\n    //\r\n    // ex:\r\n    // http://a@b@c/ => user:a@b host:c\r\n    // http://a@b?@c => user:a host:c path:/?@c\r\n\r\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\r\n    // Review our test case against browsers more comprehensively.\r\n\r\n    // find the first instance of any hostEndingChars\r\n    var hostEnd = -1;\r\n    for (var i = 0; i < hostEndingChars.length; i++) {\r\n      var hec = rest.indexOf(hostEndingChars[i]);\r\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\r\n        hostEnd = hec;\r\n    }\r\n\r\n    // at this point, either we have an explicit point where the\r\n    // auth portion cannot go past, or the last @ char is the decider.\r\n    var auth, atSign;\r\n    if (hostEnd === -1) {\r\n      // atSign can be anywhere.\r\n      atSign = rest.lastIndexOf('@');\r\n    } else {\r\n      // atSign must be in auth portion.\r\n      // http://a@b/c@d => host:b auth:a path:/c@d\r\n      atSign = rest.lastIndexOf('@', hostEnd);\r\n    }\r\n\r\n    // Now we have a portion which is definitely the auth.\r\n    // Pull that off.\r\n    if (atSign !== -1) {\r\n      auth = rest.slice(0, atSign);\r\n      rest = rest.slice(atSign + 1);\r\n      this.auth = decodeURIComponent(auth);\r\n    }\r\n\r\n    // the host is the remaining to the left of the first non-host char\r\n    hostEnd = -1;\r\n    for (var i = 0; i < nonHostChars.length; i++) {\r\n      var hec = rest.indexOf(nonHostChars[i]);\r\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\r\n        hostEnd = hec;\r\n    }\r\n    // if we still have not hit it, then the entire thing is a host.\r\n    if (hostEnd === -1)\r\n      hostEnd = rest.length;\r\n\r\n    this.host = rest.slice(0, hostEnd);\r\n    rest = rest.slice(hostEnd);\r\n\r\n    // pull out port.\r\n    this.parseHost();\r\n\r\n    // we've indicated that there is a hostname,\r\n    // so even if it's empty, it has to be present.\r\n    this.hostname = this.hostname || '';\r\n\r\n    // if hostname begins with [ and ends with ]\r\n    // assume that it's an IPv6 address.\r\n    var ipv6Hostname = this.hostname[0] === '[' &&\r\n        this.hostname[this.hostname.length - 1] === ']';\r\n\r\n    // validate a little.\r\n    if (!ipv6Hostname) {\r\n      var hostparts = this.hostname.split(/\\./);\r\n      for (var i = 0, l = hostparts.length; i < l; i++) {\r\n        var part = hostparts[i];\r\n        if (!part) continue;\r\n        if (!part.match(hostnamePartPattern)) {\r\n          var newpart = '';\r\n          for (var j = 0, k = part.length; j < k; j++) {\r\n            if (part.charCodeAt(j) > 127) {\r\n              // we replace non-ASCII char with a temporary placeholder\r\n              // we need this to make sure size of hostname is not\r\n              // broken by replacing non-ASCII by nothing\r\n              newpart += 'x';\r\n            } else {\r\n              newpart += part[j];\r\n            }\r\n          }\r\n          // we test again with ASCII char only\r\n          if (!newpart.match(hostnamePartPattern)) {\r\n            var validParts = hostparts.slice(0, i);\r\n            var notHost = hostparts.slice(i + 1);\r\n            var bit = part.match(hostnamePartStart);\r\n            if (bit) {\r\n              validParts.push(bit[1]);\r\n              notHost.unshift(bit[2]);\r\n            }\r\n            if (notHost.length) {\r\n              rest = '/' + notHost.join('.') + rest;\r\n            }\r\n            this.hostname = validParts.join('.');\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (this.hostname.length > hostnameMaxLen) {\r\n      this.hostname = '';\r\n    } else {\r\n      // hostnames are always lower case.\r\n      this.hostname = this.hostname.toLowerCase();\r\n    }\r\n\r\n    if (!ipv6Hostname) {\r\n      // IDNA Support: Returns a punycoded representation of \"domain\".\r\n      // It only converts parts of the domain name that\r\n      // have non-ASCII characters, i.e. it doesn't matter if\r\n      // you call it with a domain that already is ASCII-only.\r\n      this.hostname = punycode.toASCII(this.hostname);\r\n    }\r\n\r\n    var p = this.port ? ':' + this.port : '';\r\n    var h = this.hostname || '';\r\n    this.host = h + p;\r\n    this.href += this.host;\r\n\r\n    // strip [ and ] from the hostname\r\n    // the host field still retains them, though\r\n    if (ipv6Hostname) {\r\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\r\n      if (rest[0] !== '/') {\r\n        rest = '/' + rest;\r\n      }\r\n    }\r\n  }\r\n\r\n  // now rest is set to the post-host stuff.\r\n  // chop off any delim chars.\r\n  if (!unsafeProtocol[lowerProto]) {\r\n\r\n    // First, make 100% sure that any \"autoEscape\" chars get\r\n    // escaped, even if encodeURIComponent doesn't think they\r\n    // need to be.\r\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\r\n      var ae = autoEscape[i];\r\n      if (rest.indexOf(ae) === -1)\r\n        continue;\r\n      var esc = encodeURIComponent(ae);\r\n      if (esc === ae) {\r\n        esc = escape(ae);\r\n      }\r\n      rest = rest.split(ae).join(esc);\r\n    }\r\n  }\r\n\r\n\r\n  // chop off from the tail first.\r\n  var hash = rest.indexOf('#');\r\n  if (hash !== -1) {\r\n    // got a fragment string.\r\n    this.hash = rest.substr(hash);\r\n    rest = rest.slice(0, hash);\r\n  }\r\n  var qm = rest.indexOf('?');\r\n  if (qm !== -1) {\r\n    this.search = rest.substr(qm);\r\n    this.query = rest.substr(qm + 1);\r\n    if (parseQueryString) {\r\n      this.query = querystring.parse(this.query);\r\n    }\r\n    rest = rest.slice(0, qm);\r\n  } else if (parseQueryString) {\r\n    // no query string, but parseQueryString still requested\r\n    this.search = '';\r\n    this.query = {};\r\n  }\r\n  if (rest) this.pathname = rest;\r\n  if (slashedProtocol[lowerProto] &&\r\n      this.hostname && !this.pathname) {\r\n    this.pathname = '/';\r\n  }\r\n\r\n  //to support http.request\r\n  if (this.pathname || this.search) {\r\n    var p = this.pathname || '';\r\n    var s = this.search || '';\r\n    this.path = p + s;\r\n  }\r\n\r\n  // finally, reconstruct the href based on what has been validated.\r\n  this.href = this.format();\r\n  return this;\r\n};\r\n\r\n// format a parsed object into a url string\r\nfunction urlFormat(obj) {\r\n  // ensure it's an object, and not a string url.\r\n  // If it's an obj, this is a no-op.\r\n  // this way, you can call url_format() on strings\r\n  // to clean up potentially wonky urls.\r\n  if (util.isString(obj)) obj = urlParse(obj);\r\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\r\n  return obj.format();\r\n}\r\n\r\nUrl.prototype.format = function() {\r\n  var auth = this.auth || '';\r\n  if (auth) {\r\n    auth = encodeURIComponent(auth);\r\n    auth = auth.replace(/%3A/i, ':');\r\n    auth += '@';\r\n  }\r\n\r\n  var protocol = this.protocol || '',\r\n      pathname = this.pathname || '',\r\n      hash = this.hash || '',\r\n      host = false,\r\n      query = '';\r\n\r\n  if (this.host) {\r\n    host = auth + this.host;\r\n  } else if (this.hostname) {\r\n    host = auth + (this.hostname.indexOf(':') === -1 ?\r\n        this.hostname :\r\n        '[' + this.hostname + ']');\r\n    if (this.port) {\r\n      host += ':' + this.port;\r\n    }\r\n  }\r\n\r\n  if (this.query &&\r\n      util.isObject(this.query) &&\r\n      Object.keys(this.query).length) {\r\n    query = querystring.stringify(this.query);\r\n  }\r\n\r\n  var search = this.search || (query && ('?' + query)) || '';\r\n\r\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\r\n\r\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\r\n  // unless they had them to begin with.\r\n  if (this.slashes ||\r\n      (!protocol || slashedProtocol[protocol]) && host !== false) {\r\n    host = '//' + (host || '');\r\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\r\n  } else if (!host) {\r\n    host = '';\r\n  }\r\n\r\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\r\n  if (search && search.charAt(0) !== '?') search = '?' + search;\r\n\r\n  pathname = pathname.replace(/[?#]/g, function(match) {\r\n    return encodeURIComponent(match);\r\n  });\r\n  search = search.replace('#', '%23');\r\n\r\n  return protocol + host + pathname + search + hash;\r\n};\r\n\r\nfunction urlResolve(source, relative) {\r\n  return urlParse(source, false, true).resolve(relative);\r\n}\r\n\r\nUrl.prototype.resolve = function(relative) {\r\n  return this.resolveObject(urlParse(relative, false, true)).format();\r\n};\r\n\r\nfunction urlResolveObject(source, relative) {\r\n  if (!source) return relative;\r\n  return urlParse(source, false, true).resolveObject(relative);\r\n}\r\n\r\nUrl.prototype.resolveObject = function(relative) {\r\n  if (util.isString(relative)) {\r\n    var rel = new Url();\r\n    rel.parse(relative, false, true);\r\n    relative = rel;\r\n  }\r\n\r\n  var result = new Url();\r\n  var tkeys = Object.keys(this);\r\n  for (var tk = 0; tk < tkeys.length; tk++) {\r\n    var tkey = tkeys[tk];\r\n    result[tkey] = this[tkey];\r\n  }\r\n\r\n  // hash is always overridden, no matter what.\r\n  // even href=\"\" will remove it.\r\n  result.hash = relative.hash;\r\n\r\n  // if the relative url is empty, then there's nothing left to do here.\r\n  if (relative.href === '') {\r\n    result.href = result.format();\r\n    return result;\r\n  }\r\n\r\n  // hrefs like //foo/bar always cut to the protocol.\r\n  if (relative.slashes && !relative.protocol) {\r\n    // take everything except the protocol from relative\r\n    var rkeys = Object.keys(relative);\r\n    for (var rk = 0; rk < rkeys.length; rk++) {\r\n      var rkey = rkeys[rk];\r\n      if (rkey !== 'protocol')\r\n        result[rkey] = relative[rkey];\r\n    }\r\n\r\n    //urlParse appends trailing / to urls like http://www.example.com\r\n    if (slashedProtocol[result.protocol] &&\r\n        result.hostname && !result.pathname) {\r\n      result.path = result.pathname = '/';\r\n    }\r\n\r\n    result.href = result.format();\r\n    return result;\r\n  }\r\n\r\n  if (relative.protocol && relative.protocol !== result.protocol) {\r\n    // if it's a known url protocol, then changing\r\n    // the protocol does weird things\r\n    // first, if it's not file:, then we MUST have a host,\r\n    // and if there was a path\r\n    // to begin with, then we MUST have a path.\r\n    // if it is file:, then the host is dropped,\r\n    // because that's known to be hostless.\r\n    // anything else is assumed to be absolute.\r\n    if (!slashedProtocol[relative.protocol]) {\r\n      var keys = Object.keys(relative);\r\n      for (var v = 0; v < keys.length; v++) {\r\n        var k = keys[v];\r\n        result[k] = relative[k];\r\n      }\r\n      result.href = result.format();\r\n      return result;\r\n    }\r\n\r\n    result.protocol = relative.protocol;\r\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\r\n      var relPath = (relative.pathname || '').split('/');\r\n      while (relPath.length && !(relative.host = relPath.shift()));\r\n      if (!relative.host) relative.host = '';\r\n      if (!relative.hostname) relative.hostname = '';\r\n      if (relPath[0] !== '') relPath.unshift('');\r\n      if (relPath.length < 2) relPath.unshift('');\r\n      result.pathname = relPath.join('/');\r\n    } else {\r\n      result.pathname = relative.pathname;\r\n    }\r\n    result.search = relative.search;\r\n    result.query = relative.query;\r\n    result.host = relative.host || '';\r\n    result.auth = relative.auth;\r\n    result.hostname = relative.hostname || relative.host;\r\n    result.port = relative.port;\r\n    // to support http.request\r\n    if (result.pathname || result.search) {\r\n      var p = result.pathname || '';\r\n      var s = result.search || '';\r\n      result.path = p + s;\r\n    }\r\n    result.slashes = result.slashes || relative.slashes;\r\n    result.href = result.format();\r\n    return result;\r\n  }\r\n\r\n  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\r\n      isRelAbs = (\r\n          relative.host ||\r\n          relative.pathname && relative.pathname.charAt(0) === '/'\r\n      ),\r\n      mustEndAbs = (isRelAbs || isSourceAbs ||\r\n                    (result.host && relative.pathname)),\r\n      removeAllDots = mustEndAbs,\r\n      srcPath = result.pathname && result.pathname.split('/') || [],\r\n      relPath = relative.pathname && relative.pathname.split('/') || [],\r\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\r\n\r\n  // if the url is a non-slashed url, then relative\r\n  // links like ../.. should be able\r\n  // to crawl up to the hostname, as well.  This is strange.\r\n  // result.protocol has already been set by now.\r\n  // Later on, put the first path part into the host field.\r\n  if (psychotic) {\r\n    result.hostname = '';\r\n    result.port = null;\r\n    if (result.host) {\r\n      if (srcPath[0] === '') srcPath[0] = result.host;\r\n      else srcPath.unshift(result.host);\r\n    }\r\n    result.host = '';\r\n    if (relative.protocol) {\r\n      relative.hostname = null;\r\n      relative.port = null;\r\n      if (relative.host) {\r\n        if (relPath[0] === '') relPath[0] = relative.host;\r\n        else relPath.unshift(relative.host);\r\n      }\r\n      relative.host = null;\r\n    }\r\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\r\n  }\r\n\r\n  if (isRelAbs) {\r\n    // it's absolute.\r\n    result.host = (relative.host || relative.host === '') ?\r\n                  relative.host : result.host;\r\n    result.hostname = (relative.hostname || relative.hostname === '') ?\r\n                      relative.hostname : result.hostname;\r\n    result.search = relative.search;\r\n    result.query = relative.query;\r\n    srcPath = relPath;\r\n    // fall through to the dot-handling below.\r\n  } else if (relPath.length) {\r\n    // it's relative\r\n    // throw away the existing file, and take the new path instead.\r\n    if (!srcPath) srcPath = [];\r\n    srcPath.pop();\r\n    srcPath = srcPath.concat(relPath);\r\n    result.search = relative.search;\r\n    result.query = relative.query;\r\n  } else if (!util.isNullOrUndefined(relative.search)) {\r\n    // just pull out the search.\r\n    // like href='?foo'.\r\n    // Put this after the other two cases because it simplifies the booleans\r\n    if (psychotic) {\r\n      result.hostname = result.host = srcPath.shift();\r\n      //occationaly the auth can get stuck only in host\r\n      //this especially happens in cases like\r\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\r\n      var authInHost = result.host && result.host.indexOf('@') > 0 ?\r\n                       result.host.split('@') : false;\r\n      if (authInHost) {\r\n        result.auth = authInHost.shift();\r\n        result.host = result.hostname = authInHost.shift();\r\n      }\r\n    }\r\n    result.search = relative.search;\r\n    result.query = relative.query;\r\n    //to support http.request\r\n    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\r\n      result.path = (result.pathname ? result.pathname : '') +\r\n                    (result.search ? result.search : '');\r\n    }\r\n    result.href = result.format();\r\n    return result;\r\n  }\r\n\r\n  if (!srcPath.length) {\r\n    // no path at all.  easy.\r\n    // we've already handled the other stuff above.\r\n    result.pathname = null;\r\n    //to support http.request\r\n    if (result.search) {\r\n      result.path = '/' + result.search;\r\n    } else {\r\n      result.path = null;\r\n    }\r\n    result.href = result.format();\r\n    return result;\r\n  }\r\n\r\n  // if a url ENDs in . or .., then it must get a trailing slash.\r\n  // however, if it ends in anything else non-slashy,\r\n  // then it must NOT get a trailing slash.\r\n  var last = srcPath.slice(-1)[0];\r\n  var hasTrailingSlash = (\r\n      (result.host || relative.host || srcPath.length > 1) &&\r\n      (last === '.' || last === '..') || last === '');\r\n\r\n  // strip single dots, resolve double dots to parent dir\r\n  // if the path tries to go above the root, `up` ends up > 0\r\n  var up = 0;\r\n  for (var i = srcPath.length; i >= 0; i--) {\r\n    last = srcPath[i];\r\n    if (last === '.') {\r\n      srcPath.splice(i, 1);\r\n    } else if (last === '..') {\r\n      srcPath.splice(i, 1);\r\n      up++;\r\n    } else if (up) {\r\n      srcPath.splice(i, 1);\r\n      up--;\r\n    }\r\n  }\r\n\r\n  // if the path is allowed to go above the root, restore leading ..s\r\n  if (!mustEndAbs && !removeAllDots) {\r\n    for (; up--; up) {\r\n      srcPath.unshift('..');\r\n    }\r\n  }\r\n\r\n  if (mustEndAbs && srcPath[0] !== '' &&\r\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\r\n    srcPath.unshift('');\r\n  }\r\n\r\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\r\n    srcPath.push('');\r\n  }\r\n\r\n  var isAbsolute = srcPath[0] === '' ||\r\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\r\n\r\n  // put the host back\r\n  if (psychotic) {\r\n    result.hostname = result.host = isAbsolute ? '' :\r\n                                    srcPath.length ? srcPath.shift() : '';\r\n    //occationaly the auth can get stuck only in host\r\n    //this especially happens in cases like\r\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\r\n    var authInHost = result.host && result.host.indexOf('@') > 0 ?\r\n                     result.host.split('@') : false;\r\n    if (authInHost) {\r\n      result.auth = authInHost.shift();\r\n      result.host = result.hostname = authInHost.shift();\r\n    }\r\n  }\r\n\r\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\r\n\r\n  if (mustEndAbs && !isAbsolute) {\r\n    srcPath.unshift('');\r\n  }\r\n\r\n  if (!srcPath.length) {\r\n    result.pathname = null;\r\n    result.path = null;\r\n  } else {\r\n    result.pathname = srcPath.join('/');\r\n  }\r\n\r\n  //to support request.http\r\n  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\r\n    result.path = (result.pathname ? result.pathname : '') +\r\n                  (result.search ? result.search : '');\r\n  }\r\n  result.auth = relative.auth || result.auth;\r\n  result.slashes = result.slashes || relative.slashes;\r\n  result.href = result.format();\r\n  return result;\r\n};\r\n\r\nUrl.prototype.parseHost = function() {\r\n  var host = this.host;\r\n  var port = portPattern.exec(host);\r\n  if (port) {\r\n    port = port[0];\r\n    if (port !== ':') {\r\n      this.port = port.substr(1);\r\n    }\r\n    host = host.substr(0, host.length - port.length);\r\n  }\r\n  if (host) this.hostname = host;\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/url/url.js?");

/***/ }),

/***/ "./node_modules/url/util.js":
/*!**********************************!*\
  !*** ./node_modules/url/util.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nmodule.exports = {\r\n  isString: function(arg) {\r\n    return typeof(arg) === 'string';\r\n  },\r\n  isObject: function(arg) {\r\n    return typeof(arg) === 'object' && arg !== null;\r\n  },\r\n  isNull: function(arg) {\r\n    return arg === null;\r\n  },\r\n  isNullOrUndefined: function(arg) {\r\n    return arg == null;\r\n  }\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/url/util.js?");

/***/ }),

/***/ "./node_modules/util-deprecate/browser.js":
/*!************************************************!*\
  !*** ./node_modules/util-deprecate/browser.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {\r\n/**\r\n * Module exports.\r\n */\r\n\r\nmodule.exports = deprecate;\r\n\r\n/**\r\n * Mark that a method should not be used.\r\n * Returns a modified function which warns once by default.\r\n *\r\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\r\n *\r\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\r\n * will throw an Error when invoked.\r\n *\r\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\r\n * will invoke `console.trace()` instead of `console.error()`.\r\n *\r\n * @param {Function} fn - the function to deprecate\r\n * @param {String} msg - the string to print to the console when `fn` is invoked\r\n * @returns {Function} a new \"deprecated\" version of `fn`\r\n * @api public\r\n */\r\n\r\nfunction deprecate (fn, msg) {\r\n  if (config('noDeprecation')) {\r\n    return fn;\r\n  }\r\n\r\n  var warned = false;\r\n  function deprecated() {\r\n    if (!warned) {\r\n      if (config('throwDeprecation')) {\r\n        throw new Error(msg);\r\n      } else if (config('traceDeprecation')) {\r\n        console.trace(msg);\r\n      } else {\r\n        console.warn(msg);\r\n      }\r\n      warned = true;\r\n    }\r\n    return fn.apply(this, arguments);\r\n  }\r\n\r\n  return deprecated;\r\n}\r\n\r\n/**\r\n * Checks `localStorage` for boolean values for the given `name`.\r\n *\r\n * @param {String} name\r\n * @returns {Boolean}\r\n * @api private\r\n */\r\n\r\nfunction config (name) {\r\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\r\n  try {\r\n    if (!global.localStorage) return false;\r\n  } catch (_) {\r\n    return false;\r\n  }\r\n  var val = global.localStorage[name];\r\n  if (null == val) return false;\r\n  return String(val).toLowerCase() === 'true';\r\n}\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/util-deprecate/browser.js?");

/***/ }),

/***/ "./node_modules/util/node_modules/inherits/inherits_browser.js":
/*!*********************************************************************!*\
  !*** ./node_modules/util/node_modules/inherits/inherits_browser.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("if (typeof Object.create === 'function') {\r\n  // implementation from standard node.js 'util' module\r\n  module.exports = function inherits(ctor, superCtor) {\r\n    ctor.super_ = superCtor\r\n    ctor.prototype = Object.create(superCtor.prototype, {\r\n      constructor: {\r\n        value: ctor,\r\n        enumerable: false,\r\n        writable: true,\r\n        configurable: true\r\n      }\r\n    });\r\n  };\r\n} else {\r\n  // old school shim for old browsers\r\n  module.exports = function inherits(ctor, superCtor) {\r\n    ctor.super_ = superCtor\r\n    var TempCtor = function () {}\r\n    TempCtor.prototype = superCtor.prototype\r\n    ctor.prototype = new TempCtor()\r\n    ctor.prototype.constructor = ctor\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/util/node_modules/inherits/inherits_browser.js?");

/***/ }),

/***/ "./node_modules/util/support/isBufferBrowser.js":
/*!******************************************************!*\
  !*** ./node_modules/util/support/isBufferBrowser.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function isBuffer(arg) {\r\n  return arg && typeof arg === 'object'\r\n    && typeof arg.copy === 'function'\r\n    && typeof arg.fill === 'function'\r\n    && typeof arg.readUInt8 === 'function';\r\n}\n\n//# sourceURL=webpack:///./node_modules/util/support/isBufferBrowser.js?");

/***/ }),

/***/ "./node_modules/util/util.js":
/*!***********************************!*\
  !*** ./node_modules/util/util.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the\r\n// \"Software\"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n// persons to whom the Software is furnished to do so, subject to the\r\n// following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\r\n  function getOwnPropertyDescriptors(obj) {\r\n    var keys = Object.keys(obj);\r\n    var descriptors = {};\r\n    for (var i = 0; i < keys.length; i++) {\r\n      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);\r\n    }\r\n    return descriptors;\r\n  };\r\n\r\nvar formatRegExp = /%[sdj%]/g;\r\nexports.format = function(f) {\r\n  if (!isString(f)) {\r\n    var objects = [];\r\n    for (var i = 0; i < arguments.length; i++) {\r\n      objects.push(inspect(arguments[i]));\r\n    }\r\n    return objects.join(' ');\r\n  }\r\n\r\n  var i = 1;\r\n  var args = arguments;\r\n  var len = args.length;\r\n  var str = String(f).replace(formatRegExp, function(x) {\r\n    if (x === '%%') return '%';\r\n    if (i >= len) return x;\r\n    switch (x) {\r\n      case '%s': return String(args[i++]);\r\n      case '%d': return Number(args[i++]);\r\n      case '%j':\r\n        try {\r\n          return JSON.stringify(args[i++]);\r\n        } catch (_) {\r\n          return '[Circular]';\r\n        }\r\n      default:\r\n        return x;\r\n    }\r\n  });\r\n  for (var x = args[i]; i < len; x = args[++i]) {\r\n    if (isNull(x) || !isObject(x)) {\r\n      str += ' ' + x;\r\n    } else {\r\n      str += ' ' + inspect(x);\r\n    }\r\n  }\r\n  return str;\r\n};\r\n\r\n\r\n// Mark that a method should not be used.\r\n// Returns a modified function which warns once by default.\r\n// If --no-deprecation is set, then it is a no-op.\r\nexports.deprecate = function(fn, msg) {\r\n  if (typeof process !== 'undefined' && process.noDeprecation === true) {\r\n    return fn;\r\n  }\r\n\r\n  // Allow for deprecating things in the process of starting up.\r\n  if (typeof process === 'undefined') {\r\n    return function() {\r\n      return exports.deprecate(fn, msg).apply(this, arguments);\r\n    };\r\n  }\r\n\r\n  var warned = false;\r\n  function deprecated() {\r\n    if (!warned) {\r\n      if (process.throwDeprecation) {\r\n        throw new Error(msg);\r\n      } else if (process.traceDeprecation) {\r\n        console.trace(msg);\r\n      } else {\r\n        console.error(msg);\r\n      }\r\n      warned = true;\r\n    }\r\n    return fn.apply(this, arguments);\r\n  }\r\n\r\n  return deprecated;\r\n};\r\n\r\n\r\nvar debugs = {};\r\nvar debugEnviron;\r\nexports.debuglog = function(set) {\r\n  if (isUndefined(debugEnviron))\r\n    debugEnviron = process.env.NODE_DEBUG || '';\r\n  set = set.toUpperCase();\r\n  if (!debugs[set]) {\r\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\r\n      var pid = process.pid;\r\n      debugs[set] = function() {\r\n        var msg = exports.format.apply(exports, arguments);\r\n        console.error('%s %d: %s', set, pid, msg);\r\n      };\r\n    } else {\r\n      debugs[set] = function() {};\r\n    }\r\n  }\r\n  return debugs[set];\r\n};\r\n\r\n\r\n/**\r\n * Echos the value of a value. Trys to print the value out\r\n * in the best way possible given the different types.\r\n *\r\n * @param {Object} obj The object to print out.\r\n * @param {Object} opts Optional options object that alters the output.\r\n */\r\n/* legacy: obj, showHidden, depth, colors*/\r\nfunction inspect(obj, opts) {\r\n  // default options\r\n  var ctx = {\r\n    seen: [],\r\n    stylize: stylizeNoColor\r\n  };\r\n  // legacy...\r\n  if (arguments.length >= 3) ctx.depth = arguments[2];\r\n  if (arguments.length >= 4) ctx.colors = arguments[3];\r\n  if (isBoolean(opts)) {\r\n    // legacy...\r\n    ctx.showHidden = opts;\r\n  } else if (opts) {\r\n    // got an \"options\" object\r\n    exports._extend(ctx, opts);\r\n  }\r\n  // set default options\r\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\r\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\r\n  if (isUndefined(ctx.colors)) ctx.colors = false;\r\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\r\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\r\n  return formatValue(ctx, obj, ctx.depth);\r\n}\r\nexports.inspect = inspect;\r\n\r\n\r\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\r\ninspect.colors = {\r\n  'bold' : [1, 22],\r\n  'italic' : [3, 23],\r\n  'underline' : [4, 24],\r\n  'inverse' : [7, 27],\r\n  'white' : [37, 39],\r\n  'grey' : [90, 39],\r\n  'black' : [30, 39],\r\n  'blue' : [34, 39],\r\n  'cyan' : [36, 39],\r\n  'green' : [32, 39],\r\n  'magenta' : [35, 39],\r\n  'red' : [31, 39],\r\n  'yellow' : [33, 39]\r\n};\r\n\r\n// Don't use 'blue' not visible on cmd.exe\r\ninspect.styles = {\r\n  'special': 'cyan',\r\n  'number': 'yellow',\r\n  'boolean': 'yellow',\r\n  'undefined': 'grey',\r\n  'null': 'bold',\r\n  'string': 'green',\r\n  'date': 'magenta',\r\n  // \"name\": intentionally not styling\r\n  'regexp': 'red'\r\n};\r\n\r\n\r\nfunction stylizeWithColor(str, styleType) {\r\n  var style = inspect.styles[styleType];\r\n\r\n  if (style) {\r\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\r\n           '\\u001b[' + inspect.colors[style][1] + 'm';\r\n  } else {\r\n    return str;\r\n  }\r\n}\r\n\r\n\r\nfunction stylizeNoColor(str, styleType) {\r\n  return str;\r\n}\r\n\r\n\r\nfunction arrayToHash(array) {\r\n  var hash = {};\r\n\r\n  array.forEach(function(val, idx) {\r\n    hash[val] = true;\r\n  });\r\n\r\n  return hash;\r\n}\r\n\r\n\r\nfunction formatValue(ctx, value, recurseTimes) {\r\n  // Provide a hook for user-specified inspect functions.\r\n  // Check that value is an object with an inspect function on it\r\n  if (ctx.customInspect &&\r\n      value &&\r\n      isFunction(value.inspect) &&\r\n      // Filter out the util module, it's inspect function is special\r\n      value.inspect !== exports.inspect &&\r\n      // Also filter out any prototype objects using the circular check.\r\n      !(value.constructor && value.constructor.prototype === value)) {\r\n    var ret = value.inspect(recurseTimes, ctx);\r\n    if (!isString(ret)) {\r\n      ret = formatValue(ctx, ret, recurseTimes);\r\n    }\r\n    return ret;\r\n  }\r\n\r\n  // Primitive types cannot have properties\r\n  var primitive = formatPrimitive(ctx, value);\r\n  if (primitive) {\r\n    return primitive;\r\n  }\r\n\r\n  // Look up the keys of the object.\r\n  var keys = Object.keys(value);\r\n  var visibleKeys = arrayToHash(keys);\r\n\r\n  if (ctx.showHidden) {\r\n    keys = Object.getOwnPropertyNames(value);\r\n  }\r\n\r\n  // IE doesn't make error fields non-enumerable\r\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\r\n  if (isError(value)\r\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\r\n    return formatError(value);\r\n  }\r\n\r\n  // Some type of object without properties can be shortcutted.\r\n  if (keys.length === 0) {\r\n    if (isFunction(value)) {\r\n      var name = value.name ? ': ' + value.name : '';\r\n      return ctx.stylize('[Function' + name + ']', 'special');\r\n    }\r\n    if (isRegExp(value)) {\r\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\r\n    }\r\n    if (isDate(value)) {\r\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\r\n    }\r\n    if (isError(value)) {\r\n      return formatError(value);\r\n    }\r\n  }\r\n\r\n  var base = '', array = false, braces = ['{', '}'];\r\n\r\n  // Make Array say that they are Array\r\n  if (isArray(value)) {\r\n    array = true;\r\n    braces = ['[', ']'];\r\n  }\r\n\r\n  // Make functions say that they are functions\r\n  if (isFunction(value)) {\r\n    var n = value.name ? ': ' + value.name : '';\r\n    base = ' [Function' + n + ']';\r\n  }\r\n\r\n  // Make RegExps say that they are RegExps\r\n  if (isRegExp(value)) {\r\n    base = ' ' + RegExp.prototype.toString.call(value);\r\n  }\r\n\r\n  // Make dates with properties first say the date\r\n  if (isDate(value)) {\r\n    base = ' ' + Date.prototype.toUTCString.call(value);\r\n  }\r\n\r\n  // Make error with message first say the error\r\n  if (isError(value)) {\r\n    base = ' ' + formatError(value);\r\n  }\r\n\r\n  if (keys.length === 0 && (!array || value.length == 0)) {\r\n    return braces[0] + base + braces[1];\r\n  }\r\n\r\n  if (recurseTimes < 0) {\r\n    if (isRegExp(value)) {\r\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\r\n    } else {\r\n      return ctx.stylize('[Object]', 'special');\r\n    }\r\n  }\r\n\r\n  ctx.seen.push(value);\r\n\r\n  var output;\r\n  if (array) {\r\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\r\n  } else {\r\n    output = keys.map(function(key) {\r\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\r\n    });\r\n  }\r\n\r\n  ctx.seen.pop();\r\n\r\n  return reduceToSingleString(output, base, braces);\r\n}\r\n\r\n\r\nfunction formatPrimitive(ctx, value) {\r\n  if (isUndefined(value))\r\n    return ctx.stylize('undefined', 'undefined');\r\n  if (isString(value)) {\r\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\r\n                                             .replace(/'/g, \"\\\\'\")\r\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\r\n    return ctx.stylize(simple, 'string');\r\n  }\r\n  if (isNumber(value))\r\n    return ctx.stylize('' + value, 'number');\r\n  if (isBoolean(value))\r\n    return ctx.stylize('' + value, 'boolean');\r\n  // For some reason typeof null is \"object\", so special case here.\r\n  if (isNull(value))\r\n    return ctx.stylize('null', 'null');\r\n}\r\n\r\n\r\nfunction formatError(value) {\r\n  return '[' + Error.prototype.toString.call(value) + ']';\r\n}\r\n\r\n\r\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\r\n  var output = [];\r\n  for (var i = 0, l = value.length; i < l; ++i) {\r\n    if (hasOwnProperty(value, String(i))) {\r\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\r\n          String(i), true));\r\n    } else {\r\n      output.push('');\r\n    }\r\n  }\r\n  keys.forEach(function(key) {\r\n    if (!key.match(/^\\d+$/)) {\r\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\r\n          key, true));\r\n    }\r\n  });\r\n  return output;\r\n}\r\n\r\n\r\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\r\n  var name, str, desc;\r\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\r\n  if (desc.get) {\r\n    if (desc.set) {\r\n      str = ctx.stylize('[Getter/Setter]', 'special');\r\n    } else {\r\n      str = ctx.stylize('[Getter]', 'special');\r\n    }\r\n  } else {\r\n    if (desc.set) {\r\n      str = ctx.stylize('[Setter]', 'special');\r\n    }\r\n  }\r\n  if (!hasOwnProperty(visibleKeys, key)) {\r\n    name = '[' + key + ']';\r\n  }\r\n  if (!str) {\r\n    if (ctx.seen.indexOf(desc.value) < 0) {\r\n      if (isNull(recurseTimes)) {\r\n        str = formatValue(ctx, desc.value, null);\r\n      } else {\r\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\r\n      }\r\n      if (str.indexOf('\\n') > -1) {\r\n        if (array) {\r\n          str = str.split('\\n').map(function(line) {\r\n            return '  ' + line;\r\n          }).join('\\n').substr(2);\r\n        } else {\r\n          str = '\\n' + str.split('\\n').map(function(line) {\r\n            return '   ' + line;\r\n          }).join('\\n');\r\n        }\r\n      }\r\n    } else {\r\n      str = ctx.stylize('[Circular]', 'special');\r\n    }\r\n  }\r\n  if (isUndefined(name)) {\r\n    if (array && key.match(/^\\d+$/)) {\r\n      return str;\r\n    }\r\n    name = JSON.stringify('' + key);\r\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\r\n      name = name.substr(1, name.length - 2);\r\n      name = ctx.stylize(name, 'name');\r\n    } else {\r\n      name = name.replace(/'/g, \"\\\\'\")\r\n                 .replace(/\\\\\"/g, '\"')\r\n                 .replace(/(^\"|\"$)/g, \"'\");\r\n      name = ctx.stylize(name, 'string');\r\n    }\r\n  }\r\n\r\n  return name + ': ' + str;\r\n}\r\n\r\n\r\nfunction reduceToSingleString(output, base, braces) {\r\n  var numLinesEst = 0;\r\n  var length = output.reduce(function(prev, cur) {\r\n    numLinesEst++;\r\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\r\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\r\n  }, 0);\r\n\r\n  if (length > 60) {\r\n    return braces[0] +\r\n           (base === '' ? '' : base + '\\n ') +\r\n           ' ' +\r\n           output.join(',\\n  ') +\r\n           ' ' +\r\n           braces[1];\r\n  }\r\n\r\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\r\n}\r\n\r\n\r\n// NOTE: These type checking functions intentionally don't use `instanceof`\r\n// because it is fragile and can be easily faked with `Object.create()`.\r\nfunction isArray(ar) {\r\n  return Array.isArray(ar);\r\n}\r\nexports.isArray = isArray;\r\n\r\nfunction isBoolean(arg) {\r\n  return typeof arg === 'boolean';\r\n}\r\nexports.isBoolean = isBoolean;\r\n\r\nfunction isNull(arg) {\r\n  return arg === null;\r\n}\r\nexports.isNull = isNull;\r\n\r\nfunction isNullOrUndefined(arg) {\r\n  return arg == null;\r\n}\r\nexports.isNullOrUndefined = isNullOrUndefined;\r\n\r\nfunction isNumber(arg) {\r\n  return typeof arg === 'number';\r\n}\r\nexports.isNumber = isNumber;\r\n\r\nfunction isString(arg) {\r\n  return typeof arg === 'string';\r\n}\r\nexports.isString = isString;\r\n\r\nfunction isSymbol(arg) {\r\n  return typeof arg === 'symbol';\r\n}\r\nexports.isSymbol = isSymbol;\r\n\r\nfunction isUndefined(arg) {\r\n  return arg === void 0;\r\n}\r\nexports.isUndefined = isUndefined;\r\n\r\nfunction isRegExp(re) {\r\n  return isObject(re) && objectToString(re) === '[object RegExp]';\r\n}\r\nexports.isRegExp = isRegExp;\r\n\r\nfunction isObject(arg) {\r\n  return typeof arg === 'object' && arg !== null;\r\n}\r\nexports.isObject = isObject;\r\n\r\nfunction isDate(d) {\r\n  return isObject(d) && objectToString(d) === '[object Date]';\r\n}\r\nexports.isDate = isDate;\r\n\r\nfunction isError(e) {\r\n  return isObject(e) &&\r\n      (objectToString(e) === '[object Error]' || e instanceof Error);\r\n}\r\nexports.isError = isError;\r\n\r\nfunction isFunction(arg) {\r\n  return typeof arg === 'function';\r\n}\r\nexports.isFunction = isFunction;\r\n\r\nfunction isPrimitive(arg) {\r\n  return arg === null ||\r\n         typeof arg === 'boolean' ||\r\n         typeof arg === 'number' ||\r\n         typeof arg === 'string' ||\r\n         typeof arg === 'symbol' ||  // ES6 symbol\r\n         typeof arg === 'undefined';\r\n}\r\nexports.isPrimitive = isPrimitive;\r\n\r\nexports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ \"./node_modules/util/support/isBufferBrowser.js\");\r\n\r\nfunction objectToString(o) {\r\n  return Object.prototype.toString.call(o);\r\n}\r\n\r\n\r\nfunction pad(n) {\r\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\r\n}\r\n\r\n\r\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\r\n              'Oct', 'Nov', 'Dec'];\r\n\r\n// 26 Feb 16:19:34\r\nfunction timestamp() {\r\n  var d = new Date();\r\n  var time = [pad(d.getHours()),\r\n              pad(d.getMinutes()),\r\n              pad(d.getSeconds())].join(':');\r\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\r\n}\r\n\r\n\r\n// log is just a thin wrapper to console.log that prepends a timestamp\r\nexports.log = function() {\r\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\r\n};\r\n\r\n\r\n/**\r\n * Inherit the prototype methods from one constructor into another.\r\n *\r\n * The Function.prototype.inherits from lang.js rewritten as a standalone\r\n * function (not on Function.prototype). NOTE: If this file is to be loaded\r\n * during bootstrapping this function needs to be rewritten using some native\r\n * functions as prototype setup using normal JavaScript does not work as\r\n * expected during bootstrapping (see mirror.js in r114903).\r\n *\r\n * @param {function} ctor Constructor function which needs to inherit the\r\n *     prototype.\r\n * @param {function} superCtor Constructor function to inherit prototype from.\r\n */\r\nexports.inherits = __webpack_require__(/*! inherits */ \"./node_modules/util/node_modules/inherits/inherits_browser.js\");\r\n\r\nexports._extend = function(origin, add) {\r\n  // Don't do anything if add isn't an object\r\n  if (!add || !isObject(add)) return origin;\r\n\r\n  var keys = Object.keys(add);\r\n  var i = keys.length;\r\n  while (i--) {\r\n    origin[keys[i]] = add[keys[i]];\r\n  }\r\n  return origin;\r\n};\r\n\r\nfunction hasOwnProperty(obj, prop) {\r\n  return Object.prototype.hasOwnProperty.call(obj, prop);\r\n}\r\n\r\nvar kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;\r\n\r\nexports.promisify = function promisify(original) {\r\n  if (typeof original !== 'function')\r\n    throw new TypeError('The \"original\" argument must be of type Function');\r\n\r\n  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\r\n    var fn = original[kCustomPromisifiedSymbol];\r\n    if (typeof fn !== 'function') {\r\n      throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\r\n    }\r\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\r\n      value: fn, enumerable: false, writable: false, configurable: true\r\n    });\r\n    return fn;\r\n  }\r\n\r\n  function fn() {\r\n    var promiseResolve, promiseReject;\r\n    var promise = new Promise(function (resolve, reject) {\r\n      promiseResolve = resolve;\r\n      promiseReject = reject;\r\n    });\r\n\r\n    var args = [];\r\n    for (var i = 0; i < arguments.length; i++) {\r\n      args.push(arguments[i]);\r\n    }\r\n    args.push(function (err, value) {\r\n      if (err) {\r\n        promiseReject(err);\r\n      } else {\r\n        promiseResolve(value);\r\n      }\r\n    });\r\n\r\n    try {\r\n      original.apply(this, args);\r\n    } catch (err) {\r\n      promiseReject(err);\r\n    }\r\n\r\n    return promise;\r\n  }\r\n\r\n  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));\r\n\r\n  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {\r\n    value: fn, enumerable: false, writable: false, configurable: true\r\n  });\r\n  return Object.defineProperties(\r\n    fn,\r\n    getOwnPropertyDescriptors(original)\r\n  );\r\n}\r\n\r\nexports.promisify.custom = kCustomPromisifiedSymbol\r\n\r\nfunction callbackifyOnRejected(reason, cb) {\r\n  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).\r\n  // Because `null` is a special error value in callbacks which means \"no error\r\n  // occurred\", we error-wrap so the callback consumer can distinguish between\r\n  // \"the promise rejected with null\" or \"the promise fulfilled with undefined\".\r\n  if (!reason) {\r\n    var newReason = new Error('Promise was rejected with a falsy value');\r\n    newReason.reason = reason;\r\n    reason = newReason;\r\n  }\r\n  return cb(reason);\r\n}\r\n\r\nfunction callbackify(original) {\r\n  if (typeof original !== 'function') {\r\n    throw new TypeError('The \"original\" argument must be of type Function');\r\n  }\r\n\r\n  // We DO NOT return the promise as it gives the user a false sense that\r\n  // the promise is actually somehow related to the callback's execution\r\n  // and that the callback throwing will reject the promise.\r\n  function callbackified() {\r\n    var args = [];\r\n    for (var i = 0; i < arguments.length; i++) {\r\n      args.push(arguments[i]);\r\n    }\r\n\r\n    var maybeCb = args.pop();\r\n    if (typeof maybeCb !== 'function') {\r\n      throw new TypeError('The last argument must be of type Function');\r\n    }\r\n    var self = this;\r\n    var cb = function() {\r\n      return maybeCb.apply(self, arguments);\r\n    };\r\n    // In true node style we process the callback on `nextTick` with all the\r\n    // implications (stack, `uncaughtException`, `async_hooks`)\r\n    original.apply(this, args)\r\n      .then(function(ret) { process.nextTick(cb, null, ret) },\r\n            function(rej) { process.nextTick(callbackifyOnRejected, rej, cb) });\r\n  }\r\n\r\n  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\r\n  Object.defineProperties(callbackified,\r\n                          getOwnPropertyDescriptors(original));\r\n  return callbackified;\r\n}\r\nexports.callbackify = callbackify;\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/util/util.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || new Function(\"return this\")();\r\n} catch (e) {\r\n\t// This works if the window reference is available\r\n\tif (typeof window === \"object\") g = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(module) {\r\n\tif (!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif (!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n\n\n//# sourceURL=webpack:///(webpack)/buildin/module.js?");

/***/ }),

/***/ 0:
/*!************************************!*\
  !*** multi ; mocha ./docs/test.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("!(function webpackMissingModule() { var e = new Error(\"Cannot find module ';'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n__webpack_require__(/*! mocha */\"./node_modules/mocha/browser-entry.js\");\nmodule.exports = __webpack_require__(/*! C:\\Users\\Ogura\\Desktop\\CommunicationRobot\\docs\\test.js */\"./docs/test.js\");\n\n\n//# sourceURL=webpack:///multi_;_mocha_./docs/test.js?");

/***/ }),

/***/ 1:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//# sourceURL=webpack:///util_(ignored)?");

/***/ }),

/***/ 2:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//# sourceURL=webpack:///util_(ignored)?");

/***/ }),

/***/ 3:
/*!**********************!*\
  !*** path (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//# sourceURL=webpack:///path_(ignored)?");

/***/ }),

/***/ 4:
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//# sourceURL=webpack:///fs_(ignored)?");

/***/ }),

/***/ 5:
/*!**********************!*\
  !*** glob (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//# sourceURL=webpack:///glob_(ignored)?");

/***/ }),

/***/ 6:
/*!********************************!*\
  !*** supports-color (ignored) ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//# sourceURL=webpack:///supports-color_(ignored)?");

/***/ }),

/***/ 7:
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//# sourceURL=webpack:///fs_(ignored)?");

/***/ }),

/***/ 8:
/*!**********************!*\
  !*** path (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//# sourceURL=webpack:///path_(ignored)?");

/***/ })

/******/ });